frappe.dom.set_style("/* ../posawesome/node_modules/@vuepic/vue-datepicker/dist/main.css */\n.dp__input_wrap {\n  position: relative;\n  width: 100%;\n  box-sizing: unset;\n}\n.dp__input_wrap:focus {\n  border-color: var(--dp-border-color-hover);\n  outline: none;\n}\n.dp__input_valid {\n  box-shadow: 0 0 var(--dp-border-radius) var(--dp-success-color);\n  border-color: var(--dp-success-color);\n}\n.dp__input_valid:hover {\n  border-color: var(--dp-success-color);\n}\n.dp__input_invalid {\n  box-shadow: 0 0 var(--dp-border-radius) var(--dp-danger-color);\n  border-color: var(--dp-danger-color);\n}\n.dp__input_invalid:hover {\n  border-color: var(--dp-danger-color);\n}\n.dp__input {\n  background-color: var(--dp-background-color);\n  border-radius: var(--dp-border-radius);\n  font-family: var(--dp-font-family);\n  border: 1px solid var(--dp-border-color);\n  outline: none;\n  transition: border-color .2s cubic-bezier(0.645, 0.045, 0.355, 1);\n  width: 100%;\n  font-size: var(--dp-font-size);\n  line-height: calc(var(--dp-font-size)*1.5);\n  padding: var(--dp-input-padding);\n  color: var(--dp-text-color);\n  box-sizing: border-box;\n}\n.dp__input::placeholder {\n  opacity: .7;\n}\n.dp__input:hover:not(.dp__input_focus) {\n  border-color: var(--dp-border-color-hover);\n}\n.dp__input_reg {\n  caret-color: rgba(0, 0, 0, 0);\n}\n.dp__input_focus {\n  border-color: var(--dp-border-color-focus);\n}\n.dp__disabled {\n  background: var(--dp-disabled-color);\n}\n.dp__disabled::placeholder {\n  color: var(--dp-disabled-color-text);\n}\n.dp__input_icons {\n  display: inline-block;\n  width: var(--dp-font-size);\n  height: var(--dp-font-size);\n  stroke-width: 0;\n  font-size: var(--dp-font-size);\n  line-height: calc(var(--dp-font-size)*1.5);\n  padding: 6px 12px;\n  color: var(--dp-icon-color);\n  box-sizing: content-box;\n}\n.dp__input_icon {\n  cursor: pointer;\n  position: absolute;\n  top: 50%;\n  inset-inline-start: 0;\n  transform: translateY(-50%);\n  color: var(--dp-icon-color);\n}\n.dp--clear-btn {\n  position: absolute;\n  top: 50%;\n  inset-inline-end: 0;\n  transform: translateY(-50%);\n  cursor: pointer;\n  color: var(--dp-icon-color);\n  background: rgba(0, 0, 0, 0);\n  border: none;\n  display: inline-flex;\n  align-items: center;\n  padding: 0;\n  margin: 0;\n}\n.dp__input_icon_pad {\n  padding-inline-start: var(--dp-input-icon-padding);\n}\n.dp__menu {\n  background: var(--dp-background-color);\n  border-radius: var(--dp-border-radius);\n  min-width: var(--dp-menu-min-width);\n  font-family: var(--dp-font-family);\n  font-size: var(--dp-font-size);\n  user-select: none;\n  border: 1px solid var(--dp-menu-border-color);\n  box-sizing: border-box;\n}\n.dp__menu::after {\n  box-sizing: border-box;\n}\n.dp__menu::before {\n  box-sizing: border-box;\n}\n.dp__menu:focus {\n  border: 1px solid var(--dp-menu-border-color);\n  outline: none;\n}\n.dp--menu-wrapper {\n  position: absolute;\n  z-index: 99999;\n}\n.dp__menu_inner {\n  padding: var(--dp-menu-padding);\n}\n.dp--menu--inner-stretched {\n  padding: 6px 0;\n}\n.dp__menu_index {\n  z-index: 99999;\n}\n.dp-menu-loading,\n.dp__menu_readonly,\n.dp__menu_disabled {\n  position: absolute;\n  inset: 0;\n  z-index: 999999;\n}\n.dp__menu_disabled {\n  background: hsla(0, 0%, 100%, .5);\n  cursor: not-allowed;\n}\n.dp__menu_readonly {\n  background: rgba(0, 0, 0, 0);\n  cursor: default;\n}\n.dp-menu-loading {\n  background: hsla(0, 0%, 100%, .5);\n  cursor: default;\n}\n.dp--menu-load-container {\n  display: flex;\n  height: 100%;\n  width: 100%;\n  justify-content: center;\n  align-items: center;\n}\n.dp--menu-loader {\n  width: 48px;\n  height: 48px;\n  border: var(--dp-loader);\n  border-bottom-color: rgba(0, 0, 0, 0);\n  border-radius: 50%;\n  display: inline-block;\n  box-sizing: border-box;\n  animation: dp-load-rotation 1s linear infinite;\n  position: absolute;\n}\n@keyframes dp-load-rotation {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n.dp__arrow_top {\n  left: var(--dp-arrow-left);\n  top: 0;\n  height: 12px;\n  width: 12px;\n  background-color: var(--dp-background-color);\n  position: absolute;\n  border-inline-end: 1px solid var(--dp-menu-border-color);\n  border-top: 1px solid var(--dp-menu-border-color);\n  transform: translate(-50%, -50%) rotate(-45deg);\n}\n.dp__arrow_bottom {\n  left: var(--dp-arrow-left);\n  bottom: 0;\n  height: 12px;\n  width: 12px;\n  background-color: var(--dp-background-color);\n  position: absolute;\n  border-inline-end: 1px solid var(--dp-menu-border-color);\n  border-bottom: 1px solid var(--dp-menu-border-color);\n  transform: translate(-50%, 50%) rotate(45deg);\n}\n.dp__action_extra {\n  text-align: center;\n  padding: 2px 0;\n}\n.dp--preset-dates {\n  padding: 5px;\n  border-inline-end: 1px solid var(--dp-border-color);\n}\n.dp--preset-dates[data-dp-mobile] {\n  display: flex;\n  align-self: center;\n  border: none;\n  overflow-x: auto;\n  max-width: calc(var(--dp-menu-width) - var(--dp-action-row-padding)*2);\n}\n.dp--preset-dates-collapsed {\n  display: flex;\n  align-self: center;\n  border: none;\n  overflow-x: auto;\n  max-width: calc(var(--dp-menu-width) - var(--dp-action-row-padding)*2);\n}\n.dp__sidebar_left {\n  padding: 5px;\n  border-inline-end: 1px solid var(--dp-border-color);\n}\n.dp__sidebar_right {\n  padding: 5px;\n  margin-inline-end: 1px solid var(--dp-border-color);\n}\n.dp--preset-range {\n  display: block;\n  width: 100%;\n  padding: 5px;\n  text-align: left;\n  white-space: nowrap;\n  color: var(--dp-text-color);\n  border-radius: var(--dp-border-radius);\n  transition: var(--dp-common-transition);\n}\n.dp--preset-range:hover {\n  background-color: var(--dp-hover-color);\n  color: var(--dp-hover-text-color);\n  cursor: pointer;\n}\n.dp--preset-range[data-dp-mobile] {\n  border: 1px solid var(--dp-border-color);\n  margin: 0 3px;\n}\n.dp--preset-range[data-dp-mobile]:first-child {\n  margin-left: 0;\n}\n.dp--preset-range[data-dp-mobile]:last-child {\n  margin-right: 0;\n}\n.dp--preset-range-collapsed {\n  border: 1px solid var(--dp-border-color);\n  margin: 0 3px;\n}\n.dp--preset-range-collapsed:first-child {\n  margin-left: 0;\n}\n.dp--preset-range-collapsed:last-child {\n  margin-right: 0;\n}\n.dp__menu_content_wrapper {\n  display: flex;\n}\n.dp__menu_content_wrapper[data-dp-mobile] {\n  flex-direction: column-reverse;\n}\n.dp--menu-content-wrapper-collapsed {\n  flex-direction: column-reverse;\n}\n.dp__calendar_header {\n  position: relative;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  color: var(--dp-text-color);\n  white-space: nowrap;\n  font-weight: bold;\n}\n.dp__calendar_header_item {\n  text-align: center;\n  flex-grow: 1;\n  height: var(--dp-cell-size);\n  padding: var(--dp-cell-padding);\n  width: var(--dp-cell-size);\n  box-sizing: border-box;\n}\n.dp__calendar_row {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  margin: var(--dp-row-margin);\n}\n.dp__calendar_item {\n  text-align: center;\n  flex-grow: 1;\n  box-sizing: border-box;\n  color: var(--dp-text-color);\n}\n.dp__calendar {\n  position: relative;\n}\n.dp__calendar_header_cell {\n  border-bottom: thin solid var(--dp-border-color);\n  padding: var(--dp-calendar-header-cell-padding);\n}\n.dp__cell_inner {\n  display: flex;\n  align-items: center;\n  text-align: center;\n  justify-content: center;\n  border-radius: var(--dp-cell-border-radius);\n  height: var(--dp-cell-size);\n  padding: var(--dp-cell-padding);\n  width: var(--dp-cell-size);\n  border: 1px solid rgba(0, 0, 0, 0);\n  box-sizing: border-box;\n  position: relative;\n}\n.dp__cell_inner:hover {\n  transition: all .2s;\n}\n.dp__cell_auto_range_start,\n.dp__date_hover_start:hover,\n.dp__range_start {\n  border-end-end-radius: 0;\n  border-start-end-radius: 0;\n}\n.dp__cell_auto_range_end,\n.dp__date_hover_end:hover,\n.dp__range_end {\n  border-end-start-radius: 0;\n  border-start-start-radius: 0;\n}\n.dp__range_end,\n.dp__range_start,\n.dp__active_date {\n  background: var(--dp-primary-color);\n  color: var(--dp-primary-text-color);\n}\n.dp__date_hover_end:hover,\n.dp__date_hover_start:hover,\n.dp__date_hover:hover {\n  background: var(--dp-hover-color);\n  color: var(--dp-hover-text-color);\n}\n.dp__cell_offset {\n  color: var(--dp-secondary-color);\n}\n.dp__cell_disabled {\n  color: var(--dp-secondary-color);\n  cursor: not-allowed;\n}\n.dp__range_between {\n  background: var(--dp-range-between-dates-background-color);\n  color: var(--dp-range-between-dates-text-color);\n  border-radius: 0;\n  border: 1px solid var(--dp-range-between-border-color);\n}\n.dp__range_between_week {\n  background: var(--dp-primary-color);\n  color: var(--dp-primary-text-color);\n  border-radius: 0;\n  border-top: 1px solid var(--dp-primary-color);\n  border-bottom: 1px solid var(--dp-primary-color);\n}\n.dp__today {\n  border: 1px solid var(--dp-primary-color);\n}\n.dp__week_num {\n  color: var(--dp-secondary-color);\n  text-align: center;\n}\n.dp__cell_auto_range {\n  border-radius: 0;\n  border-top: 1px dashed var(--dp-primary-color);\n  border-bottom: 1px dashed var(--dp-primary-color);\n}\n.dp__cell_auto_range_start {\n  border-start-start-radius: var(--dp-cell-border-radius);\n  border-end-start-radius: var(--dp-cell-border-radius);\n  border-inline-start: 1px dashed var(--dp-primary-color);\n  border-top: 1px dashed var(--dp-primary-color);\n  border-bottom: 1px dashed var(--dp-primary-color);\n}\n.dp__cell_auto_range_end {\n  border-start-end-radius: var(--dp-cell-border-radius);\n  border-end-end-radius: var(--dp-cell-border-radius);\n  border-top: 1px dashed var(--dp-primary-color);\n  border-bottom: 1px dashed var(--dp-primary-color);\n  border-inline-end: 1px dashed var(--dp-primary-color);\n}\n.dp__calendar_header_separator {\n  width: 100%;\n  height: 1px;\n  background: var(--dp-border-color);\n}\n.dp__calendar_next {\n  margin-inline-start: var(--dp-multi-calendars-spacing);\n}\n.dp__marker_line,\n.dp__marker_dot {\n  height: 5px;\n  background-color: var(--dp-marker-color);\n  position: absolute;\n  bottom: 0;\n}\n.dp__marker_dot {\n  width: 5px;\n  border-radius: 50%;\n  left: 50%;\n  transform: translateX(-50%);\n}\n.dp__marker_line {\n  width: 100%;\n  left: 0;\n}\n.dp__marker_tooltip {\n  position: absolute;\n  border-radius: var(--dp-border-radius);\n  background-color: var(--dp-tooltip-color);\n  padding: 5px;\n  border: 1px solid var(--dp-border-color);\n  z-index: 99999;\n  box-sizing: border-box;\n  cursor: default;\n}\n.dp__tooltip_content {\n  white-space: nowrap;\n}\n.dp__tooltip_text {\n  display: flex;\n  align-items: center;\n  flex-flow: row nowrap;\n  color: var(--dp-text-color);\n}\n.dp__tooltip_mark {\n  height: 5px;\n  width: 5px;\n  border-radius: 50%;\n  background-color: var(--dp-text-color);\n  color: var(--dp-text-color);\n  margin-inline-end: 5px;\n}\n.dp__arrow_bottom_tp {\n  bottom: 0;\n  height: 8px;\n  width: 8px;\n  background-color: var(--dp-tooltip-color);\n  position: absolute;\n  border-inline-end: 1px solid var(--dp-border-color);\n  border-bottom: 1px solid var(--dp-border-color);\n  transform: translate(-50%, 50%) rotate(45deg);\n}\n.dp__instance_calendar {\n  position: relative;\n  width: 100%;\n}\n.dp__flex_display[data-dp-mobile] {\n  flex-direction: column;\n}\n.dp--flex-display-collapsed {\n  flex-direction: column;\n}\n.dp__cell_highlight {\n  background-color: var(--dp-highlight-color);\n}\n.dp__month_year_row {\n  display: flex;\n  align-items: center;\n  height: var(--dp-month-year-row-height);\n  color: var(--dp-text-color);\n  box-sizing: border-box;\n}\n.dp__inner_nav {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  height: var(--dp-month-year-row-button-size);\n  width: var(--dp-month-year-row-button-size);\n  color: var(--dp-icon-color);\n  text-align: center;\n  border-radius: 50%;\n}\n.dp__inner_nav svg {\n  height: var(--dp-button-icon-height);\n  width: var(--dp-button-icon-height);\n}\n.dp__inner_nav:hover {\n  background: var(--dp-hover-color);\n  color: var(--dp-hover-icon-color);\n}\n[dir=rtl] .dp__inner_nav {\n  transform: rotate(180deg);\n}\n.dp__inner_nav_disabled:hover,\n.dp__inner_nav_disabled {\n  background: var(--dp-disabled-color);\n  color: var(--dp-disabled-color-text);\n  cursor: not-allowed;\n}\n.dp--year-select,\n.dp__month_year_select {\n  text-align: center;\n  cursor: pointer;\n  height: var(--dp-month-year-row-height);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: var(--dp-border-radius);\n  box-sizing: border-box;\n  color: var(--dp-text-color);\n}\n.dp--year-select:hover,\n.dp__month_year_select:hover {\n  background: var(--dp-hover-color);\n  color: var(--dp-hover-text-color);\n  transition: var(--dp-common-transition);\n}\n.dp__month_year_select {\n  width: 50%;\n}\n.dp--year-select {\n  width: 100%;\n}\n.dp__month_year_wrap {\n  display: flex;\n  flex-direction: row;\n  width: 100%;\n}\n.dp__year_disable_select {\n  justify-content: space-around;\n}\n.dp--header-wrap {\n  display: flex;\n  width: 100%;\n  flex-direction: column;\n}\n.dp__overlay {\n  width: 100%;\n  background: var(--dp-background-color);\n  transition: opacity 1s ease-out;\n  z-index: 99999;\n  font-family: var(--dp-font-family);\n  color: var(--dp-text-color);\n  box-sizing: border-box;\n}\n.dp--overlay-absolute {\n  position: absolute;\n  height: 100%;\n  top: 0;\n  left: 0;\n}\n.dp--overlay-relative {\n  position: relative;\n}\n.dp__overlay_container::-webkit-scrollbar-track {\n  box-shadow: var(--dp-scroll-bar-background);\n  background-color: var(--dp-scroll-bar-background);\n}\n.dp__overlay_container::-webkit-scrollbar {\n  width: 5px;\n  background-color: var(--dp-scroll-bar-background);\n}\n.dp__overlay_container::-webkit-scrollbar-thumb {\n  background-color: var(--dp-scroll-bar-color);\n  border-radius: 10px;\n}\n.dp__overlay:focus {\n  border: none;\n  outline: none;\n}\n.dp__container_flex {\n  display: flex;\n}\n.dp__container_block {\n  display: block;\n}\n.dp__overlay_container {\n  flex-direction: column;\n  overflow-y: auto;\n  height: var(--dp-overlay-height);\n}\n.dp__time_picker_overlay_container {\n  height: 100%;\n}\n.dp__overlay_row {\n  padding: 0;\n  box-sizing: border-box;\n  display: flex;\n  margin-inline: auto;\n  flex-wrap: wrap;\n  max-width: 100%;\n  width: 100%;\n  align-items: center;\n}\n.dp__flex_row {\n  flex: 1;\n}\n.dp__overlay_col {\n  box-sizing: border-box;\n  width: 33%;\n  padding: var(--dp-overlay-col-padding);\n  white-space: nowrap;\n}\n.dp__overlay_cell_pad {\n  padding: var(--dp-common-padding) 0;\n}\n.dp__overlay_cell_active {\n  cursor: pointer;\n  border-radius: var(--dp-border-radius);\n  text-align: center;\n  background: var(--dp-primary-color);\n  color: var(--dp-primary-text-color);\n}\n.dp__overlay_cell {\n  cursor: pointer;\n  border-radius: var(--dp-border-radius);\n  text-align: center;\n}\n.dp__overlay_cell:hover {\n  background: var(--dp-hover-color);\n  color: var(--dp-hover-text-color);\n  transition: var(--dp-common-transition);\n}\n.dp__cell_in_between {\n  background: var(--dp-hover-color);\n  color: var(--dp-hover-text-color);\n}\n.dp__over_action_scroll {\n  right: 5px;\n  box-sizing: border-box;\n}\n.dp__overlay_cell_disabled {\n  cursor: not-allowed;\n  background: var(--dp-disabled-color);\n}\n.dp__overlay_cell_disabled:hover {\n  background: var(--dp-disabled-color);\n}\n.dp__overlay_cell_active_disabled {\n  cursor: not-allowed;\n  background: var(--dp-primary-disabled-color);\n}\n.dp__overlay_cell_active_disabled:hover {\n  background: var(--dp-primary-disabled-color);\n}\n.dp__btn,\n.dp--qr-btn,\n.dp--time-overlay-btn,\n.dp--time-invalid {\n  border: none;\n  font: inherit;\n  transition: var(--dp-common-transition);\n  line-height: normal;\n}\n.dp--year-mode-picker {\n  display: flex;\n  width: 100%;\n  align-items: center;\n  justify-content: space-between;\n  height: var(--dp-cell-size);\n}\n.dp--tp-wrap {\n  max-width: var(--dp-menu-min-width);\n}\n.dp--tp-wrap[data-dp-mobile] {\n  max-width: 100%;\n}\n.dp__time_input {\n  width: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  user-select: none;\n  font-family: var(--dp-font-family);\n  color: var(--dp-text-color);\n}\n.dp__time_col_reg_block {\n  padding: 0 20px;\n}\n.dp__time_col_reg_inline {\n  padding: 0 10px;\n}\n.dp__time_col_reg_with_button {\n  padding: 0 15px;\n}\n.dp__time_col_reg_with_button[data-compact~=true] {\n  padding: 0 5px;\n}\n.dp__time_col_sec {\n  padding: 0 10px;\n}\n.dp__time_col_sec_with_button {\n  padding: 0 5px;\n}\n.dp__time_col_sec_with_button[data-collapsed~=true] {\n  padding: 0;\n}\n.dp__time_col {\n  text-align: center;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-direction: column;\n}\n.dp__time_col_block {\n  font-size: var(--dp-time-font-size);\n}\n.dp__time_display_block {\n  padding: 0 3px;\n}\n.dp__time_display_inline {\n  padding: 5px;\n}\n.dp__time_picker_inline_container {\n  display: flex;\n  width: 100%;\n  justify-content: center;\n}\n.dp__inc_dec_button {\n  padding: 5px;\n  margin: 0;\n  height: var(--dp-time-inc-dec-button-size);\n  width: var(--dp-time-inc-dec-button-size);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  border-radius: 50%;\n  color: var(--dp-icon-color);\n  box-sizing: border-box;\n}\n.dp__inc_dec_button svg {\n  height: var(--dp-time-inc-dec-button-size);\n  width: var(--dp-time-inc-dec-button-size);\n}\n.dp__inc_dec_button:hover {\n  background: var(--dp-hover-color);\n  color: var(--dp-primary-color);\n}\n.dp__time_display {\n  cursor: pointer;\n  color: var(--dp-text-color);\n  border-radius: var(--dp-border-radius);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.dp__time_display:hover:enabled {\n  background: var(--dp-hover-color);\n  color: var(--dp-hover-text-color);\n}\n.dp__inc_dec_button_inline {\n  width: 100%;\n  padding: 0;\n  height: 8px;\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n}\n.dp__inc_dec_button_disabled,\n.dp__inc_dec_button_disabled:hover {\n  background: var(--dp-disabled-color);\n  color: var(--dp-disabled-color-text);\n  cursor: not-allowed;\n}\n.dp__pm_am_button {\n  background: var(--dp-primary-color);\n  color: var(--dp-primary-text-color);\n  border: none;\n  padding: var(--dp-common-padding);\n  border-radius: var(--dp-border-radius);\n  cursor: pointer;\n}\n.dp__pm_am_button[data-compact~=true] {\n  padding: 7px;\n}\n.dp__tp_inline_btn_bar {\n  width: 100%;\n  height: 4px;\n  background-color: var(--dp-secondary-color);\n  transition: var(--dp-common-transition);\n  border-collapse: collapse;\n}\n.dp__tp_inline_btn_top:hover .dp__tp_btn_in_r {\n  background-color: var(--dp-primary-color);\n  transform: rotate(12deg) scale(1.15) translateY(-2px);\n}\n.dp__tp_inline_btn_top:hover .dp__tp_btn_in_l {\n  background-color: var(--dp-primary-color);\n  transform: rotate(-12deg) scale(1.15) translateY(-2px);\n}\n.dp__tp_inline_btn_bottom:hover .dp__tp_btn_in_r {\n  background-color: var(--dp-primary-color);\n  transform: rotate(-12deg) scale(1.15) translateY(-2px);\n}\n.dp__tp_inline_btn_bottom:hover .dp__tp_btn_in_l {\n  background-color: var(--dp-primary-color);\n  transform: rotate(12deg) scale(1.15) translateY(-2px);\n}\n.dp--time-overlay-btn {\n  background: none;\n}\n.dp--time-invalid {\n  background-color: var(--dp-disabled-color);\n}\n.dp__action_row {\n  display: flex;\n  align-items: center;\n  width: 100%;\n  padding: var(--dp-action-row-padding);\n  box-sizing: border-box;\n  color: var(--dp-text-color);\n  flex-flow: row nowrap;\n}\n.dp__action_row svg {\n  height: var(--dp-button-icon-height);\n  width: auto;\n}\n.dp__selection_preview {\n  display: block;\n  color: var(--dp-text-color);\n  font-size: var(--dp-preview-font-size);\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n}\n.dp__action_buttons {\n  display: flex;\n  flex: 0;\n  white-space: nowrap;\n  align-items: center;\n  justify-content: flex-end;\n  margin-inline-start: auto;\n}\n.dp__action_button {\n  display: inline-flex;\n  align-items: center;\n  background: rgba(0, 0, 0, 0);\n  border: 1px solid rgba(0, 0, 0, 0);\n  padding: var(--dp-action-buttons-padding);\n  line-height: var(--dp-action-button-height);\n  margin-inline-start: 3px;\n  height: var(--dp-action-button-height);\n  cursor: pointer;\n  border-radius: var(--dp-border-radius);\n  font-size: var(--dp-preview-font-size);\n  font-family: var(--dp-font-family);\n}\n.dp__action_cancel {\n  color: var(--dp-text-color);\n  border: 1px solid var(--dp-border-color);\n}\n.dp__action_cancel:hover {\n  border-color: var(--dp-primary-color);\n  transition: var(--dp-action-row-transtion);\n}\n.dp__action_buttons .dp__action_select {\n  background: var(--dp-primary-color);\n  color: var(--dp-primary-text-color);\n}\n.dp__action_buttons .dp__action_select:hover {\n  background: var(--dp-primary-color);\n  transition: var(--dp-action-row-transtion);\n}\n.dp__action_buttons .dp__action_select:disabled {\n  background: var(--dp-primary-disabled-color);\n  cursor: not-allowed;\n}\n.dp-quarter-picker-wrap {\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n  min-width: var(--dp-menu-min-width);\n}\n.dp--qr-btn-disabled {\n  cursor: not-allowed;\n  background: var(--dp-disabled-color);\n}\n.dp--qr-btn-disabled:hover {\n  background: var(--dp-disabled-color);\n}\n.dp--qr-btn {\n  width: 100%;\n  padding: var(--dp-common-padding);\n}\n.dp--qr-btn:not(.dp--highlighted, .dp--qr-btn-active, .dp--qr-btn-disabled, .dp--qr-btn-between) {\n  background: none;\n}\n.dp--qr-btn:hover:not(.dp--qr-btn-active, .dp--qr-btn-disabled) {\n  background: var(--dp-hover-color);\n  color: var(--dp-hover-text-color);\n  transition: var(--dp-common-transition);\n}\n.dp--quarter-items {\n  display: flex;\n  flex-direction: column;\n  flex: 1;\n  width: 100%;\n  height: 100%;\n  justify-content: space-evenly;\n}\n.dp--qr-btn-active {\n  background: var(--dp-primary-color);\n  color: var(--dp-primary-text-color);\n}\n.dp--qr-btn-between {\n  background: var(--dp-hover-color);\n  color: var(--dp-hover-text-color);\n}\n:root {\n  --dp-common-transition: all 0.1s ease-in;\n  --dp-menu-padding: 6px 8px;\n  --dp-animation-duration: 0.1s;\n  --dp-menu-appear-transition-timing: cubic-bezier(.4, 0, 1, 1);\n  --dp-transition-timing: ease-out;\n  --dp-action-row-transtion: all 0.2s ease-in;\n  --dp-font-family:\n    -apple-system,\n    blinkmacsystemfont,\n    \"Segoe UI\",\n    roboto,\n    oxygen,\n    ubuntu,\n    cantarell,\n    \"Open Sans\",\n    \"Helvetica Neue\",\n    sans-serif;\n  --dp-border-radius: 4px;\n  --dp-cell-border-radius: 4px;\n  --dp-transition-length: 22px;\n  --dp-transition-timing-general: 0.1s;\n  --dp-button-height: 35px;\n  --dp-month-year-row-height: 35px;\n  --dp-month-year-row-button-size: 25px;\n  --dp-button-icon-height: 20px;\n  --dp-calendar-wrap-padding: 0 5px;\n  --dp-cell-size: 35px;\n  --dp-cell-padding: 5px;\n  --dp-common-padding: 10px;\n  --dp-input-icon-padding: 35px;\n  --dp-input-padding: 6px 30px 6px 12px;\n  --dp-menu-min-width: 260px;\n  --dp-action-buttons-padding: 1px 6px;\n  --dp-row-margin: 5px 0;\n  --dp-calendar-header-cell-padding: 0.5rem;\n  --dp-multi-calendars-spacing: 10px;\n  --dp-overlay-col-padding: 3px;\n  --dp-time-inc-dec-button-size: 32px;\n  --dp-font-size: 1rem;\n  --dp-preview-font-size: 0.8rem;\n  --dp-time-font-size: 2rem;\n  --dp-action-button-height: 22px;\n  --dp-action-row-padding: 8px;\n  --dp-direction: ltr;\n}\n.dp__theme_dark {\n  --dp-background-color: #212121;\n  --dp-text-color: #fff;\n  --dp-hover-color: #484848;\n  --dp-hover-text-color: #fff;\n  --dp-hover-icon-color: #959595;\n  --dp-primary-color: #005cb2;\n  --dp-primary-disabled-color: #61a8ea;\n  --dp-primary-text-color: #fff;\n  --dp-secondary-color: #a9a9a9;\n  --dp-border-color: #2d2d2d;\n  --dp-menu-border-color: #2d2d2d;\n  --dp-border-color-hover: #aaaeb7;\n  --dp-border-color-focus: #aaaeb7;\n  --dp-disabled-color: #737373;\n  --dp-disabled-color-text: #d0d0d0;\n  --dp-scroll-bar-background: #212121;\n  --dp-scroll-bar-color: #484848;\n  --dp-success-color: #00701a;\n  --dp-success-color-disabled: #428f59;\n  --dp-icon-color: #959595;\n  --dp-danger-color: #e53935;\n  --dp-marker-color: #e53935;\n  --dp-tooltip-color: #3e3e3e;\n  --dp-highlight-color: rgb(0 92 178 / 20%);\n  --dp-range-between-dates-background-color: var(--dp-hover-color, #484848);\n  --dp-range-between-dates-text-color: var(--dp-hover-text-color, #fff);\n  --dp-range-between-border-color: var(--dp-hover-color, #fff);\n  --dp-loader: 5px solid #005cb2;\n}\n.dp__theme_light {\n  --dp-background-color: #fff;\n  --dp-text-color: #212121;\n  --dp-hover-color: #f3f3f3;\n  --dp-hover-text-color: #212121;\n  --dp-hover-icon-color: #959595;\n  --dp-primary-color: #1976d2;\n  --dp-primary-disabled-color: #6bacea;\n  --dp-primary-text-color: #fff;\n  --dp-secondary-color: #c0c4cc;\n  --dp-border-color: #ddd;\n  --dp-menu-border-color: #ddd;\n  --dp-border-color-hover: #aaaeb7;\n  --dp-border-color-focus: #aaaeb7;\n  --dp-disabled-color: #f6f6f6;\n  --dp-scroll-bar-background: #f3f3f3;\n  --dp-scroll-bar-color: #959595;\n  --dp-success-color: #76d275;\n  --dp-success-color-disabled: #a3d9b1;\n  --dp-icon-color: #959595;\n  --dp-danger-color: #ff6f60;\n  --dp-marker-color: #ff6f60;\n  --dp-tooltip-color: #fafafa;\n  --dp-disabled-color-text: #8e8e8e;\n  --dp-highlight-color: rgb(25 118 210 / 10%);\n  --dp-range-between-dates-background-color: var(--dp-hover-color, #f3f3f3);\n  --dp-range-between-dates-text-color: var(--dp-hover-text-color, #212121);\n  --dp-range-between-border-color: var(--dp-hover-color, #f3f3f3);\n  --dp-loader: 5px solid #1976d2;\n}\n.dp__flex {\n  display: flex;\n  align-items: center;\n}\n.dp__btn {\n  background: none;\n}\n.dp__main {\n  font-family: var(--dp-font-family);\n  user-select: none;\n  box-sizing: border-box;\n  position: relative;\n  width: 100%;\n}\n.dp__main * {\n  direction: var(--dp-direction, ltr);\n}\n.dp__pointer {\n  cursor: pointer;\n}\n.dp__icon {\n  stroke: currentcolor;\n  fill: currentcolor;\n}\n.dp__button {\n  width: 100%;\n  text-align: center;\n  color: var(--dp-icon-color);\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  place-content: center center;\n  padding: var(--dp-common-padding);\n  box-sizing: border-box;\n  height: var(--dp-button-height);\n}\n.dp__button.dp__overlay_action {\n  position: absolute;\n  bottom: 0;\n}\n.dp__button:hover {\n  background: var(--dp-hover-color);\n  color: var(--dp-hover-icon-color);\n}\n.dp__button svg {\n  height: var(--dp-button-icon-height);\n  width: auto;\n}\n.dp__button_bottom {\n  border-bottom-left-radius: var(--dp-border-radius);\n  border-bottom-right-radius: var(--dp-border-radius);\n}\n.dp__flex_display {\n  display: flex;\n}\n.dp__flex_display_with_input {\n  flex-direction: column;\n  align-items: flex-start;\n}\n.dp__relative {\n  position: relative;\n}\n.calendar-next-enter-active,\n.calendar-next-leave-active,\n.calendar-prev-enter-active,\n.calendar-prev-leave-active {\n  transition: all var(--dp-transition-timing-general) ease-out;\n}\n.calendar-next-enter-from {\n  opacity: 0;\n  transform: translateX(var(--dp-transition-length));\n}\n.calendar-next-leave-to {\n  opacity: 0;\n  transform: translateX(calc(var(--dp-transition-length) * -1));\n}\n.calendar-prev-enter-from {\n  opacity: 0;\n  transform: translateX(calc(var(--dp-transition-length) * -1));\n}\n.calendar-prev-leave-to {\n  opacity: 0;\n  transform: translateX(var(--dp-transition-length));\n}\n.dp-menu-appear-bottom-enter-active,\n.dp-menu-appear-bottom-leave-active,\n.dp-menu-appear-top-enter-active,\n.dp-menu-appear-top-leave-active,\n.dp-slide-up-enter-active,\n.dp-slide-up-leave-active,\n.dp-slide-down-enter-active,\n.dp-slide-down-leave-active {\n  transition: all var(--dp-animation-duration) var(--dp-transition-timing);\n}\n.dp-menu-appear-top-enter-from,\n.dp-menu-appear-top-leave-to,\n.dp-slide-down-leave-to,\n.dp-slide-up-enter-from {\n  opacity: 0;\n  transform: translateY(var(--dp-transition-length));\n}\n.dp-menu-appear-bottom-enter-from,\n.dp-menu-appear-bottom-leave-to,\n.dp-slide-down-enter-from,\n.dp-slide-up-leave-to {\n  opacity: 0;\n  transform: translateY(calc(var(--dp-transition-length) * -1));\n}\n.dp--arrow-btn-nav {\n  transition: var(--dp-common-transition);\n}\n.dp--highlighted {\n  background-color: var(--dp-highlight-color);\n}\n.dp--hidden-el {\n  visibility: hidden;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VApp/VApp.css */\n.v-application {\n  display: flex;\n  background: rgb(var(--v-theme-background));\n  color: rgba(var(--v-theme-on-background), var(--v-high-emphasis-opacity));\n}\n.v-application__wrap {\n  backface-visibility: hidden;\n  display: flex;\n  flex-direction: column;\n  flex: 1 1 auto;\n  max-width: 100%;\n  min-height: 100vh;\n  min-height: 100dvh;\n  position: relative;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VAppBar/VAppBar.css */\n.v-app-bar {\n  display: flex;\n}\n.v-app-bar.v-toolbar {\n  background: rgb(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-app-bar.v-toolbar:not(.v-toolbar--flat) {\n  box-shadow:\n    0px 2px 4px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 4px 5px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 10px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-app-bar:not(.v-toolbar--absolute) {\n  padding-inline-end: var(--v-scrollbar-offset);\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VToolbar/VToolbar.css */\n.v-toolbar {\n  align-items: flex-start;\n  display: flex;\n  flex: none;\n  flex-direction: column;\n  justify-content: space-between;\n  max-width: 100%;\n  position: relative;\n  transition: 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n  transition-property:\n    height,\n    width,\n    transform,\n    max-width,\n    left,\n    right,\n    top,\n    bottom,\n    box-shadow;\n  width: 100%;\n}\n.v-toolbar {\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-style: solid;\n  border-width: 0;\n}\n.v-toolbar--border {\n  border-width: thin;\n  box-shadow: none;\n}\n.v-toolbar {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-toolbar {\n  border-radius: 0;\n}\n.v-toolbar {\n  background: rgb(var(--v-theme-surface-light));\n  color: rgba(var(--v-theme-on-surface-light), var(--v-high-emphasis-opacity));\n}\n.v-toolbar--absolute {\n  position: absolute;\n}\n.v-toolbar--collapse {\n  max-width: 112px;\n  overflow: hidden;\n  border-end-end-radius: 24px;\n}\n.v-toolbar--collapse .v-toolbar-title {\n  display: none;\n}\n.v-toolbar--flat {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-toolbar--floating {\n  display: inline-flex;\n  width: auto;\n}\n.v-toolbar--rounded {\n  border-radius: 4px;\n}\n.v-toolbar__content,\n.v-toolbar__extension {\n  align-items: center;\n  display: flex;\n  flex: 0 0 auto;\n  position: relative;\n  transition: inherit;\n  width: 100%;\n}\n.v-toolbar__content {\n  overflow: hidden;\n}\n.v-toolbar__content > .v-btn:first-child {\n  margin-inline-start: 4px;\n}\n.v-toolbar__content > .v-btn:last-child {\n  margin-inline-end: 4px;\n}\n.v-toolbar__content > .v-toolbar-title {\n  margin-inline-start: 20px;\n}\n.v-toolbar--density-prominent .v-toolbar__content {\n  align-items: flex-start;\n}\n.v-toolbar__image {\n  display: flex;\n  opacity: var(--v-toolbar-image-opacity, 1);\n  transition-property: opacity;\n}\n.v-toolbar__image {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n.v-toolbar__prepend,\n.v-toolbar__append {\n  align-items: center;\n  align-self: stretch;\n  display: flex;\n}\n.v-toolbar__prepend {\n  margin-inline: 4px auto;\n}\n.v-toolbar__append {\n  margin-inline: auto 4px;\n}\n.v-toolbar-title {\n  flex: 1 1;\n  font-size: 1.25rem;\n  min-width: 0;\n}\n.v-toolbar-title {\n  font-size: 1.25rem;\n  font-weight: 400;\n  letter-spacing: 0;\n  line-height: 1.75rem;\n  text-transform: none;\n}\n.v-toolbar--density-prominent .v-toolbar-title {\n  align-self: flex-end;\n  padding-bottom: 6px;\n}\n.v-toolbar--density-prominent .v-toolbar-title {\n  font-size: 1.5rem;\n  font-weight: 400;\n  letter-spacing: 0;\n  line-height: 2.25rem;\n  text-transform: none;\n}\n.v-toolbar-title__placeholder {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n.v-toolbar-items {\n  display: flex;\n  height: inherit;\n  align-self: stretch;\n}\n.v-toolbar-items > .v-btn {\n  border-radius: 0;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VImg/VImg.css */\n.v-img {\n  --v-theme-overlay-multiplier: 3;\n  z-index: 0;\n}\n.v-img.v-img--absolute {\n  height: 100%;\n  left: 0;\n  overflow: hidden;\n  position: absolute;\n  top: 0;\n  width: 100%;\n  z-index: -1;\n}\n.v-img--booting .v-responsive__sizer {\n  transition: none;\n}\n.v-img--rounded {\n  border-radius: 4px;\n}\n.v-img__img,\n.v-img__picture,\n.v-img__gradient,\n.v-img__placeholder,\n.v-img__error {\n  z-index: -1;\n}\n.v-img__img,\n.v-img__picture,\n.v-img__gradient,\n.v-img__placeholder,\n.v-img__error {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n.v-img__img--preload {\n  filter: blur(4px);\n}\n.v-img__img--contain {\n  object-fit: contain;\n}\n.v-img__img--cover {\n  object-fit: cover;\n}\n.v-img__gradient {\n  background-repeat: no-repeat;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VResponsive/VResponsive.css */\n.v-responsive {\n  display: flex;\n  flex: 1 0 auto;\n  max-height: 100%;\n  max-width: 100%;\n  overflow: hidden;\n  position: relative;\n}\n.v-responsive--inline {\n  display: inline-flex;\n  flex: 0 0 auto;\n}\n.v-responsive__content {\n  flex: 1 0 0px;\n  max-width: 100%;\n}\n.v-responsive__sizer ~ .v-responsive__content {\n  margin-inline-start: -100%;\n}\n.v-responsive__sizer {\n  flex: 1 0 0px;\n  transition: padding-bottom 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n  pointer-events: none;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VBtn/VBtn.css */\n.v-btn {\n  align-items: center;\n  border-radius: 4px;\n  display: inline-grid;\n  grid-template-areas: \"prepend content append\";\n  grid-template-columns: max-content auto max-content;\n  font-weight: 500;\n  justify-content: center;\n  letter-spacing: 0.0892857143em;\n  line-height: normal;\n  max-width: 100%;\n  outline: none;\n  position: relative;\n  text-decoration: none;\n  text-indent: 0.0892857143em;\n  text-transform: uppercase;\n  transition-property:\n    box-shadow,\n    transform,\n    opacity,\n    background;\n  transition-duration: 0.28s;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  user-select: none;\n  vertical-align: middle;\n  flex-shrink: 0;\n}\n.v-locale--is-rtl .v-btn {\n  text-indent: -0.0892857143em;\n}\n.v-btn--size-x-small {\n  --v-btn-size: 0.625rem;\n  --v-btn-height: 20px;\n  font-size: var(--v-btn-size);\n  min-width: 36px;\n  padding: 0 8px;\n}\n.v-btn--size-small {\n  --v-btn-size: 0.75rem;\n  --v-btn-height: 28px;\n  font-size: var(--v-btn-size);\n  min-width: 50px;\n  padding: 0 12px;\n}\n.v-btn--size-default {\n  --v-btn-size: 0.875rem;\n  --v-btn-height: 36px;\n  font-size: var(--v-btn-size);\n  min-width: 64px;\n  padding: 0 16px;\n}\n.v-btn--size-large {\n  --v-btn-size: 1rem;\n  --v-btn-height: 44px;\n  font-size: var(--v-btn-size);\n  min-width: 78px;\n  padding: 0 20px;\n}\n.v-btn--size-x-large {\n  --v-btn-size: 1.125rem;\n  --v-btn-height: 52px;\n  font-size: var(--v-btn-size);\n  min-width: 92px;\n  padding: 0 24px;\n}\n.v-btn.v-btn--density-default {\n  height: calc(var(--v-btn-height) + 0px);\n}\n.v-btn.v-btn--density-comfortable {\n  height: calc(var(--v-btn-height) + -8px);\n}\n.v-btn.v-btn--density-compact {\n  height: calc(var(--v-btn-height) + -12px);\n}\n.v-btn {\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-style: solid;\n  border-width: 0;\n}\n.v-btn--border {\n  border-width: thin;\n  box-shadow: none;\n}\n.v-btn--absolute {\n  position: absolute;\n}\n.v-btn--fixed {\n  position: fixed;\n}\n.v-btn:hover > .v-btn__overlay {\n  opacity: calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-btn:focus-visible > .v-btn__overlay {\n  opacity: calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier));\n}\n@supports not selector(:focus-visible) {\n  .v-btn:focus > .v-btn__overlay {\n    opacity: calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-btn--active > .v-btn__overlay,\n.v-btn[aria-haspopup=menu][aria-expanded=true] > .v-btn__overlay {\n  opacity: calc(var(--v-activated-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-btn--active:hover > .v-btn__overlay,\n.v-btn[aria-haspopup=menu][aria-expanded=true]:hover > .v-btn__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier));\n}\n.v-btn--active:focus-visible > .v-btn__overlay,\n.v-btn[aria-haspopup=menu][aria-expanded=true]:focus-visible > .v-btn__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n}\n@supports not selector(:focus-visible) {\n  .v-btn--active:focus > .v-btn__overlay,\n  .v-btn[aria-haspopup=menu][aria-expanded=true]:focus > .v-btn__overlay {\n    opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-btn--variant-plain,\n.v-btn--variant-outlined,\n.v-btn--variant-text,\n.v-btn--variant-tonal {\n  background: transparent;\n  color: inherit;\n}\n.v-btn--variant-plain {\n  opacity: 0.62;\n}\n.v-btn--variant-plain:focus,\n.v-btn--variant-plain:hover {\n  opacity: 1;\n}\n.v-btn--variant-plain .v-btn__overlay {\n  display: none;\n}\n.v-btn--variant-elevated,\n.v-btn--variant-flat {\n  background: rgb(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-btn--variant-elevated {\n  box-shadow:\n    0px 3px 1px -2px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 2px 2px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 5px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-btn--variant-flat {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-btn--variant-outlined {\n  border: thin solid currentColor;\n}\n.v-btn--variant-text .v-btn__overlay {\n  background: currentColor;\n}\n.v-btn--variant-tonal .v-btn__underlay {\n  background: currentColor;\n  opacity: var(--v-activated-opacity);\n  border-radius: inherit;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  pointer-events: none;\n}\n.v-btn .v-btn__underlay {\n  position: absolute;\n}\n@supports selector(:focus-visible) {\n  .v-btn::after {\n    pointer-events: none;\n    border: 2px solid currentColor;\n    border-radius: inherit;\n    opacity: 0;\n    transition: opacity 0.2s ease-in-out;\n  }\n  .v-btn::after {\n    content: \"\";\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n  }\n  .v-btn:focus-visible::after {\n    opacity: calc(0.25 * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-btn--icon {\n  border-radius: 50%;\n  min-width: 0;\n  padding: 0;\n}\n.v-btn--icon.v-btn--size-default {\n  --v-btn-size: 1rem;\n}\n.v-btn--icon.v-btn--density-default {\n  width: calc(var(--v-btn-height) + 12px);\n  height: calc(var(--v-btn-height) + 12px);\n}\n.v-btn--icon.v-btn--density-comfortable {\n  width: calc(var(--v-btn-height) + 0px);\n  height: calc(var(--v-btn-height) + 0px);\n}\n.v-btn--icon.v-btn--density-compact {\n  width: calc(var(--v-btn-height) + -8px);\n  height: calc(var(--v-btn-height) + -8px);\n}\n.v-btn--elevated:hover,\n.v-btn--elevated:focus {\n  box-shadow:\n    0px 2px 4px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 4px 5px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 10px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-btn--elevated:active {\n  box-shadow:\n    0px 5px 5px -3px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 8px 10px 1px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 3px 14px 2px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-btn--flat {\n  box-shadow: none;\n}\n.v-btn--block {\n  display: flex;\n  flex: 1 0 auto;\n  min-width: 100%;\n}\n.v-btn--disabled {\n  pointer-events: none;\n  opacity: 0.26;\n}\n.v-btn--disabled:hover {\n  opacity: 0.26;\n}\n.v-btn--disabled.v-btn--variant-elevated,\n.v-btn--disabled.v-btn--variant-flat {\n  box-shadow: none;\n  opacity: 1;\n  color: rgba(var(--v-theme-on-surface), 0.26);\n  background: rgb(var(--v-theme-surface));\n}\n.v-btn--disabled.v-btn--variant-elevated .v-btn__overlay,\n.v-btn--disabled.v-btn--variant-flat .v-btn__overlay {\n  opacity: 0.4615384615;\n}\n.v-btn--loading {\n  pointer-events: none;\n}\n.v-btn--loading .v-btn__content,\n.v-btn--loading .v-btn__prepend,\n.v-btn--loading .v-btn__append {\n  opacity: 0;\n}\n.v-btn--stacked {\n  grid-template-areas: \"prepend\" \"content\" \"append\";\n  grid-template-columns: auto;\n  grid-template-rows: max-content max-content max-content;\n  justify-items: center;\n  align-content: center;\n}\n.v-btn--stacked .v-btn__content {\n  flex-direction: column;\n  line-height: 1.25;\n}\n.v-btn--stacked .v-btn__prepend,\n.v-btn--stacked .v-btn__append,\n.v-btn--stacked .v-btn__content > .v-icon--start,\n.v-btn--stacked .v-btn__content > .v-icon--end {\n  margin-inline: 0;\n}\n.v-btn--stacked .v-btn__prepend,\n.v-btn--stacked .v-btn__content > .v-icon--start {\n  margin-bottom: 4px;\n}\n.v-btn--stacked .v-btn__append,\n.v-btn--stacked .v-btn__content > .v-icon--end {\n  margin-top: 4px;\n}\n.v-btn--stacked.v-btn--size-x-small {\n  --v-btn-size: 0.625rem;\n  --v-btn-height: 56px;\n  font-size: var(--v-btn-size);\n  min-width: 56px;\n  padding: 0 12px;\n}\n.v-btn--stacked.v-btn--size-small {\n  --v-btn-size: 0.75rem;\n  --v-btn-height: 64px;\n  font-size: var(--v-btn-size);\n  min-width: 64px;\n  padding: 0 14px;\n}\n.v-btn--stacked.v-btn--size-default {\n  --v-btn-size: 0.875rem;\n  --v-btn-height: 72px;\n  font-size: var(--v-btn-size);\n  min-width: 72px;\n  padding: 0 16px;\n}\n.v-btn--stacked.v-btn--size-large {\n  --v-btn-size: 1rem;\n  --v-btn-height: 80px;\n  font-size: var(--v-btn-size);\n  min-width: 80px;\n  padding: 0 18px;\n}\n.v-btn--stacked.v-btn--size-x-large {\n  --v-btn-size: 1.125rem;\n  --v-btn-height: 88px;\n  font-size: var(--v-btn-size);\n  min-width: 88px;\n  padding: 0 20px;\n}\n.v-btn--stacked.v-btn--density-default {\n  height: calc(var(--v-btn-height) + 0px);\n}\n.v-btn--stacked.v-btn--density-comfortable {\n  height: calc(var(--v-btn-height) + -16px);\n}\n.v-btn--stacked.v-btn--density-compact {\n  height: calc(var(--v-btn-height) + -24px);\n}\n.v-btn--slim {\n  padding: 0 8px;\n}\n.v-btn--readonly {\n  pointer-events: none;\n}\n.v-btn--rounded {\n  border-radius: 24px;\n}\n.v-btn--rounded.v-btn--icon {\n  border-radius: 4px;\n}\n.v-btn .v-icon {\n  --v-icon-size-multiplier: 0.8571428571;\n}\n.v-btn--icon .v-icon {\n  --v-icon-size-multiplier: 1;\n}\n.v-btn--stacked .v-icon {\n  --v-icon-size-multiplier: 1.1428571429;\n}\n.v-btn--stacked.v-btn--block {\n  min-width: 100%;\n}\n.v-btn__loader {\n  align-items: center;\n  display: flex;\n  height: 100%;\n  justify-content: center;\n  left: 0;\n  position: absolute;\n  top: 0;\n  width: 100%;\n}\n.v-btn__loader > .v-progress-circular {\n  width: 1.5em;\n  height: 1.5em;\n}\n.v-btn__content,\n.v-btn__prepend,\n.v-btn__append {\n  align-items: center;\n  display: flex;\n  transition: transform, opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-btn__prepend {\n  grid-area: prepend;\n  margin-inline: calc(var(--v-btn-height) / -9) calc(var(--v-btn-height) / 4.5);\n}\n.v-btn--slim .v-btn__prepend {\n  margin-inline-start: 0;\n}\n.v-btn__append {\n  grid-area: append;\n  margin-inline: calc(var(--v-btn-height) / 4.5) calc(var(--v-btn-height) / -9);\n}\n.v-btn--slim .v-btn__append {\n  margin-inline-end: 0;\n}\n.v-btn__content {\n  grid-area: content;\n  justify-content: center;\n  white-space: nowrap;\n}\n.v-btn__content > .v-icon--start {\n  margin-inline: calc(var(--v-btn-height) / -9) calc(var(--v-btn-height) / 4.5);\n}\n.v-btn__content > .v-icon--end {\n  margin-inline: calc(var(--v-btn-height) / 4.5) calc(var(--v-btn-height) / -9);\n}\n.v-btn--stacked .v-btn__content {\n  white-space: normal;\n}\n.v-btn__overlay {\n  background-color: currentColor;\n  border-radius: inherit;\n  opacity: 0;\n  transition: opacity 0.2s ease-in-out;\n}\n.v-btn__overlay,\n.v-btn__underlay {\n  pointer-events: none;\n}\n.v-btn__overlay,\n.v-btn__underlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n.v-pagination .v-btn {\n  width: auto;\n  padding-inline: 5px;\n}\n.v-pagination .v-btn.v-btn--density-default {\n  min-width: calc(var(--v-btn-height) + 12px);\n}\n.v-pagination .v-btn.v-btn--density-comfortable {\n  min-width: calc(var(--v-btn-height) + 0px);\n}\n.v-pagination .v-btn.v-btn--density-compact {\n  min-width: calc(var(--v-btn-height) + -8px);\n}\n.v-pagination .v-btn {\n  border-radius: 4px;\n}\n.v-pagination .v-btn--rounded {\n  border-radius: 50%;\n}\n.v-pagination .v-btn__overlay {\n  transition: none;\n}\n.v-pagination__prev .v-btn,\n.v-pagination__next .v-btn {\n  padding-inline: 0;\n}\n.v-pagination__prev .v-btn.v-btn--density-default,\n.v-pagination__next .v-btn.v-btn--density-default {\n  width: calc(var(--v-btn-height) + 12px);\n}\n.v-pagination__prev .v-btn.v-btn--density-comfortable,\n.v-pagination__next .v-btn.v-btn--density-comfortable {\n  width: calc(var(--v-btn-height) + 0px);\n}\n.v-pagination__prev .v-btn.v-btn--density-compact,\n.v-pagination__next .v-btn.v-btn--density-compact {\n  width: calc(var(--v-btn-height) + -8px);\n}\n.v-pagination .v-pagination__item--is-active .v-btn__overlay {\n  opacity: var(--v-border-opacity);\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VBtnToggle/VBtnToggle.css */\n.v-btn-toggle > .v-btn.v-btn--active:not(.v-btn--disabled) > .v-btn__overlay {\n  opacity: calc(var(--v-activated-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-btn-toggle > .v-btn.v-btn--active:not(.v-btn--disabled):hover > .v-btn__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier));\n}\n.v-btn-toggle > .v-btn.v-btn--active:not(.v-btn--disabled):focus-visible > .v-btn__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n}\n@supports not selector(:focus-visible) {\n  .v-btn-toggle > .v-btn.v-btn--active:not(.v-btn--disabled):focus > .v-btn__overlay {\n    opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-btn-toggle > .v-btn.v-btn--active:not(.v-btn--disabled).v-btn--variant-plain {\n  opacity: 1;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VBtnGroup/VBtnGroup.css */\n.v-btn-group {\n  display: inline-flex;\n  flex-wrap: nowrap;\n  max-width: 100%;\n  min-width: 0;\n  overflow-y: hidden;\n  overflow-x: auto;\n  vertical-align: middle;\n}\n.v-btn-group {\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-style: solid;\n  border-width: 0;\n}\n.v-btn-group--border {\n  border-width: thin;\n  box-shadow: none;\n}\n.v-btn-group {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-btn-group {\n  border-radius: 4px;\n}\n.v-btn-group {\n  background: transparent;\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-btn-group--density-default.v-btn-group {\n  height: 48px;\n}\n.v-btn-group--density-comfortable.v-btn-group {\n  height: 40px;\n}\n.v-btn-group--density-compact.v-btn-group {\n  height: 36px;\n}\n.v-btn-group .v-btn {\n  border-radius: 0;\n  border-color: inherit;\n}\n.v-btn-group .v-btn:not(:last-child) {\n  border-inline-end: none;\n}\n.v-btn-group .v-btn:not(:first-child) {\n  border-inline-start: none;\n}\n.v-btn-group .v-btn:first-child {\n  border-start-start-radius: inherit;\n  border-end-start-radius: inherit;\n}\n.v-btn-group .v-btn:last-child {\n  border-start-end-radius: inherit;\n  border-end-end-radius: inherit;\n}\n.v-btn-group--divided .v-btn:not(:last-child) {\n  border-inline-end-width: thin;\n  border-inline-end-style: solid;\n  border-inline-end-color: rgba(var(--v-border-color), var(--v-border-opacity));\n}\n.v-btn-group--tile {\n  border-radius: 0;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VIcon/VIcon.css */\n.v-icon {\n  --v-icon-size-multiplier: 1;\n  align-items: center;\n  display: inline-flex;\n  font-feature-settings: \"liga\";\n  height: 1em;\n  justify-content: center;\n  letter-spacing: normal;\n  line-height: 1;\n  position: relative;\n  opacity: var(--v-icon-opacity, 1);\n  text-indent: 0;\n  text-align: center;\n  user-select: none;\n  vertical-align: middle;\n  width: 1em;\n  min-width: 1em;\n}\n.v-icon--clickable {\n  cursor: pointer;\n}\n.v-icon--disabled {\n  pointer-events: none;\n  opacity: 0.38;\n}\n.v-icon--size-x-small {\n  font-size: calc(var(--v-icon-size-multiplier) * 1em);\n}\n.v-icon--size-small {\n  font-size: calc(var(--v-icon-size-multiplier) * 1.25em);\n}\n.v-icon--size-default {\n  font-size: calc(var(--v-icon-size-multiplier) * 1.5em);\n}\n.v-icon--size-large {\n  font-size: calc(var(--v-icon-size-multiplier) * 1.75em);\n}\n.v-icon--size-x-large {\n  font-size: calc(var(--v-icon-size-multiplier) * 2em);\n}\n.v-icon__svg {\n  fill: currentColor;\n  width: 100%;\n  height: 100%;\n}\n.v-icon--start {\n  margin-inline-end: 8px;\n}\n.v-icon--end {\n  margin-inline-start: 8px;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VProgressCircular/VProgressCircular.css */\n.v-progress-circular {\n  align-items: center;\n  display: inline-flex;\n  justify-content: center;\n  position: relative;\n  vertical-align: middle;\n}\n.v-progress-circular > svg {\n  width: 100%;\n  height: 100%;\n  margin: auto;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  z-index: 0;\n}\n.v-progress-circular__content {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n}\n.v-progress-circular__underlay {\n  color: rgba(var(--v-border-color), var(--v-border-opacity));\n  stroke: currentColor;\n  z-index: 1;\n}\n.v-progress-circular__overlay {\n  stroke: currentColor;\n  transition: all 0.2s ease-in-out, stroke-width 0s;\n  z-index: 2;\n}\n.v-progress-circular--size-x-small {\n  height: 16px;\n  width: 16px;\n}\n.v-progress-circular--size-small {\n  height: 24px;\n  width: 24px;\n}\n.v-progress-circular--size-default {\n  height: 32px;\n  width: 32px;\n}\n.v-progress-circular--size-large {\n  height: 48px;\n  width: 48px;\n}\n.v-progress-circular--size-x-large {\n  height: 64px;\n  width: 64px;\n}\n.v-progress-circular--indeterminate > svg {\n  animation: progress-circular-rotate 1.4s linear infinite;\n  transform-origin: center center;\n  transition: all 0.2s ease-in-out;\n}\n.v-progress-circular--indeterminate .v-progress-circular__overlay {\n  animation: progress-circular-dash 1.4s ease-in-out infinite, progress-circular-rotate 1.4s linear infinite;\n  stroke-dasharray: 25, 200;\n  stroke-dashoffset: 0;\n  stroke-linecap: round;\n  transform-origin: center center;\n  transform: rotate(-90deg);\n}\n.v-progress-circular--disable-shrink > svg {\n  animation-duration: 0.7s;\n}\n.v-progress-circular--disable-shrink .v-progress-circular__overlay {\n  animation: none;\n}\n.v-progress-circular--indeterminate:not(.v-progress-circular--visible) > svg,\n.v-progress-circular--indeterminate:not(.v-progress-circular--visible) .v-progress-circular__overlay {\n  animation-play-state: paused !important;\n}\n@keyframes progress-circular-dash {\n  0% {\n    stroke-dasharray: 1, 200;\n    stroke-dashoffset: 0px;\n  }\n  50% {\n    stroke-dasharray: 100, 200;\n    stroke-dashoffset: -15px;\n  }\n  100% {\n    stroke-dasharray: 100, 200;\n    stroke-dashoffset: -124px;\n  }\n}\n@keyframes progress-circular-rotate {\n  100% {\n    transform: rotate(270deg);\n  }\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VProgressLinear/VProgressLinear.css */\n.v-progress-linear {\n  background: transparent;\n  overflow: hidden;\n  position: relative;\n  transition: 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n  width: 100%;\n}\n.v-progress-linear--rounded {\n  border-radius: 9999px;\n}\n@media (forced-colors: active) {\n  .v-progress-linear {\n    border: thin solid buttontext;\n  }\n}\n.v-progress-linear__background,\n.v-progress-linear__buffer {\n  background: currentColor;\n  bottom: 0;\n  left: 0;\n  opacity: var(--v-border-opacity);\n  position: absolute;\n  top: 0;\n  width: 100%;\n  transition-property:\n    width,\n    left,\n    right;\n  transition: inherit;\n}\n@media (forced-colors: active) {\n  .v-progress-linear__buffer {\n    background-color: highlight;\n    opacity: 0.3;\n  }\n}\n.v-progress-linear__content {\n  align-items: center;\n  display: flex;\n  height: 100%;\n  justify-content: center;\n  left: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 0;\n  width: 100%;\n}\n.v-progress-linear__determinate,\n.v-progress-linear__indeterminate {\n  background: currentColor;\n}\n@media (forced-colors: active) {\n  .v-progress-linear__determinate,\n  .v-progress-linear__indeterminate {\n    background-color: highlight;\n  }\n}\n.v-progress-linear__determinate {\n  height: inherit;\n  left: 0;\n  position: absolute;\n  transition: inherit;\n  transition-property:\n    width,\n    left,\n    right;\n}\n.v-progress-linear__indeterminate .long,\n.v-progress-linear__indeterminate .short {\n  animation-play-state: paused;\n  animation-duration: 2.2s;\n  animation-iteration-count: infinite;\n  bottom: 0;\n  height: inherit;\n  left: 0;\n  position: absolute;\n  right: auto;\n  top: 0;\n  width: auto;\n}\n.v-progress-linear__indeterminate .long {\n  animation-name: indeterminate-ltr;\n}\n.v-progress-linear__indeterminate .short {\n  animation-name: indeterminate-short-ltr;\n}\n.v-progress-linear__stream {\n  animation: stream 0.25s infinite linear;\n  animation-play-state: paused;\n  bottom: 0;\n  left: auto;\n  opacity: 0.3;\n  pointer-events: none;\n  position: absolute;\n  transition: inherit;\n  transition-property:\n    width,\n    left,\n    right;\n}\n.v-progress-linear--reverse .v-progress-linear__background,\n.v-progress-linear--reverse .v-progress-linear__determinate,\n.v-progress-linear--reverse .v-progress-linear__content {\n  left: auto;\n  right: 0;\n}\n.v-progress-linear--reverse .v-progress-linear__indeterminate .long,\n.v-progress-linear--reverse .v-progress-linear__indeterminate .short {\n  left: auto;\n  right: 0;\n}\n.v-progress-linear--reverse .v-progress-linear__indeterminate .long {\n  animation-name: indeterminate-rtl;\n}\n.v-progress-linear--reverse .v-progress-linear__indeterminate .short {\n  animation-name: indeterminate-short-rtl;\n}\n.v-progress-linear--reverse .v-progress-linear__stream {\n  right: auto;\n}\n.v-progress-linear--absolute,\n.v-progress-linear--fixed {\n  left: 0;\n  z-index: 1;\n}\n.v-progress-linear--absolute {\n  position: absolute;\n}\n.v-progress-linear--fixed {\n  position: fixed;\n}\n.v-progress-linear--rounded {\n  border-radius: 9999px;\n}\n.v-progress-linear--rounded.v-progress-linear--rounded-bar .v-progress-linear__determinate,\n.v-progress-linear--rounded.v-progress-linear--rounded-bar .v-progress-linear__indeterminate {\n  border-radius: inherit;\n}\n.v-progress-linear--striped .v-progress-linear__determinate {\n  animation: progress-linear-stripes 1s infinite linear;\n  background-image: linear-gradient(135deg, hsla(0, 0%, 100%, 0.25) 25%, transparent 0, transparent 50%, hsla(0, 0%, 100%, 0.25) 0, hsla(0, 0%, 100%, 0.25) 75%, transparent 0, transparent);\n  background-repeat: repeat;\n  background-size: var(--v-progress-linear-height);\n}\n.v-progress-linear--active .v-progress-linear__indeterminate .long,\n.v-progress-linear--active .v-progress-linear__indeterminate .short {\n  animation-play-state: running;\n}\n.v-progress-linear--active .v-progress-linear__stream {\n  animation-play-state: running;\n}\n.v-progress-linear--rounded-bar .v-progress-linear__determinate,\n.v-progress-linear--rounded-bar .v-progress-linear__indeterminate,\n.v-progress-linear--rounded-bar .v-progress-linear__stream + .v-progress-linear__background {\n  border-radius: 9999px;\n}\n.v-progress-linear--rounded-bar .v-progress-linear__determinate {\n  border-start-start-radius: 0;\n  border-end-start-radius: 0;\n}\n@keyframes indeterminate-ltr {\n  0% {\n    left: -90%;\n    right: 100%;\n  }\n  60% {\n    left: -90%;\n    right: 100%;\n  }\n  100% {\n    left: 100%;\n    right: -35%;\n  }\n}\n@keyframes indeterminate-rtl {\n  0% {\n    left: 100%;\n    right: -90%;\n  }\n  60% {\n    left: 100%;\n    right: -90%;\n  }\n  100% {\n    left: -35%;\n    right: 100%;\n  }\n}\n@keyframes indeterminate-short-ltr {\n  0% {\n    left: -200%;\n    right: 100%;\n  }\n  60% {\n    left: 107%;\n    right: -8%;\n  }\n  100% {\n    left: 107%;\n    right: -8%;\n  }\n}\n@keyframes indeterminate-short-rtl {\n  0% {\n    left: 100%;\n    right: -200%;\n  }\n  60% {\n    left: -8%;\n    right: 107%;\n  }\n  100% {\n    left: -8%;\n    right: 107%;\n  }\n}\n@keyframes stream {\n  to {\n    transform: translateX(var(--v-progress-linear-stream-to));\n  }\n}\n@keyframes progress-linear-stripes {\n  0% {\n    background-position-x: var(--v-progress-linear-height);\n  }\n}\n\n/* ../posawesome/node_modules/vuetify/lib/directives/ripple/VRipple.css */\n.v-ripple__container {\n  color: inherit;\n  border-radius: inherit;\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n  overflow: hidden;\n  z-index: 0;\n  pointer-events: none;\n  contain: strict;\n}\n.v-ripple__animation {\n  color: inherit;\n  position: absolute;\n  top: 0;\n  left: 0;\n  border-radius: 50%;\n  background: currentColor;\n  opacity: 0;\n  pointer-events: none;\n  overflow: hidden;\n  will-change: transform, opacity;\n}\n.v-ripple__animation--enter {\n  transition: none;\n  opacity: 0;\n}\n.v-ripple__animation--in {\n  transition: transform 0.25s cubic-bezier(0, 0, 0.2, 1), opacity 0.1s cubic-bezier(0, 0, 0.2, 1);\n  opacity: calc(0.25 * var(--v-theme-overlay-multiplier));\n}\n.v-ripple__animation--out {\n  transition: opacity 0.3s cubic-bezier(0, 0, 0.2, 1);\n  opacity: 0;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VAlert/VAlert.css */\n.v-alert {\n  display: grid;\n  flex: 1 1;\n  grid-template-areas: \"prepend content append close\" \". content . .\";\n  grid-template-columns: max-content auto max-content max-content;\n  position: relative;\n  padding: 16px;\n  overflow: hidden;\n  --v-border-color: currentColor;\n}\n.v-alert--absolute {\n  position: absolute;\n}\n.v-alert--fixed {\n  position: fixed;\n}\n.v-alert--sticky {\n  position: sticky;\n}\n.v-alert {\n  border-radius: 4px;\n}\n.v-alert--variant-plain,\n.v-alert--variant-outlined,\n.v-alert--variant-text,\n.v-alert--variant-tonal {\n  background: transparent;\n  color: inherit;\n}\n.v-alert--variant-plain {\n  opacity: 0.62;\n}\n.v-alert--variant-plain:focus,\n.v-alert--variant-plain:hover {\n  opacity: 1;\n}\n.v-alert--variant-plain .v-alert__overlay {\n  display: none;\n}\n.v-alert--variant-elevated,\n.v-alert--variant-flat {\n  background: rgb(var(--v-theme-surface-light));\n  color: rgba(var(--v-theme-on-surface-light), var(--v-high-emphasis-opacity));\n}\n.v-alert--variant-elevated {\n  box-shadow:\n    0px 2px 1px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 1px 1px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 3px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-alert--variant-flat {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-alert--variant-outlined {\n  border: thin solid currentColor;\n}\n.v-alert--variant-text .v-alert__overlay {\n  background: currentColor;\n}\n.v-alert--variant-tonal .v-alert__underlay {\n  background: currentColor;\n  opacity: var(--v-activated-opacity);\n  border-radius: inherit;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  pointer-events: none;\n}\n.v-alert .v-alert__underlay {\n  position: absolute;\n}\n.v-alert--prominent {\n  grid-template-areas: \"prepend content append close\" \"prepend content . .\";\n}\n.v-alert.v-alert--border {\n  --v-border-opacity: 0.38;\n}\n.v-alert.v-alert--border.v-alert--border-start {\n  padding-inline-start: 24px;\n}\n.v-alert.v-alert--border.v-alert--border-end {\n  padding-inline-end: 24px;\n}\n.v-alert--variant-plain {\n  transition: 0.2s opacity cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-alert--density-default {\n  padding-bottom: 16px;\n  padding-top: 16px;\n}\n.v-alert--density-default.v-alert--border-top {\n  padding-top: 24px;\n}\n.v-alert--density-default.v-alert--border-bottom {\n  padding-bottom: 24px;\n}\n.v-alert--density-comfortable {\n  padding-bottom: 12px;\n  padding-top: 12px;\n}\n.v-alert--density-comfortable.v-alert--border-top {\n  padding-top: 20px;\n}\n.v-alert--density-comfortable.v-alert--border-bottom {\n  padding-bottom: 20px;\n}\n.v-alert--density-compact {\n  padding-bottom: 8px;\n  padding-top: 8px;\n}\n.v-alert--density-compact.v-alert--border-top {\n  padding-top: 16px;\n}\n.v-alert--density-compact.v-alert--border-bottom {\n  padding-bottom: 16px;\n}\n.v-alert__border {\n  border-radius: inherit;\n  bottom: 0;\n  left: 0;\n  opacity: var(--v-border-opacity);\n  position: absolute;\n  pointer-events: none;\n  right: 0;\n  top: 0;\n  width: 100%;\n}\n.v-alert__border {\n  border-color: currentColor;\n  border-style: solid;\n  border-width: 0;\n}\n.v-alert__border--border {\n  border-width: 8px;\n  box-shadow: none;\n}\n.v-alert--border-start .v-alert__border {\n  border-inline-start-width: 8px;\n}\n.v-alert--border-end .v-alert__border {\n  border-inline-end-width: 8px;\n}\n.v-alert--border-top .v-alert__border {\n  border-top-width: 8px;\n}\n.v-alert--border-bottom .v-alert__border {\n  border-bottom-width: 8px;\n}\n.v-alert__close {\n  flex: 0 1 auto;\n  grid-area: close;\n}\n.v-alert__content {\n  align-self: center;\n  grid-area: content;\n  overflow: hidden;\n}\n.v-alert__append,\n.v-alert__close {\n  align-self: flex-start;\n  margin-inline-start: 16px;\n}\n.v-alert__append {\n  align-self: flex-start;\n  grid-area: append;\n}\n.v-alert__append + .v-alert__close {\n  margin-inline-start: 16px;\n}\n.v-alert__prepend {\n  align-self: flex-start;\n  display: flex;\n  align-items: center;\n  grid-area: prepend;\n  margin-inline-end: 16px;\n}\n.v-alert--prominent .v-alert__prepend {\n  align-self: center;\n}\n.v-alert__underlay {\n  grid-area: none;\n  position: absolute;\n}\n.v-alert--border-start .v-alert__underlay {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n.v-alert--border-end .v-alert__underlay {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.v-alert--border-top .v-alert__underlay {\n  border-top-left-radius: 0;\n  border-top-right-radius: 0;\n}\n.v-alert--border-bottom .v-alert__underlay {\n  border-bottom-left-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.v-alert-title {\n  align-items: center;\n  align-self: center;\n  display: flex;\n  font-size: 1.25rem;\n  font-weight: 500;\n  hyphens: auto;\n  letter-spacing: 0.0125em;\n  line-height: 1.75rem;\n  overflow-wrap: normal;\n  text-transform: none;\n  word-break: normal;\n  word-wrap: break-word;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VAutocomplete/VAutocomplete.css */\n.v-autocomplete--chips.v-input--density-compact .v-field--variant-solo .v-label.v-field-label--floating,\n.v-autocomplete--chips.v-input--density-compact .v-field--variant-solo-inverted .v-label.v-field-label--floating,\n.v-autocomplete--chips.v-input--density-compact .v-field--variant-filled .v-label.v-field-label--floating,\n.v-autocomplete--chips.v-input--density-compact .v-field--variant-solo-filled .v-label.v-field-label--floating {\n  top: 0px;\n}\n.v-autocomplete .v-field .v-text-field__prefix,\n.v-autocomplete .v-field .v-text-field__suffix,\n.v-autocomplete .v-field .v-field__input,\n.v-autocomplete .v-field.v-field {\n  cursor: text;\n}\n.v-autocomplete .v-field .v-field__input > input {\n  flex: 1 1;\n}\n.v-autocomplete .v-field input {\n  min-width: 64px;\n}\n.v-autocomplete .v-field:not(.v-field--focused) input {\n  min-width: 0;\n}\n.v-autocomplete .v-field--dirty .v-autocomplete__selection {\n  margin-inline-end: 2px;\n}\n.v-autocomplete .v-autocomplete__selection-text {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n.v-autocomplete__content {\n  overflow: hidden;\n}\n.v-autocomplete__content {\n  box-shadow:\n    0px 2px 4px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 4px 5px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 10px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-autocomplete__content {\n  border-radius: 4px;\n}\n.v-autocomplete__mask {\n  background: rgb(var(--v-theme-surface-light));\n}\n.v-autocomplete__selection {\n  display: inline-flex;\n  align-items: center;\n  height: 1.5rem;\n  letter-spacing: inherit;\n  line-height: inherit;\n  max-width: calc(100% - 2px - 2px);\n}\n.v-autocomplete__selection:first-child {\n  margin-inline-start: 0;\n}\n.v-autocomplete--selecting-index .v-autocomplete__selection {\n  opacity: var(--v-medium-emphasis-opacity);\n}\n.v-autocomplete--selecting-index .v-autocomplete__selection--selected {\n  opacity: 1;\n}\n.v-autocomplete--selecting-index .v-field__input > input {\n  caret-color: transparent;\n}\n.v-autocomplete--single:not(.v-autocomplete--selection-slot).v-text-field input {\n  flex: 1 1;\n  position: absolute;\n  left: 0;\n  right: 0;\n  width: 100%;\n  padding-inline: inherit;\n}\n.v-autocomplete--single:not(.v-autocomplete--selection-slot) .v-field--active input {\n  transition: none;\n}\n.v-autocomplete--single:not(.v-autocomplete--selection-slot) .v-field--dirty:not(.v-field--focused) input {\n  opacity: 0;\n}\n.v-autocomplete--single:not(.v-autocomplete--selection-slot) .v-field--focused .v-autocomplete__selection {\n  opacity: 0;\n}\n.v-autocomplete__menu-icon {\n  margin-inline-start: 4px;\n  transition: 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-autocomplete--active-menu .v-autocomplete__menu-icon {\n  transform: rotate(180deg);\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VAvatar/VAvatar.css */\n.v-avatar {\n  flex: none;\n  align-items: center;\n  display: inline-flex;\n  justify-content: center;\n  line-height: normal;\n  overflow: hidden;\n  position: relative;\n  text-align: center;\n  transition: 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n  transition-property: width, height;\n  vertical-align: middle;\n}\n.v-avatar.v-avatar--size-x-small {\n  --v-avatar-height: 24px;\n}\n.v-avatar.v-avatar--size-small {\n  --v-avatar-height: 32px;\n}\n.v-avatar.v-avatar--size-default {\n  --v-avatar-height: 40px;\n}\n.v-avatar.v-avatar--size-large {\n  --v-avatar-height: 48px;\n}\n.v-avatar.v-avatar--size-x-large {\n  --v-avatar-height: 56px;\n}\n.v-avatar.v-avatar--density-default {\n  height: calc(var(--v-avatar-height) + 0px);\n  width: calc(var(--v-avatar-height) + 0px);\n}\n.v-avatar.v-avatar--density-comfortable {\n  height: calc(var(--v-avatar-height) + -4px);\n  width: calc(var(--v-avatar-height) + -4px);\n}\n.v-avatar.v-avatar--density-compact {\n  height: calc(var(--v-avatar-height) + -8px);\n  width: calc(var(--v-avatar-height) + -8px);\n}\n.v-avatar {\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-style: solid;\n  border-width: 0;\n}\n.v-avatar--border {\n  border-width: thin;\n  box-shadow: none;\n}\n.v-avatar {\n  border-radius: 50%;\n}\n.v-avatar--variant-plain,\n.v-avatar--variant-outlined,\n.v-avatar--variant-text,\n.v-avatar--variant-tonal {\n  background: transparent;\n  color: inherit;\n}\n.v-avatar--variant-plain {\n  opacity: 0.62;\n}\n.v-avatar--variant-plain:focus,\n.v-avatar--variant-plain:hover {\n  opacity: 1;\n}\n.v-avatar--variant-plain .v-avatar__overlay {\n  display: none;\n}\n.v-avatar--variant-elevated,\n.v-avatar--variant-flat {\n  background: var(--v-theme-surface);\n  color: rgba(var(--v-theme-on-surface), var(--v-medium-emphasis-opacity));\n}\n.v-avatar--variant-elevated {\n  box-shadow:\n    0px 2px 1px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 1px 1px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 3px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-avatar--variant-flat {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-avatar--variant-outlined {\n  border: thin solid currentColor;\n}\n.v-avatar--variant-text .v-avatar__overlay {\n  background: currentColor;\n}\n.v-avatar--variant-tonal .v-avatar__underlay {\n  background: currentColor;\n  opacity: var(--v-activated-opacity);\n  border-radius: inherit;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  pointer-events: none;\n}\n.v-avatar .v-avatar__underlay {\n  position: absolute;\n}\n.v-avatar--rounded {\n  border-radius: 4px;\n}\n.v-avatar--start {\n  margin-inline-end: 8px;\n}\n.v-avatar--end {\n  margin-inline-start: 8px;\n}\n.v-avatar .v-img {\n  height: 100%;\n  width: 100%;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VCheckbox/VCheckbox.css */\n.v-checkbox.v-input {\n  flex: 0 1 auto;\n}\n.v-checkbox .v-selection-control {\n  min-height: var(--v-input-control-height);\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VSelectionControl/VSelectionControl.css */\n.v-selection-control {\n  align-items: center;\n  contain: layout;\n  display: flex;\n  flex: 1 0;\n  grid-area: control;\n  position: relative;\n  user-select: none;\n}\n.v-selection-control .v-label {\n  white-space: normal;\n  word-break: break-word;\n  height: 100%;\n  opacity: 1;\n}\n.v-selection-control--disabled {\n  opacity: var(--v-disabled-opacity);\n  pointer-events: none;\n}\n.v-selection-control--error:not(.v-selection-control--disabled) .v-label {\n  color: rgb(var(--v-theme-error));\n}\n.v-selection-control--inline {\n  display: inline-flex;\n  flex: 0 0 auto;\n  min-width: 0;\n  max-width: 100%;\n}\n.v-selection-control--inline .v-label {\n  width: auto;\n}\n.v-selection-control--density-default {\n  --v-selection-control-size: 40px;\n}\n.v-selection-control--density-comfortable {\n  --v-selection-control-size: 36px;\n}\n.v-selection-control--density-compact {\n  --v-selection-control-size: 28px;\n}\n.v-selection-control__wrapper {\n  width: var(--v-selection-control-size);\n  height: var(--v-selection-control-size);\n  display: inline-flex;\n  align-items: center;\n  position: relative;\n  justify-content: center;\n  flex: none;\n}\n.v-selection-control__input {\n  width: var(--v-selection-control-size);\n  height: var(--v-selection-control-size);\n  align-items: center;\n  display: flex;\n  flex: none;\n  justify-content: center;\n  position: relative;\n  border-radius: 50%;\n}\n.v-selection-control__input input {\n  cursor: pointer;\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  opacity: 0;\n}\n.v-selection-control__input::before {\n  border-radius: 100%;\n  background-color: currentColor;\n  opacity: 0;\n  pointer-events: none;\n}\n.v-selection-control__input::before {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n.v-selection-control__input:hover::before {\n  opacity: calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-selection-control__input > .v-icon {\n  opacity: var(--v-medium-emphasis-opacity);\n}\n.v-selection-control--disabled .v-selection-control__input > .v-icon,\n.v-selection-control--dirty .v-selection-control__input > .v-icon,\n.v-selection-control--error .v-selection-control__input > .v-icon {\n  opacity: 1;\n}\n.v-selection-control--error:not(.v-selection-control--disabled) .v-selection-control__input > .v-icon {\n  color: rgb(var(--v-theme-error));\n}\n.v-selection-control--focus-visible .v-selection-control__input::before {\n  opacity: calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier));\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VLabel/VLabel.css */\n.v-label {\n  align-items: center;\n  color: inherit;\n  display: inline-flex;\n  font-size: 1rem;\n  letter-spacing: 0.009375em;\n  min-width: 0;\n  opacity: var(--v-medium-emphasis-opacity);\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n.v-label--clickable {\n  cursor: pointer;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VSelectionControlGroup/VSelectionControlGroup.css */\n.v-selection-control-group {\n  grid-area: control;\n  display: flex;\n  flex-direction: column;\n}\n.v-selection-control-group--inline {\n  flex-direction: row;\n  flex-wrap: wrap;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VInput/VInput.css */\n.v-input {\n  display: grid;\n  flex: 1 1 auto;\n  font-size: 1rem;\n  font-weight: 400;\n  line-height: 1.5;\n}\n.v-input--disabled {\n  pointer-events: none;\n}\n.v-input--density-default {\n  --v-input-control-height: 56px;\n  --v-input-padding-top: 16px;\n}\n.v-input--density-comfortable {\n  --v-input-control-height: 48px;\n  --v-input-padding-top: 12px;\n}\n.v-input--density-compact {\n  --v-input-control-height: 40px;\n  --v-input-padding-top: 8px;\n}\n.v-input--vertical {\n  grid-template-areas: \"append\" \"control\" \"prepend\";\n  grid-template-rows: max-content auto max-content;\n  grid-template-columns: min-content;\n}\n.v-input--vertical .v-input__prepend {\n  margin-block-start: 16px;\n}\n.v-input--vertical .v-input__append {\n  margin-block-end: 16px;\n}\n.v-input--horizontal {\n  grid-template-areas: \"prepend control append\" \"a messages b\";\n  grid-template-columns: max-content minmax(0, 1fr) max-content;\n  grid-template-rows: 1fr auto;\n}\n.v-input--horizontal .v-input__prepend {\n  margin-inline-end: 16px;\n}\n.v-input--horizontal .v-input__append {\n  margin-inline-start: 16px;\n}\n.v-input__details {\n  align-items: flex-end;\n  display: flex;\n  font-size: 0.75rem;\n  font-weight: 400;\n  grid-area: messages;\n  letter-spacing: 0.0333333333em;\n  line-height: normal;\n  min-height: 22px;\n  padding-top: 6px;\n  overflow: hidden;\n  justify-content: space-between;\n}\n.v-input__details > .v-icon,\n.v-input__prepend > .v-icon,\n.v-input__append > .v-icon {\n  opacity: var(--v-medium-emphasis-opacity);\n}\n.v-input--disabled .v-input__details > .v-icon,\n.v-input--disabled .v-input__details .v-messages,\n.v-input--error .v-input__details > .v-icon,\n.v-input--error .v-input__details .v-messages,\n.v-input--disabled .v-input__prepend > .v-icon,\n.v-input--disabled .v-input__prepend .v-messages,\n.v-input--error .v-input__prepend > .v-icon,\n.v-input--error .v-input__prepend .v-messages,\n.v-input--disabled .v-input__append > .v-icon,\n.v-input--disabled .v-input__append .v-messages,\n.v-input--error .v-input__append > .v-icon,\n.v-input--error .v-input__append .v-messages {\n  opacity: 1;\n}\n.v-input--glow.v-input--focused .v-input__details > .v-icon,\n.v-input--glow.v-input--focused .v-input__prepend > .v-icon,\n.v-input--glow.v-input--focused .v-input__append > .v-icon {\n  opacity: 1;\n}\n.v-input--disabled .v-input__details,\n.v-input--disabled .v-input__prepend,\n.v-input--disabled .v-input__append {\n  opacity: var(--v-disabled-opacity);\n}\n.v-input--error:not(.v-input--disabled) .v-input__details > .v-icon,\n.v-input--error:not(.v-input--disabled) .v-input__details .v-messages,\n.v-input--error:not(.v-input--disabled) .v-input__prepend > .v-icon,\n.v-input--error:not(.v-input--disabled) .v-input__prepend .v-messages,\n.v-input--error:not(.v-input--disabled) .v-input__append > .v-icon,\n.v-input--error:not(.v-input--disabled) .v-input__append .v-messages {\n  color: rgb(var(--v-theme-error));\n}\n.v-input__prepend,\n.v-input__append {\n  display: flex;\n  align-items: flex-start;\n  padding-top: var(--v-input-padding-top);\n}\n.v-input--center-affix .v-input__prepend,\n.v-input--center-affix .v-input__append {\n  align-items: center;\n  padding-top: 0;\n}\n.v-input__prepend {\n  grid-area: prepend;\n}\n.v-input__append {\n  grid-area: append;\n}\n.v-input__control {\n  display: flex;\n  grid-area: control;\n}\n.v-input--hide-spin-buttons input::-webkit-outer-spin-button,\n.v-input--hide-spin-buttons input::-webkit-inner-spin-button {\n  -webkit-appearance: none;\n  margin: 0;\n}\n.v-input--hide-spin-buttons input[type=number] {\n  -moz-appearance: textfield;\n}\n.v-input--plain-underlined .v-input__prepend,\n.v-input--plain-underlined .v-input__append {\n  align-items: flex-start;\n}\n.v-input--density-default.v-input--plain-underlined .v-input__prepend,\n.v-input--density-default.v-input--plain-underlined .v-input__append {\n  padding-top: calc(var(--v-input-padding-top) + 4px);\n}\n.v-input--density-comfortable.v-input--plain-underlined .v-input__prepend,\n.v-input--density-comfortable.v-input--plain-underlined .v-input__append {\n  padding-top: calc(var(--v-input-padding-top) + 2px);\n}\n.v-input--density-compact.v-input--plain-underlined .v-input__prepend,\n.v-input--density-compact.v-input--plain-underlined .v-input__append {\n  padding-top: calc(var(--v-input-padding-top) + 0px);\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VMessages/VMessages.css */\n.v-messages {\n  flex: 1 1 auto;\n  font-size: 12px;\n  min-height: 14px;\n  min-width: 1px;\n  opacity: var(--v-medium-emphasis-opacity);\n  position: relative;\n}\n.v-messages__message {\n  line-height: 12px;\n  word-break: break-word;\n  overflow-wrap: break-word;\n  word-wrap: break-word;\n  hyphens: auto;\n  transition-duration: 150ms;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VChip/VChip.css */\n.v-chip {\n  align-items: center;\n  display: inline-flex;\n  font-weight: 400;\n  max-width: 100%;\n  min-width: 0;\n  overflow: hidden;\n  position: relative;\n  text-decoration: none;\n  white-space: nowrap;\n  vertical-align: middle;\n}\n.v-chip .v-icon {\n  --v-icon-size-multiplier: 0.8571428571;\n}\n.v-chip.v-chip--size-x-small {\n  --v-chip-size: 0.625rem;\n  --v-chip-height: 20px;\n  font-size: 0.625rem;\n  padding: 0 8px;\n}\n.v-chip.v-chip--size-x-small .v-avatar {\n  --v-avatar-height: 14px;\n}\n.v-chip--pill.v-chip.v-chip--size-x-small .v-avatar {\n  --v-avatar-height: 20px;\n}\n.v-chip.v-chip--size-x-small .v-avatar--start {\n  margin-inline-start: -5.6px;\n  margin-inline-end: 4px;\n}\n.v-chip--pill.v-chip.v-chip--size-x-small .v-avatar--start {\n  margin-inline-start: -8px;\n}\n.v-chip.v-chip--size-x-small .v-avatar--end {\n  margin-inline-start: 4px;\n  margin-inline-end: -5.6px;\n}\n.v-chip--pill.v-chip.v-chip--size-x-small .v-avatar--end {\n  margin-inline-end: -8px;\n}\n.v-chip--pill.v-chip.v-chip--size-x-small .v-avatar--end + .v-chip__close {\n  margin-inline-start: 12px;\n}\n.v-chip.v-chip--size-x-small .v-icon--start,\n.v-chip.v-chip--size-x-small .v-chip__filter {\n  margin-inline-start: -4px;\n  margin-inline-end: 4px;\n}\n.v-chip.v-chip--size-x-small .v-icon--end,\n.v-chip.v-chip--size-x-small .v-chip__close {\n  margin-inline-start: 4px;\n  margin-inline-end: -4px;\n}\n.v-chip.v-chip--size-x-small .v-icon--end + .v-chip__close,\n.v-chip.v-chip--size-x-small .v-avatar--end + .v-chip__close,\n.v-chip.v-chip--size-x-small .v-chip__append + .v-chip__close {\n  margin-inline-start: 8px;\n}\n.v-chip.v-chip--size-small {\n  --v-chip-size: 0.75rem;\n  --v-chip-height: 26px;\n  font-size: 0.75rem;\n  padding: 0 10px;\n}\n.v-chip.v-chip--size-small .v-avatar {\n  --v-avatar-height: 20px;\n}\n.v-chip--pill.v-chip.v-chip--size-small .v-avatar {\n  --v-avatar-height: 26px;\n}\n.v-chip.v-chip--size-small .v-avatar--start {\n  margin-inline-start: -7px;\n  margin-inline-end: 5px;\n}\n.v-chip--pill.v-chip.v-chip--size-small .v-avatar--start {\n  margin-inline-start: -10px;\n}\n.v-chip.v-chip--size-small .v-avatar--end {\n  margin-inline-start: 5px;\n  margin-inline-end: -7px;\n}\n.v-chip--pill.v-chip.v-chip--size-small .v-avatar--end {\n  margin-inline-end: -10px;\n}\n.v-chip--pill.v-chip.v-chip--size-small .v-avatar--end + .v-chip__close {\n  margin-inline-start: 15px;\n}\n.v-chip.v-chip--size-small .v-icon--start,\n.v-chip.v-chip--size-small .v-chip__filter {\n  margin-inline-start: -5px;\n  margin-inline-end: 5px;\n}\n.v-chip.v-chip--size-small .v-icon--end,\n.v-chip.v-chip--size-small .v-chip__close {\n  margin-inline-start: 5px;\n  margin-inline-end: -5px;\n}\n.v-chip.v-chip--size-small .v-icon--end + .v-chip__close,\n.v-chip.v-chip--size-small .v-avatar--end + .v-chip__close,\n.v-chip.v-chip--size-small .v-chip__append + .v-chip__close {\n  margin-inline-start: 10px;\n}\n.v-chip.v-chip--size-default {\n  --v-chip-size: 0.875rem;\n  --v-chip-height: 32px;\n  font-size: 0.875rem;\n  padding: 0 12px;\n}\n.v-chip.v-chip--size-default .v-avatar {\n  --v-avatar-height: 26px;\n}\n.v-chip--pill.v-chip.v-chip--size-default .v-avatar {\n  --v-avatar-height: 32px;\n}\n.v-chip.v-chip--size-default .v-avatar--start {\n  margin-inline-start: -8.4px;\n  margin-inline-end: 6px;\n}\n.v-chip--pill.v-chip.v-chip--size-default .v-avatar--start {\n  margin-inline-start: -12px;\n}\n.v-chip.v-chip--size-default .v-avatar--end {\n  margin-inline-start: 6px;\n  margin-inline-end: -8.4px;\n}\n.v-chip--pill.v-chip.v-chip--size-default .v-avatar--end {\n  margin-inline-end: -12px;\n}\n.v-chip--pill.v-chip.v-chip--size-default .v-avatar--end + .v-chip__close {\n  margin-inline-start: 18px;\n}\n.v-chip.v-chip--size-default .v-icon--start,\n.v-chip.v-chip--size-default .v-chip__filter {\n  margin-inline-start: -6px;\n  margin-inline-end: 6px;\n}\n.v-chip.v-chip--size-default .v-icon--end,\n.v-chip.v-chip--size-default .v-chip__close {\n  margin-inline-start: 6px;\n  margin-inline-end: -6px;\n}\n.v-chip.v-chip--size-default .v-icon--end + .v-chip__close,\n.v-chip.v-chip--size-default .v-avatar--end + .v-chip__close,\n.v-chip.v-chip--size-default .v-chip__append + .v-chip__close {\n  margin-inline-start: 12px;\n}\n.v-chip.v-chip--size-large {\n  --v-chip-size: 1rem;\n  --v-chip-height: 38px;\n  font-size: 1rem;\n  padding: 0 14px;\n}\n.v-chip.v-chip--size-large .v-avatar {\n  --v-avatar-height: 32px;\n}\n.v-chip--pill.v-chip.v-chip--size-large .v-avatar {\n  --v-avatar-height: 38px;\n}\n.v-chip.v-chip--size-large .v-avatar--start {\n  margin-inline-start: -9.8px;\n  margin-inline-end: 7px;\n}\n.v-chip--pill.v-chip.v-chip--size-large .v-avatar--start {\n  margin-inline-start: -14px;\n}\n.v-chip.v-chip--size-large .v-avatar--end {\n  margin-inline-start: 7px;\n  margin-inline-end: -9.8px;\n}\n.v-chip--pill.v-chip.v-chip--size-large .v-avatar--end {\n  margin-inline-end: -14px;\n}\n.v-chip--pill.v-chip.v-chip--size-large .v-avatar--end + .v-chip__close {\n  margin-inline-start: 21px;\n}\n.v-chip.v-chip--size-large .v-icon--start,\n.v-chip.v-chip--size-large .v-chip__filter {\n  margin-inline-start: -7px;\n  margin-inline-end: 7px;\n}\n.v-chip.v-chip--size-large .v-icon--end,\n.v-chip.v-chip--size-large .v-chip__close {\n  margin-inline-start: 7px;\n  margin-inline-end: -7px;\n}\n.v-chip.v-chip--size-large .v-icon--end + .v-chip__close,\n.v-chip.v-chip--size-large .v-avatar--end + .v-chip__close,\n.v-chip.v-chip--size-large .v-chip__append + .v-chip__close {\n  margin-inline-start: 14px;\n}\n.v-chip.v-chip--size-x-large {\n  --v-chip-size: 1.125rem;\n  --v-chip-height: 44px;\n  font-size: 1.125rem;\n  padding: 0 17px;\n}\n.v-chip.v-chip--size-x-large .v-avatar {\n  --v-avatar-height: 38px;\n}\n.v-chip--pill.v-chip.v-chip--size-x-large .v-avatar {\n  --v-avatar-height: 44px;\n}\n.v-chip.v-chip--size-x-large .v-avatar--start {\n  margin-inline-start: -11.9px;\n  margin-inline-end: 8.5px;\n}\n.v-chip--pill.v-chip.v-chip--size-x-large .v-avatar--start {\n  margin-inline-start: -17px;\n}\n.v-chip.v-chip--size-x-large .v-avatar--end {\n  margin-inline-start: 8.5px;\n  margin-inline-end: -11.9px;\n}\n.v-chip--pill.v-chip.v-chip--size-x-large .v-avatar--end {\n  margin-inline-end: -17px;\n}\n.v-chip--pill.v-chip.v-chip--size-x-large .v-avatar--end + .v-chip__close {\n  margin-inline-start: 25.5px;\n}\n.v-chip.v-chip--size-x-large .v-icon--start,\n.v-chip.v-chip--size-x-large .v-chip__filter {\n  margin-inline-start: -8.5px;\n  margin-inline-end: 8.5px;\n}\n.v-chip.v-chip--size-x-large .v-icon--end,\n.v-chip.v-chip--size-x-large .v-chip__close {\n  margin-inline-start: 8.5px;\n  margin-inline-end: -8.5px;\n}\n.v-chip.v-chip--size-x-large .v-icon--end + .v-chip__close,\n.v-chip.v-chip--size-x-large .v-avatar--end + .v-chip__close,\n.v-chip.v-chip--size-x-large .v-chip__append + .v-chip__close {\n  margin-inline-start: 17px;\n}\n.v-chip.v-chip--density-default {\n  height: calc(var(--v-chip-height) + 0px);\n}\n.v-chip.v-chip--density-comfortable {\n  height: calc(var(--v-chip-height) + -4px);\n}\n.v-chip.v-chip--density-compact {\n  height: calc(var(--v-chip-height) + -8px);\n}\n.v-chip {\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-style: solid;\n  border-width: 0;\n}\n.v-chip:hover > .v-chip__overlay {\n  opacity: calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-chip:focus-visible > .v-chip__overlay {\n  opacity: calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier));\n}\n@supports not selector(:focus-visible) {\n  .v-chip:focus > .v-chip__overlay {\n    opacity: calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-chip--active > .v-chip__overlay,\n.v-chip[aria-haspopup=menu][aria-expanded=true] > .v-chip__overlay {\n  opacity: calc(var(--v-activated-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-chip--active:hover > .v-chip__overlay,\n.v-chip[aria-haspopup=menu][aria-expanded=true]:hover > .v-chip__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier));\n}\n.v-chip--active:focus-visible > .v-chip__overlay,\n.v-chip[aria-haspopup=menu][aria-expanded=true]:focus-visible > .v-chip__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n}\n@supports not selector(:focus-visible) {\n  .v-chip--active:focus > .v-chip__overlay,\n  .v-chip[aria-haspopup=menu][aria-expanded=true]:focus > .v-chip__overlay {\n    opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-chip {\n  border-radius: 9999px;\n}\n.v-chip--variant-plain,\n.v-chip--variant-outlined,\n.v-chip--variant-text,\n.v-chip--variant-tonal {\n  background: transparent;\n  color: inherit;\n}\n.v-chip--variant-plain {\n  opacity: 0.26;\n}\n.v-chip--variant-plain:focus,\n.v-chip--variant-plain:hover {\n  opacity: 1;\n}\n.v-chip--variant-plain .v-chip__overlay {\n  display: none;\n}\n.v-chip--variant-elevated,\n.v-chip--variant-flat {\n  background: rgb(var(--v-theme-surface-variant));\n  color: rgb(var(--v-theme-on-surface-variant));\n}\n.v-chip--variant-elevated {\n  box-shadow:\n    0px 2px 1px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 1px 1px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 3px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-chip--variant-flat {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-chip--variant-outlined {\n  border: thin solid currentColor;\n}\n.v-chip--variant-text .v-chip__overlay {\n  background: currentColor;\n}\n.v-chip--variant-tonal .v-chip__underlay {\n  background: currentColor;\n  opacity: var(--v-activated-opacity);\n  border-radius: inherit;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  pointer-events: none;\n}\n.v-chip .v-chip__underlay {\n  position: absolute;\n}\n.v-chip--border {\n  border-width: thin;\n}\n.v-chip--link {\n  cursor: pointer;\n}\n.v-chip--link,\n.v-chip--filter {\n  user-select: none;\n}\n.v-chip--label {\n  border-radius: 4px;\n}\n.v-chip__content {\n  align-items: center;\n  display: inline-flex;\n}\n.v-autocomplete__selection .v-chip__content,\n.v-combobox__selection .v-chip__content,\n.v-select__selection .v-chip__content {\n  overflow: hidden;\n}\n.v-chip__filter,\n.v-chip__prepend,\n.v-chip__append,\n.v-chip__close {\n  align-items: center;\n  display: inline-flex;\n}\n.v-chip__close {\n  cursor: pointer;\n  flex: 0 1 auto;\n  font-size: 18px;\n  max-height: 18px;\n  max-width: 18px;\n  user-select: none;\n}\n.v-chip__close .v-icon {\n  font-size: inherit;\n}\n.v-chip__filter {\n  transition: 0.15s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-chip__overlay {\n  background-color: currentColor;\n  border-radius: inherit;\n  pointer-events: none;\n  opacity: 0;\n  transition: opacity 0.2s ease-in-out;\n}\n.v-chip__overlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n.v-chip--disabled {\n  opacity: 0.3;\n  pointer-events: none;\n  user-select: none;\n}\n.v-chip--label {\n  border-radius: 4px;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VChipGroup/VChipGroup.css */\n.v-chip-group {\n  display: flex;\n  max-width: 100%;\n  min-width: 0;\n  overflow-x: auto;\n  padding: 4px 0;\n}\n.v-chip-group .v-chip {\n  margin: 4px 8px 4px 0;\n}\n.v-chip-group .v-chip.v-chip--selected:not(.v-chip--disabled) .v-chip__overlay {\n  opacity: var(--v-activated-opacity);\n}\n.v-chip-group--column .v-slide-group__content {\n  white-space: normal;\n  flex-wrap: wrap;\n  max-width: 100%;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VSlideGroup/VSlideGroup.css */\n.v-slide-group {\n  display: flex;\n  overflow: hidden;\n}\n.v-slide-group__next,\n.v-slide-group__prev {\n  align-items: center;\n  display: flex;\n  flex: 0 1 52px;\n  justify-content: center;\n  min-width: 52px;\n  cursor: pointer;\n}\n.v-slide-group__next--disabled,\n.v-slide-group__prev--disabled {\n  pointer-events: none;\n  opacity: var(--v-disabled-opacity);\n}\n.v-slide-group__content {\n  display: flex;\n  flex: 1 0 auto;\n  position: relative;\n  transition: 0.2s all cubic-bezier(0.4, 0, 0.2, 1);\n  white-space: nowrap;\n}\n.v-slide-group__content > * {\n  white-space: initial;\n}\n.v-slide-group__container {\n  contain: content;\n  display: flex;\n  flex: 1 1 auto;\n  overflow-x: auto;\n  overflow-y: hidden;\n  scrollbar-width: none;\n  scrollbar-color: rgba(0, 0, 0, 0);\n}\n.v-slide-group__container::-webkit-scrollbar {\n  display: none;\n}\n.v-slide-group--vertical {\n  max-height: inherit;\n}\n.v-slide-group--vertical,\n.v-slide-group--vertical .v-slide-group__container,\n.v-slide-group--vertical .v-slide-group__content {\n  flex-direction: column;\n}\n.v-slide-group--vertical .v-slide-group__container {\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VList/VList.css */\n.v-list {\n  overflow: auto;\n  padding: 8px 0;\n  position: relative;\n  outline: none;\n}\n.v-list {\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-style: solid;\n  border-width: 0;\n}\n.v-list--border {\n  border-width: thin;\n  box-shadow: none;\n}\n.v-list {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-list {\n  border-radius: 0;\n}\n.v-list {\n  background: rgba(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-list--disabled {\n  pointer-events: none;\n  user-select: none;\n}\n.v-list--nav {\n  padding-inline: 8px;\n}\n.v-list--rounded {\n  border-radius: 4px;\n}\n.v-list--subheader {\n  padding-top: 0;\n}\n.v-list-img {\n  border-radius: inherit;\n  display: flex;\n  height: 100%;\n  left: 0;\n  overflow: hidden;\n  position: absolute;\n  top: 0;\n  width: 100%;\n  z-index: -1;\n}\n.v-list-subheader {\n  align-items: center;\n  background: inherit;\n  color: rgba(var(--v-theme-on-surface), var(--v-medium-emphasis-opacity));\n  display: flex;\n  font-size: 0.875rem;\n  font-weight: 400;\n  line-height: 1.375rem;\n  padding-inline-end: 16px;\n  min-height: 40px;\n  transition: 0.2s min-height cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-list-subheader__text {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n.v-list--density-default .v-list-subheader {\n  min-height: 40px;\n  padding-inline-start: calc(16px + var(--indent-padding)) !important;\n}\n.v-list--density-comfortable .v-list-subheader {\n  min-height: 36px;\n  padding-inline-start: calc(16px + var(--indent-padding)) !important;\n}\n.v-list--density-compact .v-list-subheader {\n  min-height: 32px;\n  padding-inline-start: calc(16px + var(--indent-padding)) !important;\n}\n.v-list-subheader--inset {\n  --indent-padding: 56px;\n}\n.v-list--nav .v-list-subheader {\n  font-size: 0.75rem;\n}\n.v-list-subheader--sticky {\n  background: inherit;\n  left: 0;\n  position: sticky;\n  top: 0;\n  z-index: 1;\n}\n.v-list__overlay {\n  background-color: currentColor;\n  border-radius: inherit;\n  bottom: 0;\n  left: 0;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  right: 0;\n  top: 0;\n  transition: opacity 0.2s ease-in-out;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VList/VListItem.css */\n.v-list-item {\n  align-items: center;\n  display: grid;\n  flex: none;\n  grid-template-areas: \"prepend content append\";\n  grid-template-columns: max-content 1fr auto;\n  outline: none;\n  max-width: 100%;\n  padding: 4px 16px;\n  position: relative;\n  text-decoration: none;\n}\n.v-list-item {\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-style: solid;\n  border-width: 0;\n}\n.v-list-item--border {\n  border-width: thin;\n  box-shadow: none;\n}\n.v-list-item:hover > .v-list-item__overlay {\n  opacity: calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-list-item:focus-visible > .v-list-item__overlay {\n  opacity: calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier));\n}\n@supports not selector(:focus-visible) {\n  .v-list-item:focus > .v-list-item__overlay {\n    opacity: calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-list-item--active > .v-list-item__overlay,\n.v-list-item[aria-haspopup=menu][aria-expanded=true] > .v-list-item__overlay {\n  opacity: calc(var(--v-activated-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-list-item--active:hover > .v-list-item__overlay,\n.v-list-item[aria-haspopup=menu][aria-expanded=true]:hover > .v-list-item__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier));\n}\n.v-list-item--active:focus-visible > .v-list-item__overlay,\n.v-list-item[aria-haspopup=menu][aria-expanded=true]:focus-visible > .v-list-item__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n}\n@supports not selector(:focus-visible) {\n  .v-list-item--active:focus > .v-list-item__overlay,\n  .v-list-item[aria-haspopup=menu][aria-expanded=true]:focus > .v-list-item__overlay {\n    opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-list-item {\n  border-radius: 0;\n}\n.v-list-item--variant-plain,\n.v-list-item--variant-outlined,\n.v-list-item--variant-text,\n.v-list-item--variant-tonal {\n  background: transparent;\n  color: inherit;\n}\n.v-list-item--variant-plain {\n  opacity: 0.62;\n}\n.v-list-item--variant-plain:focus,\n.v-list-item--variant-plain:hover {\n  opacity: 1;\n}\n.v-list-item--variant-plain .v-list-item__overlay {\n  display: none;\n}\n.v-list-item--variant-elevated,\n.v-list-item--variant-flat {\n  background: rgba(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-list-item--variant-elevated {\n  box-shadow:\n    0px 2px 1px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 1px 1px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 3px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-list-item--variant-flat {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-list-item--variant-outlined {\n  border: thin solid currentColor;\n}\n.v-list-item--variant-text .v-list-item__overlay {\n  background: currentColor;\n}\n.v-list-item--variant-tonal .v-list-item__underlay {\n  background: currentColor;\n  opacity: var(--v-activated-opacity);\n  border-radius: inherit;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  pointer-events: none;\n}\n.v-list-item .v-list-item__underlay {\n  position: absolute;\n}\n@supports selector(:focus-visible) {\n  .v-list-item::after {\n    pointer-events: none;\n    border: 2px solid currentColor;\n    border-radius: 4px;\n    opacity: 0;\n    transition: opacity 0.2s ease-in-out;\n  }\n  .v-list-item::after {\n    content: \"\";\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n  }\n  .v-list-item:focus-visible::after {\n    opacity: calc(0.15 * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-list-item__prepend > .v-badge .v-icon,\n.v-list-item__prepend > .v-icon,\n.v-list-item__append > .v-badge .v-icon,\n.v-list-item__append > .v-icon {\n  opacity: var(--v-medium-emphasis-opacity);\n}\n.v-list-item--active .v-list-item__prepend > .v-badge .v-icon,\n.v-list-item--active .v-list-item__prepend > .v-icon,\n.v-list-item--active .v-list-item__append > .v-badge .v-icon,\n.v-list-item--active .v-list-item__append > .v-icon {\n  opacity: 1;\n}\n.v-list-item--active:not(.v-list-item--link) .v-list-item__overlay {\n  opacity: calc(var(--v-activated-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-list-item--rounded {\n  border-radius: 4px;\n}\n.v-list-item--disabled {\n  pointer-events: none;\n  user-select: none;\n  opacity: 0.6;\n}\n.v-list-item--link {\n  cursor: pointer;\n}\n.v-navigation-drawer--rail:not(.v-navigation-drawer--expand-on-hover) .v-list-item .v-avatar,\n.v-navigation-drawer--rail.v-navigation-drawer--expand-on-hover:not(.v-navigation-drawer--is-hovering) .v-list-item .v-avatar {\n  --v-avatar-height: 24px;\n}\n.v-list-item__prepend {\n  align-items: center;\n  align-self: center;\n  display: flex;\n  grid-area: prepend;\n}\n.v-list-item__prepend > .v-badge ~ .v-list-item__spacer,\n.v-list-item__prepend > .v-icon ~ .v-list-item__spacer,\n.v-list-item__prepend > .v-tooltip ~ .v-list-item__spacer {\n  width: 32px;\n}\n.v-list-item__prepend > .v-avatar ~ .v-list-item__spacer,\n.v-list-item__prepend > .v-badge:is(:has(.v-avatar)) ~ .v-list-item__spacer {\n  width: 16px;\n}\n.v-list-item--slim .v-list-item__prepend > .v-badge ~ .v-list-item__spacer,\n.v-list-item--slim .v-list-item__prepend > .v-icon ~ .v-list-item__spacer,\n.v-list-item--slim .v-list-item__prepend > .v-tooltip ~ .v-list-item__spacer {\n  width: 20px;\n}\n.v-list-item--slim .v-list-item__prepend > .v-avatar ~ .v-list-item__spacer,\n.v-list-item--slim .v-list-item__prepend > .v-badge:is(:has(.v-avatar)) ~ .v-list-item__spacer {\n  width: 4px;\n}\n.v-list-item--slim .v-list-item__prepend > .v-list-item-action ~ .v-list-item__spacer {\n  width: 4px;\n}\n.v-list-item--three-line .v-list-item__prepend {\n  align-self: start;\n}\n.v-list-item__append {\n  align-self: center;\n  display: flex;\n  align-items: center;\n  grid-area: append;\n}\n.v-list-item__append .v-list-item__spacer {\n  order: -1;\n  transition: 150ms width cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-list-item__append > .v-badge ~ .v-list-item__spacer,\n.v-list-item__append > .v-icon ~ .v-list-item__spacer,\n.v-list-item__append > .v-tooltip ~ .v-list-item__spacer {\n  width: 32px;\n}\n.v-list-item__append > .v-avatar ~ .v-list-item__spacer,\n.v-list-item__append > .v-badge:is(:has(.v-avatar)) ~ .v-list-item__spacer {\n  width: 16px;\n}\n.v-list-item__append > .v-list-item-action ~ .v-list-item__spacer {\n  width: 16px;\n}\n.v-list-item--slim .v-list-item__append > .v-badge ~ .v-list-item__spacer,\n.v-list-item--slim .v-list-item__append > .v-icon ~ .v-list-item__spacer,\n.v-list-item--slim .v-list-item__append > .v-tooltip ~ .v-list-item__spacer {\n  width: 20px;\n}\n.v-list-item--slim .v-list-item__append > .v-avatar ~ .v-list-item__spacer,\n.v-list-item--slim .v-list-item__append > .v-badge:is(:has(.v-avatar)) ~ .v-list-item__spacer {\n  width: 4px;\n}\n.v-list-item--slim .v-list-item__append > .v-list-item-action ~ .v-list-item__spacer {\n  width: 4px;\n}\n.v-list-item--three-line .v-list-item__append {\n  align-self: start;\n}\n.v-list-item__content {\n  align-self: center;\n  grid-area: content;\n  overflow: hidden;\n  min-width: 40px;\n}\n.v-list-item-action {\n  align-self: center;\n  display: flex;\n  align-items: center;\n  flex: none;\n  transition: inherit;\n  transition-property: height, width;\n}\n.v-list-item-action--start {\n  margin-inline-end: 8px;\n  margin-inline-start: -8px;\n}\n.v-list-item-action--end {\n  margin-inline-start: 8px;\n  margin-inline-end: -8px;\n}\n.v-list-item-media {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n.v-list-item-media--start {\n  margin-inline-end: 16px;\n}\n.v-list-item-media--end {\n  margin-inline-start: 16px;\n}\n.v-list-item--two-line .v-list-item-media {\n  margin-top: -4px;\n  margin-bottom: -4px;\n}\n.v-list-item--three-line .v-list-item-media {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n.v-list-item-subtitle {\n  -webkit-box-orient: vertical;\n  display: -webkit-box;\n  opacity: var(--v-list-item-subtitle-opacity, var(--v-medium-emphasis-opacity));\n  overflow: hidden;\n  padding: 0;\n  text-overflow: ellipsis;\n  overflow-wrap: break-word;\n  word-break: initial;\n}\n.v-list-item--one-line .v-list-item-subtitle {\n  -webkit-line-clamp: 1;\n}\n.v-list-item--two-line .v-list-item-subtitle {\n  -webkit-line-clamp: 2;\n}\n.v-list-item--three-line .v-list-item-subtitle {\n  -webkit-line-clamp: 3;\n}\n.v-list-item-subtitle {\n  font-size: 0.875rem;\n  font-weight: 400;\n  letter-spacing: 0.0178571429em;\n  line-height: 1rem;\n  text-transform: none;\n}\n.v-list-item--nav .v-list-item-subtitle {\n  font-size: 0.75rem;\n  font-weight: 400;\n  letter-spacing: 0.0178571429em;\n  line-height: 1rem;\n}\n.v-list-item-title {\n  hyphens: auto;\n  overflow-wrap: normal;\n  overflow: hidden;\n  padding: 0;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  word-break: normal;\n  word-wrap: break-word;\n}\n.v-list-item-title {\n  font-size: 1rem;\n  font-weight: 400;\n  letter-spacing: 0.009375em;\n  line-height: 1.5;\n  text-transform: none;\n}\n.v-list-item--nav .v-list-item-title {\n  font-size: 0.8125rem;\n  font-weight: 500;\n  letter-spacing: normal;\n  line-height: 1rem;\n}\n.v-list-item--density-default {\n  min-height: 40px;\n}\n.v-list-item--density-default.v-list-item--one-line {\n  min-height: 48px;\n  padding-top: 4px;\n  padding-bottom: 4px;\n}\n.v-list-item--density-default.v-list-item--two-line {\n  min-height: 64px;\n  padding-top: 12px;\n  padding-bottom: 12px;\n}\n.v-list-item--density-default.v-list-item--three-line {\n  min-height: 88px;\n  padding-top: 16px;\n  padding-bottom: 16px;\n}\n.v-list-item--density-default.v-list-item--three-line .v-list-item__prepend,\n.v-list-item--density-default.v-list-item--three-line .v-list-item__append {\n  padding-top: 8px;\n}\n.v-list-item--density-default:not(.v-list-item--nav).v-list-item--one-line {\n  padding-inline: 16px;\n}\n.v-list-item--density-default:not(.v-list-item--nav).v-list-item--two-line {\n  padding-inline: 16px;\n}\n.v-list-item--density-default:not(.v-list-item--nav).v-list-item--three-line {\n  padding-inline: 16px;\n}\n.v-list-item--density-comfortable {\n  min-height: 36px;\n}\n.v-list-item--density-comfortable.v-list-item--one-line {\n  min-height: 44px;\n}\n.v-list-item--density-comfortable.v-list-item--two-line {\n  min-height: 60px;\n  padding-top: 8px;\n  padding-bottom: 8px;\n}\n.v-list-item--density-comfortable.v-list-item--three-line {\n  min-height: 84px;\n  padding-top: 12px;\n  padding-bottom: 12px;\n}\n.v-list-item--density-comfortable.v-list-item--three-line .v-list-item__prepend,\n.v-list-item--density-comfortable.v-list-item--three-line .v-list-item__append {\n  padding-top: 6px;\n}\n.v-list-item--density-comfortable:not(.v-list-item--nav).v-list-item--one-line {\n  padding-inline: 16px;\n}\n.v-list-item--density-comfortable:not(.v-list-item--nav).v-list-item--two-line {\n  padding-inline: 16px;\n}\n.v-list-item--density-comfortable:not(.v-list-item--nav).v-list-item--three-line {\n  padding-inline: 16px;\n}\n.v-list-item--density-compact {\n  min-height: 32px;\n}\n.v-list-item--density-compact.v-list-item--one-line {\n  min-height: 40px;\n}\n.v-list-item--density-compact.v-list-item--two-line {\n  min-height: 56px;\n  padding-top: 4px;\n  padding-bottom: 4px;\n}\n.v-list-item--density-compact.v-list-item--three-line {\n  min-height: 80px;\n  padding-top: 8px;\n  padding-bottom: 8px;\n}\n.v-list-item--density-compact.v-list-item--three-line .v-list-item__prepend,\n.v-list-item--density-compact.v-list-item--three-line .v-list-item__append {\n  padding-top: 4px;\n}\n.v-list-item--density-compact:not(.v-list-item--nav).v-list-item--one-line {\n  padding-inline: 16px;\n}\n.v-list-item--density-compact:not(.v-list-item--nav).v-list-item--two-line {\n  padding-inline: 16px;\n}\n.v-list-item--density-compact:not(.v-list-item--nav).v-list-item--three-line {\n  padding-inline: 16px;\n}\n.v-list-item--nav {\n  padding-inline: 8px;\n}\n.v-list .v-list-item--nav:not(:only-child) {\n  margin-bottom: 4px;\n}\n.v-list-item__underlay {\n  position: absolute;\n}\n.v-list-item__overlay {\n  background-color: currentColor;\n  border-radius: inherit;\n  bottom: 0;\n  left: 0;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  right: 0;\n  top: 0;\n  transition: opacity 0.2s ease-in-out;\n}\n.v-list-item--active.v-list-item--variant-elevated .v-list-item__overlay {\n  --v-theme-overlay-multiplier: 0;\n}\n.v-list {\n  --indent-padding: 0px;\n}\n.v-list--nav {\n  --indent-padding: -8px;\n}\n.v-list-group {\n  --list-indent-size: 16px;\n  --parent-padding: var(--indent-padding);\n  --prepend-width: 40px;\n}\n.v-list--slim .v-list-group {\n  --prepend-width: 28px;\n}\n.v-list-group--fluid {\n  --list-indent-size: 0px;\n}\n.v-list-group--prepend {\n  --parent-padding: calc(var(--indent-padding) + var(--prepend-width));\n}\n.v-list-group--fluid.v-list-group--prepend {\n  --parent-padding: var(--indent-padding);\n}\n.v-list-group__items {\n  --indent-padding: calc(var(--parent-padding) + var(--list-indent-size));\n  min-width: min-content;\n}\n.v-list-group__items .v-list-item {\n  padding-inline-start: calc(16px + var(--indent-padding)) !important;\n}\n.v-list-group__header:not(.v-treeview-item--activatable-group-activator).v-list-item--active:not(:focus-visible) .v-list-item__overlay {\n  opacity: 0;\n}\n.v-list-group__header:not(.v-treeview-item--activatable-group-activator).v-list-item--active:hover .v-list-item__overlay {\n  opacity: calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier));\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VDivider/VDivider.css */\n.v-divider {\n  display: block;\n  flex: 1 1 100%;\n  height: 0px;\n  max-height: 0px;\n  opacity: var(--v-border-opacity);\n  transition: inherit;\n}\n.v-divider {\n  border-style: solid;\n  border-width: thin 0 0 0;\n}\n.v-divider--vertical {\n  align-self: stretch;\n  border-width: 0 thin 0 0;\n  display: inline-flex;\n  height: auto;\n  margin-left: -1px;\n  max-height: 100%;\n  max-width: 0px;\n  vertical-align: text-bottom;\n  width: 0px;\n}\n.v-divider--inset:not(.v-divider--vertical) {\n  max-width: calc(100% - 72px);\n  margin-inline-start: 72px;\n}\n.v-divider--inset.v-divider--vertical {\n  margin-bottom: 8px;\n  margin-top: 8px;\n  max-height: calc(100% - 16px);\n}\n.v-divider__content {\n  padding: 0 16px;\n  text-wrap: nowrap;\n}\n.v-divider__wrapper--vertical .v-divider__content {\n  padding: 4px 0;\n}\n.v-divider__wrapper {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.v-divider__wrapper--vertical {\n  flex-direction: column;\n  height: 100%;\n}\n.v-divider__wrapper--vertical .v-divider {\n  margin: 0 auto;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VMenu/VMenu.css */\n.v-menu > .v-overlay__content {\n  display: flex;\n  flex-direction: column;\n}\n.v-menu > .v-overlay__content {\n  border-radius: 4px;\n}\n.v-menu > .v-overlay__content > .v-card,\n.v-menu > .v-overlay__content > .v-sheet,\n.v-menu > .v-overlay__content > .v-list {\n  background: rgb(var(--v-theme-surface));\n  border-radius: inherit;\n  overflow: auto;\n  height: 100%;\n}\n.v-menu > .v-overlay__content > .v-card,\n.v-menu > .v-overlay__content > .v-sheet,\n.v-menu > .v-overlay__content > .v-list {\n  box-shadow:\n    0px 5px 5px -3px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 8px 10px 1px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 3px 14px 2px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VOverlay/VOverlay.css */\n.v-overlay-container {\n  contain: layout;\n  left: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 0;\n  display: contents;\n}\n.v-overlay-scroll-blocked {\n  padding-inline-end: var(--v-scrollbar-offset);\n}\n.v-overlay-scroll-blocked:not(html) {\n  overflow-y: hidden !important;\n}\nhtml.v-overlay-scroll-blocked {\n  position: fixed;\n  top: var(--v-body-scroll-y);\n  left: var(--v-body-scroll-x);\n  width: 100%;\n  height: 100%;\n}\n.v-overlay {\n  --v-overlay-opacity: 0.32;\n  border-radius: inherit;\n  display: flex;\n  left: 0;\n  pointer-events: none;\n  position: fixed;\n  top: 0;\n  bottom: 0;\n  right: 0;\n}\n.v-overlay__content {\n  outline: none;\n  position: absolute;\n  pointer-events: auto;\n  contain: layout;\n}\n.v-overlay__scrim {\n  pointer-events: auto;\n  background: rgb(var(--v-theme-on-surface));\n  border-radius: inherit;\n  bottom: 0;\n  left: 0;\n  opacity: var(--v-overlay-opacity);\n  position: fixed;\n  right: 0;\n  top: 0;\n}\n.v-overlay--absolute {\n  position: absolute;\n}\n.v-overlay--contained .v-overlay__scrim {\n  position: absolute;\n}\n.v-overlay--scroll-blocked {\n  padding-inline-end: var(--v-scrollbar-offset);\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VSelect/VSelect.css */\n.v-select--chips.v-input--density-compact .v-field--variant-solo .v-label.v-field-label--floating,\n.v-select--chips.v-input--density-compact .v-field--variant-solo-inverted .v-label.v-field-label--floating,\n.v-select--chips.v-input--density-compact .v-field--variant-filled .v-label.v-field-label--floating,\n.v-select--chips.v-input--density-compact .v-field--variant-solo-filled .v-label.v-field-label--floating {\n  top: 0px;\n}\n.v-select .v-field .v-text-field__prefix,\n.v-select .v-field .v-text-field__suffix,\n.v-select .v-field .v-field__input,\n.v-select .v-field.v-field {\n  cursor: pointer;\n}\n.v-select .v-field .v-field__input > input {\n  align-self: flex-start;\n  opacity: 1;\n  flex: 0 0;\n  position: absolute;\n  width: 100%;\n  transition: none;\n  pointer-events: none;\n  caret-color: transparent;\n}\n.v-select .v-field--dirty .v-select__selection {\n  margin-inline-end: 2px;\n}\n.v-select .v-select__selection-text {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n.v-select__content {\n  overflow: hidden;\n}\n.v-select__content {\n  box-shadow:\n    0px 2px 4px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 4px 5px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 10px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-select__content {\n  border-radius: 4px;\n}\n.v-select__selection {\n  display: inline-flex;\n  align-items: center;\n  letter-spacing: inherit;\n  line-height: inherit;\n  max-width: 100%;\n}\n.v-select .v-select__selection:first-child {\n  margin-inline-start: 0;\n}\n.v-select--selected .v-field .v-field__input > input {\n  opacity: 0;\n}\n.v-select__menu-icon {\n  margin-inline-start: 4px;\n  transition: 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-select--active-menu .v-select__menu-icon {\n  transform: rotate(180deg);\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VTextField/VTextField.css */\n.v-text-field input {\n  color: inherit;\n  opacity: 0;\n  flex: 1;\n  transition: 0.15s opacity cubic-bezier(0.4, 0, 0.2, 1);\n  min-width: 0;\n}\n.v-text-field input:focus,\n.v-text-field input:active {\n  outline: none;\n}\n.v-text-field input:invalid {\n  box-shadow: none;\n}\n.v-text-field .v-field {\n  cursor: text;\n}\n.v-text-field--prefixed.v-text-field .v-field:not(.v-field--reverse) .v-field__input {\n  --v-field-padding-start: 6px;\n}\n.v-text-field--suffixed.v-text-field .v-field:not(.v-field--reverse) .v-field__input {\n  --v-field-padding-end: 0;\n}\n.v-text-field--prefixed.v-text-field .v-field.v-field--reverse .v-field__input {\n  --v-field-padding-end: 6px;\n}\n.v-text-field--suffixed.v-text-field .v-field.v-field--reverse .v-field__input {\n  --v-field-padding-start: 0;\n}\n.v-text-field .v-input__details {\n  padding-inline: 16px;\n}\n.v-input--plain-underlined.v-text-field .v-input__details {\n  padding-inline: 0;\n}\n.v-text-field .v-field--no-label input,\n.v-text-field .v-field--active input {\n  opacity: 1;\n}\n.v-text-field .v-field--single-line input {\n  transition: none;\n}\n.v-text-field__prefix,\n.v-text-field__suffix {\n  align-items: center;\n  color: rgba(var(--v-theme-on-surface), var(--v-medium-emphasis-opacity));\n  cursor: default;\n  display: flex;\n  opacity: 0;\n  transition: inherit;\n  white-space: nowrap;\n  min-height: max(var(--v-input-control-height, 56px), 1.5rem + var(--v-field-input-padding-top) + var(--v-field-input-padding-bottom));\n  padding-top: calc(var(--v-field-padding-top, 4px) + var(--v-input-padding-top, 0));\n  padding-bottom: var(--v-field-padding-bottom, 6px);\n}\n.v-field--active .v-text-field__prefix,\n.v-field--active .v-text-field__suffix {\n  opacity: 1;\n}\n.v-field--disabled .v-text-field__prefix,\n.v-field--disabled .v-text-field__suffix {\n  color: rgba(var(--v-theme-on-surface), var(--v-disabled-opacity));\n}\n.v-field:not(.v-field--reverse) .v-text-field__prefix {\n  padding-inline-start: var(--v-field-padding-start);\n}\n.v-field.v-field--reverse .v-text-field__prefix {\n  padding-inline-end: var(--v-field-padding-end);\n}\n.v-field:not(.v-field--reverse) .v-text-field__suffix {\n  padding-inline-end: var(--v-field-padding-end);\n}\n.v-field.v-field--reverse .v-text-field__suffix {\n  padding-inline-start: var(--v-field-padding-start);\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VCounter/VCounter.css */\n.v-counter {\n  color: rgba(var(--v-theme-on-surface), var(--v-medium-emphasis-opacity));\n  flex: 0 1 auto;\n  font-size: 12px;\n  transition-duration: 150ms;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VField/VField.css */\n.v-field {\n  display: grid;\n  grid-template-areas: \"prepend-inner field clear append-inner\";\n  grid-template-columns: min-content minmax(0, 1fr) min-content min-content;\n  font-size: 16px;\n  letter-spacing: 0.009375em;\n  max-width: 100%;\n  border-radius: 4px;\n  contain: layout;\n  flex: 1 0;\n  grid-area: control;\n  position: relative;\n  --v-theme-overlay-multiplier: 1;\n  --v-field-padding-start: 16px;\n  --v-field-padding-end: 16px;\n  --v-field-padding-top: 8px;\n  --v-field-padding-bottom: 4px;\n  --v-field-input-padding-top: calc(var(--v-field-padding-top, 8px) + var(--v-input-padding-top, 0px));\n  --v-field-input-padding-bottom: var(--v-field-padding-bottom, 4px);\n}\n.v-field--disabled {\n  opacity: var(--v-disabled-opacity);\n  pointer-events: none;\n}\n.v-field .v-chip {\n  --v-chip-height: 24px;\n}\n.v-field--prepended {\n  padding-inline-start: 12px;\n}\n.v-field--appended {\n  padding-inline-end: 12px;\n}\n.v-field--variant-solo,\n.v-field--variant-solo-filled {\n  background: rgb(var(--v-theme-surface));\n  border-color: transparent;\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-field--variant-solo,\n.v-field--variant-solo-filled {\n  box-shadow:\n    0px 3px 1px -2px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 2px 2px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 5px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-field--variant-solo-inverted {\n  background: rgb(var(--v-theme-surface));\n  border-color: transparent;\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-field--variant-solo-inverted {\n  box-shadow:\n    0px 3px 1px -2px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 2px 2px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 5px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-field--variant-solo-inverted.v-field--focused {\n  color: rgb(var(--v-theme-on-surface-variant));\n}\n.v-field--variant-filled {\n  border-bottom-left-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.v-input--density-default .v-field--variant-solo,\n.v-input--density-default .v-field--variant-solo-inverted,\n.v-input--density-default .v-field--variant-solo-filled,\n.v-input--density-default .v-field--variant-filled {\n  --v-input-control-height: 56px;\n  --v-field-padding-bottom: 4px;\n}\n.v-input--density-comfortable .v-field--variant-solo,\n.v-input--density-comfortable .v-field--variant-solo-inverted,\n.v-input--density-comfortable .v-field--variant-solo-filled,\n.v-input--density-comfortable .v-field--variant-filled {\n  --v-input-control-height: 48px;\n  --v-field-padding-bottom: 0px;\n}\n.v-input--density-compact .v-field--variant-solo,\n.v-input--density-compact .v-field--variant-solo-inverted,\n.v-input--density-compact .v-field--variant-solo-filled,\n.v-input--density-compact .v-field--variant-filled {\n  --v-input-control-height: 40px;\n  --v-field-padding-bottom: 0px;\n}\n.v-field--variant-outlined,\n.v-field--single-line,\n.v-field--no-label {\n  --v-field-padding-top: 0px;\n}\n.v-input--density-default .v-field--variant-outlined,\n.v-input--density-default .v-field--single-line,\n.v-input--density-default .v-field--no-label {\n  --v-field-padding-bottom: 16px;\n}\n.v-input--density-comfortable .v-field--variant-outlined,\n.v-input--density-comfortable .v-field--single-line,\n.v-input--density-comfortable .v-field--no-label {\n  --v-field-padding-bottom: 12px;\n}\n.v-input--density-compact .v-field--variant-outlined,\n.v-input--density-compact .v-field--single-line,\n.v-input--density-compact .v-field--no-label {\n  --v-field-padding-bottom: 8px;\n}\n.v-field--variant-plain,\n.v-field--variant-underlined {\n  border-radius: 0;\n  padding: 0;\n}\n.v-field--variant-plain.v-field,\n.v-field--variant-underlined.v-field {\n  --v-field-padding-start: 0px;\n  --v-field-padding-end: 0px;\n}\n.v-input--density-default .v-field--variant-plain,\n.v-input--density-default .v-field--variant-underlined {\n  --v-input-control-height: 48px;\n  --v-field-padding-top: 4px;\n  --v-field-padding-bottom: 4px;\n}\n.v-input--density-comfortable .v-field--variant-plain,\n.v-input--density-comfortable .v-field--variant-underlined {\n  --v-input-control-height: 40px;\n  --v-field-padding-top: 2px;\n  --v-field-padding-bottom: 0px;\n}\n.v-input--density-compact .v-field--variant-plain,\n.v-input--density-compact .v-field--variant-underlined {\n  --v-input-control-height: 32px;\n  --v-field-padding-top: 0px;\n  --v-field-padding-bottom: 0px;\n}\n.v-field--flat {\n  box-shadow: none;\n}\n.v-field--rounded {\n  border-radius: 24px;\n}\n.v-field.v-field--prepended {\n  --v-field-padding-start: 6px;\n}\n.v-field.v-field--appended {\n  --v-field-padding-end: 6px;\n}\n.v-field__input {\n  align-items: center;\n  color: inherit;\n  column-gap: 2px;\n  display: flex;\n  flex-wrap: wrap;\n  letter-spacing: 0.009375em;\n  opacity: var(--v-high-emphasis-opacity);\n  min-height: max(var(--v-input-control-height, 56px), 1.5rem + var(--v-field-input-padding-top) + var(--v-field-input-padding-bottom));\n  min-width: 0;\n  padding-inline: var(--v-field-padding-start) var(--v-field-padding-end);\n  padding-top: var(--v-field-input-padding-top);\n  padding-bottom: var(--v-field-input-padding-bottom);\n  position: relative;\n  width: 100%;\n}\n.v-input--density-default .v-field__input {\n  row-gap: 8px;\n}\n.v-input--density-comfortable .v-field__input {\n  row-gap: 6px;\n}\n.v-input--density-compact .v-field__input {\n  row-gap: 4px;\n}\n.v-field__input input {\n  letter-spacing: inherit;\n}\n.v-field__input input::placeholder,\ninput.v-field__input::placeholder,\ntextarea.v-field__input::placeholder {\n  color: currentColor;\n  opacity: var(--v-disabled-opacity);\n}\n.v-field__input:focus,\n.v-field__input:active {\n  outline: none;\n}\n.v-field__input:invalid {\n  box-shadow: none;\n}\n.v-field__field {\n  flex: 1 0;\n  grid-area: field;\n  position: relative;\n  align-items: flex-start;\n  display: flex;\n}\n.v-field__prepend-inner {\n  grid-area: prepend-inner;\n  padding-inline-end: var(--v-field-padding-after);\n}\n.v-field__clearable {\n  grid-area: clear;\n}\n.v-field__append-inner {\n  grid-area: append-inner;\n  padding-inline-start: var(--v-field-padding-after);\n}\n.v-field__append-inner,\n.v-field__clearable,\n.v-field__prepend-inner {\n  display: flex;\n  align-items: flex-start;\n  padding-top: var(--v-input-padding-top, 8px);\n}\n.v-field--center-affix .v-field__append-inner,\n.v-field--center-affix .v-field__clearable,\n.v-field--center-affix .v-field__prepend-inner {\n  align-items: center;\n  padding-top: 0;\n}\n.v-field.v-field--variant-underlined .v-field__append-inner,\n.v-field.v-field--variant-underlined .v-field__clearable,\n.v-field.v-field--variant-underlined .v-field__prepend-inner,\n.v-field.v-field--variant-plain .v-field__append-inner,\n.v-field.v-field--variant-plain .v-field__clearable,\n.v-field.v-field--variant-plain .v-field__prepend-inner {\n  align-items: flex-start;\n  padding-top: calc(var(--v-field-padding-top, 8px) + var(--v-input-padding-top, 0px));\n  padding-bottom: var(--v-field-padding-bottom, 4px);\n}\n.v-field--focused .v-field__prepend-inner,\n.v-field--focused .v-field__append-inner {\n  opacity: 1;\n}\n.v-field__prepend-inner > .v-icon,\n.v-field__append-inner > .v-icon,\n.v-field__clearable > .v-icon {\n  opacity: var(--v-medium-emphasis-opacity);\n}\n.v-field--disabled .v-field__prepend-inner > .v-icon,\n.v-field--error .v-field__prepend-inner > .v-icon,\n.v-field--glow.v-field--focused .v-field__prepend-inner > .v-icon,\n.v-field--disabled .v-field__append-inner > .v-icon,\n.v-field--error .v-field__append-inner > .v-icon,\n.v-field--glow.v-field--focused .v-field__append-inner > .v-icon,\n.v-field--disabled .v-field__clearable > .v-icon,\n.v-field--error .v-field__clearable > .v-icon,\n.v-field--glow.v-field--focused .v-field__clearable > .v-icon {\n  opacity: 1;\n}\n.v-field--error:not(.v-field--disabled) .v-field__prepend-inner > .v-icon,\n.v-field--error:not(.v-field--disabled) .v-field__append-inner > .v-icon,\n.v-field--error:not(.v-field--disabled) .v-field__clearable > .v-icon {\n  color: rgb(var(--v-theme-error));\n}\n.v-field__clearable {\n  cursor: pointer;\n  opacity: 0;\n  overflow: hidden;\n  margin-inline: 4px;\n  transition: 0.15s cubic-bezier(0.4, 0, 0.2, 1);\n  transition-property:\n    opacity,\n    transform,\n    width;\n}\n.v-field--focused .v-field__clearable,\n.v-field--persistent-clear .v-field__clearable {\n  opacity: 1;\n}\n@media (hover: hover) {\n  .v-field:hover .v-field__clearable {\n    opacity: 1;\n  }\n}\n@media (hover: none) {\n  .v-field__clearable {\n    opacity: 1;\n  }\n}\n.v-label.v-field-label {\n  contain: layout paint;\n  display: block;\n  margin-inline-start: var(--v-field-padding-start);\n  margin-inline-end: var(--v-field-padding-end);\n  max-width: calc(100% - var(--v-field-padding-start) - var(--v-field-padding-end));\n  pointer-events: none;\n  position: absolute;\n  top: var(--v-input-padding-top);\n  transform-origin: left center;\n  transition: 0.15s cubic-bezier(0.4, 0, 0.2, 1);\n  transition-property: opacity, transform;\n  z-index: 1;\n}\n.v-field--variant-underlined .v-label.v-field-label,\n.v-field--variant-plain .v-label.v-field-label {\n  top: calc(var(--v-input-padding-top) + var(--v-field-padding-top));\n}\n.v-field--center-affix .v-label.v-field-label {\n  top: 50%;\n  transform: translateY(-50%);\n}\n.v-field--active .v-label.v-field-label {\n  visibility: hidden;\n}\n.v-field--focused .v-label.v-field-label,\n.v-field--error .v-label.v-field-label {\n  opacity: 1;\n}\n.v-field--error:not(.v-field--disabled) .v-label.v-field-label {\n  color: rgb(var(--v-theme-error));\n}\n.v-label.v-field-label--floating {\n  --v-field-label-scale: 0.75em;\n  font-size: var(--v-field-label-scale);\n  visibility: hidden;\n}\n.v-field--variant-outlined .v-label.v-field-label--floating {\n  max-width: 100%;\n}\n.v-field--center-affix .v-label.v-field-label--floating {\n  transform: none;\n}\n.v-field.v-field--active .v-label.v-field-label--floating {\n  visibility: unset;\n}\n.v-input--density-default .v-field--variant-solo .v-label.v-field-label--floating,\n.v-input--density-default .v-field--variant-solo-inverted .v-label.v-field-label--floating,\n.v-input--density-default .v-field--variant-filled .v-label.v-field-label--floating,\n.v-input--density-default .v-field--variant-solo-filled .v-label.v-field-label--floating {\n  top: 7px;\n}\n.v-input--density-comfortable .v-field--variant-solo .v-label.v-field-label--floating,\n.v-input--density-comfortable .v-field--variant-solo-inverted .v-label.v-field-label--floating,\n.v-input--density-comfortable .v-field--variant-filled .v-label.v-field-label--floating,\n.v-input--density-comfortable .v-field--variant-solo-filled .v-label.v-field-label--floating {\n  top: 5px;\n}\n.v-input--density-compact .v-field--variant-solo .v-label.v-field-label--floating,\n.v-input--density-compact .v-field--variant-solo-inverted .v-label.v-field-label--floating,\n.v-input--density-compact .v-field--variant-filled .v-label.v-field-label--floating,\n.v-input--density-compact .v-field--variant-solo-filled .v-label.v-field-label--floating {\n  top: 3px;\n}\n.v-field--variant-plain .v-label.v-field-label--floating,\n.v-field--variant-underlined .v-label.v-field-label--floating {\n  transform: translateY(-16px);\n  margin: 0;\n  top: var(--v-input-padding-top);\n}\n.v-field--variant-outlined .v-label.v-field-label--floating {\n  transform: translateY(-50%);\n  transform-origin: center;\n  position: static;\n  margin: 0 4px;\n}\n.v-field__outline {\n  --v-field-border-width: 1px;\n  --v-field-border-opacity: 0.38;\n  align-items: stretch;\n  contain: layout;\n  display: flex;\n  height: 100%;\n  left: 0;\n  pointer-events: none;\n  position: absolute;\n  right: 0;\n  width: 100%;\n}\n@media (hover: hover) {\n  .v-field:hover .v-field__outline {\n    --v-field-border-opacity: var(--v-high-emphasis-opacity);\n  }\n}\n.v-field--error:not(.v-field--disabled) .v-field__outline {\n  color: rgb(var(--v-theme-error));\n}\n.v-field.v-field--focused .v-field__outline,\n.v-input.v-input--error .v-field__outline {\n  --v-field-border-opacity: 1;\n}\n.v-field--variant-outlined.v-field--focused .v-field__outline {\n  --v-field-border-width: 2px;\n}\n.v-field--variant-filled .v-field__outline::before,\n.v-field--variant-underlined .v-field__outline::before {\n  border-color: currentColor;\n  border-style: solid;\n  border-width: 0 0 var(--v-field-border-width);\n  opacity: var(--v-field-border-opacity);\n  transition: opacity 250ms cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-field--variant-filled .v-field__outline::before,\n.v-field--variant-underlined .v-field__outline::before {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n.v-field--variant-filled .v-field__outline::after,\n.v-field--variant-underlined .v-field__outline::after {\n  border-color: currentColor;\n  border-style: solid;\n  border-width: 0 0 2px;\n  transform: scaleX(0);\n  transition: transform 0.15s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-field--variant-filled .v-field__outline::after,\n.v-field--variant-underlined .v-field__outline::after {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n.v-field--focused.v-field--variant-filled .v-field__outline::after,\n.v-field--focused.v-field--variant-underlined .v-field__outline::after {\n  transform: scaleX(1);\n}\n.v-field--variant-outlined .v-field__outline {\n  border-radius: inherit;\n}\n.v-field--variant-outlined .v-field__outline__start,\n.v-field--variant-outlined .v-field__outline__notch::before,\n.v-field--variant-outlined .v-field__outline__notch::after,\n.v-field--variant-outlined .v-field__outline__end {\n  border: 0 solid currentColor;\n  opacity: var(--v-field-border-opacity);\n  transition: opacity 250ms cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-field--variant-outlined .v-field__outline__start {\n  flex: 0 0 12px;\n  border-top-width: var(--v-field-border-width);\n  border-bottom-width: var(--v-field-border-width);\n  border-inline-start-width: var(--v-field-border-width);\n  border-start-start-radius: inherit;\n  border-start-end-radius: 0;\n  border-end-end-radius: 0;\n  border-end-start-radius: inherit;\n}\n.v-field--rounded.v-field--variant-outlined .v-field__outline__start,\n[class^=rounded-].v-field--variant-outlined .v-field__outline__start,\n[class*=\" rounded-\"].v-field--variant-outlined .v-field__outline__start {\n  flex-basis: calc(var(--v-input-control-height) / 2 + 2px);\n}\n.v-field--reverse.v-field--variant-outlined .v-field__outline__start {\n  border-start-start-radius: 0;\n  border-start-end-radius: inherit;\n  border-end-end-radius: inherit;\n  border-end-start-radius: 0;\n  border-inline-end-width: var(--v-field-border-width);\n  border-inline-start-width: 0;\n}\n.v-field--variant-outlined .v-field__outline__notch {\n  flex: none;\n  position: relative;\n  max-width: calc(100% - 24px);\n}\n.v-field--rounded.v-field--variant-outlined .v-field__outline__notch,\n[class^=rounded-].v-field--variant-outlined .v-field__outline__notch,\n[class*=\" rounded-\"].v-field--variant-outlined .v-field__outline__notch {\n  max-width: calc(100% - var(--v-input-control-height));\n}\n.v-field--variant-outlined .v-field__outline__notch::before,\n.v-field--variant-outlined .v-field__outline__notch::after {\n  opacity: var(--v-field-border-opacity);\n  transition: opacity 250ms cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-field--variant-outlined .v-field__outline__notch::before,\n.v-field--variant-outlined .v-field__outline__notch::after {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n.v-field--variant-outlined .v-field__outline__notch::before {\n  border-width: var(--v-field-border-width) 0 0;\n}\n.v-field--variant-outlined .v-field__outline__notch::after {\n  bottom: 0;\n  border-width: 0 0 var(--v-field-border-width);\n}\n.v-field--active.v-field--variant-outlined .v-field__outline__notch::before {\n  opacity: 0;\n}\n.v-field--variant-outlined .v-field__outline__end {\n  flex: 1;\n  border-top-width: var(--v-field-border-width);\n  border-bottom-width: var(--v-field-border-width);\n  border-inline-end-width: var(--v-field-border-width);\n  border-start-start-radius: 0;\n  border-start-end-radius: inherit;\n  border-end-end-radius: inherit;\n  border-end-start-radius: 0;\n}\n.v-field--reverse.v-field--variant-outlined .v-field__outline__end {\n  border-start-start-radius: inherit;\n  border-start-end-radius: 0;\n  border-end-end-radius: 0;\n  border-end-start-radius: inherit;\n  border-inline-end-width: 0;\n  border-inline-start-width: var(--v-field-border-width);\n}\n.v-field__loader {\n  top: calc(100% - 2px);\n  left: 0;\n  position: absolute;\n  right: 0;\n  width: 100%;\n  border-top-left-radius: 0;\n  border-top-right-radius: 0;\n  border-bottom-left-radius: inherit;\n  border-bottom-right-radius: inherit;\n  overflow: hidden;\n}\n.v-field--variant-outlined .v-field__loader {\n  top: calc(100% - 3px);\n  width: calc(100% - 1px * 2);\n  left: 1px;\n}\n.v-field__overlay {\n  border-radius: inherit;\n  pointer-events: none;\n}\n.v-field__overlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n.v-field--variant-filled .v-field__overlay {\n  background-color: currentColor;\n  opacity: 0.04;\n  transition: opacity 250ms cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-field--variant-filled.v-field--has-background .v-field__overlay {\n  opacity: 0;\n}\n@media (hover: hover) {\n  .v-field--variant-filled:hover .v-field__overlay {\n    opacity: calc((0.04 + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-field--variant-filled.v-field--focused .v-field__overlay {\n  opacity: calc((0.04 + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n}\n.v-field--variant-solo-filled .v-field__overlay {\n  background-color: currentColor;\n  opacity: 0.04;\n  transition: opacity 250ms cubic-bezier(0.4, 0, 0.2, 1);\n}\n@media (hover: hover) {\n  .v-field--variant-solo-filled:hover .v-field__overlay {\n    opacity: calc((0.04 + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-field--variant-solo-filled.v-field--focused .v-field__overlay {\n  opacity: calc((0.04 + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n}\n.v-field--variant-solo-inverted .v-field__overlay {\n  transition: opacity 250ms cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-field--variant-solo-inverted.v-field--has-background .v-field__overlay {\n  opacity: 0;\n}\n@media (hover: hover) {\n  .v-field--variant-solo-inverted:hover .v-field__overlay {\n    opacity: calc((0.04 + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-field--variant-solo-inverted.v-field--focused .v-field__overlay {\n  background-color: rgb(var(--v-theme-surface-variant));\n  opacity: 1;\n}\n.v-field--reverse .v-field__field,\n.v-field--reverse .v-field__input,\n.v-field--reverse .v-field__outline {\n  flex-direction: row-reverse;\n}\n.v-field--reverse .v-field__input,\n.v-field--reverse input {\n  text-align: end;\n}\n.v-input--disabled .v-field--variant-filled .v-field__outline::before,\n.v-input--disabled .v-field--variant-underlined .v-field__outline::before {\n  border-image: repeating-linear-gradient(to right, rgba(var(--v-theme-on-surface), var(--v-disabled-opacity)) 0px, rgba(var(--v-theme-on-surface), var(--v-disabled-opacity)) 2px, transparent 2px, transparent 4px) 1 repeat;\n}\n.v-field--loading .v-field__outline::after,\n.v-field--loading .v-field__outline::before {\n  opacity: 0;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VVirtualScroll/VVirtualScroll.css */\n.v-virtual-scroll {\n  display: block;\n  flex: 1 1 auto;\n  max-width: 100%;\n  overflow: auto;\n  position: relative;\n}\n.v-virtual-scroll__container {\n  display: block;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VBadge/VBadge.css */\n.v-badge {\n  display: inline-block;\n  line-height: 1;\n}\n.v-badge__badge {\n  align-items: center;\n  display: inline-flex;\n  border-radius: 10px;\n  font-family: \"Roboto\", sans-serif;\n  font-size: 0.75rem;\n  font-weight: 500;\n  height: 1.25rem;\n  justify-content: center;\n  min-width: 20px;\n  padding: 4px 6px;\n  pointer-events: auto;\n  position: absolute;\n  text-align: center;\n  text-indent: 0;\n  transition: 0.225s cubic-bezier(0.4, 0, 0.2, 1);\n  white-space: nowrap;\n}\n.v-badge__badge {\n  background: rgb(var(--v-theme-surface-variant));\n  color: rgba(var(--v-theme-on-surface-variant), var(--v-high-emphasis-opacity));\n}\n.v-badge__badge:has(.v-icon) {\n  padding: 4px 6px;\n}\n.v-badge--bordered .v-badge__badge::after {\n  border-radius: inherit;\n  border-style: solid;\n  border-width: 2px;\n  bottom: 0;\n  color: rgb(var(--v-theme-background));\n  content: \"\";\n  left: 0;\n  position: absolute;\n  right: 0;\n  top: 0;\n  transform: scale(1.05);\n}\n.v-badge--dot .v-badge__badge {\n  border-radius: 4.5px;\n  height: 9px;\n  min-width: 0;\n  padding: 0;\n  width: 9px;\n}\n.v-badge--dot .v-badge__badge::after {\n  border-width: 1.5px;\n}\n.v-badge--inline .v-badge__badge {\n  position: relative;\n  vertical-align: middle;\n}\n.v-badge__badge .v-icon {\n  color: inherit;\n  font-size: 0.75rem;\n  margin: 0 -2px;\n}\n.v-badge__badge img,\n.v-badge__badge .v-img {\n  height: 100%;\n  width: 100%;\n}\n.v-badge__wrapper {\n  display: flex;\n  position: relative;\n}\n.v-badge--inline .v-badge__wrapper {\n  align-items: center;\n  display: inline-flex;\n  justify-content: center;\n  margin: 0 4px;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VBanner/VBanner.css */\n.v-banner {\n  display: grid;\n  flex: 1 1;\n  font-size: 0.875rem;\n  grid-template-areas: \"prepend content actions\";\n  grid-template-columns: max-content auto max-content;\n  grid-template-rows: max-content max-content;\n  line-height: 1.6;\n  overflow: hidden;\n  padding-inline: 16px 8px;\n  padding-top: 16px;\n  padding-bottom: 16px;\n  position: relative;\n  width: 100%;\n}\n.v-banner {\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-style: solid;\n  border-width: 0 0 thin 0;\n}\n.v-banner--border {\n  border-width: thin;\n  box-shadow: none;\n}\n.v-banner {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-banner--absolute {\n  position: absolute;\n}\n.v-banner--fixed {\n  position: fixed;\n}\n.v-banner--sticky {\n  position: sticky;\n}\n.v-banner {\n  border-radius: 0;\n}\n.v-banner {\n  background: rgb(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-banner--rounded {\n  border-radius: 4px;\n}\n.v-banner--stacked:not(.v-banner--one-line) {\n  grid-template-areas: \"prepend content\" \". actions\";\n}\n.v-banner--stacked .v-banner-text {\n  padding-inline-end: 36px;\n}\n.v-banner--density-default .v-banner-actions {\n  margin-bottom: -8px;\n}\n.v-banner--density-default.v-banner--one-line {\n  padding-top: 8px;\n  padding-bottom: 8px;\n}\n.v-banner--density-default.v-banner--one-line .v-banner-actions {\n  margin-bottom: 0;\n}\n.v-banner--density-default.v-banner--one-line {\n  padding-top: 10px;\n}\n.v-banner--density-default.v-banner--two-line {\n  padding-top: 16px;\n  padding-bottom: 16px;\n}\n.v-banner--density-default.v-banner--three-line {\n  padding-top: 24px;\n  padding-bottom: 16px;\n}\n.v-banner--density-default:not(.v-banner--one-line) .v-banner-actions,\n.v-banner--density-default.v-banner--two-line .v-banner-actions,\n.v-banner--density-default.v-banner--three-line .v-banner-actions {\n  margin-top: 20px;\n}\n.v-banner--density-comfortable .v-banner-actions {\n  margin-bottom: -4px;\n}\n.v-banner--density-comfortable.v-banner--one-line {\n  padding-top: 4px;\n  padding-bottom: 4px;\n}\n.v-banner--density-comfortable.v-banner--one-line .v-banner-actions {\n  margin-bottom: 0;\n}\n.v-banner--density-comfortable.v-banner--two-line {\n  padding-top: 12px;\n  padding-bottom: 12px;\n}\n.v-banner--density-comfortable.v-banner--three-line {\n  padding-top: 20px;\n  padding-bottom: 12px;\n}\n.v-banner--density-comfortable:not(.v-banner--one-line) .v-banner-actions,\n.v-banner--density-comfortable.v-banner--two-line .v-banner-actions,\n.v-banner--density-comfortable.v-banner--three-line .v-banner-actions {\n  margin-top: 16px;\n}\n.v-banner--density-compact .v-banner-actions {\n  margin-bottom: 0px;\n}\n.v-banner--density-compact.v-banner--one-line {\n  padding-top: 0px;\n  padding-bottom: 0px;\n}\n.v-banner--density-compact.v-banner--one-line .v-banner-actions {\n  margin-bottom: 0;\n}\n.v-banner--density-compact.v-banner--two-line {\n  padding-top: 8px;\n  padding-bottom: 8px;\n}\n.v-banner--density-compact.v-banner--three-line {\n  padding-top: 16px;\n  padding-bottom: 8px;\n}\n.v-banner--density-compact:not(.v-banner--one-line) .v-banner-actions,\n.v-banner--density-compact.v-banner--two-line .v-banner-actions,\n.v-banner--density-compact.v-banner--three-line .v-banner-actions {\n  margin-top: 12px;\n}\n.v-banner--sticky {\n  top: 0;\n  z-index: 1;\n}\n.v-banner__content {\n  align-items: center;\n  display: flex;\n  grid-area: content;\n}\n.v-banner__prepend {\n  align-self: flex-start;\n  grid-area: prepend;\n  margin-inline-end: 24px;\n}\n.v-banner-actions {\n  align-self: flex-end;\n  display: flex;\n  flex: 0 1;\n  grid-area: actions;\n  justify-content: flex-end;\n}\n.v-banner--two-line .v-banner-actions,\n.v-banner--three-line .v-banner-actions {\n  margin-top: 20px;\n}\n.v-banner-text {\n  -webkit-box-orient: vertical;\n  display: -webkit-box;\n  padding-inline-end: 90px;\n  overflow: hidden;\n}\n.v-banner--one-line .v-banner-text {\n  -webkit-line-clamp: 1;\n}\n.v-banner--two-line .v-banner-text {\n  -webkit-line-clamp: 2;\n}\n.v-banner--three-line .v-banner-text {\n  -webkit-line-clamp: 3;\n}\n.v-banner--two-line .v-banner-text,\n.v-banner--three-line .v-banner-text {\n  align-self: flex-start;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VBottomNavigation/VBottomNavigation.css */\n.v-bottom-navigation {\n  display: flex;\n  max-width: 100%;\n  overflow: hidden;\n  position: absolute;\n  transition:\n    transform,\n    color,\n    0.2s,\n    0.1s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-bottom-navigation {\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-style: solid;\n  border-width: 0;\n}\n.v-bottom-navigation--border {\n  border-width: thin;\n  box-shadow: none;\n}\n.v-bottom-navigation {\n  border-radius: 0;\n}\n.v-bottom-navigation {\n  background: rgb(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-bottom-navigation--active {\n  box-shadow:\n    0px 2px 4px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 4px 5px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 10px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-bottom-navigation__content {\n  display: flex;\n  flex: none;\n  font-size: 0.75rem;\n  justify-content: center;\n  transition: inherit;\n  width: 100%;\n}\n.v-bottom-navigation .v-bottom-navigation__content > .v-btn {\n  font-size: inherit;\n  height: 100%;\n  max-width: 168px;\n  min-width: 80px;\n  text-transform: none;\n  transition: inherit;\n  width: auto;\n}\n.v-bottom-navigation .v-bottom-navigation__content > .v-btn {\n  border-radius: 0;\n}\n.v-bottom-navigation .v-bottom-navigation__content > .v-btn .v-btn__content,\n.v-bottom-navigation .v-bottom-navigation__content > .v-btn .v-btn__icon {\n  transition: inherit;\n}\n.v-bottom-navigation .v-bottom-navigation__content > .v-btn .v-btn__icon {\n  font-size: 1.5rem;\n}\n.v-bottom-navigation--grow .v-bottom-navigation__content > .v-btn {\n  flex-basis: 0;\n  flex-grow: 1;\n}\n.v-bottom-navigation--shift .v-bottom-navigation__content .v-btn:not(.v-btn--selected) .v-btn__content > span {\n  transition: inherit;\n  opacity: 0;\n}\n.v-bottom-navigation--shift .v-bottom-navigation__content .v-btn:not(.v-btn--selected) .v-btn__content {\n  transform: translateY(0.5rem);\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VBottomSheet/VBottomSheet.css */\n.bottom-sheet-transition-enter-from {\n  transform: translateY(100%);\n}\n.bottom-sheet-transition-leave-to {\n  transform: translateY(100%);\n}\n.v-bottom-sheet > .v-bottom-sheet__content.v-overlay__content {\n  align-self: flex-end;\n  border-radius: 0;\n  flex: 0 1 auto;\n  left: 0;\n  right: 0;\n  margin-inline: auto;\n  margin-bottom: 0;\n  transition-duration: 0.2s;\n  width: 100%;\n  max-width: 100%;\n  overflow: visible;\n}\n.v-bottom-sheet > .v-bottom-sheet__content.v-overlay__content {\n  box-shadow:\n    0px 7px 8px -4px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 12px 17px 2px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 5px 22px 4px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-bottom-sheet > .v-bottom-sheet__content.v-overlay__content > .v-card,\n.v-bottom-sheet > .v-bottom-sheet__content.v-overlay__content > .v-sheet {\n  border-radius: 0;\n}\n.v-bottom-sheet.v-bottom-sheet--inset {\n  max-width: none;\n}\n@media (min-width: 600px) {\n  .v-bottom-sheet.v-bottom-sheet--inset {\n    max-width: 70%;\n  }\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VDialog/VDialog.css */\n.v-dialog {\n  align-items: center;\n  justify-content: center;\n  margin: auto;\n}\n.v-dialog > .v-overlay__content {\n  max-height: calc(100% - 48px);\n  width: calc(100% - 48px);\n  max-width: calc(100% - 48px);\n  margin: 24px;\n}\n.v-dialog > .v-overlay__content,\n.v-dialog > .v-overlay__content > form {\n  display: flex;\n  flex-direction: column;\n  min-height: 0;\n}\n.v-dialog > .v-overlay__content > .v-card,\n.v-dialog > .v-overlay__content > .v-sheet,\n.v-dialog > .v-overlay__content > form > .v-card,\n.v-dialog > .v-overlay__content > form > .v-sheet {\n  --v-scrollbar-offset: 0px;\n  border-radius: 4px;\n  overflow-y: auto;\n  flex: 1 1 100%;\n}\n.v-dialog > .v-overlay__content > .v-card,\n.v-dialog > .v-overlay__content > .v-sheet,\n.v-dialog > .v-overlay__content > form > .v-card,\n.v-dialog > .v-overlay__content > form > .v-sheet {\n  box-shadow:\n    0px 11px 15px -7px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 24px 38px 3px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 9px 46px 8px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-dialog > .v-overlay__content > .v-card,\n.v-dialog > .v-overlay__content > form > .v-card {\n  display: flex;\n  flex-direction: column;\n}\n.v-dialog > .v-overlay__content > .v-card > .v-card-item,\n.v-dialog > .v-overlay__content > form > .v-card > .v-card-item {\n  padding: 16px 24px;\n}\n.v-dialog > .v-overlay__content > .v-card > .v-card-item + .v-card-text,\n.v-dialog > .v-overlay__content > form > .v-card > .v-card-item + .v-card-text {\n  padding-top: 0;\n}\n.v-dialog > .v-overlay__content > .v-card > .v-card-text,\n.v-dialog > .v-overlay__content > form > .v-card > .v-card-text {\n  font-size: inherit;\n  letter-spacing: 0.03125em;\n  line-height: inherit;\n  padding: 16px 24px 24px;\n}\n.v-dialog > .v-overlay__content > .v-card > .v-card-actions,\n.v-dialog > .v-overlay__content > form > .v-card > .v-card-actions {\n  justify-content: flex-end;\n}\n.v-dialog--fullscreen {\n  --v-scrollbar-offset: 0px;\n}\n.v-dialog--fullscreen > .v-overlay__content {\n  border-radius: 0;\n  margin: 0;\n  padding: 0;\n  width: 100%;\n  height: 100%;\n  max-width: 100%;\n  max-height: 100%;\n  overflow-y: auto;\n  top: 0;\n  left: 0;\n}\n.v-dialog--fullscreen > .v-overlay__content > .v-card,\n.v-dialog--fullscreen > .v-overlay__content > .v-sheet,\n.v-dialog--fullscreen > .v-overlay__content > form > .v-card,\n.v-dialog--fullscreen > .v-overlay__content > form > .v-sheet {\n  min-height: 100%;\n  min-width: 100%;\n  border-radius: 0;\n}\n.v-dialog--scrollable > .v-overlay__content > form,\n.v-dialog--scrollable > .v-overlay__content > form > .v-card {\n  max-height: 100%;\n  max-width: 100%;\n}\n.v-dialog--scrollable > .v-overlay__content,\n.v-dialog--scrollable > .v-overlay__content > .v-card,\n.v-dialog--scrollable > .v-overlay__content > form,\n.v-dialog--scrollable > .v-overlay__content > form > .v-card {\n  display: flex;\n  flex: 1 1 100%;\n  flex-direction: column;\n}\n.v-dialog--scrollable > .v-overlay__content > .v-card > .v-card-text,\n.v-dialog--scrollable > .v-overlay__content > form > .v-card > .v-card-text {\n  backface-visibility: hidden;\n  overflow-y: auto;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VBreadcrumbs/VBreadcrumbs.css */\n.v-breadcrumbs {\n  display: flex;\n  align-items: center;\n  line-height: 1.6;\n  padding: 16px 12px;\n}\n.v-breadcrumbs--rounded {\n  border-radius: 4px;\n}\n.v-breadcrumbs--density-default {\n  padding-top: 16px;\n  padding-bottom: 16px;\n}\n.v-breadcrumbs--density-comfortable {\n  padding-top: 12px;\n  padding-bottom: 12px;\n}\n.v-breadcrumbs--density-compact {\n  padding-top: 8px;\n  padding-bottom: 8px;\n}\n.v-breadcrumbs__prepend {\n  align-items: center;\n  display: inline-flex;\n}\n.v-breadcrumbs-item {\n  align-items: center;\n  color: inherit;\n  display: inline-flex;\n  padding: 0 4px;\n  text-decoration: none;\n  vertical-align: middle;\n}\n.v-breadcrumbs-item--disabled {\n  opacity: var(--v-disabled-opacity);\n  pointer-events: none;\n}\n.v-breadcrumbs-item--link {\n  color: inherit;\n  text-decoration: none;\n}\n.v-breadcrumbs-item--link:hover {\n  text-decoration: underline;\n}\n.v-breadcrumbs-item .v-icon {\n  font-size: 1rem;\n  margin-inline: -4px 2px;\n}\n.v-breadcrumbs-divider {\n  display: inline-block;\n  padding: 0 8px;\n  vertical-align: middle;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VCard/VCard.css */\n.v-card {\n  display: block;\n  overflow: hidden;\n  overflow-wrap: break-word;\n  position: relative;\n  padding: 0;\n  text-decoration: none;\n  transition-duration: 0.28s;\n  transition-property:\n    box-shadow,\n    opacity,\n    background;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  z-index: 0;\n}\n.v-card {\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-style: solid;\n  border-width: 0;\n}\n.v-card--border {\n  border-width: thin;\n  box-shadow: none;\n}\n.v-card--absolute {\n  position: absolute;\n}\n.v-card--fixed {\n  position: fixed;\n}\n.v-card {\n  border-radius: 4px;\n}\n.v-card:hover > .v-card__overlay {\n  opacity: calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-card:focus-visible > .v-card__overlay {\n  opacity: calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier));\n}\n@supports not selector(:focus-visible) {\n  .v-card:focus > .v-card__overlay {\n    opacity: calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-card--active > .v-card__overlay,\n.v-card[aria-haspopup=menu][aria-expanded=true] > .v-card__overlay {\n  opacity: calc(var(--v-activated-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-card--active:hover > .v-card__overlay,\n.v-card[aria-haspopup=menu][aria-expanded=true]:hover > .v-card__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier));\n}\n.v-card--active:focus-visible > .v-card__overlay,\n.v-card[aria-haspopup=menu][aria-expanded=true]:focus-visible > .v-card__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n}\n@supports not selector(:focus-visible) {\n  .v-card--active:focus > .v-card__overlay,\n  .v-card[aria-haspopup=menu][aria-expanded=true]:focus > .v-card__overlay {\n    opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-card--variant-plain,\n.v-card--variant-outlined,\n.v-card--variant-text,\n.v-card--variant-tonal {\n  background: transparent;\n  color: inherit;\n}\n.v-card--variant-plain {\n  opacity: 0.62;\n}\n.v-card--variant-plain:focus,\n.v-card--variant-plain:hover {\n  opacity: 1;\n}\n.v-card--variant-plain .v-card__overlay {\n  display: none;\n}\n.v-card--variant-elevated,\n.v-card--variant-flat {\n  background: rgb(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-card--variant-elevated {\n  box-shadow:\n    0px 2px 1px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 1px 1px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 3px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-card--variant-flat {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-card--variant-outlined {\n  border: thin solid currentColor;\n}\n.v-card--variant-text .v-card__overlay {\n  background: currentColor;\n}\n.v-card--variant-tonal .v-card__underlay {\n  background: currentColor;\n  opacity: var(--v-activated-opacity);\n  border-radius: inherit;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  pointer-events: none;\n}\n.v-card .v-card__underlay {\n  position: absolute;\n}\n.v-card--disabled {\n  pointer-events: none;\n  user-select: none;\n}\n.v-card--disabled > :not(.v-card__loader) {\n  opacity: 0.6;\n}\n.v-card--flat {\n  box-shadow: none;\n}\n.v-card--hover {\n  cursor: pointer;\n}\n.v-card--hover::before,\n.v-card--hover::after {\n  border-radius: inherit;\n  bottom: 0;\n  content: \"\";\n  display: block;\n  left: 0;\n  pointer-events: none;\n  position: absolute;\n  right: 0;\n  top: 0;\n  transition: inherit;\n}\n.v-card--hover::before {\n  opacity: 1;\n  z-index: -1;\n}\n.v-card--hover::before {\n  box-shadow:\n    0px 2px 1px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 1px 1px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 3px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-card--hover::after {\n  z-index: 1;\n  opacity: 0;\n}\n.v-card--hover::after {\n  box-shadow:\n    0px 5px 5px -3px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 8px 10px 1px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 3px 14px 2px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-card--hover:hover::after {\n  opacity: 1;\n}\n.v-card--hover:hover::before {\n  opacity: 0;\n}\n.v-card--hover:hover {\n  box-shadow:\n    0px 5px 5px -3px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 8px 10px 1px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 3px 14px 2px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-card--link {\n  cursor: pointer;\n}\n.v-card-actions {\n  align-items: center;\n  display: flex;\n  flex: none;\n  min-height: 52px;\n  padding: 0.5rem;\n  gap: 0.5rem;\n}\n.v-card-item {\n  align-items: center;\n  display: grid;\n  flex: none;\n  grid-template-areas: \"prepend content append\";\n  grid-template-columns: max-content auto max-content;\n  padding: 0.625rem 1rem;\n}\n.v-card-item + .v-card-text {\n  padding-top: 0;\n}\n.v-card-item__prepend,\n.v-card-item__append {\n  align-items: center;\n  display: flex;\n}\n.v-card-item__prepend {\n  grid-area: prepend;\n  padding-inline-end: 0.5rem;\n}\n.v-card-item__append {\n  grid-area: append;\n  padding-inline-start: 0.5rem;\n}\n.v-card-item__content {\n  align-self: center;\n  grid-area: content;\n  overflow: hidden;\n}\n.v-card-title {\n  display: block;\n  flex: none;\n  font-size: 1.25rem;\n  font-weight: 500;\n  hyphens: auto;\n  letter-spacing: 0.0125em;\n  min-width: 0;\n  overflow-wrap: normal;\n  overflow: hidden;\n  padding: 0.5rem 1rem;\n  text-overflow: ellipsis;\n  text-transform: none;\n  white-space: nowrap;\n  word-break: normal;\n  word-wrap: break-word;\n}\n.v-card .v-card-title {\n  line-height: 1.6;\n}\n.v-card--density-comfortable .v-card-title {\n  line-height: 1.75rem;\n}\n.v-card--density-compact .v-card-title {\n  line-height: 1.55rem;\n}\n.v-card-item .v-card-title {\n  padding: 0;\n}\n.v-card-title + .v-card-text,\n.v-card-title + .v-card-actions {\n  padding-top: 0;\n}\n.v-card-subtitle {\n  display: block;\n  flex: none;\n  font-size: 0.875rem;\n  font-weight: 400;\n  letter-spacing: 0.0178571429em;\n  opacity: var(--v-card-subtitle-opacity, var(--v-medium-emphasis-opacity));\n  overflow: hidden;\n  padding: 0 1rem;\n  text-overflow: ellipsis;\n  text-transform: none;\n  white-space: nowrap;\n}\n.v-card .v-card-subtitle {\n  line-height: 1.425;\n}\n.v-card--density-comfortable .v-card-subtitle {\n  line-height: 1.125rem;\n}\n.v-card--density-compact .v-card-subtitle {\n  line-height: 1rem;\n}\n.v-card-item .v-card-subtitle {\n  padding: 0 0 0.25rem;\n}\n.v-card-text {\n  flex: 1 1 auto;\n  font-size: 0.875rem;\n  font-weight: 400;\n  letter-spacing: 0.0178571429em;\n  opacity: var(--v-card-text-opacity, 1);\n  padding: 1rem;\n  text-transform: none;\n}\n.v-card .v-card-text {\n  line-height: 1.425;\n}\n.v-card--density-comfortable .v-card-text {\n  line-height: 1.2rem;\n}\n.v-card--density-compact .v-card-text {\n  line-height: 1.15rem;\n}\n.v-card__image {\n  display: flex;\n  height: 100%;\n  flex: 1 1 auto;\n  left: 0;\n  overflow: hidden;\n  position: absolute;\n  top: 0;\n  width: 100%;\n  z-index: -1;\n}\n.v-card__content {\n  border-radius: inherit;\n  overflow: hidden;\n  position: relative;\n}\n.v-card__loader {\n  bottom: auto;\n  top: 0;\n  left: 0;\n  position: absolute;\n  right: 0;\n  width: 100%;\n  z-index: 1;\n}\n.v-card__overlay {\n  background-color: currentColor;\n  border-radius: inherit;\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  pointer-events: none;\n  opacity: 0;\n  transition: opacity 0.2s ease-in-out;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VCarousel/VCarousel.css */\n.v-carousel {\n  overflow: hidden;\n  position: relative;\n  width: 100%;\n}\n.v-carousel__controls {\n  align-items: center;\n  bottom: 0;\n  display: flex;\n  height: 50px;\n  justify-content: center;\n  list-style-type: none;\n  position: absolute;\n  width: 100%;\n  z-index: 1;\n}\n.v-carousel__controls {\n  background: rgba(var(--v-theme-surface-variant), 0.3);\n  color: rgb(var(--v-theme-on-surface-variant));\n}\n.v-carousel__controls > .v-item-group {\n  flex: 0 1 auto;\n}\n.v-carousel__controls__item {\n  margin: 0 8px;\n}\n.v-carousel__controls__item .v-icon {\n  opacity: 0.5;\n}\n.v-carousel__controls__item--active .v-icon {\n  opacity: 1;\n  vertical-align: middle;\n}\n.v-carousel__controls__item:hover {\n  background: none;\n}\n.v-carousel__controls__item:hover .v-icon {\n  opacity: 0.8;\n}\n.v-carousel__progress {\n  margin: 0;\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n}\n.v-carousel-item {\n  display: block;\n  height: inherit;\n  text-decoration: none;\n}\n.v-carousel-item > .v-img {\n  height: inherit;\n}\n.v-carousel--hide-delimiter-background .v-carousel__controls {\n  background: transparent;\n}\n.v-carousel--vertical-delimiters .v-carousel__controls {\n  flex-direction: column;\n  height: 100% !important;\n  width: 50px;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VWindow/VWindow.css */\n.v-window {\n  overflow: hidden;\n}\n.v-window__container {\n  display: flex;\n  flex-direction: column;\n  height: inherit;\n  position: relative;\n  transition: 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);\n}\n.v-window__controls {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  padding: 0 16px;\n  pointer-events: none;\n}\n.v-window__controls > * {\n  pointer-events: auto;\n}\n.v-window--show-arrows-on-hover {\n  overflow: hidden;\n}\n.v-window--show-arrows-on-hover .v-window__left {\n  transform: translateX(-200%);\n}\n.v-window--show-arrows-on-hover .v-window__right {\n  transform: translateX(200%);\n}\n.v-window--show-arrows-on-hover:hover .v-window__left,\n.v-window--show-arrows-on-hover:hover .v-window__right {\n  transform: translateX(0);\n}\n.v-window-x-transition-enter-active,\n.v-window-x-transition-leave-active,\n.v-window-x-reverse-transition-enter-active,\n.v-window-x-reverse-transition-leave-active,\n.v-window-y-transition-enter-active,\n.v-window-y-transition-leave-active,\n.v-window-y-reverse-transition-enter-active,\n.v-window-y-reverse-transition-leave-active {\n  transition: 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);\n}\n.v-window-x-transition-leave-from,\n.v-window-x-transition-leave-to,\n.v-window-x-reverse-transition-leave-from,\n.v-window-x-reverse-transition-leave-to,\n.v-window-y-transition-leave-from,\n.v-window-y-transition-leave-to,\n.v-window-y-reverse-transition-leave-from,\n.v-window-y-reverse-transition-leave-to {\n  position: absolute !important;\n  top: 0;\n  width: 100%;\n}\n.v-window-x-transition-enter-from {\n  transform: translateX(100%);\n}\n.v-window-x-transition-leave-to {\n  transform: translateX(-100%);\n}\n.v-window-x-reverse-transition-enter-from {\n  transform: translateX(-100%);\n}\n.v-window-x-reverse-transition-leave-to {\n  transform: translateX(100%);\n}\n.v-window-y-transition-enter-from {\n  transform: translateY(100%);\n}\n.v-window-y-transition-leave-to {\n  transform: translateY(-100%);\n}\n.v-window-y-reverse-transition-enter-from {\n  transform: translateY(-100%);\n}\n.v-window-y-reverse-transition-leave-to {\n  transform: translateY(100%);\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VCode/VCode.css */\n.v-code {\n  background-color: rgb(var(--v-theme-code));\n  color: rgb(var(--v-theme-on-code));\n  border-radius: 4px;\n  line-height: 1.8;\n  font-size: 0.9em;\n  font-weight: normal;\n  padding: 0.2em 0.4em;\n}\n.v-code:has(> pre) {\n  display: inline-block;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VColorPicker/VColorPicker.css */\n.v-color-picker {\n  align-self: flex-start;\n  contain: content;\n  width: 300px;\n}\n.v-color-picker.v-sheet.v-picker {\n  box-shadow:\n    0px 3px 1px -2px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 2px 2px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 5px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-color-picker.v-sheet.v-picker {\n  border-radius: 4px;\n}\n.v-color-picker__controls {\n  display: flex;\n  flex-direction: column;\n  padding: 16px;\n}\n.v-color-picker--flat {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-color-picker--flat .v-color-picker__track:not(.v-input--is-disabled) .v-slider__thumb {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VColorPicker/VColorPickerCanvas.css */\n.v-color-picker-canvas {\n  display: flex;\n  position: relative;\n  overflow: hidden;\n  contain: content;\n  touch-action: none;\n}\n.v-color-picker-canvas__dot {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 15px;\n  height: 15px;\n  background: transparent;\n  border-radius: 50%;\n  box-shadow: 0px 0px 0px 1.5px rgb(255, 255, 255), inset 0px 0px 1px 1.5px rgba(0, 0, 0, 0.3);\n}\n.v-color-picker-canvas__dot--disabled {\n  box-shadow: 0px 0px 0px 1.5px rgba(255, 255, 255, 0.7), inset 0px 0px 1px 1.5px rgba(0, 0, 0, 0.3);\n}\n.v-color-picker-canvas:hover .v-color-picker-canvas__dot {\n  will-change: transform;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VColorPicker/VColorPickerEdit.css */\n.v-color-picker-edit {\n  display: flex;\n  margin-top: 24px;\n}\n.v-color-picker-edit__input {\n  width: 100%;\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: center;\n  text-align: center;\n}\n.v-color-picker-edit__input:not(:last-child) {\n  margin-inline-end: 8px;\n}\n.v-color-picker-edit__input input {\n  border-radius: 4px;\n  margin-bottom: 8px;\n  min-width: 0;\n  outline: none;\n  text-align: center;\n  width: 100%;\n  height: 32px;\n  background: rgba(var(--v-theme-surface-variant), 0.2);\n  color: rgba(var(--v-theme-on-surface));\n}\n.v-color-picker-edit__input span {\n  font-size: 0.75rem;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VColorPicker/VColorPickerPreview.css */\n.v-color-picker-preview__alpha .v-slider-track__background {\n  background-color: transparent !important;\n}\n.v-locale--is-ltr.v-color-picker-preview__alpha .v-slider-track__background,\n.v-locale--is-ltr .v-color-picker-preview__alpha .v-slider-track__background {\n  background-image: linear-gradient(to right, transparent, var(--v-color-picker-color-hsv));\n}\n.v-locale--is-rtl.v-color-picker-preview__alpha .v-slider-track__background,\n.v-locale--is-rtl .v-color-picker-preview__alpha .v-slider-track__background {\n  background-image: linear-gradient(to left, transparent, var(--v-color-picker-color-hsv));\n}\n.v-color-picker-preview__alpha .v-slider-track__background::after {\n  content: \"\";\n  z-index: -1;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAAXNSR0IArs4c6QAAACRJREFUKFNjPHTo0H8GJGBnZ8eIzGekgwJk+0BsdCtRHEQbBQBbbh0dIGKknQAAAABJRU5ErkJggg==) repeat;\n  border-radius: inherit;\n}\n.v-color-picker-preview__sliders {\n  display: flex;\n  flex: 1 0 auto;\n  flex-direction: column;\n  padding-inline-end: 16px;\n}\n.v-color-picker-preview__dot {\n  position: relative;\n  height: 30px;\n  width: 30px;\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAAXNSR0IArs4c6QAAACRJREFUKFNjPHTo0H8GJGBnZ8eIzGekgwJk+0BsdCtRHEQbBQBbbh0dIGKknQAAAABJRU5ErkJggg==) repeat;\n  border-radius: 50%;\n  overflow: hidden;\n  margin-inline-end: 24px;\n}\n.v-color-picker-preview__dot > div {\n  width: 100%;\n  height: 100%;\n}\n.v-locale--is-ltr.v-color-picker-preview__hue:not(.v-input--is-disabled) .v-slider-track__background,\n.v-locale--is-ltr .v-color-picker-preview__hue:not(.v-input--is-disabled) .v-slider-track__background {\n  background: linear-gradient(to right, #F00 0%, #FF0 16.66%, #0F0 33.33%, #0FF 50%, #00F 66.66%, #F0F 83.33%, #F00 100%);\n}\n.v-locale--is-rtl.v-color-picker-preview__hue:not(.v-input--is-disabled) .v-slider-track__background,\n.v-locale--is-rtl .v-color-picker-preview__hue:not(.v-input--is-disabled) .v-slider-track__background {\n  background: linear-gradient(to left, #F00 0%, #FF0 16.66%, #0F0 33.33%, #0FF 50%, #00F 66.66%, #F0F 83.33%, #F00 100%);\n}\n.v-color-picker-preview__track {\n  position: relative;\n  width: 100%;\n  margin: 0 !important;\n}\n.v-color-picker-preview__track .v-slider-track__fill {\n  display: none;\n}\n.v-color-picker-preview {\n  align-items: center;\n  display: flex;\n  margin-bottom: 0;\n}\n.v-color-picker-preview__eye-dropper {\n  position: relative;\n  margin-right: 12px;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VSlider/VSlider.css */\n.v-slider .v-slider__container input {\n  cursor: default;\n  padding: 0;\n  width: 100%;\n  display: none;\n}\n.v-slider > .v-input__append,\n.v-slider > .v-input__prepend {\n  padding: 0;\n}\n.v-slider__container {\n  position: relative;\n  min-height: inherit;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  cursor: pointer;\n}\n.v-input--disabled .v-slider__container {\n  opacity: var(--v-disabled-opacity);\n}\n.v-input--error:not(.v-input--disabled) .v-slider__container {\n  color: rgb(var(--v-theme-error));\n}\n.v-slider.v-input--horizontal {\n  align-items: center;\n  margin-inline: 8px 8px;\n}\n.v-slider.v-input--horizontal > .v-input__control {\n  min-height: 32px;\n  display: flex;\n  align-items: center;\n}\n.v-slider.v-input--vertical {\n  justify-content: center;\n  margin-top: 12px;\n  margin-bottom: 12px;\n}\n.v-slider.v-input--vertical > .v-input__control {\n  min-height: 300px;\n}\n.v-slider.v-input--disabled {\n  pointer-events: none;\n}\n.v-slider--has-labels > .v-input__control {\n  margin-bottom: 4px;\n}\n.v-slider__label {\n  margin-inline-end: 12px;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VSlider/VSliderThumb.css */\n.v-slider-thumb {\n  touch-action: none;\n  color: rgb(var(--v-theme-surface-variant));\n}\n.v-input--error:not(.v-input--disabled) .v-slider-thumb {\n  color: inherit;\n}\n.v-slider-thumb__label {\n  background: rgba(var(--v-theme-surface-variant), 0.7);\n  color: rgb(var(--v-theme-on-surface-variant));\n}\n.v-slider-thumb__label::before {\n  color: rgba(var(--v-theme-surface-variant), 0.7);\n}\n.v-slider-thumb {\n  outline: none;\n  position: absolute;\n  transition: 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);\n}\n.v-slider-thumb__surface {\n  cursor: pointer;\n  width: var(--v-slider-thumb-size);\n  height: var(--v-slider-thumb-size);\n  border-radius: 50%;\n  user-select: none;\n  background-color: currentColor;\n}\n@media (forced-colors: active) {\n  .v-slider-thumb__surface {\n    background-color: highlight;\n  }\n}\n.v-slider-thumb__surface::before {\n  transition: 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n  content: \"\";\n  color: inherit;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  border-radius: 50%;\n  background: currentColor;\n  position: absolute;\n  pointer-events: none;\n  opacity: 0;\n}\n.v-slider-thumb__surface::after {\n  content: \"\";\n  width: 42px;\n  height: 42px;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n.v-slider-thumb__label-container {\n  position: absolute;\n  transition: 0.2s cubic-bezier(0.4, 0, 1, 1);\n}\n.v-slider-thumb__label {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 0.75rem;\n  min-width: 35px;\n  height: 25px;\n  border-radius: 4px;\n  padding: 6px;\n  position: absolute;\n  user-select: none;\n  transition: 0.2s cubic-bezier(0.4, 0, 1, 1);\n}\n.v-slider-thumb__label::before {\n  content: \"\";\n  width: 0;\n  height: 0;\n  position: absolute;\n}\n.v-slider-thumb__ripple {\n  position: absolute;\n  left: calc(var(--v-slider-thumb-size) / -2);\n  top: calc(var(--v-slider-thumb-size) / -2);\n  width: calc(var(--v-slider-thumb-size) * 2);\n  height: calc(var(--v-slider-thumb-size) * 2);\n  background: inherit;\n}\n.v-slider.v-input--horizontal .v-slider-thumb {\n  top: 50%;\n  transform: translateY(-50%);\n  inset-inline-start: calc(var(--v-slider-thumb-position) - var(--v-slider-thumb-size) / 2);\n}\n.v-slider.v-input--horizontal .v-slider-thumb__label-container {\n  left: calc(var(--v-slider-thumb-size) / 2);\n  top: 0;\n}\n.v-slider.v-input--horizontal .v-slider-thumb__label {\n  bottom: calc(var(--v-slider-thumb-size) / 2);\n}\n.v-locale--is-ltr.v-slider.v-input--horizontal .v-slider-thumb__label,\n.v-locale--is-ltr .v-slider.v-input--horizontal .v-slider-thumb__label {\n  transform: translateX(-50%);\n}\n.v-locale--is-rtl.v-slider.v-input--horizontal .v-slider-thumb__label,\n.v-locale--is-rtl .v-slider.v-input--horizontal .v-slider-thumb__label {\n  transform: translateX(50%);\n}\n.v-slider.v-input--horizontal .v-slider-thumb__label::before {\n  border-left: 6px solid transparent;\n  border-right: 6px solid transparent;\n  border-top: 6px solid currentColor;\n  bottom: -6px;\n}\n.v-slider.v-input--vertical .v-slider-thumb {\n  top: calc(var(--v-slider-thumb-position) - var(--v-slider-thumb-size) / 2);\n}\n.v-slider.v-input--vertical .v-slider-thumb__label-container {\n  top: calc(var(--v-slider-thumb-size) / 2);\n  right: 0;\n}\n.v-slider.v-input--vertical .v-slider-thumb__label {\n  top: -12.5px;\n  left: calc(var(--v-slider-thumb-size) / 2);\n}\n.v-slider.v-input--vertical .v-slider-thumb__label::before {\n  border-right: 6px solid currentColor;\n  border-top: 6px solid transparent;\n  border-bottom: 6px solid transparent;\n  left: -6px;\n}\n.v-slider-thumb--focused .v-slider-thumb__surface::before {\n  transform: scale(2);\n  opacity: var(--v-focus-opacity);\n}\n.v-slider-thumb--pressed {\n  transition: none;\n}\n.v-slider-thumb--pressed .v-slider-thumb__surface::before {\n  opacity: var(--v-pressed-opacity);\n}\n@media (hover: hover) {\n  .v-slider-thumb:hover .v-slider-thumb__surface::before {\n    transform: scale(2);\n  }\n  .v-slider-thumb:hover:not(.v-slider-thumb--focused) .v-slider-thumb__surface::before {\n    opacity: var(--v-hover-opacity);\n  }\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VSlider/VSliderTrack.css */\n.v-slider-track__background {\n  background-color: rgb(var(--v-theme-surface-variant));\n}\n@media (forced-colors: active) {\n  .v-slider-track__background {\n    background-color: highlight;\n  }\n}\n.v-slider-track__fill {\n  background-color: rgb(var(--v-theme-surface-variant));\n}\n@media (forced-colors: active) {\n  .v-slider-track__fill {\n    background-color: highlight;\n  }\n}\n.v-slider-track__tick {\n  background-color: rgb(var(--v-theme-surface-variant));\n}\n.v-slider-track__tick--filled {\n  background-color: rgb(var(--v-theme-surface-light));\n}\n.v-slider-track {\n  border-radius: 6px;\n}\n@media (forced-colors: active) {\n  .v-slider-track {\n    border: thin solid buttontext;\n  }\n}\n.v-slider-track__background,\n.v-slider-track__fill {\n  position: absolute;\n  transition: 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);\n  border-radius: inherit;\n}\n.v-slider--pressed .v-slider-track__background,\n.v-slider--pressed .v-slider-track__fill {\n  transition: none;\n}\n.v-input--error:not(.v-input--disabled) .v-slider-track__background,\n.v-input--error:not(.v-input--disabled) .v-slider-track__fill {\n  background-color: currentColor;\n}\n.v-slider-track__ticks {\n  height: 100%;\n  width: 100%;\n  position: relative;\n}\n.v-slider-track__tick {\n  position: absolute;\n  opacity: 0;\n  transition: 0.2s opacity cubic-bezier(0.4, 0, 0.2, 1);\n  border-radius: 2px;\n  width: var(--v-slider-tick-size);\n  height: var(--v-slider-tick-size);\n  transform: translate(calc(var(--v-slider-tick-size) / -2), calc(var(--v-slider-tick-size) / -2));\n}\n.v-locale--is-ltr.v-slider-track__tick--first .v-slider-track__tick-label,\n.v-locale--is-ltr .v-slider-track__tick--first .v-slider-track__tick-label {\n  transform: none;\n}\n.v-locale--is-rtl.v-slider-track__tick--first .v-slider-track__tick-label,\n.v-locale--is-rtl .v-slider-track__tick--first .v-slider-track__tick-label {\n  transform: translateX(100%);\n}\n.v-locale--is-ltr.v-slider-track__tick--last .v-slider-track__tick-label,\n.v-locale--is-ltr .v-slider-track__tick--last .v-slider-track__tick-label {\n  transform: translateX(-100%);\n}\n.v-locale--is-rtl.v-slider-track__tick--last .v-slider-track__tick-label,\n.v-locale--is-rtl .v-slider-track__tick--last .v-slider-track__tick-label {\n  transform: none;\n}\n.v-slider-track__tick-label {\n  position: absolute;\n  user-select: none;\n  white-space: nowrap;\n}\n.v-slider.v-input--horizontal .v-slider-track {\n  display: flex;\n  align-items: center;\n  width: 100%;\n  height: calc(var(--v-slider-track-size) + 2px);\n  touch-action: pan-y;\n}\n.v-slider.v-input--horizontal .v-slider-track__background {\n  height: var(--v-slider-track-size);\n}\n.v-slider.v-input--horizontal .v-slider-track__fill {\n  height: inherit;\n}\n.v-slider.v-input--horizontal .v-slider-track__tick {\n  margin-top: calc(calc(var(--v-slider-track-size) + 2px) / 2);\n}\n.v-locale--is-rtl.v-slider.v-input--horizontal .v-slider-track__tick,\n.v-locale--is-rtl .v-slider.v-input--horizontal .v-slider-track__tick {\n  transform: translate(calc(var(--v-slider-tick-size) / 2), calc(var(--v-slider-tick-size) / -2));\n}\n.v-slider.v-input--horizontal .v-slider-track__tick .v-slider-track__tick-label {\n  margin-top: calc(var(--v-slider-track-size) / 2 + 8px);\n}\n.v-locale--is-ltr.v-slider.v-input--horizontal .v-slider-track__tick .v-slider-track__tick-label,\n.v-locale--is-ltr .v-slider.v-input--horizontal .v-slider-track__tick .v-slider-track__tick-label {\n  transform: translateX(-50%);\n}\n.v-locale--is-rtl.v-slider.v-input--horizontal .v-slider-track__tick .v-slider-track__tick-label,\n.v-locale--is-rtl .v-slider.v-input--horizontal .v-slider-track__tick .v-slider-track__tick-label {\n  transform: translateX(50%);\n}\n.v-slider.v-input--horizontal .v-slider-track__tick--first {\n  margin-inline-start: calc(var(--v-slider-tick-size) + 1px);\n}\n.v-locale--is-ltr.v-slider.v-input--horizontal .v-slider-track__tick--first .v-slider-track__tick-label,\n.v-locale--is-ltr .v-slider.v-input--horizontal .v-slider-track__tick--first .v-slider-track__tick-label {\n  transform: translateX(0%);\n}\n.v-locale--is-rtl.v-slider.v-input--horizontal .v-slider-track__tick--first .v-slider-track__tick-label,\n.v-locale--is-rtl .v-slider.v-input--horizontal .v-slider-track__tick--first .v-slider-track__tick-label {\n  transform: translateX(0%);\n}\n.v-slider.v-input--horizontal .v-slider-track__tick--last {\n  margin-inline-start: calc(100% - var(--v-slider-tick-size) - 1px);\n}\n.v-locale--is-ltr.v-slider.v-input--horizontal .v-slider-track__tick--last .v-slider-track__tick-label,\n.v-locale--is-ltr .v-slider.v-input--horizontal .v-slider-track__tick--last .v-slider-track__tick-label {\n  transform: translateX(-100%);\n}\n.v-locale--is-rtl.v-slider.v-input--horizontal .v-slider-track__tick--last .v-slider-track__tick-label,\n.v-locale--is-rtl .v-slider.v-input--horizontal .v-slider-track__tick--last .v-slider-track__tick-label {\n  transform: translateX(100%);\n}\n.v-slider.v-input--vertical .v-slider-track {\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  width: calc(var(--v-slider-track-size) + 2px);\n  touch-action: pan-x;\n}\n.v-slider.v-input--vertical .v-slider-track__background {\n  width: var(--v-slider-track-size);\n}\n.v-slider.v-input--vertical .v-slider-track__fill {\n  width: inherit;\n}\n.v-slider.v-input--vertical .v-slider-track__ticks {\n  height: 100%;\n}\n.v-slider.v-input--vertical .v-slider-track__tick {\n  margin-inline-start: calc(calc(var(--v-slider-track-size) + 2px) / 2);\n  transform: translate(calc(var(--v-slider-tick-size) / -2), calc(var(--v-slider-tick-size) / 2));\n}\n.v-locale--is-rtl.v-slider.v-input--vertical .v-slider-track__tick,\n.v-locale--is-rtl .v-slider.v-input--vertical .v-slider-track__tick {\n  transform: translate(calc(var(--v-slider-tick-size) / 2), calc(var(--v-slider-tick-size) / 2));\n}\n.v-slider.v-input--vertical .v-slider-track__tick--first {\n  bottom: calc(0% + var(--v-slider-tick-size) + 1px);\n}\n.v-slider.v-input--vertical .v-slider-track__tick--last {\n  bottom: calc(100% - var(--v-slider-tick-size) - 1px);\n}\n.v-slider.v-input--vertical .v-slider-track__tick .v-slider-track__tick-label {\n  margin-inline-start: calc(var(--v-slider-track-size) / 2 + 12px);\n  transform: translateY(-50%);\n}\n.v-slider-track__ticks--always-show .v-slider-track__tick,\n.v-slider--focused .v-slider-track__tick {\n  opacity: 1;\n}\n.v-slider-track__background--opacity {\n  opacity: 0.38;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VColorPicker/VColorPickerSwatches.css */\n.v-color-picker-swatches {\n  overflow-y: auto;\n}\n.v-color-picker-swatches > div {\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: center;\n  padding: 8px;\n}\n.v-color-picker-swatches__swatch {\n  display: flex;\n  flex-direction: column;\n  margin-bottom: 10px;\n}\n.v-color-picker-swatches__color {\n  position: relative;\n  height: 18px;\n  max-height: 18px;\n  width: 45px;\n  margin: 2px 4px;\n  border-radius: 2px;\n  user-select: none;\n  overflow: hidden;\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAAXNSR0IArs4c6QAAACRJREFUKFNjPHTo0H8GJGBnZ8eIzGekgwJk+0BsdCtRHEQbBQBbbh0dIGKknQAAAABJRU5ErkJggg==) repeat;\n  cursor: pointer;\n}\n.v-color-picker-swatches__color > div {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  height: 100%;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/labs/VPicker/VPicker.css */\n.v-picker.v-sheet {\n  display: grid;\n  grid-auto-rows: min-content;\n  grid-template-areas: \"title\" \"header\" \"body\";\n  overflow: hidden;\n}\n.v-picker.v-sheet {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-picker.v-sheet {\n  border-radius: 4px;\n}\n.v-picker.v-sheet.v-picker--with-actions {\n  grid-template-areas: \"title\" \"header\" \"body\" \"actions\";\n}\n.v-picker__body {\n  grid-area: body;\n  overflow: hidden;\n  position: relative;\n}\n.v-picker__header {\n  grid-area: header;\n}\n.v-picker__actions {\n  grid-area: actions;\n  padding: 0 12px 12px;\n  display: flex;\n  align-items: center;\n  justify-content: flex-end;\n}\n.v-picker__actions .v-btn {\n  min-width: 48px;\n}\n.v-picker__actions .v-btn:not(:last-child) {\n  margin-inline-end: 8px;\n}\n.v-picker--divided .v-picker__header {\n  border-bottom-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n}\n.v-picker--landscape {\n  grid-template-areas: \"title\" \"header body\" \"header body\";\n}\n.v-picker--landscape.v-picker--with-actions {\n  grid-template-areas: \"title\" \"header body\" \"header actions\";\n}\n.v-picker-title {\n  text-transform: uppercase;\n  font-size: 0.75rem;\n  grid-area: title;\n  padding-inline: 24px 12px;\n  padding-top: 16px;\n  padding-bottom: 16px;\n  font-weight: 400;\n  letter-spacing: 0.1666666667em;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VSheet/VSheet.css */\n.v-sheet {\n  display: block;\n}\n.v-sheet {\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-style: solid;\n  border-width: 0;\n}\n.v-sheet--border {\n  border-width: thin;\n  box-shadow: none;\n}\n.v-sheet {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-sheet--absolute {\n  position: absolute;\n}\n.v-sheet--fixed {\n  position: fixed;\n}\n.v-sheet--relative {\n  position: relative;\n}\n.v-sheet--sticky {\n  position: sticky;\n}\n.v-sheet {\n  border-radius: 0;\n}\n.v-sheet {\n  background: rgb(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-sheet--rounded {\n  border-radius: 4px;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VCombobox/VCombobox.css */\n.v-combobox--chips.v-input--density-compact .v-field--variant-solo .v-label.v-field-label--floating,\n.v-combobox--chips.v-input--density-compact .v-field--variant-solo-inverted .v-label.v-field-label--floating,\n.v-combobox--chips.v-input--density-compact .v-field--variant-filled .v-label.v-field-label--floating,\n.v-combobox--chips.v-input--density-compact .v-field--variant-solo-filled .v-label.v-field-label--floating {\n  top: 0px;\n}\n.v-combobox .v-field .v-text-field__prefix,\n.v-combobox .v-field .v-text-field__suffix,\n.v-combobox .v-field .v-field__input,\n.v-combobox .v-field.v-field {\n  cursor: text;\n}\n.v-combobox .v-field .v-field__input > input {\n  flex: 1 1;\n}\n.v-combobox .v-field input {\n  min-width: 64px;\n}\n.v-combobox .v-field:not(.v-field--focused) input {\n  min-width: 0;\n}\n.v-combobox .v-field--dirty .v-combobox__selection {\n  margin-inline-end: 2px;\n}\n.v-combobox .v-combobox__selection-text {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n.v-combobox__content {\n  overflow: hidden;\n}\n.v-combobox__content {\n  box-shadow:\n    0px 2px 4px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 4px 5px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 10px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-combobox__content {\n  border-radius: 4px;\n}\n.v-combobox__mask {\n  background: rgb(var(--v-theme-surface-light));\n}\n.v-combobox__selection {\n  display: inline-flex;\n  align-items: center;\n  height: 1.5rem;\n  letter-spacing: inherit;\n  line-height: inherit;\n  max-width: calc(100% - 2px - 2px);\n}\n.v-combobox__selection:first-child {\n  margin-inline-start: 0;\n}\n.v-combobox--selecting-index .v-combobox__selection {\n  opacity: var(--v-medium-emphasis-opacity);\n}\n.v-combobox--selecting-index .v-combobox__selection--selected {\n  opacity: 1;\n}\n.v-combobox--selecting-index .v-field__input > input {\n  caret-color: transparent;\n}\n.v-combobox--single:not(.v-combobox--selection-slot).v-text-field input {\n  flex: 1 1;\n  position: absolute;\n  left: 0;\n  right: 0;\n  width: 100%;\n  padding-inline: inherit;\n}\n.v-combobox--single:not(.v-combobox--selection-slot) .v-field--active input {\n  transition: none;\n}\n.v-combobox--single:not(.v-combobox--selection-slot) .v-field--dirty:not(.v-field--focused) input {\n  opacity: 0;\n}\n.v-combobox--single:not(.v-combobox--selection-slot) .v-field--focused .v-combobox__selection {\n  opacity: 0;\n}\n.v-combobox__menu-icon {\n  margin-inline-start: 4px;\n  transition: 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-combobox--active-menu .v-combobox__menu-icon {\n  transform: rotate(180deg);\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VDataTable/VDataTable.css */\n.v-data-table {\n  width: 100%;\n}\n.v-data-table__table {\n  width: 100%;\n  border-collapse: separate;\n  border-spacing: 0;\n}\n.v-data-table__tr--focus {\n  border: 1px dotted black;\n}\n.v-data-table__tr--clickable {\n  cursor: pointer;\n}\n.v-data-table .v-table__wrapper > table > thead > tr > td.v-data-table-column--align-end,\n.v-data-table .v-table__wrapper > table > thead > tr th.v-data-table-column--align-end,\n.v-data-table .v-table__wrapper > table tbody > tr > td.v-data-table-column--align-end,\n.v-data-table .v-table__wrapper > table tbody > tr th.v-data-table-column--align-end {\n  text-align: end;\n}\n.v-data-table .v-table__wrapper > table > thead > tr > td.v-data-table-column--align-end .v-data-table-header__content,\n.v-data-table .v-table__wrapper > table > thead > tr th.v-data-table-column--align-end .v-data-table-header__content,\n.v-data-table .v-table__wrapper > table tbody > tr > td.v-data-table-column--align-end .v-data-table-header__content,\n.v-data-table .v-table__wrapper > table tbody > tr th.v-data-table-column--align-end .v-data-table-header__content {\n  flex-direction: row-reverse;\n}\n.v-data-table .v-table__wrapper > table > thead > tr > td.v-data-table-column--align-center,\n.v-data-table .v-table__wrapper > table > thead > tr th.v-data-table-column--align-center,\n.v-data-table .v-table__wrapper > table tbody > tr > td.v-data-table-column--align-center,\n.v-data-table .v-table__wrapper > table tbody > tr th.v-data-table-column--align-center {\n  text-align: center;\n}\n.v-data-table .v-table__wrapper > table > thead > tr > td.v-data-table-column--align-center .v-data-table-header__content,\n.v-data-table .v-table__wrapper > table > thead > tr th.v-data-table-column--align-center .v-data-table-header__content,\n.v-data-table .v-table__wrapper > table tbody > tr > td.v-data-table-column--align-center .v-data-table-header__content,\n.v-data-table .v-table__wrapper > table tbody > tr th.v-data-table-column--align-center .v-data-table-header__content {\n  justify-content: center;\n}\n.v-data-table .v-table__wrapper > table > thead > tr > td.v-data-table-column--no-padding,\n.v-data-table .v-table__wrapper > table > thead > tr th.v-data-table-column--no-padding,\n.v-data-table .v-table__wrapper > table tbody > tr > td.v-data-table-column--no-padding,\n.v-data-table .v-table__wrapper > table tbody > tr th.v-data-table-column--no-padding {\n  padding: 0 8px;\n}\n.v-data-table .v-table__wrapper > table > thead > tr > td.v-data-table-column--nowrap,\n.v-data-table .v-table__wrapper > table > thead > tr th.v-data-table-column--nowrap,\n.v-data-table .v-table__wrapper > table tbody > tr > td.v-data-table-column--nowrap,\n.v-data-table .v-table__wrapper > table tbody > tr th.v-data-table-column--nowrap {\n  text-overflow: ellipsis;\n  text-wrap: nowrap;\n  overflow: hidden;\n}\n.v-data-table .v-table__wrapper > table > thead > tr > td.v-data-table-column--nowrap .v-data-table-header__content,\n.v-data-table .v-table__wrapper > table > thead > tr th.v-data-table-column--nowrap .v-data-table-header__content,\n.v-data-table .v-table__wrapper > table tbody > tr > td.v-data-table-column--nowrap .v-data-table-header__content,\n.v-data-table .v-table__wrapper > table tbody > tr th.v-data-table-column--nowrap .v-data-table-header__content {\n  display: contents;\n}\n.v-data-table .v-table__wrapper > table > thead > tr > th,\n.v-data-table .v-table__wrapper > table tbody > tr > th {\n  align-items: center;\n}\n.v-data-table .v-table__wrapper > table > thead > tr > th.v-data-table__th--fixed,\n.v-data-table .v-table__wrapper > table tbody > tr > th.v-data-table__th--fixed {\n  position: sticky;\n}\n.v-data-table .v-table__wrapper > table > thead > tr > th.v-data-table__th--sortable:hover,\n.v-data-table .v-table__wrapper > table > thead > tr > th.v-data-table__th--sortable:focus,\n.v-data-table .v-table__wrapper > table tbody > tr > th.v-data-table__th--sortable:hover,\n.v-data-table .v-table__wrapper > table tbody > tr > th.v-data-table__th--sortable:focus {\n  cursor: pointer;\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-data-table .v-table__wrapper > table > thead > tr > th:not(.v-data-table__th--sorted) .v-data-table-header__sort-icon,\n.v-data-table .v-table__wrapper > table tbody > tr > th:not(.v-data-table__th--sorted) .v-data-table-header__sort-icon {\n  opacity: 0;\n}\n.v-data-table .v-table__wrapper > table > thead > tr > th:not(.v-data-table__th--sorted):hover .v-data-table-header__sort-icon,\n.v-data-table .v-table__wrapper > table > thead > tr > th:not(.v-data-table__th--sorted):focus .v-data-table-header__sort-icon,\n.v-data-table .v-table__wrapper > table tbody > tr > th:not(.v-data-table__th--sorted):hover .v-data-table-header__sort-icon,\n.v-data-table .v-table__wrapper > table tbody > tr > th:not(.v-data-table__th--sorted):focus .v-data-table-header__sort-icon {\n  opacity: 0.5;\n}\n.v-data-table .v-table__wrapper > table > thead > tr.v-data-table__tr--mobile > td,\n.v-data-table .v-table__wrapper > table tbody > tr.v-data-table__tr--mobile > td {\n  height: fit-content;\n}\n.v-data-table-column--fixed,\n.v-data-table__th--sticky {\n  background: rgb(var(--v-theme-surface));\n  position: sticky !important;\n  left: 0;\n  z-index: 1;\n}\n.v-data-table-column--last-fixed {\n  border-right: 1px solid rgba(var(--v-border-color), var(--v-border-opacity));\n}\n.v-data-table.v-table--fixed-header > .v-table__wrapper > table > thead > tr > th.v-data-table-column--fixed {\n  z-index: 2;\n}\n.v-data-table-group-header-row td {\n  background: rgba(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-surface));\n}\n.v-data-table-group-header-row td > span {\n  padding-left: 5px;\n}\n.v-data-table--loading .v-data-table__td {\n  opacity: var(--v-disabled-opacity);\n}\n.v-data-table-group-header-row__column {\n  padding-left: calc(var(--v-data-table-group-header-row-depth) * 16px) !important;\n}\n.v-data-table-header__content {\n  display: flex;\n  align-items: center;\n}\n.v-data-table-header__sort-badge {\n  display: inline-flex;\n  justify-content: center;\n  align-items: center;\n  font-size: 0.875rem;\n  padding: 4px;\n  border-radius: 50%;\n  background: rgba(var(--v-border-color), var(--v-border-opacity));\n  min-width: 20px;\n  min-height: 20px;\n  width: 20px;\n  height: 20px;\n}\n.v-data-table-progress > th {\n  border: none !important;\n  height: auto !important;\n  padding: 0 !important;\n}\n.v-data-table-progress__loader {\n  position: relative;\n}\n.v-data-table-rows-loading,\n.v-data-table-rows-no-data {\n  text-align: center;\n}\n.v-data-table__tr--mobile > .v-data-table__td--expanded-row {\n  grid-template-columns: auto;\n  justify-content: center;\n}\n.v-data-table__tr--mobile > .v-data-table__td--select-row {\n  grid-template-columns: 0;\n  justify-content: end;\n}\n.v-data-table__tr--mobile > td {\n  align-items: center;\n  column-gap: 4px;\n  display: grid;\n  grid-template-columns: repeat(2, 1fr);\n  min-height: var(--v-table-row-height);\n}\n.v-data-table__tr--mobile > td:not(:last-child) {\n  border-bottom: 0 !important;\n}\n.v-data-table__td-title {\n  font-weight: 500;\n  text-align: start;\n}\n.v-data-table__td-value {\n  text-align: end;\n}\n.v-data-table__td-sort-icon {\n  color: rgba(var(--v-theme-on-surface), var(--v-disabled-opacity));\n}\n.v-data-table__td-sort-icon-active {\n  color: rgba(var(--v-theme-on-surface));\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VDataTable/VDataTableFooter.css */\n.v-data-table-footer {\n  align-items: center;\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: flex-end;\n  padding: 8px 4px;\n}\n.v-data-table-footer__items-per-page {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n}\n.v-data-table-footer__items-per-page > span {\n  padding-inline-end: 8px;\n}\n.v-data-table-footer__items-per-page > .v-select {\n  width: 90px;\n}\n.v-data-table-footer__info {\n  display: flex;\n  justify-content: flex-end;\n  min-width: 116px;\n  padding: 0 16px;\n}\n.v-data-table-footer__paginationz {\n  align-items: center;\n  display: flex;\n  margin-inline-start: 16px;\n}\n.v-data-table-footer__page {\n  padding: 0 8px;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VPagination/VPagination.css */\n.v-pagination__list {\n  display: inline-flex;\n  list-style-type: none;\n  justify-content: center;\n  width: 100%;\n}\n.v-pagination__item,\n.v-pagination__first,\n.v-pagination__prev,\n.v-pagination__next,\n.v-pagination__last {\n  margin: 0.3rem;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VTable/VTable.css */\n.v-table {\n  font-size: 0.875rem;\n  transition-duration: 0.28s;\n  transition-property:\n    box-shadow,\n    opacity,\n    background,\n    height;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-table {\n  background: rgb(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-table .v-table-divider {\n  border-right: thin solid rgba(var(--v-border-color), var(--v-border-opacity));\n}\n.v-table .v-table__wrapper > table > thead > tr > th {\n  border-bottom: thin solid rgba(var(--v-border-color), var(--v-border-opacity));\n}\n.v-table .v-table__wrapper > table > tbody > tr:not(:last-child) > td,\n.v-table .v-table__wrapper > table > tbody > tr:not(:last-child) > th {\n  border-bottom: thin solid rgba(var(--v-border-color), var(--v-border-opacity));\n}\n.v-table .v-table__wrapper > table > tfoot > tr > td,\n.v-table .v-table__wrapper > table > tfoot > tr > th {\n  border-top: thin solid rgba(var(--v-border-color), var(--v-border-opacity));\n}\n.v-table.v-table--hover > .v-table__wrapper > table > tbody > tr > td {\n  position: relative;\n}\n.v-table.v-table--hover > .v-table__wrapper > table > tbody > tr:hover > td::after {\n  background: rgba(var(--v-border-color), var(--v-hover-opacity));\n  pointer-events: none;\n}\n.v-table.v-table--hover > .v-table__wrapper > table > tbody > tr:hover > td::after {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n.v-table.v-table--fixed-header > .v-table__wrapper > table > thead > tr > th {\n  background: rgb(var(--v-theme-surface));\n  box-shadow: inset 0 -1px 0 rgba(var(--v-border-color), var(--v-border-opacity));\n  z-index: 1;\n}\n.v-table.v-table--fixed-footer > tfoot > tr > th,\n.v-table.v-table--fixed-footer > tfoot > tr > td {\n  background: rgb(var(--v-theme-surface));\n  box-shadow: inset 0 1px 0 rgba(var(--v-border-color), var(--v-border-opacity));\n}\n.v-table {\n  border-radius: inherit;\n  line-height: 1.5;\n  max-width: 100%;\n  display: flex;\n  flex-direction: column;\n}\n.v-table > .v-table__wrapper > table {\n  width: 100%;\n  border-spacing: 0;\n}\n.v-table > .v-table__wrapper > table > tbody > tr > td,\n.v-table > .v-table__wrapper > table > tbody > tr > th,\n.v-table > .v-table__wrapper > table > thead > tr > td,\n.v-table > .v-table__wrapper > table > thead > tr > th,\n.v-table > .v-table__wrapper > table > tfoot > tr > td,\n.v-table > .v-table__wrapper > table > tfoot > tr > th {\n  padding: 0 16px;\n  transition-duration: 0.28s;\n  transition-property:\n    box-shadow,\n    opacity,\n    background,\n    height;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-table > .v-table__wrapper > table > tbody > tr > td,\n.v-table > .v-table__wrapper > table > thead > tr > td,\n.v-table > .v-table__wrapper > table > tfoot > tr > td {\n  height: var(--v-table-row-height);\n}\n.v-table > .v-table__wrapper > table > tbody > tr > th,\n.v-table > .v-table__wrapper > table > thead > tr > th,\n.v-table > .v-table__wrapper > table > tfoot > tr > th {\n  height: var(--v-table-header-height);\n  font-weight: 500;\n  user-select: none;\n  text-align: start;\n}\n.v-table--density-default {\n  --v-table-header-height: 56px;\n  --v-table-row-height: 52px;\n}\n.v-table--density-comfortable {\n  --v-table-header-height: 48px;\n  --v-table-row-height: 44px;\n}\n.v-table--density-compact {\n  --v-table-header-height: 40px;\n  --v-table-row-height: 36px;\n}\n.v-table__wrapper {\n  border-radius: inherit;\n  overflow: auto;\n  flex: 1 1 auto;\n}\n.v-table--has-top > .v-table__wrapper {\n  border-top-left-radius: 0;\n  border-top-right-radius: 0;\n}\n.v-table--has-bottom > .v-table__wrapper {\n  border-bottom-left-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.v-table--fixed-height > .v-table__wrapper {\n  overflow-y: auto;\n}\n.v-table--fixed-header > .v-table__wrapper > table > thead {\n  position: sticky;\n  top: 0;\n  z-index: 2;\n}\n.v-table--fixed-header > .v-table__wrapper > table > thead > tr > th {\n  border-bottom: 0px !important;\n}\n.v-table--fixed-footer > .v-table__wrapper > table > tfoot > tr {\n  position: sticky;\n  bottom: 0;\n  z-index: 1;\n}\n.v-table--fixed-footer > .v-table__wrapper > table > tfoot > tr > td,\n.v-table--fixed-footer > .v-table__wrapper > table > tfoot > tr > th {\n  border-top: 0px !important;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VDatePicker/VDatePicker.css */\n.v-date-picker {\n  overflow: hidden;\n  width: 328px;\n}\n.v-date-picker--show-week {\n  width: 368px;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VDatePicker/VDatePickerControls.css */\n.v-date-picker-controls {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  font-size: 0.875rem;\n  height: var(--v-date-picker-controls-height, 56px);\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-inline-start: 6px;\n  padding-inline-end: 12px;\n}\n.v-date-picker-controls > .v-btn:first-child {\n  text-transform: none;\n  font-weight: 400;\n  line-height: initial;\n  letter-spacing: initial;\n}\n.v-date-picker-controls--variant-classic {\n  padding-inline-start: 12px;\n}\n.v-date-picker-controls--variant-modern .v-date-picker__title:not(:hover) {\n  opacity: 0.7;\n}\n.v-date-picker--month .v-date-picker-controls--variant-modern .v-date-picker__title {\n  cursor: pointer;\n}\n.v-date-picker--year .v-date-picker-controls--variant-modern .v-date-picker__title {\n  opacity: 1;\n}\n.v-date-picker-controls .v-btn:last-child {\n  margin-inline-start: 4px;\n}\n.v-date-picker--year .v-date-picker-controls .v-date-picker-controls__mode-btn {\n  transform: rotate(180deg);\n}\n.v-date-picker-controls__date {\n  margin-inline-end: 4px;\n}\n.v-date-picker-controls--variant-classic .v-date-picker-controls__date {\n  margin: auto;\n  text-align: center;\n}\n.v-date-picker-controls__month {\n  display: flex;\n}\n.v-locale--is-rtl.v-date-picker-controls__month,\n.v-locale--is-rtl .v-date-picker-controls__month {\n  flex-direction: row-reverse;\n}\n.v-date-picker-controls--variant-classic .v-date-picker-controls__month {\n  flex: 1 0 auto;\n}\n.v-date-picker__title {\n  display: inline-block;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VGrid/VGrid.css */\n.v-container {\n  width: 100%;\n  padding: 16px;\n  margin-right: auto;\n  margin-left: auto;\n}\n@media (min-width: 960px) {\n  .v-container {\n    max-width: 900px;\n  }\n}\n@media (min-width: 1280px) {\n  .v-container {\n    max-width: 1200px;\n  }\n}\n@media (min-width: 1920px) {\n  .v-container {\n    max-width: 1800px;\n  }\n}\n@media (min-width: 2560px) {\n  .v-container {\n    max-width: 2400px;\n  }\n}\n.v-container--fluid {\n  max-width: 100%;\n}\n.v-container.fill-height {\n  align-items: center;\n  display: flex;\n  flex-wrap: wrap;\n}\n.v-row {\n  display: flex;\n  flex-wrap: wrap;\n  flex: 1 1 auto;\n  margin: -12px;\n}\n.v-row + .v-row {\n  margin-top: 12px;\n}\n.v-row + .v-row--dense {\n  margin-top: 4px;\n}\n.v-row--dense {\n  margin: -4px;\n}\n.v-row--dense > .v-col,\n.v-row--dense > [class*=v-col-] {\n  padding: 4px;\n}\n.v-row.v-row--no-gutters {\n  margin: 0;\n}\n.v-row.v-row--no-gutters > .v-col,\n.v-row.v-row--no-gutters > [class*=v-col-] {\n  padding: 0;\n}\n.v-spacer {\n  flex-grow: 1;\n}\n.v-col-xxl,\n.v-col-xxl-auto,\n.v-col-xxl-12,\n.v-col-xxl-11,\n.v-col-xxl-10,\n.v-col-xxl-9,\n.v-col-xxl-8,\n.v-col-xxl-7,\n.v-col-xxl-6,\n.v-col-xxl-5,\n.v-col-xxl-4,\n.v-col-xxl-3,\n.v-col-xxl-2,\n.v-col-xxl-1,\n.v-col-xl,\n.v-col-xl-auto,\n.v-col-xl-12,\n.v-col-xl-11,\n.v-col-xl-10,\n.v-col-xl-9,\n.v-col-xl-8,\n.v-col-xl-7,\n.v-col-xl-6,\n.v-col-xl-5,\n.v-col-xl-4,\n.v-col-xl-3,\n.v-col-xl-2,\n.v-col-xl-1,\n.v-col-lg,\n.v-col-lg-auto,\n.v-col-lg-12,\n.v-col-lg-11,\n.v-col-lg-10,\n.v-col-lg-9,\n.v-col-lg-8,\n.v-col-lg-7,\n.v-col-lg-6,\n.v-col-lg-5,\n.v-col-lg-4,\n.v-col-lg-3,\n.v-col-lg-2,\n.v-col-lg-1,\n.v-col-md,\n.v-col-md-auto,\n.v-col-md-12,\n.v-col-md-11,\n.v-col-md-10,\n.v-col-md-9,\n.v-col-md-8,\n.v-col-md-7,\n.v-col-md-6,\n.v-col-md-5,\n.v-col-md-4,\n.v-col-md-3,\n.v-col-md-2,\n.v-col-md-1,\n.v-col-sm,\n.v-col-sm-auto,\n.v-col-sm-12,\n.v-col-sm-11,\n.v-col-sm-10,\n.v-col-sm-9,\n.v-col-sm-8,\n.v-col-sm-7,\n.v-col-sm-6,\n.v-col-sm-5,\n.v-col-sm-4,\n.v-col-sm-3,\n.v-col-sm-2,\n.v-col-sm-1,\n.v-col,\n.v-col-auto,\n.v-col-12,\n.v-col-11,\n.v-col-10,\n.v-col-9,\n.v-col-8,\n.v-col-7,\n.v-col-6,\n.v-col-5,\n.v-col-4,\n.v-col-3,\n.v-col-2,\n.v-col-1 {\n  width: 100%;\n  padding: 12px;\n}\n.v-col {\n  flex-basis: 0;\n  flex-grow: 1;\n  max-width: 100%;\n}\n.v-col-auto {\n  flex: 0 0 auto;\n  width: auto;\n  max-width: 100%;\n}\n.v-col-1 {\n  flex: 0 0 8.3333333333%;\n  max-width: 8.3333333333%;\n}\n.v-col-2 {\n  flex: 0 0 16.6666666667%;\n  max-width: 16.6666666667%;\n}\n.v-col-3 {\n  flex: 0 0 25%;\n  max-width: 25%;\n}\n.v-col-4 {\n  flex: 0 0 33.3333333333%;\n  max-width: 33.3333333333%;\n}\n.v-col-5 {\n  flex: 0 0 41.6666666667%;\n  max-width: 41.6666666667%;\n}\n.v-col-6 {\n  flex: 0 0 50%;\n  max-width: 50%;\n}\n.v-col-7 {\n  flex: 0 0 58.3333333333%;\n  max-width: 58.3333333333%;\n}\n.v-col-8 {\n  flex: 0 0 66.6666666667%;\n  max-width: 66.6666666667%;\n}\n.v-col-9 {\n  flex: 0 0 75%;\n  max-width: 75%;\n}\n.v-col-10 {\n  flex: 0 0 83.3333333333%;\n  max-width: 83.3333333333%;\n}\n.v-col-11 {\n  flex: 0 0 91.6666666667%;\n  max-width: 91.6666666667%;\n}\n.v-col-12 {\n  flex: 0 0 100%;\n  max-width: 100%;\n}\n.offset-1 {\n  margin-inline-start: 8.3333333333%;\n}\n.offset-2 {\n  margin-inline-start: 16.6666666667%;\n}\n.offset-3 {\n  margin-inline-start: 25%;\n}\n.offset-4 {\n  margin-inline-start: 33.3333333333%;\n}\n.offset-5 {\n  margin-inline-start: 41.6666666667%;\n}\n.offset-6 {\n  margin-inline-start: 50%;\n}\n.offset-7 {\n  margin-inline-start: 58.3333333333%;\n}\n.offset-8 {\n  margin-inline-start: 66.6666666667%;\n}\n.offset-9 {\n  margin-inline-start: 75%;\n}\n.offset-10 {\n  margin-inline-start: 83.3333333333%;\n}\n.offset-11 {\n  margin-inline-start: 91.6666666667%;\n}\n@media (min-width: 600px) {\n  .v-col-sm {\n    flex-basis: 0;\n    flex-grow: 1;\n    max-width: 100%;\n  }\n  .v-col-sm-auto {\n    flex: 0 0 auto;\n    width: auto;\n    max-width: 100%;\n  }\n  .v-col-sm-1 {\n    flex: 0 0 8.3333333333%;\n    max-width: 8.3333333333%;\n  }\n  .v-col-sm-2 {\n    flex: 0 0 16.6666666667%;\n    max-width: 16.6666666667%;\n  }\n  .v-col-sm-3 {\n    flex: 0 0 25%;\n    max-width: 25%;\n  }\n  .v-col-sm-4 {\n    flex: 0 0 33.3333333333%;\n    max-width: 33.3333333333%;\n  }\n  .v-col-sm-5 {\n    flex: 0 0 41.6666666667%;\n    max-width: 41.6666666667%;\n  }\n  .v-col-sm-6 {\n    flex: 0 0 50%;\n    max-width: 50%;\n  }\n  .v-col-sm-7 {\n    flex: 0 0 58.3333333333%;\n    max-width: 58.3333333333%;\n  }\n  .v-col-sm-8 {\n    flex: 0 0 66.6666666667%;\n    max-width: 66.6666666667%;\n  }\n  .v-col-sm-9 {\n    flex: 0 0 75%;\n    max-width: 75%;\n  }\n  .v-col-sm-10 {\n    flex: 0 0 83.3333333333%;\n    max-width: 83.3333333333%;\n  }\n  .v-col-sm-11 {\n    flex: 0 0 91.6666666667%;\n    max-width: 91.6666666667%;\n  }\n  .v-col-sm-12 {\n    flex: 0 0 100%;\n    max-width: 100%;\n  }\n  .offset-sm-0 {\n    margin-inline-start: 0;\n  }\n  .offset-sm-1 {\n    margin-inline-start: 8.3333333333%;\n  }\n  .offset-sm-2 {\n    margin-inline-start: 16.6666666667%;\n  }\n  .offset-sm-3 {\n    margin-inline-start: 25%;\n  }\n  .offset-sm-4 {\n    margin-inline-start: 33.3333333333%;\n  }\n  .offset-sm-5 {\n    margin-inline-start: 41.6666666667%;\n  }\n  .offset-sm-6 {\n    margin-inline-start: 50%;\n  }\n  .offset-sm-7 {\n    margin-inline-start: 58.3333333333%;\n  }\n  .offset-sm-8 {\n    margin-inline-start: 66.6666666667%;\n  }\n  .offset-sm-9 {\n    margin-inline-start: 75%;\n  }\n  .offset-sm-10 {\n    margin-inline-start: 83.3333333333%;\n  }\n  .offset-sm-11 {\n    margin-inline-start: 91.6666666667%;\n  }\n}\n@media (min-width: 960px) {\n  .v-col-md {\n    flex-basis: 0;\n    flex-grow: 1;\n    max-width: 100%;\n  }\n  .v-col-md-auto {\n    flex: 0 0 auto;\n    width: auto;\n    max-width: 100%;\n  }\n  .v-col-md-1 {\n    flex: 0 0 8.3333333333%;\n    max-width: 8.3333333333%;\n  }\n  .v-col-md-2 {\n    flex: 0 0 16.6666666667%;\n    max-width: 16.6666666667%;\n  }\n  .v-col-md-3 {\n    flex: 0 0 25%;\n    max-width: 25%;\n  }\n  .v-col-md-4 {\n    flex: 0 0 33.3333333333%;\n    max-width: 33.3333333333%;\n  }\n  .v-col-md-5 {\n    flex: 0 0 41.6666666667%;\n    max-width: 41.6666666667%;\n  }\n  .v-col-md-6 {\n    flex: 0 0 50%;\n    max-width: 50%;\n  }\n  .v-col-md-7 {\n    flex: 0 0 58.3333333333%;\n    max-width: 58.3333333333%;\n  }\n  .v-col-md-8 {\n    flex: 0 0 66.6666666667%;\n    max-width: 66.6666666667%;\n  }\n  .v-col-md-9 {\n    flex: 0 0 75%;\n    max-width: 75%;\n  }\n  .v-col-md-10 {\n    flex: 0 0 83.3333333333%;\n    max-width: 83.3333333333%;\n  }\n  .v-col-md-11 {\n    flex: 0 0 91.6666666667%;\n    max-width: 91.6666666667%;\n  }\n  .v-col-md-12 {\n    flex: 0 0 100%;\n    max-width: 100%;\n  }\n  .offset-md-0 {\n    margin-inline-start: 0;\n  }\n  .offset-md-1 {\n    margin-inline-start: 8.3333333333%;\n  }\n  .offset-md-2 {\n    margin-inline-start: 16.6666666667%;\n  }\n  .offset-md-3 {\n    margin-inline-start: 25%;\n  }\n  .offset-md-4 {\n    margin-inline-start: 33.3333333333%;\n  }\n  .offset-md-5 {\n    margin-inline-start: 41.6666666667%;\n  }\n  .offset-md-6 {\n    margin-inline-start: 50%;\n  }\n  .offset-md-7 {\n    margin-inline-start: 58.3333333333%;\n  }\n  .offset-md-8 {\n    margin-inline-start: 66.6666666667%;\n  }\n  .offset-md-9 {\n    margin-inline-start: 75%;\n  }\n  .offset-md-10 {\n    margin-inline-start: 83.3333333333%;\n  }\n  .offset-md-11 {\n    margin-inline-start: 91.6666666667%;\n  }\n}\n@media (min-width: 1280px) {\n  .v-col-lg {\n    flex-basis: 0;\n    flex-grow: 1;\n    max-width: 100%;\n  }\n  .v-col-lg-auto {\n    flex: 0 0 auto;\n    width: auto;\n    max-width: 100%;\n  }\n  .v-col-lg-1 {\n    flex: 0 0 8.3333333333%;\n    max-width: 8.3333333333%;\n  }\n  .v-col-lg-2 {\n    flex: 0 0 16.6666666667%;\n    max-width: 16.6666666667%;\n  }\n  .v-col-lg-3 {\n    flex: 0 0 25%;\n    max-width: 25%;\n  }\n  .v-col-lg-4 {\n    flex: 0 0 33.3333333333%;\n    max-width: 33.3333333333%;\n  }\n  .v-col-lg-5 {\n    flex: 0 0 41.6666666667%;\n    max-width: 41.6666666667%;\n  }\n  .v-col-lg-6 {\n    flex: 0 0 50%;\n    max-width: 50%;\n  }\n  .v-col-lg-7 {\n    flex: 0 0 58.3333333333%;\n    max-width: 58.3333333333%;\n  }\n  .v-col-lg-8 {\n    flex: 0 0 66.6666666667%;\n    max-width: 66.6666666667%;\n  }\n  .v-col-lg-9 {\n    flex: 0 0 75%;\n    max-width: 75%;\n  }\n  .v-col-lg-10 {\n    flex: 0 0 83.3333333333%;\n    max-width: 83.3333333333%;\n  }\n  .v-col-lg-11 {\n    flex: 0 0 91.6666666667%;\n    max-width: 91.6666666667%;\n  }\n  .v-col-lg-12 {\n    flex: 0 0 100%;\n    max-width: 100%;\n  }\n  .offset-lg-0 {\n    margin-inline-start: 0;\n  }\n  .offset-lg-1 {\n    margin-inline-start: 8.3333333333%;\n  }\n  .offset-lg-2 {\n    margin-inline-start: 16.6666666667%;\n  }\n  .offset-lg-3 {\n    margin-inline-start: 25%;\n  }\n  .offset-lg-4 {\n    margin-inline-start: 33.3333333333%;\n  }\n  .offset-lg-5 {\n    margin-inline-start: 41.6666666667%;\n  }\n  .offset-lg-6 {\n    margin-inline-start: 50%;\n  }\n  .offset-lg-7 {\n    margin-inline-start: 58.3333333333%;\n  }\n  .offset-lg-8 {\n    margin-inline-start: 66.6666666667%;\n  }\n  .offset-lg-9 {\n    margin-inline-start: 75%;\n  }\n  .offset-lg-10 {\n    margin-inline-start: 83.3333333333%;\n  }\n  .offset-lg-11 {\n    margin-inline-start: 91.6666666667%;\n  }\n}\n@media (min-width: 1920px) {\n  .v-col-xl {\n    flex-basis: 0;\n    flex-grow: 1;\n    max-width: 100%;\n  }\n  .v-col-xl-auto {\n    flex: 0 0 auto;\n    width: auto;\n    max-width: 100%;\n  }\n  .v-col-xl-1 {\n    flex: 0 0 8.3333333333%;\n    max-width: 8.3333333333%;\n  }\n  .v-col-xl-2 {\n    flex: 0 0 16.6666666667%;\n    max-width: 16.6666666667%;\n  }\n  .v-col-xl-3 {\n    flex: 0 0 25%;\n    max-width: 25%;\n  }\n  .v-col-xl-4 {\n    flex: 0 0 33.3333333333%;\n    max-width: 33.3333333333%;\n  }\n  .v-col-xl-5 {\n    flex: 0 0 41.6666666667%;\n    max-width: 41.6666666667%;\n  }\n  .v-col-xl-6 {\n    flex: 0 0 50%;\n    max-width: 50%;\n  }\n  .v-col-xl-7 {\n    flex: 0 0 58.3333333333%;\n    max-width: 58.3333333333%;\n  }\n  .v-col-xl-8 {\n    flex: 0 0 66.6666666667%;\n    max-width: 66.6666666667%;\n  }\n  .v-col-xl-9 {\n    flex: 0 0 75%;\n    max-width: 75%;\n  }\n  .v-col-xl-10 {\n    flex: 0 0 83.3333333333%;\n    max-width: 83.3333333333%;\n  }\n  .v-col-xl-11 {\n    flex: 0 0 91.6666666667%;\n    max-width: 91.6666666667%;\n  }\n  .v-col-xl-12 {\n    flex: 0 0 100%;\n    max-width: 100%;\n  }\n  .offset-xl-0 {\n    margin-inline-start: 0;\n  }\n  .offset-xl-1 {\n    margin-inline-start: 8.3333333333%;\n  }\n  .offset-xl-2 {\n    margin-inline-start: 16.6666666667%;\n  }\n  .offset-xl-3 {\n    margin-inline-start: 25%;\n  }\n  .offset-xl-4 {\n    margin-inline-start: 33.3333333333%;\n  }\n  .offset-xl-5 {\n    margin-inline-start: 41.6666666667%;\n  }\n  .offset-xl-6 {\n    margin-inline-start: 50%;\n  }\n  .offset-xl-7 {\n    margin-inline-start: 58.3333333333%;\n  }\n  .offset-xl-8 {\n    margin-inline-start: 66.6666666667%;\n  }\n  .offset-xl-9 {\n    margin-inline-start: 75%;\n  }\n  .offset-xl-10 {\n    margin-inline-start: 83.3333333333%;\n  }\n  .offset-xl-11 {\n    margin-inline-start: 91.6666666667%;\n  }\n}\n@media (min-width: 2560px) {\n  .v-col-xxl {\n    flex-basis: 0;\n    flex-grow: 1;\n    max-width: 100%;\n  }\n  .v-col-xxl-auto {\n    flex: 0 0 auto;\n    width: auto;\n    max-width: 100%;\n  }\n  .v-col-xxl-1 {\n    flex: 0 0 8.3333333333%;\n    max-width: 8.3333333333%;\n  }\n  .v-col-xxl-2 {\n    flex: 0 0 16.6666666667%;\n    max-width: 16.6666666667%;\n  }\n  .v-col-xxl-3 {\n    flex: 0 0 25%;\n    max-width: 25%;\n  }\n  .v-col-xxl-4 {\n    flex: 0 0 33.3333333333%;\n    max-width: 33.3333333333%;\n  }\n  .v-col-xxl-5 {\n    flex: 0 0 41.6666666667%;\n    max-width: 41.6666666667%;\n  }\n  .v-col-xxl-6 {\n    flex: 0 0 50%;\n    max-width: 50%;\n  }\n  .v-col-xxl-7 {\n    flex: 0 0 58.3333333333%;\n    max-width: 58.3333333333%;\n  }\n  .v-col-xxl-8 {\n    flex: 0 0 66.6666666667%;\n    max-width: 66.6666666667%;\n  }\n  .v-col-xxl-9 {\n    flex: 0 0 75%;\n    max-width: 75%;\n  }\n  .v-col-xxl-10 {\n    flex: 0 0 83.3333333333%;\n    max-width: 83.3333333333%;\n  }\n  .v-col-xxl-11 {\n    flex: 0 0 91.6666666667%;\n    max-width: 91.6666666667%;\n  }\n  .v-col-xxl-12 {\n    flex: 0 0 100%;\n    max-width: 100%;\n  }\n  .offset-xxl-0 {\n    margin-inline-start: 0;\n  }\n  .offset-xxl-1 {\n    margin-inline-start: 8.3333333333%;\n  }\n  .offset-xxl-2 {\n    margin-inline-start: 16.6666666667%;\n  }\n  .offset-xxl-3 {\n    margin-inline-start: 25%;\n  }\n  .offset-xxl-4 {\n    margin-inline-start: 33.3333333333%;\n  }\n  .offset-xxl-5 {\n    margin-inline-start: 41.6666666667%;\n  }\n  .offset-xxl-6 {\n    margin-inline-start: 50%;\n  }\n  .offset-xxl-7 {\n    margin-inline-start: 58.3333333333%;\n  }\n  .offset-xxl-8 {\n    margin-inline-start: 66.6666666667%;\n  }\n  .offset-xxl-9 {\n    margin-inline-start: 75%;\n  }\n  .offset-xxl-10 {\n    margin-inline-start: 83.3333333333%;\n  }\n  .offset-xxl-11 {\n    margin-inline-start: 91.6666666667%;\n  }\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VDatePicker/VDatePickerHeader.css */\n.v-date-picker-header {\n  align-items: flex-end;\n  height: 70px;\n  display: grid;\n  grid-template-areas: \"prepend content append\";\n  grid-template-columns: min-content minmax(0, 1fr) min-content;\n  overflow: hidden;\n  padding-inline: 24px 12px;\n  padding-bottom: 12px;\n}\n.v-date-picker-header__append {\n  grid-area: append;\n}\n.v-date-picker-header__prepend {\n  grid-area: prepend;\n  padding-inline-start: 8px;\n}\n.v-date-picker-header__content {\n  align-items: center;\n  display: inline-flex;\n  font-size: 32px;\n  line-height: 40px;\n  grid-area: content;\n  justify-content: space-between;\n}\n.v-date-picker-header--clickable .v-date-picker-header__content {\n  cursor: pointer;\n}\n.v-date-picker-header--clickable .v-date-picker-header__content:not(:hover) {\n  opacity: 0.7;\n}\n.date-picker-header-transition-enter-active,\n.date-picker-header-reverse-transition-enter-active {\n  transition-duration: 0.3s;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n}\n.date-picker-header-transition-leave-active,\n.date-picker-header-reverse-transition-leave-active {\n  transition-duration: 0.3s;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n}\n.date-picker-header-transition-enter-from {\n  transform: translate(0, 100%);\n}\n.date-picker-header-transition-leave-to {\n  opacity: 0;\n  transform: translate(0, -100%);\n}\n.date-picker-header-reverse-transition-enter-from {\n  transform: translate(0, -100%);\n}\n.date-picker-header-reverse-transition-leave-to {\n  opacity: 0;\n  transform: translate(0, 100%);\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VDatePicker/VDatePickerMonth.css */\n.v-date-picker-month {\n  display: flex;\n  justify-content: center;\n  padding: 0 12px 8px;\n  --v-date-picker-month-day-diff: 4px;\n}\n.v-date-picker-month__weeks {\n  display: grid;\n  grid-template-rows: min-content min-content min-content min-content min-content min-content min-content;\n  column-gap: 4px;\n  font-size: 0.85rem;\n}\n.v-date-picker-month__weeks + .v-date-picker-month__days {\n  grid-row-gap: 0;\n}\n.v-date-picker-month__weekday {\n  font-size: 0.85rem;\n}\n.v-date-picker-month__days {\n  display: grid;\n  grid-template-columns: min-content min-content min-content min-content min-content min-content min-content;\n  column-gap: 4px;\n  flex: 1 1;\n  justify-content: space-around;\n}\n.v-date-picker-month__day {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n  position: relative;\n  height: 40px;\n  width: 40px;\n}\n.v-date-picker-month__day--selected .v-btn {\n  background-color: rgb(var(--v-theme-surface-variant));\n  color: rgb(var(--v-theme-on-surface-variant));\n}\n.v-date-picker-month__day .v-btn.v-date-picker-month__day-btn {\n  --v-btn-height: 24px;\n  --v-btn-size: 0.85rem;\n}\n.v-date-picker-month__day--week {\n  font-size: var(--v-btn-size);\n}\n.v-date-picker-month__day--adjacent {\n  opacity: 0.5;\n}\n.v-date-picker-month__day--hide-adjacent {\n  opacity: 0;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VDatePicker/VDatePickerMonths.css */\n.v-date-picker-months {\n  height: 288px;\n}\n.v-date-picker-months__content {\n  align-items: center;\n  display: grid;\n  flex: 1 1;\n  height: inherit;\n  justify-content: space-around;\n  grid-template-columns: repeat(2, 1fr);\n  grid-gap: 0px 24px;\n  padding-inline-start: 36px;\n  padding-inline-end: 36px;\n}\n.v-date-picker-months__content .v-btn {\n  text-transform: none;\n  padding-inline-start: 8px;\n  padding-inline-end: 8px;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VDatePicker/VDatePickerYears.css */\n.v-date-picker-years {\n  height: 288px;\n  overflow-y: scroll;\n}\n.v-date-picker-years__content {\n  display: grid;\n  flex: 1 1;\n  justify-content: space-around;\n  grid-template-columns: repeat(3, 1fr);\n  gap: 8px 24px;\n  padding-inline: 32px;\n}\n.v-date-picker-years__content .v-btn {\n  padding-inline: 8px;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VEmptyState/VEmptyState.css */\n.v-empty-state {\n  align-items: center;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  min-height: 100%;\n  padding: 16px;\n}\n.v-empty-state--start {\n  align-items: flex-start;\n}\n.v-empty-state--center {\n  align-items: center;\n}\n.v-empty-state--end {\n  align-items: flex-end;\n}\n.v-empty-state__media {\n  text-align: center;\n  width: 100%;\n}\n.v-empty-state__media .v-icon {\n  color: rgba(var(--v-theme-on-surface), var(--v-medium-emphasis-opacity));\n}\n.v-empty-state__headline {\n  color: rgba(var(--v-theme-on-surface), var(--v-medium-emphasis-opacity));\n  font-size: 3.75rem;\n  font-weight: 300;\n  line-height: 1;\n  text-align: center;\n  margin-bottom: 8px;\n}\n.v-empty-state--mobile .v-empty-state__headline {\n  font-size: 2.125rem;\n}\n.v-empty-state__title {\n  font-size: 1.25rem;\n  font-weight: 500;\n  line-height: 1.6;\n  margin-bottom: 4px;\n  text-align: center;\n}\n.v-empty-state__text {\n  font-size: 0.875rem;\n  font-weight: 400;\n  line-height: 1.425;\n  padding: 0 16px;\n  text-align: center;\n}\n.v-empty-state__content {\n  padding: 24px 0;\n}\n.v-empty-state__actions {\n  display: flex;\n  gap: 8px;\n  padding: 16px;\n}\n.v-empty-state__action-btn.v-btn {\n  background-color: initial;\n  color: initial;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VExpansionPanel/VExpansionPanel.css */\n.v-expansion-panel {\n  background-color: rgb(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-expansion-panel:not(:first-child)::after {\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n}\n.v-expansion-panel--disabled .v-expansion-panel-title {\n  color: rgba(var(--v-theme-on-surface), 0.26);\n}\n.v-expansion-panel--disabled .v-expansion-panel-title .v-expansion-panel-title__overlay {\n  opacity: 0.4615384615;\n}\n.v-expansion-panels {\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: center;\n  list-style-type: none;\n  padding: 0;\n  width: 100%;\n  position: relative;\n  z-index: 1;\n}\n.v-expansion-panels:not(.v-expansion-panels--variant-accordion) > :not(:first-child):not(:last-child):not(.v-expansion-panel--active):not(.v-expansion-panel--before-active) {\n  border-bottom-left-radius: 0 !important;\n  border-bottom-right-radius: 0 !important;\n}\n.v-expansion-panels:not(.v-expansion-panels--variant-accordion) > :not(:first-child):not(:last-child):not(.v-expansion-panel--active):not(.v-expansion-panel--after-active) {\n  border-top-left-radius: 0 !important;\n  border-top-right-radius: 0 !important;\n}\n.v-expansion-panels:not(.v-expansion-panels--variant-accordion) > :first-child:not(:last-child):not(.v-expansion-panel--active):not(.v-expansion-panel--before-active) {\n  border-bottom-left-radius: 0 !important;\n  border-bottom-right-radius: 0 !important;\n}\n.v-expansion-panels:not(.v-expansion-panels--variant-accordion) > :last-child:not(:first-child):not(.v-expansion-panel--active):not(.v-expansion-panel--after-active) {\n  border-top-left-radius: 0 !important;\n  border-top-right-radius: 0 !important;\n}\n.v-expansion-panels--variant-accordion > :first-child:not(:last-child) {\n  border-bottom-left-radius: 0 !important;\n  border-bottom-right-radius: 0 !important;\n}\n.v-expansion-panels--variant-accordion > :last-child:not(:first-child) {\n  border-top-left-radius: 0 !important;\n  border-top-right-radius: 0 !important;\n}\n.v-expansion-panels--variant-accordion > :last-child:not(:first-child) .v-expansion-panel-title--active {\n  border-bottom-left-radius: initial;\n  border-bottom-right-radius: initial;\n}\n.v-expansion-panels--variant-accordion > :not(:first-child):not(:last-child) {\n  border-radius: 0 !important;\n}\n.v-expansion-panels--variant-accordion .v-expansion-panel-title__overlay {\n  transition: 0.3s border-radius cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-expansion-panel {\n  flex: 1 0 100%;\n  max-width: 100%;\n  position: relative;\n  transition: 0.3s all cubic-bezier(0.4, 0, 0.2, 1);\n  transition-property:\n    margin-top,\n    border-radius,\n    border,\n    max-width;\n  border-radius: 4px;\n}\n.v-expansion-panel:not(:first-child)::after {\n  border-top-style: solid;\n  border-top-width: thin;\n  content: \"\";\n  left: 0;\n  position: absolute;\n  right: 0;\n  top: 0;\n  transition: 0.3s opacity cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-expansion-panel--disabled .v-expansion-panel-title {\n  pointer-events: none;\n}\n.v-expansion-panel--active:not(:first-child),\n.v-expansion-panel--active + .v-expansion-panel {\n  margin-top: 16px;\n}\n.v-expansion-panel--active:not(:first-child)::after,\n.v-expansion-panel--active + .v-expansion-panel::after {\n  opacity: 0;\n}\n.v-expansion-panel--active > .v-expansion-panel-title {\n  border-bottom-left-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.v-expansion-panel--active > .v-expansion-panel-title:not(.v-expansion-panel-title--static) {\n  min-height: 64px;\n}\n.v-expansion-panel__shadow {\n  border-radius: inherit;\n  z-index: -1;\n}\n.v-expansion-panel__shadow {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n.v-expansion-panel__shadow {\n  box-shadow:\n    0px 3px 1px -2px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 2px 2px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 5px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-expansion-panel-title {\n  align-items: center;\n  text-align: start;\n  border-radius: inherit;\n  display: flex;\n  font-size: 0.9375rem;\n  line-height: 1;\n  min-height: 48px;\n  outline: none;\n  padding: 16px 24px;\n  position: relative;\n  transition: 0.3s min-height cubic-bezier(0.4, 0, 0.2, 1);\n  width: 100%;\n  justify-content: space-between;\n}\n.v-expansion-panel-title:hover > .v-expansion-panel-title__overlay {\n  opacity: calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-expansion-panel-title:focus-visible > .v-expansion-panel-title__overlay {\n  opacity: calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier));\n}\n@supports not selector(:focus-visible) {\n  .v-expansion-panel-title:focus > .v-expansion-panel-title__overlay {\n    opacity: calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-expansion-panel-title--focusable.v-expansion-panel-title--active .v-expansion-panel-title__overlay {\n  opacity: calc(var(--v-activated-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-expansion-panel-title--focusable.v-expansion-panel-title--active:hover .v-expansion-panel-title__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier));\n}\n.v-expansion-panel-title--focusable.v-expansion-panel-title--active:focus-visible .v-expansion-panel-title__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n}\n@supports not selector(:focus-visible) {\n  .v-expansion-panel-title--focusable.v-expansion-panel-title--active:focus .v-expansion-panel-title__overlay {\n    opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-expansion-panel-title__overlay {\n  background-color: currentColor;\n  border-radius: inherit;\n  opacity: 0;\n}\n.v-expansion-panel-title__overlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n.v-expansion-panel-title__icon {\n  display: inline-flex;\n  margin-bottom: -4px;\n  margin-top: -4px;\n  user-select: none;\n  margin-inline-start: auto;\n}\n.v-expansion-panel-text {\n  display: flex;\n}\n.v-expansion-panel-text__wrapper {\n  padding: 8px 24px 16px;\n  flex: 1 1 auto;\n  max-width: 100%;\n}\n.v-expansion-panels--variant-accordion > .v-expansion-panel {\n  margin-top: 0;\n}\n.v-expansion-panels--variant-accordion > .v-expansion-panel::after {\n  opacity: 1;\n}\n.v-expansion-panels--variant-popout > .v-expansion-panel {\n  max-width: calc(100% - 32px);\n}\n.v-expansion-panels--variant-popout > .v-expansion-panel--active {\n  max-width: calc(100% + 16px);\n}\n.v-expansion-panels--variant-inset > .v-expansion-panel {\n  max-width: 100%;\n}\n.v-expansion-panels--variant-inset > .v-expansion-panel--active {\n  max-width: calc(100% - 32px);\n}\n.v-expansion-panels--flat > .v-expansion-panel::after {\n  border-top: none;\n}\n.v-expansion-panels--flat > .v-expansion-panel .v-expansion-panel__shadow {\n  display: none;\n}\n.v-expansion-panels--tile {\n  border-radius: 0;\n}\n.v-expansion-panels--tile > .v-expansion-panel {\n  border-radius: 0;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VFab/VFab.css */\n.v-fab {\n  align-items: center;\n  display: inline-flex;\n  flex: 1 1 auto;\n  pointer-events: none;\n  position: relative;\n  transition-duration: 0.2s;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  vertical-align: middle;\n}\n.v-fab .v-btn {\n  pointer-events: auto;\n}\n.v-fab .v-btn--variant-elevated {\n  box-shadow:\n    0px 3px 3px -2px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 3px 4px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 8px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-fab--app,\n.v-fab--absolute {\n  display: flex;\n}\n.v-fab--absolute {\n  position: absolute;\n  inset: 0;\n}\n.v-fab--start,\n.v-fab--left {\n  justify-content: flex-start;\n}\n.v-fab--center {\n  align-items: center;\n  justify-content: center;\n}\n.v-fab--end,\n.v-fab--right {\n  justify-content: flex-end;\n}\n.v-fab--bottom {\n  align-items: flex-end;\n}\n.v-fab--top {\n  align-items: flex-start;\n}\n.v-fab--extended .v-btn {\n  border-radius: 9999px !important;\n}\n.v-fab__container {\n  align-self: center;\n  display: inline-flex;\n  vertical-align: middle;\n}\n.v-fab--app .v-fab__container {\n  margin: 12px;\n  position: fixed;\n}\n.v-fab--absolute .v-fab__container {\n  position: absolute;\n  z-index: 4;\n}\n.v-fab--offset.v-fab--top .v-fab__container {\n  transform: translateY(-50%);\n}\n.v-fab--offset.v-fab--bottom .v-fab__container {\n  transform: translateY(50%);\n}\n.v-fab--top .v-fab__container {\n  top: 0;\n}\n.v-fab--bottom .v-fab__container {\n  bottom: 0;\n}\n.v-fab--left .v-fab__container,\n.v-fab--start .v-fab__container {\n  left: 0;\n}\n.v-fab--right .v-fab__container,\n.v-fab--end .v-fab__container {\n  right: 0;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VFileInput/VFileInput.css */\n.v-file-input--hide.v-input .v-field,\n.v-file-input--hide.v-input .v-input__control,\n.v-file-input--hide.v-input .v-input__details {\n  display: none;\n}\n.v-file-input--hide.v-input .v-input__prepend {\n  grid-area: control;\n  margin: 0 auto;\n}\n.v-file-input--chips.v-input--density-compact .v-field--variant-solo .v-label.v-field-label--floating,\n.v-file-input--chips.v-input--density-compact .v-field--variant-solo-inverted .v-label.v-field-label--floating,\n.v-file-input--chips.v-input--density-compact .v-field--variant-filled .v-label.v-field-label--floating,\n.v-file-input--chips.v-input--density-compact .v-field--variant-solo-filled .v-label.v-field-label--floating {\n  top: 0px;\n}\n.v-file-input input[type=file] {\n  height: 100%;\n  left: 0;\n  opacity: 0;\n  position: absolute;\n  top: 0;\n  width: 100%;\n  z-index: 0;\n}\n.v-file-input--dragging input[type=file] {\n  z-index: 1;\n}\n.v-file-input .v-input__details {\n  padding-inline: 16px;\n}\n.v-input--plain-underlined.v-file-input .v-input__details {\n  padding-inline: 0;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VFooter/VFooter.css */\n.v-footer {\n  align-items: center;\n  display: flex;\n  flex: 1 1 auto;\n  padding: 8px 16px;\n  position: relative;\n  transition: 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n  transition-property:\n    height,\n    width,\n    transform,\n    max-width,\n    left,\n    right,\n    top,\n    bottom;\n}\n.v-footer {\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-style: solid;\n  border-width: 0;\n}\n.v-footer--border {\n  border-width: thin;\n  box-shadow: none;\n}\n.v-footer {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-footer--absolute {\n  position: absolute;\n}\n.v-footer--fixed {\n  position: fixed;\n}\n.v-footer {\n  border-radius: 0;\n}\n.v-footer {\n  background: rgb(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-footer--rounded {\n  border-radius: 4px;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VInfiniteScroll/VInfiniteScroll.css */\n.v-infinite-scroll--horizontal {\n  display: flex;\n  flex-direction: row;\n  overflow-x: auto;\n}\n.v-infinite-scroll--horizontal .v-infinite-scroll-intersect {\n  height: 100%;\n  width: var(--v-infinite-margin-size, 1px);\n}\n.v-infinite-scroll--vertical {\n  display: flex;\n  flex-direction: column;\n  overflow-y: auto;\n}\n.v-infinite-scroll--vertical .v-infinite-scroll-intersect {\n  height: 1px;\n  width: 100%;\n}\n.v-infinite-scroll-intersect {\n  pointer-events: none;\n  margin-top: var(--v-infinite-margin);\n  margin-bottom: calc(var(--v-infinite-margin) * -1);\n}\n.v-infinite-scroll-intersect:nth-child(2) {\n  --v-infinite-margin: var(--v-infinite-margin-size, 1px);\n}\n.v-infinite-scroll-intersect:nth-last-child(2) {\n  --v-infinite-margin: calc(var(--v-infinite-margin-size, 1px) * -1);\n}\n.v-infinite-scroll__side {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n  padding: 8px;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VItemGroup/VItemGroup.css */\n.v-item-group {\n  flex: 0 1 auto;\n  max-width: 100%;\n  position: relative;\n  transition: 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VKbd/VKbd.css */\n.v-kbd {\n  background: rgb(var(--v-theme-kbd));\n  color: rgb(var(--v-theme-on-kbd));\n  border-radius: 3px;\n  display: inline;\n  font-size: 85%;\n  font-weight: normal;\n  padding: 0.2em 0.4rem;\n}\n.v-kbd {\n  box-shadow:\n    0px 3px 1px -2px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 2px 2px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 5px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VLayout/VLayout.css */\n.v-layout {\n  --v-scrollbar-offset: 0px;\n  display: flex;\n  flex: 1 1 auto;\n}\n.v-layout--full-height {\n  --v-scrollbar-offset: inherit;\n  height: 100%;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VLayout/VLayoutItem.css */\n.v-layout-item {\n  position: absolute;\n  transition: 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-layout-item--absolute {\n  position: absolute;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VLocaleProvider/VLocaleProvider.css */\n.v-locale-provider {\n  display: contents;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VMain/VMain.css */\n.v-main {\n  flex: 1 0 auto;\n  max-width: 100%;\n  transition: 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n  padding-left: var(--v-layout-left);\n  padding-right: var(--v-layout-right);\n  padding-top: var(--v-layout-top);\n  padding-bottom: var(--v-layout-bottom);\n}\n.v-main__scroller {\n  max-width: 100%;\n  position: relative;\n}\n.v-main--scrollable {\n  display: flex;\n}\n.v-main--scrollable {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n.v-main--scrollable > .v-main__scroller {\n  flex: 1 1 auto;\n  overflow-y: auto;\n  --v-layout-left: 0px;\n  --v-layout-right: 0px;\n  --v-layout-top: 0px;\n  --v-layout-bottom: 0px;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VNavigationDrawer/VNavigationDrawer.css */\n.v-navigation-drawer {\n  -webkit-overflow-scrolling: touch;\n  background: rgb(var(--v-theme-surface));\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n  max-width: 100%;\n  pointer-events: auto;\n  transition-duration: 0.2s;\n  transition-property:\n    box-shadow,\n    transform,\n    visibility,\n    width,\n    height,\n    left,\n    right,\n    top,\n    bottom;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  position: absolute;\n}\n.v-navigation-drawer {\n  border-color: rgba(var(--v-border-color), var(--v-border-opacity));\n  border-style: solid;\n  border-width: 0;\n}\n.v-navigation-drawer--border {\n  border-width: thin;\n  box-shadow: none;\n}\n.v-navigation-drawer {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-navigation-drawer {\n  background: rgb(var(--v-theme-surface));\n  color: rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity));\n}\n.v-navigation-drawer--rounded {\n  border-radius: 4px;\n}\n.v-navigation-drawer--top {\n  top: 0;\n  border-bottom-width: thin;\n}\n.v-navigation-drawer--bottom {\n  left: 0;\n  border-top-width: thin;\n}\n.v-navigation-drawer--left {\n  top: 0;\n  left: 0;\n  right: auto;\n  border-right-width: thin;\n}\n.v-navigation-drawer--right {\n  top: 0;\n  left: auto;\n  right: 0;\n  border-left-width: thin;\n}\n.v-navigation-drawer--floating {\n  border: none;\n}\n.v-navigation-drawer--temporary.v-navigation-drawer--active {\n  box-shadow:\n    0px 8px 10px -5px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 16px 24px 2px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 6px 30px 5px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-navigation-drawer--sticky {\n  height: auto;\n  transition:\n    box-shadow,\n    transform,\n    visibility,\n    width,\n    height,\n    left,\n    right;\n}\n.v-navigation-drawer .v-list {\n  overflow: hidden;\n}\n.v-navigation-drawer__content {\n  flex: 0 1 auto;\n  height: 100%;\n  max-width: 100%;\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n.v-navigation-drawer__img {\n  height: 100%;\n  left: 0;\n  position: absolute;\n  top: 0;\n  width: 100%;\n  z-index: -1;\n}\n.v-navigation-drawer__img img:not(.v-img__img) {\n  height: inherit;\n  object-fit: cover;\n  width: inherit;\n}\n.v-navigation-drawer__scrim {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: black;\n  opacity: 0.2;\n  transition: opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n  z-index: 1;\n}\n.v-navigation-drawer__prepend,\n.v-navigation-drawer__append {\n  flex: none;\n  overflow: hidden;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VNumberInput/VNumberInput.css */\n.v-number-input input[type=number] {\n  -moz-appearance: textfield;\n}\n.v-number-input input[type=number]::-webkit-outer-spin-button,\n.v-number-input input[type=number]::-webkit-inner-spin-button {\n  -webkit-appearance: none;\n}\n.v-number-input .v-field:has(.v-field__prepend-inner > .v-number-input__control:first-child) {\n  padding-inline-start: 0;\n}\n.v-number-input .v-field:has(.v-field__append-inner > .v-number-input__control:last-child) {\n  padding-inline-end: 0;\n}\n.v-number-input .v-field__prepend-inner:has(.v-number-input__control) > .v-icon {\n  margin-inline-end: 4px;\n}\n.v-number-input .v-field__prepend-inner:has(.v-number-input__control) > hr + .v-icon,\n.v-number-input .v-field__prepend-inner:has(.v-number-input__control) > .v-number-input__control + .v-icon {\n  margin-inline: 8px 0;\n}\n.v-number-input .v-field__append-inner:has(.v-number-input__control) > .v-icon {\n  margin-inline-start: 4px;\n}\n.v-number-input .v-field__append-inner:has(.v-number-input__control) > .v-icon:has(+ hr),\n.v-number-input .v-field__append-inner:has(.v-number-input__control) > .v-icon:has(+ .v-number-input__control) {\n  margin-inline: 0 8px;\n}\n.v-number-input .v-field__clearable:has(+ .v-field__append-inner > hr:first-child) {\n  margin-inline-end: 8px;\n}\n.v-number-input--inset .v-divider {\n  height: 55%;\n  width: 55%;\n  align-self: center;\n}\n.v-number-input--split .v-field__input {\n  text-align: center;\n}\n.v-number-input--stacked .v-number-input__control {\n  flex-direction: column-reverse;\n}\n.v-number-input--stacked .v-number-input__control .v-btn {\n  flex: 1;\n}\n.v-number-input--hide-input .v-field {\n  flex: none;\n}\n.v-number-input--hide-input .v-field__input {\n  width: 0;\n  padding-inline: 0;\n}\n.v-number-input__control {\n  display: flex;\n  height: 100%;\n}\n.v-number-input__control .v-btn {\n  background-color: transparent;\n  border-radius: 0;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VOtpInput/VOtpInput.css */\n.v-otp-input {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n  padding: 0.5rem 0;\n  position: relative;\n}\n.v-otp-input {\n  border-radius: 4px;\n}\n.v-otp-input .v-field {\n  height: 100%;\n}\n.v-otp-input__divider {\n  margin: 0 8px;\n}\n.v-otp-input__content {\n  align-items: center;\n  display: flex;\n  gap: 0.5rem;\n  height: 64px;\n  padding: 0.5rem;\n  justify-content: center;\n  max-width: 320px;\n  position: relative;\n  border-radius: inherit;\n}\n.v-otp-input--divided .v-otp-input__content {\n  max-width: 360px;\n}\n.v-otp-input__field {\n  color: inherit;\n  font-size: 1.25rem;\n  height: 100%;\n  outline: none;\n  text-align: center;\n  width: 100%;\n}\n.v-otp-input__field[type=number]::-webkit-outer-spin-button,\n.v-otp-input__field[type=number]::-webkit-inner-spin-button {\n  -webkit-appearance: none;\n  margin: 0;\n}\n.v-otp-input__field[type=number] {\n  -moz-appearance: textfield;\n}\n.v-otp-input__loader {\n  align-items: center;\n  display: flex;\n  height: 100%;\n  justify-content: center;\n  width: 100%;\n}\n.v-otp-input__loader .v-progress-linear {\n  position: absolute;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VParallax/VParallax.css */\n.v-parallax {\n  position: relative;\n  overflow: hidden;\n}\n.v-parallax--active > .v-img__img {\n  will-change: transform;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VRadioGroup/VRadioGroup.css */\n.v-radio-group > .v-input__control {\n  flex-direction: column;\n}\n.v-radio-group > .v-input__control > .v-label {\n  margin-inline-start: 16px;\n}\n.v-radio-group > .v-input__control > .v-label + .v-selection-control-group {\n  padding-inline-start: 6px;\n  margin-top: 8px;\n}\n.v-radio-group .v-input__details {\n  padding-inline: 16px;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VRating/VRating.css */\n.v-rating {\n  max-width: 100%;\n  display: inline-flex;\n  white-space: nowrap;\n}\n.v-rating--readonly {\n  pointer-events: none;\n}\n.v-rating__wrapper {\n  align-items: center;\n  display: inline-flex;\n  flex-direction: column;\n}\n.v-rating__wrapper--bottom {\n  flex-direction: column-reverse;\n}\n.v-rating__item {\n  display: inline-flex;\n  position: relative;\n}\n.v-rating__item label {\n  cursor: pointer;\n}\n.v-rating__item .v-btn--variant-plain {\n  opacity: 1;\n}\n.v-rating__item .v-btn {\n  transition-property: transform;\n}\n.v-rating__item .v-btn .v-icon {\n  transition: inherit;\n  transition-timing-function: cubic-bezier(0, 0, 0.2, 1);\n}\n.v-rating--hover .v-rating__item:hover:not(.v-rating__item--focused) .v-btn {\n  transform: scale(1.25);\n}\n.v-rating__item--half {\n  overflow: hidden;\n  position: absolute;\n  clip-path: polygon(0 0, 50% 0, 50% 100%, 0 100%);\n  z-index: 1;\n}\n.v-rating__item--half .v-btn__overlay,\n.v-rating__item--half:hover .v-btn__overlay {\n  opacity: 0;\n}\n.v-rating__hidden {\n  height: 0;\n  opacity: 0;\n  position: absolute;\n  width: 0;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VSkeletonLoader/VSkeletonLoader.css */\n.v-skeleton-loader {\n  align-items: center;\n  background: rgb(var(--v-theme-surface));\n  border-radius: 4px;\n  display: flex;\n  flex-wrap: wrap;\n  position: relative;\n  vertical-align: top;\n}\n.v-skeleton-loader__actions {\n  justify-content: end;\n}\n.v-skeleton-loader .v-skeleton-loader__ossein {\n  height: 100%;\n}\n.v-skeleton-loader .v-skeleton-loader__avatar,\n.v-skeleton-loader .v-skeleton-loader__button,\n.v-skeleton-loader .v-skeleton-loader__chip,\n.v-skeleton-loader .v-skeleton-loader__divider,\n.v-skeleton-loader .v-skeleton-loader__heading,\n.v-skeleton-loader .v-skeleton-loader__image,\n.v-skeleton-loader .v-skeleton-loader__ossein,\n.v-skeleton-loader .v-skeleton-loader__text {\n  background: rgba(var(--v-theme-on-surface), var(--v-border-opacity));\n}\n.v-skeleton-loader .v-skeleton-loader__list-item,\n.v-skeleton-loader .v-skeleton-loader__list-item-avatar,\n.v-skeleton-loader .v-skeleton-loader__list-item-text,\n.v-skeleton-loader .v-skeleton-loader__list-item-two-line,\n.v-skeleton-loader .v-skeleton-loader__list-item-avatar-two-line,\n.v-skeleton-loader .v-skeleton-loader__list-item-three-line,\n.v-skeleton-loader .v-skeleton-loader__list-item-avatar-three-line {\n  border-radius: 4px;\n}\n.v-skeleton-loader__bone {\n  align-items: center;\n  border-radius: inherit;\n  display: flex;\n  flex: 1 1 100%;\n  flex-wrap: wrap;\n  overflow: hidden;\n  position: relative;\n}\n.v-skeleton-loader__bone::after {\n  animation: loading 1.5s infinite;\n  background: linear-gradient(90deg, rgba(var(--v-theme-surface), 0), rgba(var(--v-theme-surface), 0.3), rgba(var(--v-theme-surface), 0));\n  transform: translateX(-100%);\n  z-index: 1;\n}\n.v-skeleton-loader__bone::after {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n.v-skeleton-loader__avatar {\n  border-radius: 50%;\n  flex: 0 1 auto;\n  margin: 8px 16px;\n  max-height: 48px;\n  min-height: 48px;\n  height: 48px;\n  max-width: 48px;\n  min-width: 48px;\n  width: 48px;\n}\n.v-skeleton-loader__avatar + .v-skeleton-loader__bone {\n  flex: 1 1 auto;\n  margin-inline-start: 0;\n}\n.v-skeleton-loader__avatar + .v-skeleton-loader__sentences > .v-skeleton-loader__text,\n.v-skeleton-loader__avatar + .v-skeleton-loader__paragraph > .v-skeleton-loader__text {\n  margin-inline-start: 0;\n}\n.v-skeleton-loader__button {\n  border-radius: 4px;\n  height: 36px;\n  margin: 16px;\n  max-width: 64px;\n}\n.v-skeleton-loader__button + .v-skeleton-loader__bone {\n  flex: 1 1 auto;\n  margin-inline-start: 0;\n}\n.v-skeleton-loader__button + .v-skeleton-loader__sentences > .v-skeleton-loader__text,\n.v-skeleton-loader__button + .v-skeleton-loader__paragraph > .v-skeleton-loader__text {\n  margin-inline-start: 0;\n}\n.v-skeleton-loader__chip {\n  border-radius: 16px;\n  margin: 16px;\n  height: 32px;\n  max-width: 96px;\n}\n.v-skeleton-loader__chip + .v-skeleton-loader__bone {\n  flex: 1 1 auto;\n  margin-inline-start: 0;\n}\n.v-skeleton-loader__chip + .v-skeleton-loader__sentences > .v-skeleton-loader__text,\n.v-skeleton-loader__chip + .v-skeleton-loader__paragraph > .v-skeleton-loader__text {\n  margin-inline-start: 0;\n}\n.v-skeleton-loader__date-picker {\n  border-radius: inherit;\n}\n.v-skeleton-loader__date-picker .v-skeleton-loader__list-item:first-child .v-skeleton-loader__text {\n  max-width: 88px;\n  width: 20%;\n}\n.v-skeleton-loader__date-picker .v-skeleton-loader__heading {\n  max-width: 256px;\n  width: 40%;\n}\n.v-skeleton-loader__date-picker-days {\n  flex-wrap: wrap;\n  margin: 16px;\n}\n.v-skeleton-loader__date-picker-days .v-skeleton-loader__avatar {\n  border-radius: 4px;\n  margin: 4px;\n  max-width: 100%;\n}\n.v-skeleton-loader__date-picker-options {\n  flex-wrap: nowrap;\n}\n.v-skeleton-loader__date-picker-options .v-skeleton-loader__text {\n  flex: 1 1 auto;\n}\n.v-skeleton-loader__divider {\n  border-radius: 1px;\n  height: 2px;\n}\n.v-skeleton-loader__heading {\n  border-radius: 12px;\n  margin: 16px;\n  height: 24px;\n}\n.v-skeleton-loader__heading + .v-skeleton-loader__subtitle {\n  margin-top: -16px;\n}\n.v-skeleton-loader__image {\n  height: 150px;\n  border-radius: 0;\n}\n.v-skeleton-loader__card .v-skeleton-loader__image {\n  border-radius: 0;\n}\n.v-skeleton-loader__list-item {\n  margin: 16px;\n}\n.v-skeleton-loader__list-item .v-skeleton-loader__text {\n  margin: 0;\n}\n.v-skeleton-loader__table-thead {\n  justify-content: space-between;\n}\n.v-skeleton-loader__table-thead .v-skeleton-loader__heading {\n  margin-top: 16px;\n  max-width: 16px;\n}\n.v-skeleton-loader__table-tfoot {\n  flex-wrap: nowrap;\n}\n.v-skeleton-loader__table-tfoot > .v-skeleton-loader__text.v-skeleton-loader__bone {\n  margin-top: 16px;\n}\n.v-skeleton-loader__table-row {\n  align-items: baseline;\n  margin: 0 8px;\n  justify-content: space-evenly;\n  flex-wrap: nowrap;\n}\n.v-skeleton-loader__table-row > .v-skeleton-loader__text.v-skeleton-loader__bone {\n  margin-inline: 8px;\n}\n.v-skeleton-loader__table-row + .v-skeleton-loader__divider {\n  margin: 0 16px;\n}\n.v-skeleton-loader__table-cell {\n  align-items: center;\n  display: flex;\n  height: 48px;\n  width: 88px;\n}\n.v-skeleton-loader__table-cell .v-skeleton-loader__text {\n  margin-bottom: 0;\n}\n.v-skeleton-loader__subtitle {\n  max-width: 70%;\n}\n.v-skeleton-loader__subtitle > .v-skeleton-loader__text {\n  height: 16px;\n  border-radius: 8px;\n}\n.v-skeleton-loader__text {\n  border-radius: 6px;\n  margin: 16px;\n  height: 12px;\n}\n.v-skeleton-loader__text + .v-skeleton-loader__text {\n  margin-top: -8px;\n  max-width: 50%;\n}\n.v-skeleton-loader__text + .v-skeleton-loader__text + .v-skeleton-loader__text {\n  max-width: 70%;\n}\n.v-skeleton-loader--boilerplate .v-skeleton-loader__bone:after {\n  display: none;\n}\n.v-skeleton-loader--is-loading {\n  overflow: hidden;\n}\n.v-skeleton-loader--tile {\n  border-radius: 0;\n}\n.v-skeleton-loader--tile .v-skeleton-loader__bone {\n  border-radius: 0;\n}\n@keyframes loading {\n  100% {\n    transform: translateX(100%);\n  }\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VSnackbar/VSnackbar.css */\n.v-snackbar {\n  justify-content: center;\n  z-index: 10000;\n  margin: 8px;\n  margin-inline-end: calc(8px + var(--v-scrollbar-offset));\n  padding: var(--v-layout-top) var(--v-layout-right) var(--v-layout-bottom) var(--v-layout-left);\n}\n.v-snackbar:not(.v-snackbar--center):not(.v-snackbar--top) {\n  align-items: flex-end;\n}\n.v-snackbar__wrapper {\n  align-items: center;\n  display: flex;\n  max-width: 672px;\n  min-height: 48px;\n  min-width: 344px;\n  overflow: hidden;\n  padding: 0;\n}\n.v-snackbar__wrapper {\n  border-radius: 4px;\n}\n.v-snackbar--variant-plain,\n.v-snackbar--variant-outlined,\n.v-snackbar--variant-text,\n.v-snackbar--variant-tonal {\n  background: transparent;\n  color: inherit;\n}\n.v-snackbar--variant-plain {\n  opacity: 0.62;\n}\n.v-snackbar--variant-plain:focus,\n.v-snackbar--variant-plain:hover {\n  opacity: 1;\n}\n.v-snackbar--variant-plain .v-snackbar__overlay {\n  display: none;\n}\n.v-snackbar--variant-elevated,\n.v-snackbar--variant-flat {\n  background: rgb(var(--v-theme-surface-variant));\n  color: rgb(var(--v-theme-on-surface-variant));\n}\n.v-snackbar--variant-elevated {\n  box-shadow:\n    0px 3px 5px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 6px 10px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 18px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-snackbar--variant-flat {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-snackbar--variant-outlined {\n  border: thin solid currentColor;\n}\n.v-snackbar--variant-text .v-snackbar__overlay {\n  background: currentColor;\n}\n.v-snackbar--variant-tonal .v-snackbar__underlay {\n  background: currentColor;\n  opacity: var(--v-activated-opacity);\n  border-radius: inherit;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  pointer-events: none;\n}\n.v-snackbar .v-snackbar__underlay {\n  position: absolute;\n}\n.v-snackbar__content {\n  flex-grow: 1;\n  font-size: 0.875rem;\n  font-weight: 400;\n  letter-spacing: 0.0178571429em;\n  line-height: 1.425;\n  margin-right: auto;\n  padding: 14px 16px;\n  text-align: initial;\n}\n.v-snackbar__actions {\n  align-items: center;\n  align-self: center;\n  display: flex;\n  margin-inline-end: 8px;\n}\n.v-snackbar__actions > .v-btn {\n  padding: 0 8px;\n  min-width: auto;\n}\n.v-snackbar__timer {\n  width: 100%;\n  position: absolute;\n  top: 0;\n}\n.v-snackbar__timer .v-progress-linear {\n  transition: 0.2s linear;\n}\n.v-snackbar--absolute {\n  position: absolute;\n  z-index: 1;\n}\n.v-snackbar--multi-line .v-snackbar__wrapper {\n  min-height: 68px;\n}\n.v-snackbar--vertical .v-snackbar__wrapper {\n  flex-direction: column;\n}\n.v-snackbar--vertical .v-snackbar__wrapper .v-snackbar__actions {\n  align-self: flex-end;\n  margin-bottom: 8px;\n}\n.v-snackbar--center {\n  align-items: center;\n  justify-content: center;\n}\n.v-snackbar--top {\n  align-items: flex-start;\n}\n.v-snackbar--bottom {\n  align-items: flex-end;\n}\n.v-snackbar--left,\n.v-snackbar--start {\n  justify-content: flex-start;\n}\n.v-snackbar--right,\n.v-snackbar--end {\n  justify-content: flex-end;\n}\n.v-snackbar-transition-enter-active,\n.v-snackbar-transition-leave-active {\n  transition-duration: 0.15s;\n  transition-timing-function: cubic-bezier(0, 0, 0.2, 1);\n}\n.v-snackbar-transition-enter-active {\n  transition-property: opacity, transform;\n}\n.v-snackbar-transition-enter-from {\n  opacity: 0;\n  transform: scale(0.8);\n}\n.v-snackbar-transition-leave-active {\n  transition-property: opacity;\n}\n.v-snackbar-transition-leave-to {\n  opacity: 0;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VSpeedDial/VSpeedDial.css */\n.v-speed-dial__content {\n  gap: 8px;\n}\n.v-speed-dial__content.v-overlay__content.v-speed-dial__content--end,\n.v-speed-dial__content.v-overlay__content.v-speed-dial__content--end-center,\n.v-speed-dial__content.v-overlay__content.v-speed-dial__content--right,\n.v-speed-dial__content.v-overlay__content.v-speed-dial__content--right-center {\n  flex-direction: row;\n}\n.v-speed-dial__content.v-overlay__content.v-speed-dial__content--left,\n.v-speed-dial__content.v-overlay__content.v-speed-dial__content--left-center,\n.v-speed-dial__content.v-overlay__content.v-speed-dial__content--start,\n.v-speed-dial__content.v-overlay__content.v-speed-dial__content--start-center {\n  flex-direction: row-reverse;\n}\n.v-speed-dial__content.v-overlay__content.v-speed-dial__content--top,\n.v-speed-dial__content.v-overlay__content.v-speed-dial__content--top-center {\n  flex-direction: column-reverse;\n}\n.v-speed-dial__content > *:nth-child(1) {\n  transition-delay: 0.001s;\n}\n.v-speed-dial__content > *:nth-child(2) {\n  transition-delay: 0.05s;\n}\n.v-speed-dial__content > *:nth-child(3) {\n  transition-delay: 0.1s;\n}\n.v-speed-dial__content > *:nth-child(4) {\n  transition-delay: 0.15s;\n}\n.v-speed-dial__content > *:nth-child(5) {\n  transition-delay: 0.2s;\n}\n.v-speed-dial__content > *:nth-child(6) {\n  transition-delay: 0.25s;\n}\n.v-speed-dial__content > *:nth-child(7) {\n  transition-delay: 0.3s;\n}\n.v-speed-dial__content > *:nth-child(8) {\n  transition-delay: 0.35s;\n}\n.v-speed-dial__content > *:nth-child(9) {\n  transition-delay: 0.4s;\n}\n.v-speed-dial__content > *:nth-child(10) {\n  transition-delay: 0.45s;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VStepper/VStepper.css */\n.v-stepper.v-sheet {\n  overflow: hidden;\n}\n.v-stepper.v-sheet {\n  box-shadow:\n    0px 3px 1px -2px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 2px 2px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 5px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-stepper.v-sheet {\n  border-radius: 4px;\n}\n.v-stepper.v-sheet.v-stepper--flat {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-stepper-header {\n  align-items: center;\n  display: flex;\n  position: relative;\n  overflow-x: auto;\n  justify-content: space-between;\n  z-index: 1;\n}\n.v-stepper-header {\n  box-shadow:\n    0px 3px 1px -2px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 2px 2px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 5px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-stepper-header .v-divider {\n  margin: 0 -16px;\n}\n.v-stepper-header .v-divider:last-child {\n  margin-inline-end: 0;\n}\n.v-stepper-header .v-divider:first-child {\n  margin-inline-start: 0;\n}\n.v-stepper--alt-labels .v-stepper-header {\n  height: auto;\n}\n.v-stepper--alt-labels .v-stepper-header .v-divider {\n  align-self: flex-start;\n  margin: 35px -67px 0;\n}\n.v-stepper-window {\n  margin: 1.5rem;\n}\n.v-stepper-actions {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  padding: 1rem;\n}\n.v-stepper .v-stepper-actions {\n  padding: 0 1.5rem 1rem;\n}\n.v-stepper-window-item .v-stepper-actions {\n  padding: 1.5rem 0 0;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VStepper/VStepperItem.css */\n.v-stepper-item {\n  align-items: center;\n  align-self: stretch;\n  display: inline-flex;\n  flex: none;\n  outline: none;\n  opacity: var(--v-medium-emphasis-opacity);\n  padding: 1.5rem;\n  position: relative;\n  transition-duration: 0.2s;\n  transition-property: opacity;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-stepper-item:hover > .v-stepper-item__overlay {\n  opacity: calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-stepper-item:focus-visible > .v-stepper-item__overlay {\n  opacity: calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier));\n}\n@supports not selector(:focus-visible) {\n  .v-stepper-item:focus > .v-stepper-item__overlay {\n    opacity: calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-stepper-item--active > .v-stepper-item__overlay,\n.v-stepper-item[aria-haspopup=menu][aria-expanded=true] > .v-stepper-item__overlay {\n  opacity: calc(var(--v-activated-opacity) * var(--v-theme-overlay-multiplier));\n}\n.v-stepper-item--active:hover > .v-stepper-item__overlay,\n.v-stepper-item[aria-haspopup=menu][aria-expanded=true]:hover > .v-stepper-item__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier));\n}\n.v-stepper-item--active:focus-visible > .v-stepper-item__overlay,\n.v-stepper-item[aria-haspopup=menu][aria-expanded=true]:focus-visible > .v-stepper-item__overlay {\n  opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n}\n@supports not selector(:focus-visible) {\n  .v-stepper-item--active:focus > .v-stepper-item__overlay,\n  .v-stepper-item[aria-haspopup=menu][aria-expanded=true]:focus > .v-stepper-item__overlay {\n    opacity: calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier));\n  }\n}\n.v-stepper--non-linear .v-stepper-item {\n  opacity: var(--v-high-emphasis-opacity);\n}\n.v-stepper-item--selected {\n  opacity: 1;\n}\n.v-stepper-item--error {\n  color: rgb(var(--v-theme-error));\n}\n.v-stepper-item--disabled {\n  opacity: var(--v-medium-emphasis-opacity);\n  pointer-events: none;\n}\n.v-stepper--alt-labels .v-stepper-item {\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: center;\n  flex-basis: 175px;\n}\n.v-stepper-item__avatar.v-avatar {\n  background: rgba(var(--v-theme-surface-variant), var(--v-medium-emphasis-opacity));\n  color: rgb(var(--v-theme-on-surface-variant));\n  font-size: 0.75rem;\n  margin-inline-end: 8px;\n}\n.v-stepper--mobile .v-stepper-item__avatar.v-avatar {\n  margin-inline-end: 0;\n}\n.v-stepper-item__avatar.v-avatar .v-icon {\n  font-size: 0.875rem;\n}\n.v-stepper-item--selected .v-stepper-item__avatar.v-avatar,\n.v-stepper-item--complete .v-stepper-item__avatar.v-avatar {\n  background: rgb(var(--v-theme-surface-variant));\n}\n.v-stepper-item--error .v-stepper-item__avatar.v-avatar {\n  background: rgb(var(--v-theme-error));\n}\n.v-stepper--alt-labels .v-stepper-item__avatar.v-avatar {\n  margin-bottom: 16px;\n  margin-inline-end: 0;\n}\n.v-stepper-item__title {\n  line-height: 1;\n}\n.v-stepper--mobile .v-stepper-item__title {\n  display: none;\n}\n.v-stepper-item__subtitle {\n  font-size: 0.75rem;\n  text-align: left;\n  line-height: 1;\n  opacity: var(--v-medium-emphasis-opacity);\n}\n.v-stepper--alt-labels .v-stepper-item__subtitle {\n  text-align: center;\n}\n.v-stepper--mobile .v-stepper-item__subtitle {\n  display: none;\n}\n.v-stepper-item__overlay {\n  background-color: currentColor;\n  border-radius: inherit;\n  opacity: 0;\n  transition: opacity 0.2s ease-in-out;\n}\n.v-stepper-item__overlay,\n.v-stepper-item__underlay {\n  pointer-events: none;\n}\n.v-stepper-item__overlay,\n.v-stepper-item__underlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VSwitch/VSwitch.css */\n.v-switch .v-label {\n  padding-inline-start: 10px;\n}\n.v-switch__loader {\n  display: flex;\n}\n.v-switch__loader .v-progress-circular {\n  color: rgb(var(--v-theme-surface));\n}\n.v-switch__track,\n.v-switch__thumb {\n  transition: none;\n}\n.v-selection-control--error:not(.v-selection-control--disabled) .v-switch__track,\n.v-selection-control--error:not(.v-selection-control--disabled) .v-switch__thumb {\n  background-color: rgb(var(--v-theme-error));\n  color: rgb(var(--v-theme-on-error));\n}\n.v-switch__track-true {\n  margin-inline-end: auto;\n}\n.v-selection-control:not(.v-selection-control--dirty) .v-switch__track-true {\n  opacity: 0;\n}\n.v-switch__track-false {\n  margin-inline-start: auto;\n}\n.v-selection-control--dirty .v-switch__track-false {\n  opacity: 0;\n}\n.v-switch__track {\n  display: inline-flex;\n  align-items: center;\n  font-size: 0.5rem;\n  padding: 0 5px;\n  background-color: rgb(var(--v-theme-surface-variant));\n  border-radius: 9999px;\n  height: 14px;\n  opacity: 0.6;\n  min-width: 36px;\n  cursor: pointer;\n  transition: 0.2s background-color cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-switch--inset .v-switch__track {\n  border-radius: 9999px;\n  font-size: 0.75rem;\n  height: 32px;\n  min-width: 52px;\n}\n.v-switch__thumb {\n  align-items: center;\n  background-color: rgb(var(--v-theme-surface-bright));\n  color: rgb(var(--v-theme-on-surface-bright));\n  border-radius: 50%;\n  display: flex;\n  font-size: 0.75rem;\n  height: 20px;\n  justify-content: center;\n  width: 20px;\n  pointer-events: none;\n  transition:\n    0.15s 0.05s transform cubic-bezier(0, 0, 0.2, 1),\n    0.2s color cubic-bezier(0.4, 0, 0.2, 1),\n    0.2s background-color cubic-bezier(0.4, 0, 0.2, 1);\n  position: relative;\n  overflow: hidden;\n}\n.v-switch:not(.v-switch--inset) .v-switch__thumb {\n  box-shadow:\n    0px 2px 4px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 4px 5px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 1px 10px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-switch.v-switch--flat:not(.v-switch--inset) .v-switch__thumb {\n  background: rgb(var(--v-theme-surface-variant));\n  color: rgb(var(--v-theme-on-surface-variant));\n}\n.v-switch.v-switch--flat:not(.v-switch--inset) .v-switch__thumb {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-switch--inset .v-switch__thumb {\n  height: 24px;\n  width: 24px;\n  transform: scale(0.6666666667);\n}\n.v-switch--inset .v-switch__thumb--filled {\n  transform: none;\n}\n.v-switch--inset .v-selection-control--dirty .v-switch__thumb {\n  transform: none;\n  transition: 0.15s 0.05s transform cubic-bezier(0, 0, 0.2, 1);\n}\n.v-switch.v-input {\n  flex: 0 1 auto;\n}\n.v-switch .v-selection-control {\n  min-height: var(--v-input-control-height);\n}\n.v-switch .v-selection-control__input {\n  border-radius: 50%;\n  transition: 0.2s transform cubic-bezier(0.4, 0, 0.2, 1);\n  position: absolute;\n}\n.v-locale--is-ltr.v-switch .v-selection-control__input,\n.v-locale--is-ltr .v-switch .v-selection-control__input {\n  transform: translateX(-10px);\n}\n.v-locale--is-rtl.v-switch .v-selection-control__input,\n.v-locale--is-rtl .v-switch .v-selection-control__input {\n  transform: translateX(10px);\n}\n.v-switch .v-selection-control__input .v-icon {\n  position: absolute;\n}\n.v-locale--is-ltr.v-switch .v-selection-control--dirty .v-selection-control__input,\n.v-locale--is-ltr .v-switch .v-selection-control--dirty .v-selection-control__input {\n  transform: translateX(10px);\n}\n.v-locale--is-rtl.v-switch .v-selection-control--dirty .v-selection-control__input,\n.v-locale--is-rtl .v-switch .v-selection-control--dirty .v-selection-control__input {\n  transform: translateX(-10px);\n}\n.v-switch.v-switch--indeterminate .v-selection-control__input {\n  transform: scale(0.8);\n}\n.v-switch.v-switch--indeterminate .v-switch__thumb {\n  transform: scale(0.75);\n  box-shadow: none;\n}\n.v-switch.v-switch--inset .v-selection-control__wrapper {\n  width: auto;\n}\n.v-switch.v-input--vertical .v-label {\n  min-width: max-content;\n}\n.v-switch.v-input--vertical .v-selection-control__wrapper {\n  transform: rotate(-90deg);\n}\n@media (forced-colors: active) {\n  .v-switch .v-switch__loader .v-progress-circular {\n    color: currentColor;\n  }\n  .v-switch .v-switch__thumb {\n    background-color: buttontext;\n  }\n  .v-switch .v-switch__track,\n  .v-switch .v-switch__thumb {\n    border: 1px solid;\n    color: buttontext;\n  }\n  .v-switch:not(.v-switch--loading):not(.v-input--disabled) .v-selection-control--dirty .v-switch__thumb {\n    background-color: highlight;\n  }\n  .v-switch:not(.v-input--disabled) .v-selection-control--dirty .v-switch__track {\n    background-color: highlight;\n  }\n  .v-switch:not(.v-input--disabled) .v-selection-control--dirty .v-switch__track,\n  .v-switch:not(.v-input--disabled) .v-selection-control--dirty .v-switch__thumb {\n    color: highlight;\n  }\n  .v-switch.v-switch--inset .v-switch__track {\n    border-width: 2px;\n  }\n  .v-switch.v-switch--inset:not(.v-switch--loading):not(.v-input--disabled) .v-selection-control--dirty .v-switch__thumb {\n    background-color: highlighttext;\n    color: highlighttext;\n  }\n  .v-switch.v-input--disabled .v-switch__thumb {\n    background-color: graytext;\n  }\n  .v-switch.v-input--disabled .v-switch__track,\n  .v-switch.v-input--disabled .v-switch__thumb {\n    color: graytext;\n  }\n  .v-switch.v-switch--loading .v-switch__thumb {\n    background-color: canvas;\n  }\n  .v-switch.v-switch--loading.v-switch--inset .v-switch__thumb,\n  .v-switch.v-switch--loading.v-switch--indeterminate .v-switch__thumb {\n    border-width: 0;\n  }\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VSystemBar/VSystemBar.css */\n.v-system-bar {\n  align-items: center;\n  display: flex;\n  flex: 1 1 auto;\n  height: 24px;\n  justify-content: flex-end;\n  max-width: 100%;\n  padding-inline: 8px;\n  position: relative;\n  text-align: end;\n  width: 100%;\n}\n.v-system-bar .v-icon {\n  opacity: var(--v-medium-emphasis-opacity);\n}\n.v-system-bar {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-system-bar--absolute {\n  position: absolute;\n}\n.v-system-bar--fixed {\n  position: fixed;\n}\n.v-system-bar {\n  background: rgba(var(--v-theme-surface-light));\n  color: rgba(var(--v-theme-on-surface-light), var(--v-high-emphasis-opacity));\n}\n.v-system-bar {\n  font-size: 0.75rem;\n  font-weight: 400;\n  letter-spacing: 0.0333333333em;\n  line-height: 1.667;\n  text-transform: none;\n}\n.v-system-bar--rounded {\n  border-radius: 0;\n}\n.v-system-bar--window {\n  height: 32px;\n}\n.v-system-bar:not(.v-system-bar--absolute) {\n  padding-inline-end: calc(var(--v-scrollbar-offset) + 8px);\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VTabs/VTab.css */\n.v-tab.v-tab.v-btn {\n  height: var(--v-tabs-height);\n  border-radius: 0;\n  min-width: 90px;\n}\n.v-slide-group--horizontal .v-tab {\n  max-width: 360px;\n}\n.v-slide-group--vertical .v-tab {\n  justify-content: start;\n}\n.v-tab__slider {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  height: 2px;\n  width: 100%;\n  background: currentColor;\n  pointer-events: none;\n  opacity: 0;\n}\n.v-tab--selected .v-tab__slider {\n  opacity: 1;\n}\n.v-slide-group--vertical .v-tab__slider {\n  top: 0;\n  height: 100%;\n  width: 2px;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VTabs/VTabs.css */\n.v-tabs {\n  display: flex;\n  height: var(--v-tabs-height);\n}\n.v-tabs--density-default {\n  --v-tabs-height: 48px;\n}\n.v-tabs--density-default.v-tabs--stacked {\n  --v-tabs-height: 72px;\n}\n.v-tabs--density-comfortable {\n  --v-tabs-height: 44px;\n}\n.v-tabs--density-comfortable.v-tabs--stacked {\n  --v-tabs-height: 68px;\n}\n.v-tabs--density-compact {\n  --v-tabs-height: 36px;\n}\n.v-tabs--density-compact.v-tabs--stacked {\n  --v-tabs-height: 60px;\n}\n.v-tabs.v-slide-group--vertical {\n  height: auto;\n  flex: none;\n  --v-tabs-height: 48px;\n}\n.v-tabs--align-tabs-title:not(.v-slide-group--has-affixes) .v-tab:first-child {\n  margin-inline-start: 42px;\n}\n.v-tabs--fixed-tabs .v-slide-group__content > *:last-child,\n.v-tabs--align-tabs-center .v-slide-group__content > *:last-child {\n  margin-inline-end: auto;\n}\n.v-tabs--fixed-tabs .v-slide-group__content > *:first-child,\n.v-tabs--align-tabs-center .v-slide-group__content > *:first-child {\n  margin-inline-start: auto;\n}\n.v-tabs--grow {\n  flex-grow: 1;\n}\n.v-tabs--grow .v-tab {\n  flex: 1 0 auto;\n  max-width: none;\n}\n.v-tabs--align-tabs-end .v-tab:first-child {\n  margin-inline-start: auto;\n}\n.v-tabs--align-tabs-end .v-tab:last-child {\n  margin-inline-end: 0;\n}\n@media (max-width: 1279.98px) {\n  .v-tabs.v-slide-group--is-overflowing.v-slide-group--horizontal:not(.v-slide-group--has-affixes) .v-tab:first-child {\n    margin-inline-start: 52px;\n  }\n  .v-tabs.v-slide-group--is-overflowing.v-slide-group--horizontal:not(.v-slide-group--has-affixes) .v-tab:last-child {\n    margin-inline-end: 52px;\n  }\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VTextarea/VTextarea.css */\n.v-textarea .v-field {\n  --v-textarea-control-height: var(--v-input-control-height);\n}\n.v-textarea .v-field__field {\n  --v-input-control-height: var(--v-textarea-control-height);\n}\n.v-textarea .v-field__input {\n  flex: 1 1 auto;\n  outline: none;\n  -webkit-mask-image: linear-gradient(to bottom, transparent, transparent calc(var(--v-field-padding-top, 0) + var(--v-input-padding-top, 0) - 6px), black calc(var(--v-field-padding-top, 0) + var(--v-input-padding-top, 0) + 4px));\n  mask-image: linear-gradient(to bottom, transparent, transparent calc(var(--v-field-padding-top, 0) + var(--v-input-padding-top, 0) - 6px), black calc(var(--v-field-padding-top, 0) + var(--v-input-padding-top, 0) + 4px));\n}\n.v-textarea .v-field__input.v-textarea__sizer {\n  visibility: hidden;\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 0 !important;\n  min-height: 0 !important;\n  pointer-events: none;\n}\n.v-textarea--no-resize .v-field__input {\n  resize: none;\n}\n.v-textarea .v-field--no-label textarea,\n.v-textarea .v-field--active textarea {\n  opacity: 1;\n}\n.v-textarea textarea {\n  opacity: 0;\n  flex: 1;\n  min-width: 0;\n  height: 100%;\n  transition: 0.15s opacity cubic-bezier(0.4, 0, 0.2, 1);\n}\n.v-textarea textarea:focus,\n.v-textarea textarea:active {\n  outline: none;\n}\n.v-textarea textarea:invalid {\n  box-shadow: none;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VThemeProvider/VThemeProvider.css */\n.v-theme-provider {\n  background: rgb(var(--v-theme-background));\n  color: rgb(var(--v-theme-on-background));\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VTimeline/VTimeline.css */\n.v-timeline .v-timeline-divider__dot {\n  background: rgb(var(--v-theme-surface-light));\n}\n.v-timeline .v-timeline-divider__inner-dot {\n  background: rgb(var(--v-theme-on-surface));\n}\n.v-timeline {\n  display: grid;\n  grid-auto-flow: dense;\n  position: relative;\n}\n.v-timeline--horizontal.v-timeline {\n  grid-column-gap: 24px;\n  width: 100%;\n}\n.v-timeline--horizontal.v-timeline .v-timeline--side-end > .v-timeline-item .v-timeline-item__body,\n.v-timeline--horizontal.v-timeline:not(.v-timeline--side-start) > .v-timeline-item--side-end .v-timeline-item__body,\n.v-timeline--horizontal.v-timeline:not(.v-timeline--side-start) > .v-timeline-item:nth-child(2n+1):not(.v-timeline-item--side-start) .v-timeline-item__body {\n  grid-row: 3;\n  align-self: flex-start;\n  padding-block-start: 24px;\n}\n.v-timeline--horizontal.v-timeline .v-timeline--side-end > .v-timeline-item .v-timeline-item__opposite,\n.v-timeline--horizontal.v-timeline:not(.v-timeline--side-start) > .v-timeline-item--side-end .v-timeline-item__opposite,\n.v-timeline--horizontal.v-timeline:not(.v-timeline--side-start) > .v-timeline-item:nth-child(2n+1):not(.v-timeline-item--side-start) .v-timeline-item__opposite {\n  grid-row: 1;\n  align-self: flex-end;\n  padding-block-end: 24px;\n}\n.v-timeline--horizontal.v-timeline .v-timeline--side-start > .v-timeline-item .v-timeline-item__body,\n.v-timeline--horizontal.v-timeline:not(.v-timeline--side-end) > .v-timeline-item--side-start .v-timeline-item__body,\n.v-timeline--horizontal.v-timeline:not(.v-timeline--side-end) > .v-timeline-item:nth-child(2n):not(.v-timeline-item--side-end) .v-timeline-item__body {\n  grid-row: 1;\n  align-self: flex-end;\n  padding-block-end: 24px;\n}\n.v-timeline--horizontal.v-timeline .v-timeline--side-start > .v-timeline-item .v-timeline-item__opposite,\n.v-timeline--horizontal.v-timeline:not(.v-timeline--side-end) > .v-timeline-item--side-start .v-timeline-item__opposite,\n.v-timeline--horizontal.v-timeline:not(.v-timeline--side-end) > .v-timeline-item:nth-child(2n):not(.v-timeline-item--side-end) .v-timeline-item__opposite {\n  grid-row: 3;\n  align-self: flex-start;\n  padding-block-start: 24px;\n}\n.v-timeline--vertical.v-timeline {\n  row-gap: 24px;\n  height: 100%;\n}\n.v-timeline--vertical.v-timeline .v-timeline-item:first-child .v-timeline-divider,\n.v-timeline--vertical.v-timeline .v-timeline-item:first-child .v-timeline-item__body,\n.v-timeline--vertical.v-timeline .v-timeline-item:first-child .v-timeline-item__opposite {\n  padding-block-start: 24px;\n}\n.v-timeline--vertical.v-timeline .v-timeline-item:last-child .v-timeline-divider,\n.v-timeline--vertical.v-timeline .v-timeline-item:last-child .v-timeline-item__body,\n.v-timeline--vertical.v-timeline .v-timeline-item:last-child .v-timeline-item__opposite {\n  padding-block-end: 24px;\n}\n.v-timeline--vertical.v-timeline .v-timeline--side-start > .v-timeline-item .v-timeline-item__body,\n.v-timeline--vertical.v-timeline:not(.v-timeline--side-end) > .v-timeline-item--side-start .v-timeline-item__body,\n.v-timeline--vertical.v-timeline:not(.v-timeline--side-end) > .v-timeline-item:nth-child(2n):not(.v-timeline-item--side-end) .v-timeline-item__body {\n  grid-column: 1;\n  justify-self: flex-end;\n  padding-inline-end: 24px;\n}\n.v-timeline--vertical.v-timeline .v-timeline--side-start > .v-timeline-item .v-timeline-item__opposite,\n.v-timeline--vertical.v-timeline:not(.v-timeline--side-end) > .v-timeline-item--side-start .v-timeline-item__opposite,\n.v-timeline--vertical.v-timeline:not(.v-timeline--side-end) > .v-timeline-item:nth-child(2n):not(.v-timeline-item--side-end) .v-timeline-item__opposite {\n  grid-column: 3;\n  justify-self: flex-start;\n  padding-inline-start: 24px;\n}\n.v-timeline--vertical.v-timeline .v-timeline--side-end > .v-timeline-item .v-timeline-item__body,\n.v-timeline--vertical.v-timeline:not(.v-timeline--side-start) > .v-timeline-item--side-end .v-timeline-item__body,\n.v-timeline--vertical.v-timeline:not(.v-timeline--side-start) > .v-timeline-item:nth-child(2n+1):not(.v-timeline-item--side-start) .v-timeline-item__body {\n  grid-column: 3;\n  justify-self: flex-start;\n  padding-inline-start: 24px;\n}\n.v-timeline--vertical.v-timeline .v-timeline--side-end > .v-timeline-item .v-timeline-item__opposite,\n.v-timeline--vertical.v-timeline:not(.v-timeline--side-start) > .v-timeline-item--side-end .v-timeline-item__opposite,\n.v-timeline--vertical.v-timeline:not(.v-timeline--side-start) > .v-timeline-item:nth-child(2n+1):not(.v-timeline-item--side-start) .v-timeline-item__opposite {\n  grid-column: 1;\n  justify-self: flex-end;\n  padding-inline-end: 24px;\n}\n.v-timeline-item {\n  display: contents;\n}\n.v-timeline-divider {\n  position: relative;\n  display: flex;\n  align-items: center;\n}\n.v-timeline--horizontal .v-timeline-divider {\n  flex-direction: row;\n  grid-row: 2;\n  width: 100%;\n}\n.v-timeline--vertical .v-timeline-divider {\n  height: 100%;\n  flex-direction: column;\n  grid-column: 2;\n}\n.v-timeline-divider__before {\n  background: rgba(var(--v-border-color), var(--v-border-opacity));\n  position: absolute;\n}\n.v-timeline--horizontal .v-timeline-divider__before {\n  height: var(--v-timeline-line-thickness);\n  width: calc(var(--v-timeline-line-size-base) + 12px - var(--v-timeline-line-inset));\n  inset-inline-start: -12px;\n  inset-inline-end: initial;\n}\n.v-timeline--vertical .v-timeline-divider__before {\n  height: calc(var(--v-timeline-line-size-base) + 12px - var(--v-timeline-line-inset));\n  width: var(--v-timeline-line-thickness);\n  top: -12px;\n}\n.v-timeline-divider__after {\n  background: rgba(var(--v-border-color), var(--v-border-opacity));\n  position: absolute;\n}\n.v-timeline--horizontal .v-timeline-divider__after {\n  height: var(--v-timeline-line-thickness);\n  width: calc(var(--v-timeline-line-size-base) + 12px - var(--v-timeline-line-inset));\n  inset-inline-end: -12px;\n  inset-inline-start: initial;\n}\n.v-timeline--vertical .v-timeline-divider__after {\n  height: calc(var(--v-timeline-line-size-base) + 12px - var(--v-timeline-line-inset));\n  width: var(--v-timeline-line-thickness);\n  bottom: -12px;\n}\n.v-timeline--vertical .v-timeline-item:first-child .v-timeline-divider__before {\n  height: calc(var(--v-timeline-line-size-base) + 12px - var(--v-timeline-line-inset));\n  top: 0;\n}\n.v-timeline--horizontal .v-timeline-item:first-child .v-timeline-divider__before {\n  width: calc(var(--v-timeline-line-size-base) + 12px - var(--v-timeline-line-inset));\n  inset-inline-start: 0;\n  inset-inline-end: initial;\n}\n.v-timeline--vertical .v-timeline-item:first-child .v-timeline-divider__after {\n  height: calc(var(--v-timeline-line-size-base) - var(--v-timeline-line-inset) + var(--v-timeline-line-size-offset));\n}\n.v-timeline--horizontal .v-timeline-item:first-child .v-timeline-divider__after {\n  width: calc(var(--v-timeline-line-size-base) - var(--v-timeline-line-inset) + var(--v-timeline-line-size-offset));\n  inset-inline-end: -12px;\n  inset-inline-start: initial;\n}\n.v-timeline--vertical .v-timeline-item:last-child .v-timeline-divider__before {\n  height: calc(var(--v-timeline-line-size-base) - var(--v-timeline-line-inset) + var(--v-timeline-line-size-offset));\n}\n.v-timeline--horizontal .v-timeline-item:last-child .v-timeline-divider__before {\n  width: calc(var(--v-timeline-line-size-base) - var(--v-timeline-line-inset) + var(--v-timeline-line-size-offset));\n}\n.v-timeline--vertical .v-timeline-item:last-child .v-timeline-divider__after {\n  height: calc(var(--v-timeline-line-size-base) + 12px - var(--v-timeline-line-inset));\n  bottom: 0;\n}\n.v-timeline--horizontal .v-timeline-item:last-child .v-timeline-divider__after {\n  width: calc(var(--v-timeline-line-size-base) + 12px - var(--v-timeline-line-inset));\n  inset-inline-end: 0;\n  inset-inline-start: initial;\n}\n.v-timeline--vertical .v-timeline-item:only-child .v-timeline-divider__after {\n  height: calc(var(--v-timeline-line-size-base) - var(--v-timeline-line-inset));\n}\n.v-timeline-divider__dot {\n  z-index: 1;\n  flex-shrink: 0;\n  border-radius: 50%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.v-timeline-divider__dot {\n  box-shadow:\n    0px 0px 0px 0px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, 0.2)),\n    0px 0px 0px 0px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, 0.14)),\n    0px 0px 0px 0px var(--v-shadow-key-ambient-opacity, rgba(0, 0, 0, 0.12));\n}\n.v-timeline-divider__dot--size-x-small {\n  height: 22px;\n  width: 22px;\n}\n.v-timeline-divider__dot--size-x-small .v-timeline-divider__inner-dot {\n  height: calc(100% - 6px);\n  width: calc(100% - 6px);\n}\n.v-timeline-divider__dot--size-small {\n  height: 30px;\n  width: 30px;\n}\n.v-timeline-divider__dot--size-small .v-timeline-divider__inner-dot {\n  height: calc(100% - 8px);\n  width: calc(100% - 8px);\n}\n.v-timeline-divider__dot--size-default {\n  height: 38px;\n  width: 38px;\n}\n.v-timeline-divider__dot--size-default .v-timeline-divider__inner-dot {\n  height: calc(100% - 8px);\n  width: calc(100% - 8px);\n}\n.v-timeline-divider__dot--size-large {\n  height: 46px;\n  width: 46px;\n}\n.v-timeline-divider__dot--size-large .v-timeline-divider__inner-dot {\n  height: calc(100% - 8px);\n  width: calc(100% - 8px);\n}\n.v-timeline-divider__dot--size-x-large {\n  height: 54px;\n  width: 54px;\n}\n.v-timeline-divider__dot--size-x-large .v-timeline-divider__inner-dot {\n  height: calc(100% - 10px);\n  width: calc(100% - 10px);\n}\n.v-timeline-divider__inner-dot {\n  align-items: center;\n  border-radius: 50%;\n  display: flex;\n  justify-content: center;\n}\n.v-timeline--horizontal.v-timeline--justify-center {\n  grid-template-rows: minmax(auto, 50%) min-content minmax(auto, 50%);\n}\n.v-timeline--vertical.v-timeline--justify-center {\n  grid-template-columns: minmax(auto, 50%) min-content minmax(auto, 50%);\n}\n.v-timeline--horizontal.v-timeline--justify-auto {\n  grid-template-rows: auto min-content auto;\n}\n.v-timeline--vertical.v-timeline--justify-auto {\n  grid-template-columns: auto min-content auto;\n}\n.v-timeline--horizontal.v-timeline--density-comfortable {\n  height: 100%;\n}\n.v-timeline--horizontal.v-timeline--density-comfortable.v-timeline--side-end {\n  grid-template-rows: min-content min-content auto;\n}\n.v-timeline--horizontal.v-timeline--density-comfortable.v-timeline--side-start {\n  grid-template-rows: auto min-content min-content;\n}\n.v-timeline--vertical.v-timeline--density-comfortable {\n  width: 100%;\n}\n.v-timeline--vertical.v-timeline--density-comfortable.v-timeline--side-end {\n  grid-template-columns: min-content min-content auto;\n}\n.v-timeline--vertical.v-timeline--density-comfortable.v-timeline--side-start {\n  grid-template-columns: auto min-content min-content;\n}\n.v-timeline--horizontal.v-timeline--density-compact.v-timeline--side-end {\n  grid-template-rows: 0 min-content auto;\n}\n.v-timeline--horizontal.v-timeline--density-compact.v-timeline--side-start {\n  grid-template-rows: auto min-content 0;\n}\n.v-timeline--horizontal.v-timeline--density-compact .v-timeline-item__body {\n  grid-row: 1;\n}\n.v-timeline--vertical.v-timeline--density-compact.v-timeline--side-end {\n  grid-template-columns: 0 min-content auto;\n}\n.v-timeline--vertical.v-timeline--density-compact.v-timeline--side-start {\n  grid-template-columns: auto min-content 0;\n}\n.v-timeline--vertical.v-timeline--density-compact .v-timeline-item__body {\n  grid-column: 3;\n}\n.v-timeline--horizontal.v-timeline.v-timeline--side-end .v-timeline-item .v-timeline-item__body {\n  grid-row: 3;\n  align-self: flex-start;\n  padding-block-end: initial;\n  padding-block-start: 24px;\n}\n.v-timeline--horizontal.v-timeline.v-timeline--side-end .v-timeline-item .v-timeline-item__opposite {\n  grid-row: 1;\n  align-self: flex-end;\n  padding-block-end: 24px;\n  padding-block-start: initial;\n}\n.v-timeline--vertical.v-timeline.v-timeline--side-end .v-timeline-item .v-timeline-item__body {\n  grid-column: 3;\n  justify-self: flex-start;\n  padding-inline-start: 24px;\n  padding-inline-end: initial;\n}\n.v-timeline--vertical.v-timeline.v-timeline--side-end .v-timeline-item .v-timeline-item__opposite {\n  grid-column: 1;\n  justify-self: flex-end;\n  padding-inline-end: 24px;\n  padding-inline-start: initial;\n}\n.v-timeline--horizontal.v-timeline.v-timeline--side-start .v-timeline-item .v-timeline-item__body {\n  grid-row: 1;\n  align-self: flex-end;\n  padding-block-end: 24px;\n  padding-block-start: initial;\n}\n.v-timeline--horizontal.v-timeline.v-timeline--side-start .v-timeline-item .v-timeline-item__opposite {\n  grid-row: 3;\n  align-self: flex-start;\n  padding-block-end: initial;\n  padding-block-start: 24px;\n}\n.v-timeline--vertical.v-timeline.v-timeline--side-start .v-timeline-item .v-timeline-item__body {\n  grid-column: 1;\n  justify-self: flex-end;\n  padding-inline-end: 24px;\n}\n.v-timeline--vertical.v-timeline.v-timeline--side-start .v-timeline-item .v-timeline-item__opposite {\n  grid-column: 3;\n  justify-self: flex-start;\n  padding-inline-start: 24px;\n}\n.v-timeline-divider--fill-dot .v-timeline-divider__inner-dot {\n  height: inherit;\n  width: inherit;\n}\n.v-timeline--align-center {\n  --v-timeline-line-size-base: 50%;\n  --v-timeline-line-size-offset: 0px;\n}\n.v-timeline--horizontal.v-timeline--align-center {\n  justify-items: center;\n}\n.v-timeline--horizontal.v-timeline--align-center .v-timeline-item__body {\n  padding-inline: 12px;\n}\n.v-timeline--horizontal.v-timeline--align-center .v-timeline-item__opposite {\n  padding-inline: 12px;\n}\n.v-timeline--horizontal.v-timeline--align-center .v-timeline-divider {\n  justify-content: center;\n}\n.v-timeline--vertical.v-timeline--align-center {\n  align-items: center;\n}\n.v-timeline--vertical.v-timeline--align-center .v-timeline-divider {\n  justify-content: center;\n}\n.v-timeline--align-start {\n  --v-timeline-line-size-base: 100%;\n  --v-timeline-line-size-offset: 12px;\n}\n.v-timeline--align-start .v-timeline-item:first-child .v-timeline-divider__before {\n  --v-timeline-line-size-offset: 24px;\n}\n.v-timeline--align-start .v-timeline-item:first-child .v-timeline-divider__after {\n  --v-timeline-line-size-offset: -12px;\n}\n.v-timeline--align-start .v-timeline-item:last-child .v-timeline-divider__after {\n  --v-timeline-line-size-offset: 0px;\n}\n.v-timeline--horizontal.v-timeline--align-start {\n  justify-items: flex-start;\n}\n.v-timeline--horizontal.v-timeline--align-start .v-timeline-divider {\n  justify-content: flex-start;\n}\n.v-timeline--horizontal.v-timeline--align-start .v-timeline-divider .v-timeline-divider__before {\n  width: calc(var(--v-timeline-line-size-offset) + var(--v-timeline-dot-size) / 2 - var(--v-timeline-line-inset));\n}\n.v-timeline--horizontal.v-timeline--align-start .v-timeline-divider .v-timeline-divider__after {\n  width: calc(var(--v-timeline-line-size-base) - var(--v-timeline-dot-size) / 2 + var(--v-timeline-line-size-offset) - var(--v-timeline-line-inset));\n}\n.v-timeline--vertical.v-timeline--align-start {\n  align-items: flex-start;\n}\n.v-timeline--vertical.v-timeline--align-start .v-timeline-divider {\n  justify-content: flex-start;\n}\n.v-timeline--vertical.v-timeline--align-start .v-timeline-divider .v-timeline-divider__before {\n  height: calc(var(--v-timeline-line-size-offset) + var(--v-timeline-dot-size) / 2 - var(--v-timeline-line-inset));\n}\n.v-timeline--vertical.v-timeline--align-start .v-timeline-divider .v-timeline-divider__after {\n  height: calc(var(--v-timeline-line-size-base) - var(--v-timeline-dot-size) / 2 + var(--v-timeline-line-size-offset) - var(--v-timeline-line-inset));\n}\n.v-timeline--truncate-line-start .v-timeline-item:first-child .v-timeline-divider__before {\n  display: none;\n}\n.v-timeline--truncate-line-start .v-timeline-item:first-child .v-timeline-divider__after {\n  --v-timeline-line-size-offset: 12px;\n}\n.v-timeline--vertical.v-timeline--truncate-line-start .v-timeline-item:first-child .v-timeline-divider,\n.v-timeline--vertical.v-timeline--truncate-line-start .v-timeline-item:first-child .v-timeline-item__body,\n.v-timeline--vertical.v-timeline--truncate-line-start .v-timeline-item:first-child .v-timeline-item__opposite {\n  padding-block-start: 0;\n}\n.v-timeline--horizontal.v-timeline--truncate-line-start .v-timeline-item:first-child .v-timeline-divider,\n.v-timeline--horizontal.v-timeline--truncate-line-start .v-timeline-item:first-child .v-timeline-item__body,\n.v-timeline--horizontal.v-timeline--truncate-line-start .v-timeline-item:first-child .v-timeline-item__opposite {\n  padding-inline-start: 0;\n}\n.v-timeline--truncate-line-end .v-timeline-item:last-child .v-timeline-divider__after {\n  display: none;\n}\n.v-timeline--truncate-line-end .v-timeline-item:last-child .v-timeline-divider__before {\n  --v-timeline-line-size-offset: 12px;\n}\n.v-timeline--vertical.v-timeline--truncate-line-end .v-timeline-item:last-child .v-timeline-divider,\n.v-timeline--vertical.v-timeline--truncate-line-end .v-timeline-item:last-child .v-timeline-item__body,\n.v-timeline--vertical.v-timeline--truncate-line-end .v-timeline-item:last-child .v-timeline-item__opposite {\n  padding-block-end: 0;\n}\n.v-timeline--horizontal.v-timeline--truncate-line-end .v-timeline-item:last-child .v-timeline-divider,\n.v-timeline--horizontal.v-timeline--truncate-line-end .v-timeline-item:last-child .v-timeline-item__body,\n.v-timeline--horizontal.v-timeline--truncate-line-end .v-timeline-item:last-child .v-timeline-item__opposite {\n  padding-inline-end: 0;\n}\n\n/* ../posawesome/node_modules/vuetify/lib/components/VTooltip/VTooltip.css */\n.v-tooltip > .v-overlay__content {\n  background: rgb(var(--v-theme-surface-variant));\n  color: rgb(var(--v-theme-on-surface-variant));\n  border-radius: 4px;\n  font-size: 0.875rem;\n  line-height: 1.6;\n  display: inline-block;\n  padding: 5px 16px;\n  text-transform: initial;\n  width: auto;\n  opacity: 1;\n  transition-property: opacity, transform;\n  overflow-wrap: break-word;\n}\n.v-tooltip > .v-overlay__content[class*=enter-active] {\n  transition-timing-function: cubic-bezier(0, 0, 0.2, 1);\n  transition-duration: 150ms;\n}\n.v-tooltip > .v-overlay__content[class*=leave-active] {\n  transition-timing-function: cubic-bezier(0.4, 0, 1, 1);\n  transition-duration: 75ms;\n}\n.v-tooltip:not(.v-tooltip--interactive) > .v-overlay__content {\n  pointer-events: none;\n}\n\n/* sfc-style:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/navbar/NavbarAppBar.vue?type=style&index=0 */\n.navbar-enhanced[data-v-559a00f1] {\n  background-image: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%) !important;\n  background-color: #ffffff !important;\n  border-bottom: 2px solid #e3f2fd !important;\n  backdrop-filter: blur(10px);\n  transition: all 0.3s ease;\n  padding-bottom: 4px !important;\n}\n.navbar-enhanced[data-v-559a00f1]:hover {\n  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1) !important;\n}\n.navbar-title[data-v-559a00f1] {\n  text-decoration: none !important;\n  border-bottom: none !important;\n}\n.navbar-title[data-v-559a00f1]:hover {\n  text-decoration: none !important;\n}\n.nav-icon[data-v-559a00f1] {\n  border-radius: 12px;\n  padding: 6px;\n  transition: all 0.3s ease;\n}\n.nav-icon[data-v-559a00f1]:hover {\n  background-color: rgba(25, 118, 210, 0.1);\n  transform: scale(1.1);\n}\n.profile-section[data-v-559a00f1] {\n  margin: 0 8px;\n}\n.profile-chip[data-v-559a00f1] {\n  font-weight: 500;\n  padding: 6px 12px;\n  border-radius: 20px;\n  transition: all 0.3s ease;\n}\n.profile-chip[data-v-559a00f1]:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 4px 12px rgba(25, 118, 210, 0.3);\n}\n.offline-invoices-btn[data-v-559a00f1] {\n  position: relative;\n  transition: all 0.3s ease;\n  padding: 4px;\n}\n.offline-invoices-btn[data-v-559a00f1]:hover {\n  transform: scale(1.05);\n}\n.offline-invoices-btn.has-pending[data-v-559a00f1] {\n  animation: pulse-559a00f1 2s infinite;\n}\n@keyframes pulse-559a00f1 {\n  0% {\n    box-shadow: 0 0 0 0 rgba(244, 67, 54, 0.4);\n  }\n  70% {\n    box-shadow: 0 0 0 10px rgba(244, 67, 54, 0);\n  }\n  100% {\n    box-shadow: 0 0 0 0 rgba(244, 67, 54, 0);\n  }\n}\n[data-v-559a00f1] .dark-theme .navbar-enhanced,\n[data-v-559a00f1] .v-theme--dark .navbar-enhanced {\n  background-image: linear-gradient(135deg, var(--surface-primary, #1e1e1e) 0%, var(--surface-secondary, #2d2d2d) 100%) !important;\n  background-color: var(--surface-primary, #1e1e1e) !important;\n  border-bottom: 2px solid var(--border-color, rgba(255, 255, 255, 0.12)) !important;\n  color: var(--text-primary, #ffffff) !important;\n}\n[data-v-559a00f1] .dark-theme .navbar-enhanced:hover,\n[data-v-559a00f1] .v-theme--dark .navbar-enhanced:hover {\n  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3) !important;\n}\n[data-v-559a00f1] .dark-theme .nav-icon,\n[data-v-559a00f1] .v-theme--dark .nav-icon {\n  color: var(--text-primary, #ffffff) !important;\n}\n[data-v-559a00f1] .dark-theme .nav-icon:hover,\n[data-v-559a00f1] .v-theme--dark .nav-icon:hover {\n  background-color: rgba(144, 202, 249, 0.1);\n}\n[data-v-559a00f1] .dark-theme .navbar-title,\n[data-v-559a00f1] .v-theme--dark .navbar-title {\n  color: var(--text-primary, #ffffff) !important;\n}\n[data-v-559a00f1] .dark-theme .profile-chip,\n[data-v-559a00f1] .v-theme--dark .profile-chip {\n  background-color: var(--surface-secondary, #2d2d2d) !important;\n  color: var(--text-primary, #ffffff) !important;\n  border-color: var(--primary-light, #90caf9) !important;\n}\n\n/* sfc-style:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/navbar/NavbarDrawer.vue?type=style&index=0 */\n.drawer-custom[data-v-5ea7027e] {\n  background-color: var(--surface-secondary, #ffffff);\n  transition: var(--transition-normal, all 0.3s ease);\n  z-index: 1005 !important;\n}\n.drawer-header[data-v-5ea7027e] {\n  display: flex;\n  align-items: center;\n  height: 64px;\n  padding: 0 16px;\n  background: linear-gradient(135deg, #f8f9fa 0%, #e3f2fd 100%);\n  border-bottom: 1px solid rgba(0, 0, 0, 0.1);\n}\n.drawer-header-mini[data-v-5ea7027e] {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 64px;\n  background: linear-gradient(135deg, #f8f9fa 0%, #e3f2fd 100%);\n  border-bottom: 1px solid rgba(0, 0, 0, 0.1);\n}\n.drawer-company[data-v-5ea7027e] {\n  margin-left: 12px;\n  flex: 1;\n  font-weight: 500;\n  font-size: 1rem;\n  color: var(--text-primary, #333);\n  font-family: \"Roboto\", sans-serif;\n}\n.drawer-icon[data-v-5ea7027e] {\n  font-size: 24px;\n  color: var(--primary-start, #1976d2);\n}\n.drawer-item-title[data-v-5ea7027e] {\n  margin-left: 8px;\n  font-weight: 500;\n  font-size: 0.95rem;\n  color: #000000 !important;\n  font-family: \"Roboto\", sans-serif;\n}\n.v-list-item[data-v-5ea7027e]:hover {\n  background-color: rgba(25, 118, 210, 0.08) !important;\n}\n.active-item[data-v-5ea7027e] {\n  background-color: rgba(25, 118, 210, 0.12) !important;\n  border-right: 3px solid #1976d2;\n}\n[data-v-5ea7027e] .dark-theme .drawer-custom,\n[data-v-5ea7027e] .v-theme--dark .drawer-custom {\n  background-color: var(--surface-primary, #1e1e1e) !important;\n  color: var(--text-primary, #ffffff) !important;\n}\n[data-v-5ea7027e] .dark-theme .drawer-header,\n[data-v-5ea7027e] .dark-theme .drawer-header-mini,\n[data-v-5ea7027e] .v-theme--dark .drawer-header,\n[data-v-5ea7027e] .v-theme--dark .drawer-header-mini {\n  background: linear-gradient(135deg, #2d2d2d 0%, #1e1e1e 100%);\n  border-bottom: 1px solid rgba(255, 255, 255, 0.12);\n}\n[data-v-5ea7027e] .dark-theme .drawer-item-title,\n[data-v-5ea7027e] .v-theme--dark .drawer-item-title {\n  color: #000000 !important;\n  font-weight: 500;\n  font-size: 0.95rem;\n  font-family: \"Roboto\", sans-serif;\n}\n[data-v-5ea7027e] .dark-theme .drawer-company,\n[data-v-5ea7027e] .v-theme--dark .drawer-company {\n  color: var(--text-primary, #ffffff) !important;\n  font-weight: 500;\n  font-size: 1rem;\n  font-family: \"Roboto\", sans-serif;\n}\n[data-v-5ea7027e] .dark-theme .drawer-icon,\n[data-v-5ea7027e] .v-theme--dark .drawer-icon {\n  color: var(--primary-light, #90caf9) !important;\n  font-size: 24px;\n}\n[data-v-5ea7027e] .dark-theme .v-list-item:hover,\n[data-v-5ea7027e] .v-theme--dark .v-list-item:hover {\n  background-color: rgba(144, 202, 249, 0.08) !important;\n}\n[data-v-5ea7027e] .dark-theme .active-item,\n[data-v-5ea7027e] .v-theme--dark .active-item {\n  background-color: rgba(144, 202, 249, 0.12) !important;\n  border-right: 3px solid #90caf9;\n}\n[data-v-5ea7027e] .dark-theme .v-divider,\n[data-v-5ea7027e] .v-theme--dark .v-divider {\n  border-color: rgba(255, 255, 255, 0.12) !important;\n}\n@media (max-width: 768px) {\n  .drawer-custom[data-v-5ea7027e] {\n    width: 280px !important;\n  }\n  [data-v-5ea7027e] .dark-theme .drawer-custom,\n  [data-v-5ea7027e] .v-theme--dark .drawer-custom {\n    background-color: var(--surface-primary, #1e1e1e) !important;\n  }\n}\n\n/* sfc-style:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/navbar/NavbarMenu.vue?type=style&index=0 */\n.menu-btn-compact[data-v-9128e291] {\n  margin-left: 8px;\n  margin-right: 4px;\n  padding: 6px 16px;\n  border-radius: 20px;\n  font-weight: 600;\n  text-transform: none;\n  font-size: 13px;\n  letter-spacing: 0.3px;\n  box-shadow: 0 2px 8px rgba(25, 118, 210, 0.2);\n  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n  background: linear-gradient(135deg, #1976d2 0%, #42a5f5 100%);\n  min-width: 90px;\n  height: 36px;\n}\n.menu-btn-compact[data-v-9128e291]:hover {\n  transform: translateY(-1px) scale(1.02);\n  box-shadow: 0 4px 12px rgba(25, 118, 210, 0.3);\n  background: linear-gradient(135deg, #1565c0 0%, #1976d2 100%);\n}\n.menu-card-compact[data-v-9128e291] {\n  border-radius: 16px;\n  overflow: hidden;\n  background: #ffffff;\n  border: none;\n  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12), 0 2px 6px rgba(0, 0, 0, 0.08);\n  backdrop-filter: blur(8px);\n  min-width: 260px;\n  max-width: 280px;\n  margin-top: 2px;\n}\n.menu-header-compact[data-v-9128e291] {\n  padding: 12px 16px 10px;\n  background: linear-gradient(135deg, #f8f9fa 0%, #e3f2fd 100%);\n  display: flex;\n  align-items: center;\n  gap: 10px;\n  border-bottom: 1px solid rgba(25, 118, 210, 0.06);\n}\n.menu-header-text-compact[data-v-9128e291] {\n  font-size: 14px;\n  font-weight: 600;\n  color: #1976d2;\n  letter-spacing: 0.3px;\n}\n.menu-list-compact[data-v-9128e291] {\n  padding: 8px 6px 12px;\n  background: #ffffff;\n}\n.menu-item-compact[data-v-9128e291] {\n  border-radius: 12px;\n  margin: 3px 0;\n  padding: 12px 16px;\n  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n  cursor: pointer;\n  position: relative;\n  overflow: hidden;\n  min-height: 56px;\n  display: flex;\n  align-items: center;\n  gap: 12px;\n}\n.menu-item-compact[data-v-9128e291]::before {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: transparent;\n  transition: all 0.3s ease;\n  z-index: 0;\n  border-radius: 12px;\n}\n.menu-item-compact[data-v-9128e291]:hover::before {\n  background: linear-gradient(135deg, rgba(25, 118, 210, 0.05) 0%, rgba(66, 165, 245, 0.08) 100%);\n}\n.menu-item-compact[data-v-9128e291]:hover {\n  transform: translateX(3px) scale(1.01);\n  box-shadow: 0 3px 12px rgba(0, 0, 0, 0.08);\n}\n.menu-icon-wrapper-compact[data-v-9128e291] {\n  width: 32px;\n  height: 32px;\n  border-radius: 10px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: all 0.3s ease;\n  position: relative;\n  z-index: 1;\n  flex-shrink: 0;\n}\n.menu-content-compact[data-v-9128e291] {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  gap: 2px;\n  position: relative;\n  z-index: 1;\n}\n.primary-icon[data-v-9128e291] {\n  background: linear-gradient(135deg, #1976d2 0%, #42a5f5 100%);\n  box-shadow: 0 2px 6px rgba(25, 118, 210, 0.2);\n}\n.secondary-icon[data-v-9128e291] {\n  background: linear-gradient(135deg, #7b1fa2 0%, #ba68c8 100%);\n  box-shadow: 0 2px 6px rgba(123, 31, 162, 0.2);\n}\n.info-icon[data-v-9128e291] {\n  background: linear-gradient(135deg, #0288d1 0%, #4fc3f7 100%);\n  box-shadow: 0 2px 6px rgba(2, 136, 209, 0.2);\n}\n.neutral-icon[data-v-9128e291] {\n  background: linear-gradient(135deg, #616161 0%, #9e9e9e 100%);\n  box-shadow: 0 2px 6px rgba(97, 97, 97, 0.2);\n}\n.danger-icon[data-v-9128e291] {\n  background: linear-gradient(135deg, #d32f2f 0%, #f44336 100%);\n  box-shadow: 0 2px 6px rgba(211, 47, 47, 0.2);\n}\n.warning-icon[data-v-9128e291] {\n  background: linear-gradient(135deg, #ff9800 0%, #ffc107 100%);\n  box-shadow: 0 2px 6px rgba(255, 152, 0, 0.2);\n}\n.menu-item-title-compact[data-v-9128e291] {\n  font-weight: 600;\n  font-size: 14px;\n  color: #212121;\n  line-height: 1.2;\n  margin-bottom: 1px;\n}\n.menu-item-subtitle-compact[data-v-9128e291] {\n  font-size: 11px;\n  color: #666666;\n  line-height: 1.3;\n  font-weight: 400;\n}\n.menu-section-divider-compact[data-v-9128e291] {\n  margin: 8px 10px;\n  opacity: 0.12;\n  border-color: #1976d2;\n}\n.primary-action:hover .primary-icon[data-v-9128e291] {\n  transform: scale(1.1) rotate(5deg);\n  box-shadow: 0 3px 8px rgba(25, 118, 210, 0.25);\n}\n.secondary-action:hover .secondary-icon[data-v-9128e291] {\n  transform: scale(1.1) rotate(-5deg);\n  box-shadow: 0 3px 8px rgba(123, 31, 162, 0.25);\n}\n.info-action:hover .info-icon[data-v-9128e291] {\n  transform: scale(1.1) rotate(360deg);\n  box-shadow: 0 3px 8px rgba(2, 136, 209, 0.25);\n}\n.neutral-action:hover .neutral-icon[data-v-9128e291] {\n  transform: scale(1.1);\n  box-shadow: 0 3px 8px rgba(97, 97, 97, 0.25);\n}\n.danger-action:hover .danger-icon[data-v-9128e291] {\n  transform: scale(1.1) rotate(-5deg);\n  box-shadow: 0 3px 8px rgba(211, 47, 47, 0.25);\n}\n.danger-action[data-v-9128e291]:hover::before {\n  background: linear-gradient(135deg, rgba(211, 47, 47, 0.05) 0%, rgba(244, 67, 54, 0.08) 100%) !important;\n}\n.warning-action:hover .warning-icon[data-v-9128e291] {\n  transform: scale(1.1) rotate(-5deg);\n  box-shadow: 0 3px 8px rgba(255, 152, 0, 0.25);\n}\n.warning-action[data-v-9128e291]:hover::before {\n  background: linear-gradient(135deg, rgba(255, 152, 0, 0.05) 0%, rgba(255, 193, 7, 0.08) 100%) !important;\n}\n@media (max-width: 768px) {\n  .menu-card-compact[data-v-9128e291] {\n    min-width: 240px;\n    max-width: 260px;\n    border-radius: 14px;\n  }\n  .menu-item-compact[data-v-9128e291] {\n    padding: 10px 14px;\n    min-height: 52px;\n    gap: 10px;\n  }\n  .menu-icon-wrapper-compact[data-v-9128e291] {\n    width: 30px;\n    height: 30px;\n  }\n  .menu-header-compact[data-v-9128e291] {\n    padding: 10px 14px 8px;\n  }\n  .menu-btn-compact[data-v-9128e291] {\n    margin-left: 6px;\n    padding: 5px 14px;\n    min-width: 85px;\n    height: 34px;\n    font-size: 12px;\n  }\n}\n@media (max-width: 480px) {\n  .menu-card-compact[data-v-9128e291] {\n    min-width: 220px;\n    max-width: 240px;\n  }\n  .menu-item-compact[data-v-9128e291] {\n    padding: 9px 12px;\n    min-height: 48px;\n    gap: 9px;\n  }\n  .menu-header-compact[data-v-9128e291] {\n    padding: 9px 12px 7px;\n  }\n  .menu-btn-compact[data-v-9128e291] {\n    min-width: 80px;\n    height: 32px;\n  }\n}\n.v-overlay__content[data-v-9128e291] {\n  animation: menuSlideInCompact-9128e291 0.25s cubic-bezier(0.4, 0, 0.2, 1);\n}\n@keyframes menuSlideInCompact-9128e291 {\n  from {\n    opacity: 0;\n    transform: translateY(-8px) scale(0.95);\n  }\n  to {\n    opacity: 1;\n    transform: translateY(0) scale(1);\n  }\n}\n.menu-item-compact[data-v-9128e291]:focus-visible {\n  outline: 1px solid #1976d2;\n  outline-offset: 1px;\n}\n.menu-btn-compact[data-v-9128e291]:focus-visible {\n  outline: 1px solid #1976d2;\n  outline-offset: 2px;\n}\n[data-v-9128e291] .dark-theme .menu-btn-compact,\n[data-v-9128e291] .v-theme--dark .menu-btn-compact {\n  background: linear-gradient(135deg, #90caf9 0%, #42a5f5 100%);\n  color: #1e1e1e !important;\n}\n[data-v-9128e291] .dark-theme .menu-btn-compact:hover,\n[data-v-9128e291] .v-theme--dark .menu-btn-compact:hover {\n  background: linear-gradient(135deg, #64b5f6 0%, #1976d2 100%);\n  box-shadow: 0 4px 12px rgba(144, 202, 249, 0.3);\n}\n[data-v-9128e291] .dark-theme .menu-card-compact,\n[data-v-9128e291] .v-theme--dark .menu-card-compact {\n  background: var(--surface-primary, #1e1e1e) !important;\n  border: 1px solid rgba(255, 255, 255, 0.12);\n  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4), 0 2px 6px rgba(0, 0, 0, 0.2);\n}\n[data-v-9128e291] .dark-theme .menu-header-compact,\n[data-v-9128e291] .v-theme--dark .menu-header-compact {\n  background: linear-gradient(135deg, #2d2d2d 0%, #1e1e1e 100%) !important;\n  border-bottom: 1px solid rgba(255, 255, 255, 0.12);\n}\n[data-v-9128e291] .dark-theme .menu-header-text-compact,\n[data-v-9128e291] .v-theme--dark .menu-header-text-compact {\n  color: var(--primary-light, #90caf9) !important;\n}\n[data-v-9128e291] .dark-theme .menu-list-compact,\n[data-v-9128e291] .v-theme--dark .menu-list-compact {\n  background: var(--surface-primary, #1e1e1e) !important;\n}\n[data-v-9128e291] .dark-theme .menu-item-title-compact,\n[data-v-9128e291] .v-theme--dark .menu-item-title-compact {\n  color: var(--text-primary, #ffffff) !important;\n}\n[data-v-9128e291] .dark-theme .menu-item-subtitle-compact,\n[data-v-9128e291] .v-theme--dark .menu-item-subtitle-compact {\n  color: var(--text-secondary, #b0b0b0) !important;\n}\n[data-v-9128e291] .dark-theme .menu-section-divider-compact,\n[data-v-9128e291] .v-theme--dark .menu-section-divider-compact {\n  border-color: rgba(255, 255, 255, 0.12) !important;\n}\n[data-v-9128e291] .dark-theme .menu-item-compact:hover::before,\n[data-v-9128e291] .v-theme--dark .menu-item-compact:hover::before {\n  background: linear-gradient(135deg, rgba(144, 202, 249, 0.05) 0%, rgba(144, 202, 249, 0.08) 100%) !important;\n}\n[data-v-9128e291] .dark-theme .primary-icon,\n[data-v-9128e291] .v-theme--dark .primary-icon {\n  background: linear-gradient(135deg, #90caf9 0%, #42a5f5 100%);\n  box-shadow: 0 2px 6px rgba(144, 202, 249, 0.3);\n}\n[data-v-9128e291] .dark-theme .secondary-icon,\n[data-v-9128e291] .v-theme--dark .secondary-icon {\n  background: linear-gradient(135deg, #ce93d8 0%, #ba68c8 100%);\n  box-shadow: 0 2px 6px rgba(206, 147, 216, 0.3);\n}\n[data-v-9128e291] .dark-theme .info-icon,\n[data-v-9128e291] .v-theme--dark .info-icon {\n  background: linear-gradient(135deg, #81d4fa 0%, #4fc3f7 100%);\n  box-shadow: 0 2px 6px rgba(129, 212, 250, 0.3);\n}\n[data-v-9128e291] .dark-theme .neutral-icon,\n[data-v-9128e291] .v-theme--dark .neutral-icon {\n  background: linear-gradient(135deg, #bdbdbd 0%, #9e9e9e 100%);\n  box-shadow: 0 2px 6px rgba(189, 189, 189, 0.3);\n}\n[data-v-9128e291] .dark-theme .danger-icon,\n[data-v-9128e291] .v-theme--dark .danger-icon {\n  background: linear-gradient(135deg, #ef5350 0%, #f44336 100%);\n  box-shadow: 0 2px 6px rgba(239, 83, 80, 0.3);\n}\n[data-v-9128e291] .dark-theme .warning-icon,\n[data-v-9128e291] .v-theme--dark .warning-icon {\n  background: linear-gradient(135deg, #ffb74d 0%, #ffc107 100%);\n  box-shadow: 0 2px 6px rgba(255, 183, 77, 0.3);\n}\n\n/* sfc-style:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/navbar/StatusIndicator.vue?type=style&index=0 */\n.status-section-enhanced[data-v-fe826534] {\n  display: flex;\n  align-items: center;\n  gap: 8px;\n  margin-right: 8px;\n}\n.status-btn-enhanced[data-v-fe826534] {\n  background: rgba(25, 118, 210, 0.1) !important;\n  border: 1px solid rgba(25, 118, 210, 0.3);\n  transition: all 0.3s ease;\n  padding: 4px;\n}\n.status-btn-enhanced[data-v-fe826534]:hover {\n  background: rgba(25, 118, 210, 0.2) !important;\n  transform: scale(1.05);\n}\n.status-info-always-visible[data-v-fe826534] {\n  display: flex;\n  flex-direction: column;\n  align-items: flex-start;\n  min-width: 120px;\n}\n.status-title-inline[data-v-fe826534] {\n  font-size: 12px;\n  font-weight: 600;\n  line-height: 1.2;\n  transition: color 0.3s ease;\n}\n.status-title-inline.status-connected[data-v-fe826534] {\n  color: #4caf50;\n}\n.status-title-inline.status-offline[data-v-fe826534] {\n  color: #f44336;\n}\n.status-detail-inline[data-v-fe826534] {\n  font-size: 11px;\n  color: #666;\n  line-height: 1.2;\n  margin-top: 2px;\n}\n@media (max-width: 768px) {\n  .status-info-always-visible[data-v-fe826534] {\n    display: none;\n  }\n  .status-section-enhanced[data-v-fe826534] {\n    margin-right: 4px;\n  }\n}\n\n/* sfc-style:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/navbar/CacheUsageMeter.vue?type=style&index=0 */\n.cache-usage-section[data-v-d47ae9a3] {\n  display: flex;\n  align-items: center;\n  margin: 0 8px;\n}\n.cache-meter-container[data-v-d47ae9a3] {\n  cursor: pointer;\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: all 0.3s ease;\n}\n.cache-meter-container[data-v-d47ae9a3]:hover {\n  transform: scale(1.1);\n}\n.cache-meter[data-v-d47ae9a3] {\n  transition: all 0.3s ease;\n}\n.cache-tooltip-content[data-v-d47ae9a3] {\n  padding: 12px;\n  min-width: 200px;\n}\n.cache-tooltip-title[data-v-d47ae9a3] {\n  font-weight: 600;\n  font-size: 14px;\n  margin-bottom: 8px;\n  color: var(--primary);\n}\n.cache-tooltip-detail[data-v-d47ae9a3] {\n  font-size: 12px;\n  margin-bottom: 8px;\n  line-height: 1.5;\n}\n.cache-tooltip-action[data-v-d47ae9a3] {\n  font-size: 11px;\n  opacity: 0.7;\n  display: flex;\n  align-items: center;\n  margin-top: 8px;\n  color: var(--primary);\n}\n\n/* sfc-style:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/navbar/AboutDialog.vue?type=style&index=0 */\n.about-dialog-card-improved[data-v-a26a8d71] {\n  border-radius: 16px !important;\n  overflow: hidden;\n  background: white;\n  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1) !important;\n  max-height: 90vh;\n}\n.about-header-improved[data-v-a26a8d71] {\n  background: white;\n  color: #1a1a1a;\n  border-bottom: 1px solid #f0f0f0;\n  position: relative;\n  min-height: auto !important;\n}\n.about-header-improved[data-v-a26a8d71]::before {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  height: 3px;\n  background: linear-gradient(90deg, #1976d2 0%, #42a5f5 100%);\n}\n.header-content-improved[data-v-a26a8d71] {\n  display: flex;\n  align-items: center;\n  gap: 16px;\n  padding-right: 60px;\n}\n.header-icon-wrapper-improved[data-v-a26a8d71] {\n  background: linear-gradient(135deg, #1976d2 0%, #42a5f5 100%);\n  border-radius: 14px;\n  padding: 10px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  box-shadow: 0 2px 8px rgba(25, 118, 210, 0.3);\n}\n.header-icon[data-v-a26a8d71] {\n  color: white;\n}\n.header-text-improved[data-v-a26a8d71] {\n  flex: 1;\n}\n.header-title-improved[data-v-a26a8d71] {\n  margin: 0 0 4px 0;\n  font-weight: 600;\n  color: #1a1a1a;\n  font-size: 1.25rem;\n  line-height: 1.2;\n}\n.header-subtitle-improved[data-v-a26a8d71] {\n  margin: 0;\n  font-size: 14px;\n  color: #666;\n  font-weight: 400;\n  line-height: 1.2;\n}\n.header-stats-improved[data-v-a26a8d71] {\n  display: flex;\n  gap: 8px;\n}\n.status-chip-improved[data-v-a26a8d71] {\n  font-weight: 600;\n  border-radius: 10px;\n  height: 28px !important;\n}\n.close-btn-improved[data-v-a26a8d71] {\n  position: absolute;\n  top: 12px;\n  right: 12px;\n  color: #666 !important;\n}\n.white-background[data-v-a26a8d71] {\n  background: white;\n}\n.content-container-improved[data-v-a26a8d71] {\n  padding: 20px;\n  max-height: 55vh;\n  overflow-y: auto;\n}\n.empty-state-improved[data-v-a26a8d71] {\n  padding: 30px;\n}\n.apps-list-improved[data-v-a26a8d71] {\n  width: 100%;\n}\n.apps-header-improved[data-v-a26a8d71] {\n  margin-bottom: 16px;\n  padding-bottom: 12px;\n  border-bottom: 1px solid #f0f0f0;\n}\n.apps-grid-improved[data-v-a26a8d71] {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));\n  gap: 12px;\n  max-height: 350px;\n  overflow-y: auto;\n}\n.app-item-improved[data-v-a26a8d71] {\n  display: flex;\n  align-items: center;\n  gap: 12px;\n  padding: 12px 16px;\n  background: #f8f9fa;\n  border-radius: 10px;\n  border: 1px solid #e9ecef;\n  transition: all 0.2s ease;\n}\n.app-item-improved[data-v-a26a8d71]:hover {\n  background: #e3f2fd;\n  border-color: #1976d2;\n  transform: translateY(-1px);\n  box-shadow: 0 2px 8px rgba(25, 118, 210, 0.15);\n}\n.app-icon-improved[data-v-a26a8d71] {\n  background: linear-gradient(135deg, #1976d2 0%, #42a5f5 100%);\n  border-radius: 8px;\n  padding: 8px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  min-width: 34px;\n  height: 34px;\n}\n.app-details-improved[data-v-a26a8d71] {\n  flex: 1;\n  min-width: 0;\n}\n.app-name-improved[data-v-a26a8d71] {\n  font-weight: 500;\n  font-size: 14px;\n  color: #1a1a1a;\n  line-height: 1.3;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.app-version-improved[data-v-a26a8d71] {\n  font-size: 12px;\n  color: #666;\n  font-weight: 400;\n  line-height: 1.3;\n  margin-top: 2px;\n}\n.dialog-actions-improved[data-v-a26a8d71] {\n  background: #f8f9fa;\n  border-top: 1px solid #f0f0f0;\n  min-height: auto !important;\n}\n.footer-info-improved[data-v-a26a8d71] {\n  display: flex;\n  align-items: center;\n}\n.footer-text-improved[data-v-a26a8d71] {\n  font-size: 13px;\n  color: #666;\n  display: flex;\n  align-items: center;\n  gap: 6px;\n}\n.close-btn-action-improved[data-v-a26a8d71] {\n  border-radius: 10px;\n  font-weight: 600;\n  text-transform: none;\n  height: 36px;\n  padding: 0 20px;\n}\n@media (max-width: 700px) {\n  .about-dialog-card-improved[data-v-a26a8d71] {\n    margin: 16px;\n    max-height: 85vh;\n  }\n  .apps-grid-improved[data-v-a26a8d71] {\n    grid-template-columns: 1fr;\n    max-height: 300px;\n  }\n  .header-content-improved[data-v-a26a8d71] {\n    gap: 12px;\n    padding-right: 50px;\n  }\n  .content-container-improved[data-v-a26a8d71] {\n    padding: 16px;\n    max-height: 50vh;\n  }\n}\n.content-container-improved[data-v-a26a8d71]::-webkit-scrollbar,\n.apps-grid-improved[data-v-a26a8d71]::-webkit-scrollbar {\n  width: 6px;\n}\n.content-container-improved[data-v-a26a8d71]::-webkit-scrollbar-track,\n.apps-grid-improved[data-v-a26a8d71]::-webkit-scrollbar-track {\n  background: #f1f1f1;\n  border-radius: 3px;\n}\n.content-container-improved[data-v-a26a8d71]::-webkit-scrollbar-thumb,\n.apps-grid-improved[data-v-a26a8d71]::-webkit-scrollbar-thumb {\n  background: #c1c1c1;\n  border-radius: 3px;\n}\n.content-container-improved[data-v-a26a8d71]::-webkit-scrollbar-thumb:hover,\n.apps-grid-improved[data-v-a26a8d71]::-webkit-scrollbar-thumb:hover {\n  background: #a8a8a8;\n}\n\n/* sfc-style:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/OfflineInvoices.vue?type=style&index=0 */\n.offline-invoices-card {\n  composes: pos-card;\n  border-radius: var(--border-radius-xl) !important;\n}\n.offline-header {\n  background: var(--surface-primary);\n  color: var(--text-primary);\n  border-bottom: 1px solid var(--field-border);\n  position: relative;\n}\n.offline-header::before {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  height: 4px;\n  background: linear-gradient(90deg, var(--primary-start) 0%, var(--primary-end) 100%);\n}\n.header-content {\n  display: flex;\n  align-items: center;\n  gap: var(--dynamic-md);\n}\n.header-icon-wrapper {\n  background: linear-gradient(135deg, var(--primary-start) 0%, var(--primary-end) 100%);\n  border-radius: var(--border-radius-md);\n  padding: var(--dynamic-md);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  box-shadow: var(--shadow-md);\n}\n.header-icon {\n  color: white;\n}\n.header-text {\n  flex: 1;\n}\n.header-title {\n  margin: 0 0 var(--dynamic-xs) 0;\n  font-weight: 700;\n  color: var(--text-primary);\n  font-size: 1.5rem;\n}\n.header-subtitle {\n  margin: 0 0 var(--dynamic-sm) 0;\n  font-size: 14px;\n  color: var(--text-secondary);\n  font-weight: 400;\n}\n.header-stats {\n  display: flex;\n  gap: var(--dynamic-xs);\n}\n.status-chip {\n  font-weight: 600;\n  border-radius: var(--border-radius-md);\n}\n.header-actions {\n  display: flex;\n  gap: var(--dynamic-sm);\n}\n.sync-btn {\n  border-radius: var(--border-radius-md);\n}\n.offline-invoices-card {\n  border-radius: 20px !important;\n  overflow: hidden;\n  background: white;\n  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1) !important;\n}\n:deep(.dark-theme) .offline-invoices-card,\n:deep(.v-theme--dark) .offline-invoices-card,\n::v-deep(.dark-theme) .offline-invoices-card,\n::v-deep(.v-theme--dark) .offline-invoices-card {\n  background-color: #1E1E1E !important;\n  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5) !important;\n}\n.offline-header {\n  background: white;\n  color: #1a1a1a;\n  border-bottom: 1px solid #f0f0f0;\n  position: relative;\n}\n:deep(.dark-theme) .offline-header,\n:deep(.v-theme--dark) .offline-header,\n::v-deep(.dark-theme) .offline-header,\n::v-deep(.v-theme--dark) .offline-header {\n  background-color: #1E1E1E !important;\n  color: #fff !important;\n  border-bottom-color: #333 !important;\n}\n.offline-header::before {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  height: 4px;\n  background: linear-gradient(90deg, #1976d2 0%, #42a5f5 100%);\n}\n.header-content {\n  display: flex;\n  align-items: center;\n  gap: 20px;\n}\n.header-icon-wrapper {\n  background: linear-gradient(135deg, #1976d2 0%, #42a5f5 100%);\n  border-radius: 16px;\n  padding: 16px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  box-shadow: 0 4px 16px rgba(25, 118, 210, 0.3);\n}\n.header-icon {\n  color: white;\n}\n.header-text {\n  flex: 1;\n}\n.header-title {\n  margin: 0 0 4px 0;\n  font-weight: 700;\n  color: #1a1a1a;\n  font-size: 1.5rem;\n}\n.header-subtitle {\n  margin: 0 0 12px 0;\n  font-size: 14px;\n  color: #666;\n  font-weight: 400;\n}\n.header-stats {\n  display: flex;\n  gap: 8px;\n}\n.status-chip {\n  font-weight: 600;\n  border-radius: 12px;\n}\n.header-actions {\n  display: flex;\n  gap: 12px;\n}\n.sync-btn {\n  border-radius: 12px;\n  font-weight: 600;\n  text-transform: none;\n  box-shadow: 0 4px 12px rgba(25, 118, 210, 0.3);\n}\n.header-divider {\n  border-color: #f0f0f0;\n}\n.white-background {\n  background: white;\n}\n:deep(.dark-theme) .white-background,\n:deep(.v-theme--dark) .white-background,\n::v-deep(.dark-theme) .white-background,\n::v-deep(.v-theme--dark) .white-background {\n  background-color: #121212 !important;\n}\n.empty-state {\n  padding: 64px 24px;\n  background: white;\n}\n:deep(.dark-theme) .empty-state,\n:deep(.v-theme--dark) .empty-state,\n::v-deep(.dark-theme) .empty-state,\n::v-deep(.v-theme--dark) .empty-state {\n  background-color: #121212 !important;\n}\n.empty-icon-wrapper {\n  display: inline-block;\n  padding: 20px;\n  background: rgba(76, 175, 80, 0.1);\n  border-radius: 50%;\n}\n.empty-icon {\n  filter: drop-shadow(0 2px 8px rgba(76, 175, 80, 0.3));\n}\n.table-container {\n  background: white;\n}\n:deep(.dark-theme) .table-container,\n:deep(.v-theme--dark) .table-container,\n::v-deep(.dark-theme) .table-container,\n::v-deep(.v-theme--dark) .table-container {\n  background-color: #121212 !important;\n}\n.table-header {\n  padding: 0 4px;\n}\n:deep(.dark-theme) .table-header,\n:deep(.v-theme--dark) .table-header,\n::v-deep(.dark-theme) .table-header,\n::v-deep(.v-theme--dark) .table-header {\n  color: #e0e0e0 !important;\n}\n.white-table {\n  background: white;\n  border: 1px solid #f0f0f0;\n  border-radius: 16px;\n  overflow: hidden;\n}\n:deep(.dark-theme) .white-table,\n:deep(.v-theme--dark) .white-table,\n::v-deep(.dark-theme) .white-table,\n::v-deep(.v-theme--dark) .white-table {\n  background-color: #121212 !important;\n}\n:deep(.dark-theme) .white-table :deep(th),\n:deep(.v-theme--dark) .white-table :deep(th),\n:deep(.dark-theme) .white-table :deep(td),\n:deep(.v-theme--dark) .white-table :deep(td),\n::v-deep(.dark-theme) .white-table th,\n::v-deep(.v-theme--dark) .white-table th,\n::v-deep(.dark-theme) .white-table td,\n::v-deep(.v-theme--dark) .white-table td {\n  color: #fff !important;\n  background-color: #1E1E1E !important;\n  border-color: #373737 !important;\n}\n:deep(.dark-theme) .white-table :deep(thead th),\n:deep(.v-theme--dark) .white-table :deep(thead th),\n::v-deep(.dark-theme) .white-table thead th,\n::v-deep(.v-theme--dark) .white-table thead th {\n  background-color: #121212 !important;\n  color: #fff !important;\n}\n:deep(.dark-theme) .white-table :deep(.v-data-table-header__content),\n:deep(.v-theme--dark) .white-table :deep(.v-data-table-header__content),\n::v-deep(.dark-theme) .white-table .v-data-table-header__content,\n::v-deep(.v-theme--dark) .white-table .v-data-table-header__content {\n  background-color: #121212 !important;\n}\n:deep(.dark-theme) .white-table :deep(thead),\n:deep(.v-theme--dark) .white-table :deep(thead),\n::v-deep(.dark-theme) .white-table thead,\n::v-deep(.v-theme--dark) .white-table thead {\n  background-color: #121212 !important;\n}\n:deep(.v-data-table-header) {\n  background: #fafafa;\n  border-bottom: 2px solid #f0f0f0;\n}\n:deep(.v-data-table-header th) {\n  font-weight: 600;\n  color: #424242;\n  font-size: 0.875rem;\n  padding: 16px;\n}\n:deep(.v-data-table__tr) {\n  border-bottom: 1px solid #f5f5f5;\n}\n:deep(.v-data-table__tr:hover) {\n  background-color: rgba(25, 118, 210, 0.02);\n}\n:deep(.v-data-table__td) {\n  padding: 16px;\n  border-bottom: 1px solid #f5f5f5;\n}\n.customer-cell {\n  display: flex;\n  align-items: center;\n}\n.amount-cell {\n  font-family: \"Roboto Mono\", monospace;\n}\n.date-chip {\n  border-radius: 8px;\n  font-weight: 500;\n}\n.delete-btn {\n  border-radius: 8px;\n  transition: all 0.2s ease;\n}\n.delete-btn:hover {\n  background-color: rgba(244, 67, 54, 0.08);\n  transform: scale(1.05);\n}\n.close-btn {\n  border-radius: 8px;\n  text-transform: none;\n  font-weight: 500;\n  padding: 8px 24px;\n}\n@media (max-width: 768px) {\n  .offline-header {\n    padding: 16px !important;\n  }\n  .header-content {\n    flex-direction: column;\n    align-items: flex-start;\n    gap: 16px;\n  }\n  .header-actions {\n    width: 100%;\n    justify-content: flex-end;\n  }\n  .table-container {\n    overflow-x: auto;\n  }\n}\n.dialog-actions-container {\n  background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%) !important;\n  border-top: 1px solid #e0e0e0 !important;\n  padding: 16px 24px !important;\n  gap: 12px !important;\n}\n:deep(.dark-theme) .dialog-actions-container,\n:deep(.v-theme--dark) .dialog-actions-container,\n::v-deep(.dark-theme) .dialog-actions-container,\n::v-deep(.v-theme--dark) .dialog-actions-container {\n  background: #1E1E1E !important;\n  border-top-color: #333 !important;\n}\n.pos-action-btn {\n  border-radius: 12px !important;\n  text-transform: none !important;\n  font-weight: 600 !important;\n  padding: 12px 32px !important;\n  min-width: 120px !important;\n  transition: all 0.3s ease !important;\n  color: white !important;\n}\n.pos-action-btn .v-icon {\n  color: white !important;\n}\n.pos-action-btn span {\n  color: white !important;\n}\n.cancel-action-btn {\n  background: linear-gradient(135deg, #d32f2f 0%, #c62828 100%) !important;\n}\n.sync-action-btn {\n  background: linear-gradient(135deg, #1976d2 0%, #1565c0 100%) !important;\n}\n.cancel-action-btn:hover,\n.sync-action-btn:hover {\n  transform: translateY(-2px) !important;\n}\n.cancel-action-btn:hover {\n  box-shadow: 0 6px 20px rgba(211, 47, 47, 0.4) !important;\n}\n.sync-action-btn:hover {\n  box-shadow: 0 6px 20px rgba(25, 118, 210, 0.4) !important;\n}\n.pos-action-btn:disabled {\n  opacity: 0.6 !important;\n  transform: none !important;\n  box-shadow: none !important;\n}\n.pos-action-btn:disabled .v-icon,\n.pos-action-btn:disabled span {\n  color: white !important;\n}\n\n/* sfc-style:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/Navbar.vue?type=style&index=0 */\nnav[data-v-8763b898] {\n  position: relative;\n  z-index: 1000;\n}\n[data-v-8763b898] .v-snackbar {\n  z-index: 9999;\n}\n[data-v-8763b898] .dark-theme nav,\n[data-v-8763b898] .v-theme--dark nav {\n  background-color: var(--background) !important;\n}\n\n/* sfc-style:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/CameraScanner.vue?type=style&index=0 */\n.scanner-container[data-v-5eb7f7b8] {\n  position: relative;\n  overflow: hidden;\n  background: #121212;\n}\n.barcode-scanner[data-v-5eb7f7b8] {\n  position: relative;\n}\n.scanning-overlay[data-v-5eb7f7b8] {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  pointer-events: none;\n  z-index: 10;\n}\n.scan-line[data-v-5eb7f7b8] {\n  position: absolute;\n  top: 50%;\n  left: 10%;\n  right: 10%;\n  height: 2px;\n  background: linear-gradient(90deg, transparent, #4CAF50, transparent);\n  animation: scan-5eb7f7b8 2s linear infinite;\n}\n@keyframes scan-5eb7f7b8 {\n  0% {\n    transform: translateY(-100px);\n  }\n  100% {\n    transform: translateY(100px);\n  }\n}\n.scan-corners[data-v-5eb7f7b8] {\n  position: absolute;\n  top: 20%;\n  left: 20%;\n  right: 20%;\n  bottom: 20%;\n}\n.corner[data-v-5eb7f7b8] {\n  position: absolute;\n  width: 20px;\n  height: 20px;\n  border: 3px solid #4CAF50;\n}\n.corner.top-left[data-v-5eb7f7b8] {\n  top: 0;\n  left: 0;\n  border-right: none;\n  border-bottom: none;\n}\n.corner.top-right[data-v-5eb7f7b8] {\n  top: 0;\n  right: 0;\n  border-left: none;\n  border-bottom: none;\n}\n.corner.bottom-left[data-v-5eb7f7b8] {\n  bottom: 0;\n  left: 0;\n  border-right: none;\n  border-top: none;\n}\n.corner.bottom-right[data-v-5eb7f7b8] {\n  bottom: 0;\n  right: 0;\n  border-left: none;\n  border-top: none;\n}\n.status-messages[data-v-5eb7f7b8] {\n  background: rgba(255, 255, 255, 0.95);\n}\n\n/* sfc-style:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/ItemsSelector.vue?type=style&index=0 */\n.dynamic-card[data-v-02d997a2] {\n  composes: pos-card;\n}\n.dynamic-padding[data-v-02d997a2] {\n  padding: var(--dynamic-xs) var(--dynamic-sm) var(--dynamic-xs) var(--dynamic-sm);\n}\n.dynamic-scroll[data-v-02d997a2] {\n  transition: max-height var(--transition-normal);\n  padding-bottom: var(--dynamic-xs);\n  overflow-y: auto;\n  scrollbar-gutter: stable;\n}\n.items-grid[data-v-02d997a2] {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));\n  gap: var(--dynamic-sm);\n  align-items: start;\n  align-content: start;\n}\n.dynamic-item-card[data-v-02d997a2] {\n  margin: var(--dynamic-xs);\n  transition: var(--transition-normal);\n  background-color: var(--surface-secondary);\n  display: flex;\n  flex-direction: column;\n  height: auto;\n  box-sizing: border-box;\n}\n.dynamic-item-card .v-img[data-v-02d997a2] {\n  object-fit: contain;\n}\n.dynamic-item-card[data-v-02d997a2]:hover {\n  transform: scale(calc(1 + 0.02 * var(--font-scale)));\n}\n.text-success[data-v-02d997a2] {\n  color: #4CAF50 !important;\n}\n.sleek-data-table[data-v-02d997a2] {\n  composes: pos-table;\n  margin: var(--dynamic-xs);\n}\n.sleek-data-table[data-v-02d997a2]:hover {\n  box-shadow: var(--shadow-md) !important;\n}\n.settings-container[data-v-02d997a2] {\n  display: flex;\n  align-items: center;\n}\n.truncate[data-v-02d997a2] {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.selection[data-v-02d997a2],\n.cards[data-v-02d997a2] {\n  background-color: var(--surface-secondary) !important;\n}\n.dynamic-spacing-sm[data-v-02d997a2] {\n  padding: var(--dynamic-sm) !important;\n}\n.action-btn-consistent[data-v-02d997a2] {\n  margin-top: var(--dynamic-xs) !important;\n  padding: var(--dynamic-xs) var(--dynamic-sm) !important;\n  transition: var(--transition-normal) !important;\n}\n.action-btn-consistent[data-v-02d997a2]:hover {\n  background-color: rgba(25, 118, 210, 0.1) !important;\n  transform: translateY(-1px) !important;\n}\n.cards[data-v-02d997a2] {\n  margin-top: var(--dynamic-sm) !important;\n  padding: var(--dynamic-sm) !important;\n}\n@media (max-width: 768px) {\n  .dynamic-padding[data-v-02d997a2] {\n    padding: var(--dynamic-xs) var(--dynamic-xs) var(--dynamic-xs) var(--dynamic-xs);\n  }\n  .dynamic-spacing-sm[data-v-02d997a2] {\n    padding: var(--dynamic-xs) !important;\n  }\n  .action-btn-consistent[data-v-02d997a2] {\n    padding: var(--dynamic-xs) !important;\n    font-size: 0.875rem !important;\n  }\n}\n@media (max-width: 480px) {\n  .dynamic-padding[data-v-02d997a2] {\n    padding: var(--dynamic-xs) var(--dynamic-xs) var(--dynamic-xs) var(--dynamic-xs);\n  }\n  .cards[data-v-02d997a2] {\n    padding: var(--dynamic-xs) !important;\n  }\n}\n\n/* sfc-style:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/UpdateCustomer.vue?type=style&index=0 */\n[data-v-10c4be0d] .dark-theme .dark-field,\n[data-v-10c4be0d] .v-theme--dark .dark-field,\n[data-v-10c4be0d] .dark-theme .dark-field,\n[data-v-10c4be0d] .v-theme--dark .dark-field {\n  background-color: #1E1E1E !important;\n}\n[data-v-10c4be0d] .dark-theme .dark-field :deep(.v-field__input),\n[data-v-10c4be0d] .v-theme--dark .dark-field :deep(.v-field__input),\n[data-v-10c4be0d] .dark-theme .dark-field :deep(input),\n[data-v-10c4be0d] .v-theme--dark .dark-field :deep(input),\n[data-v-10c4be0d] .dark-theme .dark-field :deep(.v-label),\n[data-v-10c4be0d] .v-theme--dark .dark-field :deep(.v-label),\n[data-v-10c4be0d] .dark-theme .dark-field .v-field__input,\n[data-v-10c4be0d] .v-theme--dark .dark-field .v-field__input,\n[data-v-10c4be0d] .dark-theme .dark-field input,\n[data-v-10c4be0d] .v-theme--dark .dark-field input,\n[data-v-10c4be0d] .dark-theme .dark-field .v-label,\n[data-v-10c4be0d] .v-theme--dark .dark-field .v-label {\n  color: #fff !important;\n}\n[data-v-10c4be0d] .dark-theme .dark-field :deep(.v-field__overlay),\n[data-v-10c4be0d] .v-theme--dark .dark-field :deep(.v-field__overlay),\n[data-v-10c4be0d] .dark-theme .dark-field .v-field__overlay,\n[data-v-10c4be0d] .v-theme--dark .dark-field .v-field__overlay {\n  background-color: #1E1E1E !important;\n}\n\n/* sfc-style:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/Customer.vue?type=style&index=0 */\n.customer-input-wrapper[data-v-45726972] {\n  width: 100%;\n  max-width: 100%;\n  padding-right: 1.5rem;\n  box-sizing: border-box;\n  display: flex;\n  flex-direction: column;\n}\n.customer-autocomplete[data-v-45726972] {\n  width: 100%;\n  box-sizing: border-box;\n  border-radius: 12px;\n  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);\n  transition: box-shadow 0.3s ease;\n  background-color: #fff;\n}\n.customer-autocomplete[data-v-45726972]:hover {\n  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);\n}\n[data-v-45726972] .dark-theme .customer-autocomplete,\n[data-v-45726972] .v-theme--dark .customer-autocomplete,\n[data-v-45726972] .dark-theme .customer-autocomplete,\n[data-v-45726972] .v-theme--dark .customer-autocomplete {\n  background-color: #1E1E1E !important;\n}\n[data-v-45726972] .dark-theme .customer-autocomplete :deep(.v-field__input),\n[data-v-45726972] .v-theme--dark .customer-autocomplete :deep(.v-field__input),\n[data-v-45726972] .dark-theme .customer-autocomplete :deep(input),\n[data-v-45726972] .v-theme--dark .customer-autocomplete :deep(input),\n[data-v-45726972] .dark-theme .customer-autocomplete :deep(.v-label),\n[data-v-45726972] .v-theme--dark .customer-autocomplete :deep(.v-label),\n[data-v-45726972] .dark-theme .customer-autocomplete .v-field__input,\n[data-v-45726972] .v-theme--dark .customer-autocomplete .v-field__input,\n[data-v-45726972] .dark-theme .customer-autocomplete input,\n[data-v-45726972] .v-theme--dark .customer-autocomplete input,\n[data-v-45726972] .dark-theme .customer-autocomplete .v-label,\n[data-v-45726972] .v-theme--dark .customer-autocomplete .v-label {\n  color: #fff !important;\n}\n[data-v-45726972] .dark-theme .customer-autocomplete :deep(.v-field__overlay),\n[data-v-45726972] .v-theme--dark .customer-autocomplete :deep(.v-field__overlay),\n[data-v-45726972] .dark-theme .customer-autocomplete .v-field__overlay,\n[data-v-45726972] .v-theme--dark .customer-autocomplete .v-field__overlay {\n  background-color: #1E1E1E !important;\n}\n.icon-button[data-v-45726972] {\n  cursor: pointer;\n  font-size: 20px;\n  opacity: 0.7;\n  transition: all 0.2s ease;\n}\n.icon-button[data-v-45726972]:hover {\n  opacity: 1;\n  color: var(--v-theme-primary);\n}\n\n/* sfc-style:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/PostingDateRow.vue?type=style&index=0 */\n[data-v-b00d5d3d] .dark-theme .dark-field,\n[data-v-b00d5d3d] .v-theme--dark .dark-field,\n[data-v-b00d5d3d] .dark-theme .dark-field,\n[data-v-b00d5d3d] .v-theme--dark .dark-field {\n  background-color: #1E1E1E !important;\n}\n[data-v-b00d5d3d] .dark-theme .dark-field :deep(.v-field__input),\n[data-v-b00d5d3d] .v-theme--dark .dark-field :deep(.v-field__input),\n[data-v-b00d5d3d] .dark-theme .dark-field :deep(input),\n[data-v-b00d5d3d] .v-theme--dark .dark-field :deep(input),\n[data-v-b00d5d3d] .dark-theme .dark-field :deep(.v-label),\n[data-v-b00d5d3d] .v-theme--dark .dark-field :deep(.v-label),\n[data-v-b00d5d3d] .dark-theme .dark-field .v-field__input,\n[data-v-b00d5d3d] .v-theme--dark .dark-field .v-field__input,\n[data-v-b00d5d3d] .dark-theme .dark-field input,\n[data-v-b00d5d3d] .v-theme--dark .dark-field input,\n[data-v-b00d5d3d] .dark-theme .dark-field .v-label,\n[data-v-b00d5d3d] .v-theme--dark .dark-field .v-label {\n  color: #fff !important;\n}\n[data-v-b00d5d3d] .dark-theme .dark-field :deep(.v-field__overlay),\n[data-v-b00d5d3d] .v-theme--dark .dark-field :deep(.v-field__overlay),\n[data-v-b00d5d3d] .dark-theme .dark-field .v-field__overlay,\n[data-v-b00d5d3d] .v-theme--dark .dark-field .v-field__overlay {\n  background-color: #1E1E1E !important;\n}\n[data-v-b00d5d3d] .dark-theme .dp__input,\n[data-v-b00d5d3d] .v-theme--dark .dp__input,\n[data-v-b00d5d3d] .dark-theme .dp__input,\n[data-v-b00d5d3d] .v-theme--dark .dp__input {\n  background-color: #1E1E1E !important;\n  color: #fff !important;\n}\n[data-v-b00d5d3d] .dark-theme .dp__menu,\n[data-v-b00d5d3d] .v-theme--dark .dp__menu,\n[data-v-b00d5d3d] .dark-theme .dp__menu,\n[data-v-b00d5d3d] .v-theme--dark .dp__menu {\n  background-color: #1E1E1E !important;\n  color: #fff !important;\n}\n\n/* sfc-style:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/InvoiceSummary.vue?type=style&index=0 */\n.cards[data-v-ab85018a] {\n  background-color: #f5f5f5 !important;\n}\n[data-v-ab85018a] .dark-theme .cards,\n[data-v-ab85018a] .dark-theme .cards .v-card__underlay,\n[data-v-ab85018a] .v-theme--dark .cards,\n[data-v-ab85018a] .v-theme--dark .cards .v-card__underlay,\n[data-v-ab85018a] .cards.v-theme--dark,\n[data-v-ab85018a] .cards.v-theme--dark .v-card__underlay,\n[data-v-ab85018a] .dark-theme .cards,\n[data-v-ab85018a] .dark-theme .cards .v-card__underlay,\n[data-v-ab85018a] .v-theme--dark .cards,\n[data-v-ab85018a] .v-theme--dark .cards .v-card__underlay,\n[data-v-ab85018a] .cards.v-theme--dark,\n[data-v-ab85018a] .cards.v-theme--dark .v-card__underlay {\n  background-color: #1E1E1E !important;\n}\n.white-text-btn[data-v-ab85018a] {\n  color: white !important;\n}\n.white-text-btn[data-v-ab85018a] .v-btn__content {\n  color: white !important;\n}\n\n/* sfc-style:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/ItemsTable.vue?type=style&index=0 */\n.modern-items-table[data-v-d222eb8d] {\n  border-radius: var(--border-radius-lg);\n  overflow: hidden;\n  box-shadow: var(--shadow-md);\n  border: 1px solid rgba(0, 0, 0, 0.09);\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  transition: all 0.3s ease;\n}\n.modern-items-table[data-v-d222eb8d] .v-data-table__wrapper,\n.modern-items-table[data-v-d222eb8d] .v-table__wrapper {\n  border-radius: var(--border-radius-sm);\n  height: 100%;\n  overflow-y: auto;\n  scrollbar-width: thin;\n}\n.modern-items-table[data-v-d222eb8d] th {\n  font-weight: 600;\n  font-size: 0.9rem;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n  padding: 12px 16px;\n  transition: background-color var(--transition-normal);\n  border-bottom: 2px solid var(--table-header-border);\n  background-color: var(--table-header-bg);\n  color: var(--table-header-text);\n  position: sticky;\n  top: 0;\n  z-index: 1;\n}\n.modern-items-table[data-v-d222eb8d] tr {\n  transition: all 0.2s ease;\n  border-bottom: 1px solid rgba(0, 0, 0, 0.05);\n}\n.modern-items-table[data-v-d222eb8d] tr:hover {\n  background-color: var(--table-row-hover);\n  transform: translateY(-1px);\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);\n}\n.modern-items-table[data-v-d222eb8d] td {\n  padding: 12px 16px;\n  vertical-align: middle;\n}\n.expanded-content[data-v-d222eb8d] {\n  padding: var(--dynamic-md);\n  background-color: var(--surface-secondary);\n  border-radius: 0 0 var(--border-radius-md) var(--border-radius-md);\n  box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.05);\n  animation: fadeIn-d222eb8d 0.3s ease;\n}\n@keyframes fadeIn-d222eb8d {\n  from {\n    opacity: 0;\n    transform: translateY(-10px);\n  }\n  to {\n    opacity: 1;\n    transform: translateY(0);\n  }\n}\n.action-panel[data-v-d222eb8d] {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 12px;\n  margin-bottom: 16px;\n  background-color: rgba(0, 0, 0, 0.02);\n  border-radius: var(--border-radius-md);\n  border: 1px solid rgba(0, 0, 0, 0.05);\n}\n[data-v-d222eb8d] .dark-theme .action-panel,\n[data-v-d222eb8d] .v-theme--dark .action-panel {\n  background-color: rgba(255, 255, 255, 0.05);\n  border: 1px solid rgba(255, 255, 255, 0.1);\n}\n.action-button-group[data-v-d222eb8d] {\n  display: flex;\n  gap: 8px;\n}\n.item-action-btn[data-v-d222eb8d] {\n  min-width: 44px !important;\n  height: 44px !important;\n  border-radius: 12px !important;\n  transition: all 0.3s ease;\n  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1) !important;\n  position: relative;\n  overflow: hidden;\n  display: flex;\n  align-items: center;\n  padding: 0 16px !important;\n}\n.item-action-btn .action-label[data-v-d222eb8d] {\n  margin-left: 8px;\n  font-weight: 500;\n  display: none;\n}\n@media (min-width: 600px) {\n  .item-action-btn .action-label[data-v-d222eb8d] {\n    display: inline-block;\n  }\n  .item-action-btn[data-v-d222eb8d] {\n    min-width: 120px !important;\n  }\n}\n.item-action-btn[data-v-d222eb8d]:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 5px 12px rgba(0, 0, 0, 0.15) !important;\n}\n.item-action-btn .v-icon[data-v-d222eb8d] {\n  font-size: 22px !important;\n  position: relative;\n  z-index: 2;\n}\n.item-action-btn.delete-btn[data-v-d222eb8d] {\n  background: linear-gradient(145deg, #ffebee, #ffcdd2) !important;\n}\n.item-action-btn.delete-btn[data-v-d222eb8d]:hover {\n  background: linear-gradient(145deg, #ffcdd2, #ef9a9a) !important;\n}\n.item-action-btn.minus-btn[data-v-d222eb8d] {\n  background: linear-gradient(145deg, #fff8e1, #ffecb3) !important;\n}\n.item-action-btn.minus-btn[data-v-d222eb8d]:hover {\n  background: linear-gradient(145deg, #ffecb3, #ffe082) !important;\n}\n.item-action-btn.plus-btn[data-v-d222eb8d] {\n  background: linear-gradient(145deg, #e8f5e9, #c8e6c9) !important;\n}\n.item-action-btn.plus-btn[data-v-d222eb8d]:hover {\n  background: linear-gradient(145deg, #c8e6c9, #a5d6a7) !important;\n}\n[data-v-d222eb8d] .dark-theme .item-action-btn.delete-btn,\n[data-v-d222eb8d] .v-theme--dark .item-action-btn.delete-btn {\n  background: linear-gradient(145deg, #4a1515, #3a1010) !important;\n  color: #ff8a80 !important;\n}\n[data-v-d222eb8d] .dark-theme .item-action-btn.delete-btn:hover,\n[data-v-d222eb8d] .v-theme--dark .item-action-btn.delete-btn:hover {\n  background: linear-gradient(145deg, #5a1a1a, #4a1515) !important;\n}\n[data-v-d222eb8d] .dark-theme .item-action-btn.minus-btn,\n[data-v-d222eb8d] .v-theme--dark .item-action-btn.minus-btn {\n  background: linear-gradient(145deg, #4a3c10, #3a2e0c) !important;\n  color: #ffe082 !important;\n}\n[data-v-d222eb8d] .dark-theme .item-action-btn.minus-btn:hover,\n[data-v-d222eb8d] .v-theme--dark .item-action-btn.minus-btn:hover {\n  background: linear-gradient(145deg, #5a4a14, #4a3c10) !important;\n}\n[data-v-d222eb8d] .dark-theme .item-action-btn.plus-btn,\n[data-v-d222eb8d] .v-theme--dark .item-action-btn.plus-btn {\n  background: linear-gradient(145deg, #1b4620, #133419) !important;\n  color: #a5d6a7 !important;\n}\n[data-v-d222eb8d] .dark-theme .item-action-btn.plus-btn:hover,\n[data-v-d222eb8d] .v-theme--dark .item-action-btn.plus-btn:hover {\n  background: linear-gradient(145deg, #235828, #1b4620) !important;\n}\n[data-v-d222eb8d] .dark-theme .item-action-btn .v-icon,\n[data-v-d222eb8d] .v-theme--dark .item-action-btn .v-icon {\n  opacity: 0.9;\n}\n.item-details-form[data-v-d222eb8d] {\n  margin-top: 16px;\n}\n.form-row[data-v-d222eb8d] {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 12px;\n  margin-bottom: 12px;\n}\n.form-field[data-v-d222eb8d] {\n  flex: 1;\n  min-width: 200px;\n}\n.form-field.full-width[data-v-d222eb8d] {\n  flex-basis: 100%;\n}\n.form-section[data-v-d222eb8d] {\n  margin-top: 16px;\n  padding-top: 16px;\n  border-top: 1px dashed rgba(0, 0, 0, 0.1);\n}\n[data-v-d222eb8d] .dark-theme .form-section,\n[data-v-d222eb8d] .v-theme--dark .form-section {\n  border-top: 1px dashed rgba(255, 255, 255, 0.1);\n}\n.currency-display[data-v-d222eb8d] {\n  display: flex;\n  align-items: center;\n  justify-content: flex-end;\n}\n.currency-symbol[data-v-d222eb8d] {\n  opacity: 0.7;\n  margin-right: 2px;\n  font-size: 0.85em;\n}\n.amount-value[data-v-d222eb8d] {\n  font-weight: 500;\n  text-align: right;\n}\n.draggable-row[data-v-d222eb8d] {\n  transition: all 0.2s ease;\n  cursor: move;\n}\n.draggable-row[data-v-d222eb8d]:hover {\n  background-color: rgba(0, 0, 0, 0.02);\n}\n[data-v-d222eb8d] .dark-theme .draggable-row:hover,\n[data-v-d222eb8d] .v-theme--dark .draggable-row:hover {\n  background-color: rgba(255, 255, 255, 0.05);\n}\n.drag-handle-cell[data-v-d222eb8d] {\n  width: 40px;\n  text-align: center;\n  padding: 8px 4px;\n}\n.drag-handle[data-v-d222eb8d] {\n  cursor: grab;\n  opacity: 0.6;\n  transition: opacity 0.2s ease;\n}\n.drag-handle[data-v-d222eb8d]:hover {\n  opacity: 1;\n}\n.drag-handle[data-v-d222eb8d]:active {\n  cursor: grabbing;\n}\n.drag-source[data-v-d222eb8d] {\n  opacity: 0.5;\n  background-color: rgba(25, 118, 210, 0.1) !important;\n}\n.drag-over[data-v-d222eb8d] {\n  background-color: rgba(25, 118, 210, 0.2) !important;\n  border-top: 2px solid #1976d2;\n  transform: translateY(-1px);\n}\n.drag-active .draggable-row[data-v-d222eb8d]:not(.drag-source):not(.drag-over) {\n  opacity: 0.7;\n}\n[data-v-d222eb8d] .dark-theme .drag-source,\n[data-v-d222eb8d] .v-theme--dark .drag-source {\n  background-color: rgba(144, 202, 249, 0.1) !important;\n}\n[data-v-d222eb8d] .dark-theme .drag-over,\n[data-v-d222eb8d] .v-theme--dark .drag-over {\n  background-color: rgba(144, 202, 249, 0.2) !important;\n  border-top: 2px solid #90caf9;\n}\n.expanded-row[data-v-d222eb8d] {\n  background-color: var(--surface-secondary);\n}\n\n/* sfc-style:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/Invoice.vue?type=style&index=0 */\n.cards[data-v-698ff108] {\n  background-color: var(--surface-secondary) !important;\n}\n.v-checkbox-btn.v-selected[data-v-698ff108] {\n  background-color: var(--submit-start) !important;\n  color: white;\n}\n.border_line_bottom[data-v-698ff108] {\n  border-bottom: 1px solid var(--field-border);\n}\n.disable-events[data-v-698ff108] {\n  pointer-events: none;\n}\n[data-v-698ff108] .balance-field {\n  display: flex;\n  align-items: center;\n  justify-content: flex-end;\n}\n[data-v-698ff108] .balance-value {\n  font-size: 1.5rem;\n  font-weight: bold;\n  color: var(--primary-start);\n  margin-left: var(--dynamic-xs);\n}\n.return-mode[data-v-698ff108] {\n  border: 2px solid rgb(var(--v-theme-error)) !important;\n  position: relative;\n}\n.return-mode[data-v-698ff108]::before {\n  content: \"RETURN\";\n  position: absolute;\n  top: 0;\n  right: 0;\n  background-color: rgb(var(--v-theme-error));\n  color: white;\n  padding: 4px 12px;\n  font-weight: bold;\n  border-bottom-left-radius: 8px;\n  z-index: 1;\n}\n.dynamic-padding[data-v-698ff108] {\n  padding: var(--dynamic-xs) var(--dynamic-sm) var(--dynamic-xs) var(--dynamic-sm);\n}\n@media (max-width: 768px) {\n  .dynamic-padding[data-v-698ff108] {\n    padding: var(--dynamic-xs) var(--dynamic-xs) var(--dynamic-xs) var(--dynamic-xs);\n  }\n  .dynamic-padding .v-row[data-v-698ff108] {\n    margin: 0 -2px;\n  }\n  .dynamic-padding .v-col[data-v-698ff108] {\n    padding: 2px 4px;\n  }\n}\n@media (max-width: 480px) {\n  .dynamic-padding[data-v-698ff108] {\n    padding: var(--dynamic-xs) var(--dynamic-xs) var(--dynamic-xs) var(--dynamic-xs);\n  }\n  .dynamic-padding .v-row[data-v-698ff108] {\n    margin: 0 -1px;\n  }\n  .dynamic-padding .v-col[data-v-698ff108] {\n    padding: 1px 2px;\n  }\n}\n.column-selector-container[data-v-698ff108] {\n  display: flex;\n  justify-content: flex-end;\n  padding: 8px 16px;\n  background-color: var(--surface-secondary);\n  border-radius: 8px 8px 0 0;\n}\n[data-v-698ff108] .dark-theme .column-selector-container,\n[data-v-698ff108] .v-theme--dark .column-selector-container {\n  background-color: #1E1E1E;\n}\n.column-selector-btn[data-v-698ff108] {\n  font-size: 0.875rem;\n}\n[data-v-698ff108] .column-switch {\n  margin: 0;\n  padding: 0;\n}\n[data-v-698ff108] .column-switch .v-switch__track {\n  opacity: 0.7;\n}\n[data-v-698ff108] .column-switch .v-switch__thumb {\n  transform: scale(0.8);\n}\n[data-v-698ff108] .column-switch .v-label {\n  opacity: 0.9;\n  font-size: 0.95rem;\n}\n\n/* sfc-style:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/OpeningDialog.vue?type=style&index=0 */\n.opening-dialog-card[data-v-6c820fa0] {\n  border-radius: 16px;\n  overflow: hidden;\n  background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);\n  border: 1px solid rgba(25, 118, 210, 0.1);\n  transition: all 0.3s ease;\n  max-height: 90vh;\n  display: flex;\n  flex-direction: column;\n}\n.opening-dialog-header[data-v-6c820fa0] {\n  background: white;\n  color: #1976d2;\n  padding: 16px 24px;\n  border-bottom: 2px solid rgba(25, 118, 210, 0.1);\n  flex-shrink: 0;\n}\n.header-content[data-v-6c820fa0] {\n  display: flex;\n  align-items: center;\n  gap: 12px;\n}\n.header-icon-wrapper[data-v-6c820fa0] {\n  background: rgba(25, 118, 210, 0.1);\n  border-radius: 50%;\n  padding: 8px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: all 0.3s ease;\n}\n.header-icon[data-v-6c820fa0] {\n  font-size: 20px;\n  color: #1976d2;\n}\n.header-text[data-v-6c820fa0] {\n  flex: 1;\n}\n.header-title[data-v-6c820fa0] {\n  font-size: 1.3rem;\n  font-weight: 600;\n  margin: 0;\n  line-height: 1.2;\n  color: #1976d2;\n}\n.header-subtitle[data-v-6c820fa0] {\n  font-size: 0.85rem;\n  opacity: 0.8;\n  margin: 2px 0 0 0;\n  line-height: 1.3;\n  color: #1976d2;\n}\n.opening-dialog-content[data-v-6c820fa0] {\n  padding: 20px 24px;\n  background: white;\n  flex: 1;\n  overflow-y: auto;\n}\n.section-header-compact[data-v-6c820fa0] {\n  margin-bottom: 12px;\n}\n.section-title-compact[data-v-6c820fa0] {\n  display: flex;\n  align-items: center;\n  gap: 6px;\n  font-size: 1rem;\n  font-weight: 600;\n  color: #1976d2;\n  margin-bottom: 0;\n}\n.section-icon[data-v-6c820fa0] {\n  color: #1976d2;\n  font-size: 18px;\n}\n.form-field[data-v-6c820fa0] {\n  margin-bottom: 12px;\n}\n.enhanced-field[data-v-6c820fa0] {\n  transition: all 0.3s ease;\n}\n.enhanced-field[data-v-6c820fa0]:hover {\n  transform: translateY(-1px);\n}\n.field-focused[data-v-6c820fa0] {\n  background: rgba(25, 118, 210, 0.02);\n  border-radius: 8px;\n}\n.enhanced-table-compact[data-v-6c820fa0] {\n  border-radius: 8px;\n  overflow: hidden;\n  box-shadow: 0 1px 8px rgba(0, 0, 0, 0.06);\n  border: 1px solid rgba(25, 118, 210, 0.1);\n}\n.enhanced-table-compact[data-v-6c820fa0] .v-data-table__wrapper {\n  border-radius: 8px;\n}\n.enhanced-table-compact[data-v-6c820fa0] th {\n  background: linear-gradient(135deg, #f8f9fa 0%, #e3f2fd 100%);\n  color: #1976d2;\n  font-weight: 600;\n  border-bottom: 1px solid rgba(25, 118, 210, 0.1);\n  padding: 8px 12px;\n}\n.enhanced-table-compact[data-v-6c820fa0] td {\n  padding: 6px 12px;\n}\n.enhanced-table-compact[data-v-6c820fa0] tr:hover {\n  background: rgba(25, 118, 210, 0.04);\n}\n.amount-editor[data-v-6c820fa0] {\n  width: 100%;\n}\n.amount-display-compact[data-v-6c820fa0] {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: 4px;\n  padding: 4px 8px;\n  background: rgba(25, 118, 210, 0.05);\n  border-radius: 6px;\n  transition: all 0.3s ease;\n  cursor: pointer;\n  min-height: 32px;\n}\n.amount-display-compact[data-v-6c820fa0]:hover {\n  background: rgba(25, 118, 210, 0.1);\n  transform: scale(1.01);\n}\n.currency-symbol[data-v-6c820fa0] {\n  font-weight: 600;\n  color: #1976d2;\n  font-size: 0.9rem;\n}\n.amount-value[data-v-6c820fa0] {\n  font-weight: 500;\n  color: #333;\n  font-size: 0.9rem;\n}\n.amount-input[data-v-6c820fa0] {\n  margin-top: 4px;\n}\n.opening-dialog-actions-compact[data-v-6c820fa0] {\n  padding: 24px;\n  display: flex;\n  gap: 24px;\n}\n.action-btn-revamped[data-v-6c820fa0] {\n  padding: 16px 24px !important;\n  border-radius: 12px !important;\n  font-weight: 700 !important;\n  text-transform: uppercase !important;\n  letter-spacing: 1px !important;\n  font-size: 1.3rem !important;\n  transition: all 0.3s ease !important;\n  position: relative;\n  overflow: hidden;\n  min-width: 180px !important;\n  border: none !important;\n}\n.action-btn-revamped .v-icon[data-v-6c820fa0] {\n  font-size: 1.8rem !important;\n}\n.button-text[data-v-6c820fa0] {\n  position: relative;\n  z-index: 2;\n}\n.cancel-btn-revamped[data-v-6c820fa0] {\n  background: linear-gradient(135deg, #ff5252 0%, #d32f2f 100%) !important;\n  box-shadow: 0 4px 20px rgba(211, 47, 47, 0.4) !important;\n}\n.cancel-btn-revamped[data-v-6c820fa0]:hover {\n  box-shadow: 0 6px 25px rgba(211, 47, 47, 0.6) !important;\n  transform: translateY(-3px);\n}\n.cancel-btn-revamped[data-v-6c820fa0]:active {\n  transform: translateY(1px);\n  box-shadow: 0 2px 10px rgba(211, 47, 47, 0.4) !important;\n}\n.submit-btn-revamped[data-v-6c820fa0] {\n  background: linear-gradient(135deg, #4caf50 0%, #2e7d32 100%) !important;\n  box-shadow: 0 4px 20px rgba(46, 125, 50, 0.4) !important;\n}\n.submit-btn-revamped[data-v-6c820fa0]:hover {\n  box-shadow: 0 6px 25px rgba(46, 125, 50, 0.6) !important;\n  transform: translateY(-3px);\n}\n.submit-btn-revamped[data-v-6c820fa0]:hover:before {\n  opacity: 1;\n}\n.submit-btn-revamped[data-v-6c820fa0]:active {\n  transform: translateY(1px);\n  box-shadow: 0 2px 10px rgba(46, 125, 50, 0.4) !important;\n}\n.submit-btn-revamped[data-v-6c820fa0]:disabled {\n  background: linear-gradient(135deg, #9e9e9e 0%, #757575 100%) !important;\n  box-shadow: none !important;\n  transform: none !important;\n  opacity: 0.7;\n}\n@media (max-width: 768px) {\n  .opening-dialog-header[data-v-6c820fa0] {\n    padding: 12px 16px;\n  }\n  .header-content[data-v-6c820fa0] {\n    gap: 8px;\n  }\n  .header-title[data-v-6c820fa0] {\n    font-size: 1.2rem;\n  }\n  .opening-dialog-content[data-v-6c820fa0] {\n    padding: 16px;\n  }\n  .opening-dialog-actions-compact[data-v-6c820fa0] {\n    padding: 12px 16px;\n  }\n  .action-btn-compact[data-v-6c820fa0] {\n    padding: 6px 12px;\n    min-width: 70px;\n  }\n}\n@media (max-width: 480px) {\n  .header-content[data-v-6c820fa0] {\n    flex-direction: column;\n    text-align: center;\n    gap: 8px;\n  }\n  .opening-dialog-content[data-v-6c820fa0] {\n    padding: 12px;\n  }\n  .action-btn-compact[data-v-6c820fa0] {\n    margin-left: 4px;\n    padding: 6px 10px;\n    min-width: 60px;\n  }\n}\n@keyframes slideInFromTop-6c820fa0 {\n  from {\n    opacity: 0;\n    transform: translateY(-20px);\n  }\n  to {\n    opacity: 1;\n    transform: translateY(0);\n  }\n}\n.opening-dialog-card[data-v-6c820fa0] {\n  animation: slideInFromTop-6c820fa0 0.4s ease-out;\n}\n.enhanced-field[data-v-6c820fa0] .v-field--focused {\n  box-shadow: 0 0 0 2px rgba(25, 118, 210, 0.1);\n}\n.enhanced-table-compact[data-v-6c820fa0] .v-data-table-row--clickable:hover {\n  background: rgba(25, 118, 210, 0.04) !important;\n}\n.enhanced-field[data-v-6c820fa0] .v-field--focused .v-field__outline {\n  border-color: rgba(25, 118, 210, 0.3) !important;\n  border-width: 1px !important;\n}\n.enhanced-field[data-v-6c820fa0] .v-field--focused .v-field__overlay {\n  background: rgba(25, 118, 210, 0.02);\n}\n.dialog-actions-container[data-v-6c820fa0] {\n  background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);\n  border-top: 1px solid #e0e0e0;\n  padding: 16px 24px;\n  gap: 12px;\n}\n.pos-action-btn[data-v-6c820fa0] {\n  border-radius: 12px;\n  text-transform: none;\n  font-weight: 600;\n  padding: 12px 32px;\n  min-width: 120px;\n  transition: all 0.3s ease;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n}\n.pos-action-btn[data-v-6c820fa0],\n.pos-action-btn .v-icon[data-v-6c820fa0],\n.pos-action-btn span[data-v-6c820fa0],\n.pos-action-btn[data-v-6c820fa0] .v-btn__content {\n  color: white !important;\n}\n.cancel-action-btn[data-v-6c820fa0] {\n  background: linear-gradient(135deg, #d32f2f 0%, #c62828 100%) !important;\n}\n.cancel-action-btn[data-v-6c820fa0]:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 6px 20px rgba(211, 47, 47, 0.4);\n}\n.submit-action-btn[data-v-6c820fa0] {\n  background: linear-gradient(135deg, #388e3c 0%, #2e7d32 100%) !important;\n}\n.submit-action-btn[data-v-6c820fa0]:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 6px 20px rgba(46, 125, 50, 0.4);\n}\n.submit-action-btn[data-v-6c820fa0]:disabled {\n  opacity: 0.6;\n  transform: none;\n}\n\n/* sfc-style:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/Payments.vue?type=style&index=0 */\n.v-text-field[data-v-4f3b00ab] {\n  composes: pos-form-field;\n}\n.v-text-field--readonly[data-v-4f3b00ab] {\n  cursor: text;\n}\n.v-text-field--readonly[data-v-4f3b00ab]:hover {\n  background-color: transparent;\n}\n.cards[data-v-4f3b00ab] {\n  background-color: var(--surface-secondary) !important;\n}\n\n/* sfc-style:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/PosCoupons.vue?type=style&index=0 */\n.coupon-input[data-v-04579dff] {\n  height: 40px;\n}\n.add-coupon-btn[data-v-04579dff] {\n  height: 40px;\n  font-weight: 600 !important;\n  transition: all 0.3s ease !important;\n}\n.add-coupon-btn[data-v-04579dff]:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);\n}\n\n/* sfc-style:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/ClosingDialog.vue?type=style&index=0 */\n.closing-header[data-v-a28dc816] {\n  background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);\n  border-bottom: 1px solid #e0e0e0;\n  padding: 24px !important;\n}\n.header-content[data-v-a28dc816] {\n  display: flex;\n  align-items: center;\n  gap: 20px;\n  width: 100%;\n}\n.header-icon-wrapper[data-v-a28dc816] {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 64px;\n  height: 64px;\n  background: linear-gradient(135deg, #1976d2 0%, #1565c0 100%);\n  border-radius: 16px;\n  box-shadow: 0 4px 12px rgba(25, 118, 210, 0.3);\n}\n.header-icon[data-v-a28dc816] {\n  color: white !important;\n}\n.header-text[data-v-a28dc816] {\n  flex: 1;\n}\n.header-title[data-v-a28dc816] {\n  font-size: 1.5rem;\n  font-weight: 600;\n  color: #1a1a1a;\n  margin: 0 0 4px 0;\n  line-height: 1.2;\n}\n.header-subtitle[data-v-a28dc816] {\n  font-size: 0.95rem;\n  color: #666;\n  margin: 0;\n  font-weight: 400;\n}\n.header-divider[data-v-a28dc816] {\n  border-color: #e0e0e0;\n}\n.white-background[data-v-a28dc816] {\n  background-color: #ffffff;\n}\n.table-header[data-v-a28dc816] {\n  padding: 0 4px;\n}\n.white-table[data-v-a28dc816] {\n  background-color: white;\n  border: 1px solid #e0e0e0;\n}\n.dialog-actions-container[data-v-a28dc816] {\n  background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);\n  border-top: 1px solid #e0e0e0;\n  padding: 16px 24px;\n  gap: 12px;\n}\n.pos-action-btn[data-v-a28dc816] {\n  border-radius: 12px;\n  text-transform: none;\n  font-weight: 600;\n  padding: 12px 32px;\n  min-width: 120px;\n  transition: all 0.3s ease;\n  color: white !important;\n}\n.pos-action-btn .v-icon[data-v-a28dc816] {\n  color: white !important;\n}\n.pos-action-btn span[data-v-a28dc816] {\n  color: white !important;\n}\n.pos-action-btn:disabled .v-icon[data-v-a28dc816],\n.pos-action-btn:disabled span[data-v-a28dc816] {\n  color: white !important;\n}\n.cancel-action-btn[data-v-a28dc816] {\n  background: linear-gradient(135deg, #d32f2f 0%, #c62828 100%) !important;\n}\n.submit-action-btn[data-v-a28dc816] {\n  background: linear-gradient(135deg, #388e3c 0%, #2e7d32 100%) !important;\n}\n.submit-action-btn[data-v-a28dc816]:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 6px 20px rgba(46, 125, 50, 0.4);\n}\n.cancel-action-btn[data-v-a28dc816]:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 6px 20px rgba(211, 47, 47, 0.4);\n}\n.submit-action-btn[data-v-a28dc816]:disabled {\n  opacity: 0.6;\n  transform: none;\n}\n@media (max-width: 768px) {\n  .dialog-actions-container[data-v-a28dc816] {\n    flex-direction: column;\n    gap: 12px;\n  }\n  .pos-action-btn[data-v-a28dc816] {\n    width: 100%;\n  }\n}\n\n/* sfc-style:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/NewAddress.vue?type=style&index=0 */\n[data-v-96aa8cfb] .dark-theme .dark-field,\n[data-v-96aa8cfb] .v-theme--dark .dark-field,\n[data-v-96aa8cfb] .dark-theme .dark-field,\n[data-v-96aa8cfb] .v-theme--dark .dark-field {\n  background-color: #1E1E1E !important;\n}\n[data-v-96aa8cfb] .dark-theme .dark-field :deep(.v-field__input),\n[data-v-96aa8cfb] .v-theme--dark .dark-field :deep(.v-field__input),\n[data-v-96aa8cfb] .dark-theme .dark-field :deep(input),\n[data-v-96aa8cfb] .v-theme--dark .dark-field :deep(input),\n[data-v-96aa8cfb] .dark-theme .dark-field :deep(.v-label),\n[data-v-96aa8cfb] .v-theme--dark .dark-field :deep(.v-label),\n[data-v-96aa8cfb] .dark-theme .dark-field .v-field__input,\n[data-v-96aa8cfb] .v-theme--dark .dark-field .v-field__input,\n[data-v-96aa8cfb] .dark-theme .dark-field input,\n[data-v-96aa8cfb] .v-theme--dark .dark-field input,\n[data-v-96aa8cfb] .dark-theme .dark-field .v-label,\n[data-v-96aa8cfb] .v-theme--dark .dark-field .v-label {\n  color: #fff !important;\n}\n[data-v-96aa8cfb] .dark-theme .dark-field :deep(.v-field__overlay),\n[data-v-96aa8cfb] .v-theme--dark .dark-field :deep(.v-field__overlay),\n[data-v-96aa8cfb] .dark-theme .dark-field .v-field__overlay,\n[data-v-96aa8cfb] .v-theme--dark .dark-field .v-field__overlay {\n  background-color: #1E1E1E !important;\n}\n\n/* sfc-style:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/Pos.vue?type=style&index=0 */\n.dynamic-container[data-v-d5091f4d] {\n  padding-top: calc(25px + var(--dynamic-lg));\n  transition: all 0.3s ease;\n}\n.dynamic-main-row[data-v-d5091f4d] {\n  padding: 0;\n  margin: 0;\n}\n.dynamic-col[data-v-d5091f4d] {\n  padding: var(--dynamic-sm);\n  transition: padding 0.3s ease;\n  margin-top: var(--dynamic-sm);\n}\n@media (max-width: 768px) {\n  .dynamic-container[data-v-d5091f4d] {\n    padding-top: calc(56px + var(--dynamic-md));\n  }\n  .dynamic-col[data-v-d5091f4d] {\n    padding: var(--dynamic-xs);\n    margin-top: var(--dynamic-xs);\n  }\n}\n\n/* sfc-style:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/payments/Pay.vue?type=style&index=0 */\n:deep(.dark-theme) .dark-field,\n:deep(.v-theme--dark) .dark-field,\n::v-deep(.dark-theme) .dark-field,\n::v-deep(.v-theme--dark) .dark-field {\n  background-color: #1E1E1E !important;\n}\n:deep(.dark-theme) .dark-field :deep(.v-field__input),\n:deep(.v-theme--dark) .dark-field :deep(.v-field__input),\n:deep(.dark-theme) .dark-field :deep(input),\n:deep(.v-theme--dark) .dark-field :deep(input),\n:deep(.dark-theme) .dark-field :deep(.v-label),\n:deep(.v-theme--dark) .dark-field :deep(.v-label),\n::v-deep(.dark-theme) .dark-field .v-field__input,\n::v-deep(.v-theme--dark) .dark-field .v-field__input,\n::v-deep(.dark-theme) .dark-field input,\n::v-deep(.v-theme--dark) .dark-field input,\n::v-deep(.dark-theme) .dark-field .v-label,\n::v-deep(.v-theme--dark) .dark-field .v-label {\n  color: #fff !important;\n}\n:deep(.dark-theme) .dark-field :deep(.v-field__overlay),\n:deep(.v-theme--dark) .dark-field :deep(.v-field__overlay),\n::v-deep(.dark-theme) .dark-field .v-field__overlay,\n::v-deep(.v-theme--dark) .dark-field .v-field__overlay {\n  background-color: #1E1E1E !important;\n}\ninput[total_of_diff] {\n  text-align: right;\n}\ninput[payments_methods] {\n  text-align: right;\n}\ninput[total_selected_payments] {\n  text-align: right;\n}\ninput[total_selected_invoices] {\n  text-align: right;\n}\ninput[total_selected_mpesa_payments] {\n  text-align: right;\n}\n.selected-row {\n  background-color: #e3f2fd !important;\n}\n\n/* sfc-style:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/Home.vue?type=style&index=0 */\n.container1[data-v-528f966a] {\n  height: 100vh;\n  overflow: hidden;\n}\n.main-content[data-v-528f966a] {\n  height: 100vh;\n  display: flex;\n  flex-direction: column;\n}\n.page-content[data-v-528f966a] {\n  flex: 1;\n  overflow-y: auto;\n  padding-top: 8px;\n}\n[data-v-528f966a] .v-main__wrap {\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n}\n/*# sourceMappingURL=posawesome.bundle.4T7T7PDC.css.map */\n");
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to2, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to2, key) && key !== except)
          __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // ../posawesome/node_modules/dexie/dist/dexie.js
  var require_dexie = __commonJS({
    "../posawesome/node_modules/dexie/dist/dexie.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.Dexie = factory());
      })(exports, function() {
        "use strict";
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p2 in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p2))
                d2[p2] = b2[p2];
          };
          return extendStatics(d, b);
        };
        function __extends(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __2() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__2.prototype = b.prototype, new __2());
        }
        var __assign = function() {
          __assign = Object.assign || function __assign2(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p2 in s)
                if (Object.prototype.hasOwnProperty.call(s, p2))
                  t[p2] = s[p2];
            }
            return t;
          };
          return __assign.apply(this, arguments);
        };
        function __spreadArray(to2, from, pack) {
          if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar2; i < l; i++) {
              if (ar2 || !(i in from)) {
                if (!ar2)
                  ar2 = Array.prototype.slice.call(from, 0, i);
                ar2[i] = from[i];
              }
            }
          return to2.concat(ar2 || Array.prototype.slice.call(from));
        }
        var _global2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
        var keys2 = Object.keys;
        var isArray2 = Array.isArray;
        if (typeof Promise !== "undefined" && !_global2.Promise) {
          _global2.Promise = Promise;
        }
        function extend2(obj, extension) {
          if (typeof extension !== "object")
            return obj;
          keys2(extension).forEach(function(key) {
            obj[key] = extension[key];
          });
          return obj;
        }
        var getProto2 = Object.getPrototypeOf;
        var _hasOwn = {}.hasOwnProperty;
        function hasOwn3(obj, prop) {
          return _hasOwn.call(obj, prop);
        }
        function props(proto, extension) {
          if (typeof extension === "function")
            extension = extension(getProto2(proto));
          (typeof Reflect === "undefined" ? keys2 : Reflect.ownKeys)(extension).forEach(function(key) {
            setProp(proto, key, extension[key]);
          });
        }
        var defineProperty = Object.defineProperty;
        function setProp(obj, prop, functionOrGetSet, options) {
          defineProperty(obj, prop, extend2(functionOrGetSet && hasOwn3(functionOrGetSet, "get") && typeof functionOrGetSet.get === "function" ? { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } : { value: functionOrGetSet, configurable: true, writable: true }, options));
        }
        function derive(Child) {
          return {
            from: function(Parent) {
              Child.prototype = Object.create(Parent.prototype);
              setProp(Child.prototype, "constructor", Child);
              return {
                extend: props.bind(null, Child.prototype)
              };
            }
          };
        }
        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        function getPropertyDescriptor(obj, prop) {
          var pd = getOwnPropertyDescriptor(obj, prop);
          var proto;
          return pd || (proto = getProto2(obj)) && getPropertyDescriptor(proto, prop);
        }
        var _slice = [].slice;
        function slice(args, start, end) {
          return _slice.call(args, start, end);
        }
        function override(origFunc, overridedFactory) {
          return overridedFactory(origFunc);
        }
        function assert(b) {
          if (!b)
            throw new Error("Assertion Failed");
        }
        function asap$1(fn2) {
          if (_global2.setImmediate)
            setImmediate(fn2);
          else
            setTimeout(fn2, 0);
        }
        function arrayToObject(array, extractor) {
          return array.reduce(function(result, item, i) {
            var nameAndValue = extractor(item, i);
            if (nameAndValue)
              result[nameAndValue[0]] = nameAndValue[1];
            return result;
          }, {});
        }
        function getByKeyPath(obj, keyPath) {
          if (typeof keyPath === "string" && hasOwn3(obj, keyPath))
            return obj[keyPath];
          if (!keyPath)
            return obj;
          if (typeof keyPath !== "string") {
            var rv = [];
            for (var i = 0, l = keyPath.length; i < l; ++i) {
              var val = getByKeyPath(obj, keyPath[i]);
              rv.push(val);
            }
            return rv;
          }
          var period = keyPath.indexOf(".");
          if (period !== -1) {
            var innerObj = obj[keyPath.substr(0, period)];
            return innerObj == null ? void 0 : getByKeyPath(innerObj, keyPath.substr(period + 1));
          }
          return void 0;
        }
        function setByKeyPath(obj, keyPath, value) {
          if (!obj || keyPath === void 0)
            return;
          if ("isFrozen" in Object && Object.isFrozen(obj))
            return;
          if (typeof keyPath !== "string" && "length" in keyPath) {
            assert(typeof value !== "string" && "length" in value);
            for (var i = 0, l = keyPath.length; i < l; ++i) {
              setByKeyPath(obj, keyPath[i], value[i]);
            }
          } else {
            var period = keyPath.indexOf(".");
            if (period !== -1) {
              var currentKeyPath = keyPath.substr(0, period);
              var remainingKeyPath = keyPath.substr(period + 1);
              if (remainingKeyPath === "")
                if (value === void 0) {
                  if (isArray2(obj) && !isNaN(parseInt(currentKeyPath)))
                    obj.splice(currentKeyPath, 1);
                  else
                    delete obj[currentKeyPath];
                } else
                  obj[currentKeyPath] = value;
              else {
                var innerObj = obj[currentKeyPath];
                if (!innerObj || !hasOwn3(obj, currentKeyPath))
                  innerObj = obj[currentKeyPath] = {};
                setByKeyPath(innerObj, remainingKeyPath, value);
              }
            } else {
              if (value === void 0) {
                if (isArray2(obj) && !isNaN(parseInt(keyPath)))
                  obj.splice(keyPath, 1);
                else
                  delete obj[keyPath];
              } else
                obj[keyPath] = value;
            }
          }
        }
        function delByKeyPath(obj, keyPath) {
          if (typeof keyPath === "string")
            setByKeyPath(obj, keyPath, void 0);
          else if ("length" in keyPath)
            [].map.call(keyPath, function(kp) {
              setByKeyPath(obj, kp, void 0);
            });
        }
        function shallowClone(obj) {
          var rv = {};
          for (var m in obj) {
            if (hasOwn3(obj, m))
              rv[m] = obj[m];
          }
          return rv;
        }
        var concat = [].concat;
        function flatten(a) {
          return concat.apply([], a);
        }
        var intrinsicTypeNames = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(flatten([8, 16, 32, 64].map(function(num) {
          return ["Int", "Uint", "Float"].map(function(t) {
            return t + num + "Array";
          });
        }))).filter(function(t) {
          return _global2[t];
        });
        var intrinsicTypes = new Set(intrinsicTypeNames.map(function(t) {
          return _global2[t];
        }));
        function cloneSimpleObjectTree(o) {
          var rv = {};
          for (var k in o)
            if (hasOwn3(o, k)) {
              var v = o[k];
              rv[k] = !v || typeof v !== "object" || intrinsicTypes.has(v.constructor) ? v : cloneSimpleObjectTree(v);
            }
          return rv;
        }
        function objectIsEmpty(o) {
          for (var k in o)
            if (hasOwn3(o, k))
              return false;
          return true;
        }
        var circularRefs = null;
        function deepClone(any) {
          circularRefs = /* @__PURE__ */ new WeakMap();
          var rv = innerDeepClone(any);
          circularRefs = null;
          return rv;
        }
        function innerDeepClone(x) {
          if (!x || typeof x !== "object")
            return x;
          var rv = circularRefs.get(x);
          if (rv)
            return rv;
          if (isArray2(x)) {
            rv = [];
            circularRefs.set(x, rv);
            for (var i = 0, l = x.length; i < l; ++i) {
              rv.push(innerDeepClone(x[i]));
            }
          } else if (intrinsicTypes.has(x.constructor)) {
            rv = x;
          } else {
            var proto = getProto2(x);
            rv = proto === Object.prototype ? {} : Object.create(proto);
            circularRefs.set(x, rv);
            for (var prop in x) {
              if (hasOwn3(x, prop)) {
                rv[prop] = innerDeepClone(x[prop]);
              }
            }
          }
          return rv;
        }
        var toString2 = {}.toString;
        function toStringTag(o) {
          return toString2.call(o).slice(8, -1);
        }
        var iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
        var getIteratorOf = typeof iteratorSymbol === "symbol" ? function(x) {
          var i;
          return x != null && (i = x[iteratorSymbol]) && i.apply(x);
        } : function() {
          return null;
        };
        function delArrayItem(a, x) {
          var i = a.indexOf(x);
          if (i >= 0)
            a.splice(i, 1);
          return i >= 0;
        }
        var NO_CHAR_ARRAY = {};
        function getArrayOf(arrayLike) {
          var i, a, x, it2;
          if (arguments.length === 1) {
            if (isArray2(arrayLike))
              return arrayLike.slice();
            if (this === NO_CHAR_ARRAY && typeof arrayLike === "string")
              return [arrayLike];
            if (it2 = getIteratorOf(arrayLike)) {
              a = [];
              while (x = it2.next(), !x.done)
                a.push(x.value);
              return a;
            }
            if (arrayLike == null)
              return [arrayLike];
            i = arrayLike.length;
            if (typeof i === "number") {
              a = new Array(i);
              while (i--)
                a[i] = arrayLike[i];
              return a;
            }
            return [arrayLike];
          }
          i = arguments.length;
          a = new Array(i);
          while (i--)
            a[i] = arguments[i];
          return a;
        }
        var isAsyncFunction = typeof Symbol !== "undefined" ? function(fn2) {
          return fn2[Symbol.toStringTag] === "AsyncFunction";
        } : function() {
          return false;
        };
        var dexieErrorNames = [
          "Modify",
          "Bulk",
          "OpenFailed",
          "VersionChange",
          "Schema",
          "Upgrade",
          "InvalidTable",
          "MissingAPI",
          "NoSuchDatabase",
          "InvalidArgument",
          "SubTransaction",
          "Unsupported",
          "Internal",
          "DatabaseClosed",
          "PrematureCommit",
          "ForeignAwait"
        ];
        var idbDomErrorNames = [
          "Unknown",
          "Constraint",
          "Data",
          "TransactionInactive",
          "ReadOnly",
          "Version",
          "NotFound",
          "InvalidState",
          "InvalidAccess",
          "Abort",
          "Timeout",
          "QuotaExceeded",
          "Syntax",
          "DataClone"
        ];
        var errorList = dexieErrorNames.concat(idbDomErrorNames);
        var defaultTexts = {
          VersionChanged: "Database version changed by other database connection",
          DatabaseClosed: "Database has been closed",
          Abort: "Transaction aborted",
          TransactionInactive: "Transaction has already completed or failed",
          MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
        };
        function DexieError(name, msg) {
          this.name = name;
          this.message = msg;
        }
        derive(DexieError).from(Error).extend({
          toString: function() {
            return this.name + ": " + this.message;
          }
        });
        function getMultiErrorMessage(msg, failures) {
          return msg + ". Errors: " + Object.keys(failures).map(function(key) {
            return failures[key].toString();
          }).filter(function(v, i, s) {
            return s.indexOf(v) === i;
          }).join("\n");
        }
        function ModifyError(msg, failures, successCount, failedKeys) {
          this.failures = failures;
          this.failedKeys = failedKeys;
          this.successCount = successCount;
          this.message = getMultiErrorMessage(msg, failures);
        }
        derive(ModifyError).from(DexieError);
        function BulkError(msg, failures) {
          this.name = "BulkError";
          this.failures = Object.keys(failures).map(function(pos) {
            return failures[pos];
          });
          this.failuresByPos = failures;
          this.message = getMultiErrorMessage(msg, this.failures);
        }
        derive(BulkError).from(DexieError);
        var errnames = errorList.reduce(function(obj, name) {
          return obj[name] = name + "Error", obj;
        }, {});
        var BaseException = DexieError;
        var exceptions = errorList.reduce(function(obj, name) {
          var fullName = name + "Error";
          function DexieError2(msgOrInner, inner) {
            this.name = fullName;
            if (!msgOrInner) {
              this.message = defaultTexts[name] || fullName;
              this.inner = null;
            } else if (typeof msgOrInner === "string") {
              this.message = "".concat(msgOrInner).concat(!inner ? "" : "\n " + inner);
              this.inner = inner || null;
            } else if (typeof msgOrInner === "object") {
              this.message = "".concat(msgOrInner.name, " ").concat(msgOrInner.message);
              this.inner = msgOrInner;
            }
          }
          derive(DexieError2).from(BaseException);
          obj[name] = DexieError2;
          return obj;
        }, {});
        exceptions.Syntax = SyntaxError;
        exceptions.Type = TypeError;
        exceptions.Range = RangeError;
        var exceptionMap = idbDomErrorNames.reduce(function(obj, name) {
          obj[name + "Error"] = exceptions[name];
          return obj;
        }, {});
        function mapError(domError, message2) {
          if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])
            return domError;
          var rv = new exceptionMap[domError.name](message2 || domError.message, domError);
          if ("stack" in domError) {
            setProp(rv, "stack", { get: function() {
              return this.inner.stack;
            } });
          }
          return rv;
        }
        var fullNameExceptions = errorList.reduce(function(obj, name) {
          if (["Syntax", "Type", "Range"].indexOf(name) === -1)
            obj[name + "Error"] = exceptions[name];
          return obj;
        }, {});
        fullNameExceptions.ModifyError = ModifyError;
        fullNameExceptions.DexieError = DexieError;
        fullNameExceptions.BulkError = BulkError;
        function nop() {
        }
        function mirror(val) {
          return val;
        }
        function pureFunctionChain(f1, f2) {
          if (f1 == null || f1 === mirror)
            return f2;
          return function(val) {
            return f2(f1(val));
          };
        }
        function callBoth(on1, on2) {
          return function() {
            on1.apply(this, arguments);
            on2.apply(this, arguments);
          };
        }
        function hookCreatingChain(f1, f2) {
          if (f1 === nop)
            return f2;
          return function() {
            var res = f1.apply(this, arguments);
            if (res !== void 0)
              arguments[0] = res;
            var onsuccess = this.onsuccess, onerror = this.onerror;
            this.onsuccess = null;
            this.onerror = null;
            var res2 = f2.apply(this, arguments);
            if (onsuccess)
              this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror)
              this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
            return res2 !== void 0 ? res2 : res;
          };
        }
        function hookDeletingChain(f1, f2) {
          if (f1 === nop)
            return f2;
          return function() {
            f1.apply(this, arguments);
            var onsuccess = this.onsuccess, onerror = this.onerror;
            this.onsuccess = this.onerror = null;
            f2.apply(this, arguments);
            if (onsuccess)
              this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror)
              this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
          };
        }
        function hookUpdatingChain(f1, f2) {
          if (f1 === nop)
            return f2;
          return function(modifications) {
            var res = f1.apply(this, arguments);
            extend2(modifications, res);
            var onsuccess = this.onsuccess, onerror = this.onerror;
            this.onsuccess = null;
            this.onerror = null;
            var res2 = f2.apply(this, arguments);
            if (onsuccess)
              this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror)
              this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
            return res === void 0 ? res2 === void 0 ? void 0 : res2 : extend2(res, res2);
          };
        }
        function reverseStoppableEventChain(f1, f2) {
          if (f1 === nop)
            return f2;
          return function() {
            if (f2.apply(this, arguments) === false)
              return false;
            return f1.apply(this, arguments);
          };
        }
        function promisableChain(f1, f2) {
          if (f1 === nop)
            return f2;
          return function() {
            var res = f1.apply(this, arguments);
            if (res && typeof res.then === "function") {
              var thiz = this, i = arguments.length, args = new Array(i);
              while (i--)
                args[i] = arguments[i];
              return res.then(function() {
                return f2.apply(thiz, args);
              });
            }
            return f2.apply(this, arguments);
          };
        }
        var debug = typeof location !== "undefined" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
        function setDebug(value, filter) {
          debug = value;
        }
        var INTERNAL = {};
        var ZONE_ECHO_LIMIT = 100, _a$1 = typeof Promise === "undefined" ? [] : function() {
          var globalP = Promise.resolve();
          if (typeof crypto === "undefined" || !crypto.subtle)
            return [globalP, getProto2(globalP), globalP];
          var nativeP = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
          return [
            nativeP,
            getProto2(nativeP),
            globalP
          ];
        }(), resolvedNativePromise = _a$1[0], nativePromiseProto = _a$1[1], resolvedGlobalPromise = _a$1[2], nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
        var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
        var patchGlobalPromise = !!resolvedGlobalPromise;
        function schedulePhysicalTick() {
          queueMicrotask(physicalTick);
        }
        var asap = function(callback, args) {
          microtickQueue.push([callback, args]);
          if (needsNewPhysicalTick) {
            schedulePhysicalTick();
            needsNewPhysicalTick = false;
          }
        };
        var isOutsideMicroTick = true, needsNewPhysicalTick = true, unhandledErrors = [], rejectingErrors = [], rejectionMapper = mirror;
        var globalPSD = {
          id: "global",
          global: true,
          ref: 0,
          unhandleds: [],
          onunhandled: nop,
          pgp: false,
          env: {},
          finalize: nop
        };
        var PSD = globalPSD;
        var microtickQueue = [];
        var numScheduledCalls = 0;
        var tickFinalizers = [];
        function DexiePromise(fn2) {
          if (typeof this !== "object")
            throw new TypeError("Promises must be constructed via new");
          this._listeners = [];
          this._lib = false;
          var psd = this._PSD = PSD;
          if (typeof fn2 !== "function") {
            if (fn2 !== INTERNAL)
              throw new TypeError("Not a function");
            this._state = arguments[1];
            this._value = arguments[2];
            if (this._state === false)
              handleRejection(this, this._value);
            return;
          }
          this._state = null;
          this._value = null;
          ++psd.ref;
          executePromiseTask(this, fn2);
        }
        var thenProp = {
          get: function() {
            var psd = PSD, microTaskId = totalEchoes;
            function then(onFulfilled, onRejected) {
              var _this = this;
              var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
              var cleanup = possibleAwait && !decrementExpectedAwaits();
              var rv = new DexiePromise(function(resolve2, reject) {
                propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve2, reject, psd));
              });
              if (this._consoleTask)
                rv._consoleTask = this._consoleTask;
              return rv;
            }
            then.prototype = INTERNAL;
            return then;
          },
          set: function(value) {
            setProp(this, "then", value && value.prototype === INTERNAL ? thenProp : {
              get: function() {
                return value;
              },
              set: thenProp.set
            });
          }
        };
        props(DexiePromise.prototype, {
          then: thenProp,
          _then: function(onFulfilled, onRejected) {
            propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
          },
          catch: function(onRejected) {
            if (arguments.length === 1)
              return this.then(null, onRejected);
            var type2 = arguments[0], handler = arguments[1];
            return typeof type2 === "function" ? this.then(null, function(err) {
              return err instanceof type2 ? handler(err) : PromiseReject(err);
            }) : this.then(null, function(err) {
              return err && err.name === type2 ? handler(err) : PromiseReject(err);
            });
          },
          finally: function(onFinally) {
            return this.then(function(value) {
              return DexiePromise.resolve(onFinally()).then(function() {
                return value;
              });
            }, function(err) {
              return DexiePromise.resolve(onFinally()).then(function() {
                return PromiseReject(err);
              });
            });
          },
          timeout: function(ms, msg) {
            var _this = this;
            return ms < Infinity ? new DexiePromise(function(resolve2, reject) {
              var handle = setTimeout(function() {
                return reject(new exceptions.Timeout(msg));
              }, ms);
              _this.then(resolve2, reject).finally(clearTimeout.bind(null, handle));
            }) : this;
          }
        });
        if (typeof Symbol !== "undefined" && Symbol.toStringTag)
          setProp(DexiePromise.prototype, Symbol.toStringTag, "Dexie.Promise");
        globalPSD.env = snapShot();
        function Listener(onFulfilled, onRejected, resolve2, reject, zone) {
          this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
          this.onRejected = typeof onRejected === "function" ? onRejected : null;
          this.resolve = resolve2;
          this.reject = reject;
          this.psd = zone;
        }
        props(DexiePromise, {
          all: function() {
            var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new DexiePromise(function(resolve2, reject) {
              if (values.length === 0)
                resolve2([]);
              var remaining = values.length;
              values.forEach(function(a, i) {
                return DexiePromise.resolve(a).then(function(x) {
                  values[i] = x;
                  if (!--remaining)
                    resolve2(values);
                }, reject);
              });
            });
          },
          resolve: function(value) {
            if (value instanceof DexiePromise)
              return value;
            if (value && typeof value.then === "function")
              return new DexiePromise(function(resolve2, reject) {
                value.then(resolve2, reject);
              });
            var rv = new DexiePromise(INTERNAL, true, value);
            return rv;
          },
          reject: PromiseReject,
          race: function() {
            var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new DexiePromise(function(resolve2, reject) {
              values.map(function(value) {
                return DexiePromise.resolve(value).then(resolve2, reject);
              });
            });
          },
          PSD: {
            get: function() {
              return PSD;
            },
            set: function(value) {
              return PSD = value;
            }
          },
          totalEchoes: { get: function() {
            return totalEchoes;
          } },
          newPSD: newScope,
          usePSD,
          scheduler: {
            get: function() {
              return asap;
            },
            set: function(value) {
              asap = value;
            }
          },
          rejectionMapper: {
            get: function() {
              return rejectionMapper;
            },
            set: function(value) {
              rejectionMapper = value;
            }
          },
          follow: function(fn2, zoneProps) {
            return new DexiePromise(function(resolve2, reject) {
              return newScope(function(resolve3, reject2) {
                var psd = PSD;
                psd.unhandleds = [];
                psd.onunhandled = reject2;
                psd.finalize = callBoth(function() {
                  var _this = this;
                  run_at_end_of_this_or_next_physical_tick(function() {
                    _this.unhandleds.length === 0 ? resolve3() : reject2(_this.unhandleds[0]);
                  });
                }, psd.finalize);
                fn2();
              }, zoneProps, resolve2, reject);
            });
          }
        });
        if (NativePromise) {
          if (NativePromise.allSettled)
            setProp(DexiePromise, "allSettled", function() {
              var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
              return new DexiePromise(function(resolve2) {
                if (possiblePromises.length === 0)
                  resolve2([]);
                var remaining = possiblePromises.length;
                var results = new Array(remaining);
                possiblePromises.forEach(function(p2, i) {
                  return DexiePromise.resolve(p2).then(function(value) {
                    return results[i] = { status: "fulfilled", value };
                  }, function(reason) {
                    return results[i] = { status: "rejected", reason };
                  }).then(function() {
                    return --remaining || resolve2(results);
                  });
                });
              });
            });
          if (NativePromise.any && typeof AggregateError !== "undefined")
            setProp(DexiePromise, "any", function() {
              var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
              return new DexiePromise(function(resolve2, reject) {
                if (possiblePromises.length === 0)
                  reject(new AggregateError([]));
                var remaining = possiblePromises.length;
                var failures = new Array(remaining);
                possiblePromises.forEach(function(p2, i) {
                  return DexiePromise.resolve(p2).then(function(value) {
                    return resolve2(value);
                  }, function(failure) {
                    failures[i] = failure;
                    if (!--remaining)
                      reject(new AggregateError(failures));
                  });
                });
              });
            });
          if (NativePromise.withResolvers)
            DexiePromise.withResolvers = NativePromise.withResolvers;
        }
        function executePromiseTask(promise, fn2) {
          try {
            fn2(function(value) {
              if (promise._state !== null)
                return;
              if (value === promise)
                throw new TypeError("A promise cannot be resolved with itself.");
              var shouldExecuteTick = promise._lib && beginMicroTickScope();
              if (value && typeof value.then === "function") {
                executePromiseTask(promise, function(resolve2, reject) {
                  value instanceof DexiePromise ? value._then(resolve2, reject) : value.then(resolve2, reject);
                });
              } else {
                promise._state = true;
                promise._value = value;
                propagateAllListeners(promise);
              }
              if (shouldExecuteTick)
                endMicroTickScope();
            }, handleRejection.bind(null, promise));
          } catch (ex) {
            handleRejection(promise, ex);
          }
        }
        function handleRejection(promise, reason) {
          rejectingErrors.push(reason);
          if (promise._state !== null)
            return;
          var shouldExecuteTick = promise._lib && beginMicroTickScope();
          reason = rejectionMapper(reason);
          promise._state = false;
          promise._value = reason;
          addPossiblyUnhandledError(promise);
          propagateAllListeners(promise);
          if (shouldExecuteTick)
            endMicroTickScope();
        }
        function propagateAllListeners(promise) {
          var listeners = promise._listeners;
          promise._listeners = [];
          for (var i = 0, len = listeners.length; i < len; ++i) {
            propagateToListener(promise, listeners[i]);
          }
          var psd = promise._PSD;
          --psd.ref || psd.finalize();
          if (numScheduledCalls === 0) {
            ++numScheduledCalls;
            asap(function() {
              if (--numScheduledCalls === 0)
                finalizePhysicalTick();
            }, []);
          }
        }
        function propagateToListener(promise, listener) {
          if (promise._state === null) {
            promise._listeners.push(listener);
            return;
          }
          var cb = promise._state ? listener.onFulfilled : listener.onRejected;
          if (cb === null) {
            return (promise._state ? listener.resolve : listener.reject)(promise._value);
          }
          ++listener.psd.ref;
          ++numScheduledCalls;
          asap(callListener, [cb, promise, listener]);
        }
        function callListener(cb, promise, listener) {
          try {
            var ret, value = promise._value;
            if (!promise._state && rejectingErrors.length)
              rejectingErrors = [];
            ret = debug && promise._consoleTask ? promise._consoleTask.run(function() {
              return cb(value);
            }) : cb(value);
            if (!promise._state && rejectingErrors.indexOf(value) === -1) {
              markErrorAsHandled(promise);
            }
            listener.resolve(ret);
          } catch (e) {
            listener.reject(e);
          } finally {
            if (--numScheduledCalls === 0)
              finalizePhysicalTick();
            --listener.psd.ref || listener.psd.finalize();
          }
        }
        function physicalTick() {
          usePSD(globalPSD, function() {
            beginMicroTickScope() && endMicroTickScope();
          });
        }
        function beginMicroTickScope() {
          var wasRootExec = isOutsideMicroTick;
          isOutsideMicroTick = false;
          needsNewPhysicalTick = false;
          return wasRootExec;
        }
        function endMicroTickScope() {
          var callbacks, i, l;
          do {
            while (microtickQueue.length > 0) {
              callbacks = microtickQueue;
              microtickQueue = [];
              l = callbacks.length;
              for (i = 0; i < l; ++i) {
                var item = callbacks[i];
                item[0].apply(null, item[1]);
              }
            }
          } while (microtickQueue.length > 0);
          isOutsideMicroTick = true;
          needsNewPhysicalTick = true;
        }
        function finalizePhysicalTick() {
          var unhandledErrs = unhandledErrors;
          unhandledErrors = [];
          unhandledErrs.forEach(function(p2) {
            p2._PSD.onunhandled.call(null, p2._value, p2);
          });
          var finalizers = tickFinalizers.slice(0);
          var i = finalizers.length;
          while (i)
            finalizers[--i]();
        }
        function run_at_end_of_this_or_next_physical_tick(fn2) {
          function finalizer() {
            fn2();
            tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
          }
          tickFinalizers.push(finalizer);
          ++numScheduledCalls;
          asap(function() {
            if (--numScheduledCalls === 0)
              finalizePhysicalTick();
          }, []);
        }
        function addPossiblyUnhandledError(promise) {
          if (!unhandledErrors.some(function(p2) {
            return p2._value === promise._value;
          }))
            unhandledErrors.push(promise);
        }
        function markErrorAsHandled(promise) {
          var i = unhandledErrors.length;
          while (i)
            if (unhandledErrors[--i]._value === promise._value) {
              unhandledErrors.splice(i, 1);
              return;
            }
        }
        function PromiseReject(reason) {
          return new DexiePromise(INTERNAL, false, reason);
        }
        function wrap(fn2, errorCatcher) {
          var psd = PSD;
          return function() {
            var wasRootExec = beginMicroTickScope(), outerScope = PSD;
            try {
              switchToZone(psd, true);
              return fn2.apply(this, arguments);
            } catch (e) {
              errorCatcher && errorCatcher(e);
            } finally {
              switchToZone(outerScope, false);
              if (wasRootExec)
                endMicroTickScope();
            }
          };
        }
        var task = { awaits: 0, echoes: 0, id: 0 };
        var taskCounter = 0;
        var zoneStack = [];
        var zoneEchoes = 0;
        var totalEchoes = 0;
        var zone_id_counter = 0;
        function newScope(fn2, props2, a1, a2) {
          var parent = PSD, psd = Object.create(parent);
          psd.parent = parent;
          psd.ref = 0;
          psd.global = false;
          psd.id = ++zone_id_counter;
          globalPSD.env;
          psd.env = patchGlobalPromise ? {
            Promise: DexiePromise,
            PromiseProp: { value: DexiePromise, configurable: true, writable: true },
            all: DexiePromise.all,
            race: DexiePromise.race,
            allSettled: DexiePromise.allSettled,
            any: DexiePromise.any,
            resolve: DexiePromise.resolve,
            reject: DexiePromise.reject
          } : {};
          if (props2)
            extend2(psd, props2);
          ++parent.ref;
          psd.finalize = function() {
            --this.parent.ref || this.parent.finalize();
          };
          var rv = usePSD(psd, fn2, a1, a2);
          if (psd.ref === 0)
            psd.finalize();
          return rv;
        }
        function incrementExpectedAwaits() {
          if (!task.id)
            task.id = ++taskCounter;
          ++task.awaits;
          task.echoes += ZONE_ECHO_LIMIT;
          return task.id;
        }
        function decrementExpectedAwaits() {
          if (!task.awaits)
            return false;
          if (--task.awaits === 0)
            task.id = 0;
          task.echoes = task.awaits * ZONE_ECHO_LIMIT;
          return true;
        }
        if (("" + nativePromiseThen).indexOf("[native code]") === -1) {
          incrementExpectedAwaits = decrementExpectedAwaits = nop;
        }
        function onPossibleParallellAsync(possiblePromise) {
          if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
            incrementExpectedAwaits();
            return possiblePromise.then(function(x) {
              decrementExpectedAwaits();
              return x;
            }, function(e) {
              decrementExpectedAwaits();
              return rejection(e);
            });
          }
          return possiblePromise;
        }
        function zoneEnterEcho(targetZone) {
          ++totalEchoes;
          if (!task.echoes || --task.echoes === 0) {
            task.echoes = task.awaits = task.id = 0;
          }
          zoneStack.push(PSD);
          switchToZone(targetZone, true);
        }
        function zoneLeaveEcho() {
          var zone = zoneStack[zoneStack.length - 1];
          zoneStack.pop();
          switchToZone(zone, false);
        }
        function switchToZone(targetZone, bEnteringZone) {
          var currentZone = PSD;
          if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {
            queueMicrotask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
          }
          if (targetZone === PSD)
            return;
          PSD = targetZone;
          if (currentZone === globalPSD)
            globalPSD.env = snapShot();
          if (patchGlobalPromise) {
            var GlobalPromise = globalPSD.env.Promise;
            var targetEnv = targetZone.env;
            if (currentZone.global || targetZone.global) {
              Object.defineProperty(_global2, "Promise", targetEnv.PromiseProp);
              GlobalPromise.all = targetEnv.all;
              GlobalPromise.race = targetEnv.race;
              GlobalPromise.resolve = targetEnv.resolve;
              GlobalPromise.reject = targetEnv.reject;
              if (targetEnv.allSettled)
                GlobalPromise.allSettled = targetEnv.allSettled;
              if (targetEnv.any)
                GlobalPromise.any = targetEnv.any;
            }
          }
        }
        function snapShot() {
          var GlobalPromise = _global2.Promise;
          return patchGlobalPromise ? {
            Promise: GlobalPromise,
            PromiseProp: Object.getOwnPropertyDescriptor(_global2, "Promise"),
            all: GlobalPromise.all,
            race: GlobalPromise.race,
            allSettled: GlobalPromise.allSettled,
            any: GlobalPromise.any,
            resolve: GlobalPromise.resolve,
            reject: GlobalPromise.reject
          } : {};
        }
        function usePSD(psd, fn2, a1, a2, a3) {
          var outerScope = PSD;
          try {
            switchToZone(psd, true);
            return fn2(a1, a2, a3);
          } finally {
            switchToZone(outerScope, false);
          }
        }
        function nativeAwaitCompatibleWrap(fn2, zone, possibleAwait, cleanup) {
          return typeof fn2 !== "function" ? fn2 : function() {
            var outerZone = PSD;
            if (possibleAwait)
              incrementExpectedAwaits();
            switchToZone(zone, true);
            try {
              return fn2.apply(this, arguments);
            } finally {
              switchToZone(outerZone, false);
              if (cleanup)
                queueMicrotask(decrementExpectedAwaits);
            }
          };
        }
        function execInGlobalContext(cb) {
          if (Promise === NativePromise && task.echoes === 0) {
            if (zoneEchoes === 0) {
              cb();
            } else {
              enqueueNativeMicroTask(cb);
            }
          } else {
            setTimeout(cb, 0);
          }
        }
        var rejection = DexiePromise.reject;
        function tempTransaction(db3, mode, storeNames, fn2) {
          if (!db3.idbdb || !db3._state.openComplete && (!PSD.letThrough && !db3._vip)) {
            if (db3._state.openComplete) {
              return rejection(new exceptions.DatabaseClosed(db3._state.dbOpenError));
            }
            if (!db3._state.isBeingOpened) {
              if (!db3._state.autoOpen)
                return rejection(new exceptions.DatabaseClosed());
              db3.open().catch(nop);
            }
            return db3._state.dbReadyPromise.then(function() {
              return tempTransaction(db3, mode, storeNames, fn2);
            });
          } else {
            var trans = db3._createTransaction(mode, storeNames, db3._dbSchema);
            try {
              trans.create();
              db3._state.PR1398_maxLoop = 3;
            } catch (ex) {
              if (ex.name === errnames.InvalidState && db3.isOpen() && --db3._state.PR1398_maxLoop > 0) {
                console.warn("Dexie: Need to reopen db");
                db3.close({ disableAutoOpen: false });
                return db3.open().then(function() {
                  return tempTransaction(db3, mode, storeNames, fn2);
                });
              }
              return rejection(ex);
            }
            return trans._promise(mode, function(resolve2, reject) {
              return newScope(function() {
                PSD.trans = trans;
                return fn2(resolve2, reject, trans);
              });
            }).then(function(result) {
              if (mode === "readwrite")
                try {
                  trans.idbtrans.commit();
                } catch (_a4) {
                }
              return mode === "readonly" ? result : trans._completion.then(function() {
                return result;
              });
            });
          }
        }
        var DEXIE_VERSION = "4.0.11";
        var maxString = String.fromCharCode(65535);
        var minKey = -Infinity;
        var INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
        var STRING_EXPECTED = "String expected.";
        var connections = [];
        var DBNAMES_DB = "__dbnames";
        var READONLY = "readonly";
        var READWRITE = "readwrite";
        function combine(filter1, filter2) {
          return filter1 ? filter2 ? function() {
            return filter1.apply(this, arguments) && filter2.apply(this, arguments);
          } : filter1 : filter2;
        }
        var AnyRange = {
          type: 3,
          lower: -Infinity,
          lowerOpen: false,
          upper: [[]],
          upperOpen: false
        };
        function workaroundForUndefinedPrimKey(keyPath) {
          return typeof keyPath === "string" && !/\./.test(keyPath) ? function(obj) {
            if (obj[keyPath] === void 0 && keyPath in obj) {
              obj = deepClone(obj);
              delete obj[keyPath];
            }
            return obj;
          } : function(obj) {
            return obj;
          };
        }
        function Entity2() {
          throw exceptions.Type();
        }
        function cmp2(a, b) {
          try {
            var ta = type(a);
            var tb = type(b);
            if (ta !== tb) {
              if (ta === "Array")
                return 1;
              if (tb === "Array")
                return -1;
              if (ta === "binary")
                return 1;
              if (tb === "binary")
                return -1;
              if (ta === "string")
                return 1;
              if (tb === "string")
                return -1;
              if (ta === "Date")
                return 1;
              if (tb !== "Date")
                return NaN;
              return -1;
            }
            switch (ta) {
              case "number":
              case "Date":
              case "string":
                return a > b ? 1 : a < b ? -1 : 0;
              case "binary": {
                return compareUint8Arrays(getUint8Array(a), getUint8Array(b));
              }
              case "Array":
                return compareArrays(a, b);
            }
          } catch (_a4) {
          }
          return NaN;
        }
        function compareArrays(a, b) {
          var al = a.length;
          var bl = b.length;
          var l = al < bl ? al : bl;
          for (var i = 0; i < l; ++i) {
            var res = cmp2(a[i], b[i]);
            if (res !== 0)
              return res;
          }
          return al === bl ? 0 : al < bl ? -1 : 1;
        }
        function compareUint8Arrays(a, b) {
          var al = a.length;
          var bl = b.length;
          var l = al < bl ? al : bl;
          for (var i = 0; i < l; ++i) {
            if (a[i] !== b[i])
              return a[i] < b[i] ? -1 : 1;
          }
          return al === bl ? 0 : al < bl ? -1 : 1;
        }
        function type(x) {
          var t = typeof x;
          if (t !== "object")
            return t;
          if (ArrayBuffer.isView(x))
            return "binary";
          var tsTag = toStringTag(x);
          return tsTag === "ArrayBuffer" ? "binary" : tsTag;
        }
        function getUint8Array(a) {
          if (a instanceof Uint8Array)
            return a;
          if (ArrayBuffer.isView(a))
            return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
          return new Uint8Array(a);
        }
        var Table = function() {
          function Table2() {
          }
          Table2.prototype._trans = function(mode, fn2, writeLocked) {
            var trans = this._tx || PSD.trans;
            var tableName = this.name;
            var task2 = debug && typeof console !== "undefined" && console.createTask && console.createTask("Dexie: ".concat(mode === "readonly" ? "read" : "write", " ").concat(this.name));
            function checkTableInTransaction(resolve2, reject, trans2) {
              if (!trans2.schema[tableName])
                throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
              return fn2(trans2.idbtrans, trans2);
            }
            var wasRootExec = beginMicroTickScope();
            try {
              var p2 = trans && trans.db._novip === this.db._novip ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(function() {
                return trans._promise(mode, checkTableInTransaction, writeLocked);
              }, { trans, transless: PSD.transless || PSD }) : tempTransaction(this.db, mode, [this.name], checkTableInTransaction);
              if (task2) {
                p2._consoleTask = task2;
                p2 = p2.catch(function(err) {
                  console.trace(err);
                  return rejection(err);
                });
              }
              return p2;
            } finally {
              if (wasRootExec)
                endMicroTickScope();
            }
          };
          Table2.prototype.get = function(keyOrCrit, cb) {
            var _this = this;
            if (keyOrCrit && keyOrCrit.constructor === Object)
              return this.where(keyOrCrit).first(cb);
            if (keyOrCrit == null)
              return rejection(new exceptions.Type("Invalid argument to Table.get()"));
            return this._trans("readonly", function(trans) {
              return _this.core.get({ trans, key: keyOrCrit }).then(function(res) {
                return _this.hook.reading.fire(res);
              });
            }).then(cb);
          };
          Table2.prototype.where = function(indexOrCrit) {
            if (typeof indexOrCrit === "string")
              return new this.db.WhereClause(this, indexOrCrit);
            if (isArray2(indexOrCrit))
              return new this.db.WhereClause(this, "[".concat(indexOrCrit.join("+"), "]"));
            var keyPaths = keys2(indexOrCrit);
            if (keyPaths.length === 1)
              return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);
            var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function(ix) {
              if (ix.compound && keyPaths.every(function(keyPath) {
                return ix.keyPath.indexOf(keyPath) >= 0;
              })) {
                for (var i = 0; i < keyPaths.length; ++i) {
                  if (keyPaths.indexOf(ix.keyPath[i]) === -1)
                    return false;
                }
                return true;
              }
              return false;
            }).sort(function(a, b) {
              return a.keyPath.length - b.keyPath.length;
            })[0];
            if (compoundIndex && this.db._maxKey !== maxString) {
              var keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);
              return this.where(keyPathsInValidOrder).equals(keyPathsInValidOrder.map(function(kp) {
                return indexOrCrit[kp];
              }));
            }
            if (!compoundIndex && debug)
              console.warn("The query ".concat(JSON.stringify(indexOrCrit), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(keyPaths.join("+"), "]"));
            var idxByName = this.schema.idxByName;
            function equals(a, b) {
              return cmp2(a, b) === 0;
            }
            var _a4 = keyPaths.reduce(function(_a5, keyPath) {
              var prevIndex = _a5[0], prevFilterFn = _a5[1];
              var index = idxByName[keyPath];
              var value = indexOrCrit[keyPath];
              return [
                prevIndex || index,
                prevIndex || !index ? combine(prevFilterFn, index && index.multi ? function(x) {
                  var prop = getByKeyPath(x, keyPath);
                  return isArray2(prop) && prop.some(function(item) {
                    return equals(value, item);
                  });
                } : function(x) {
                  return equals(value, getByKeyPath(x, keyPath));
                }) : prevFilterFn
              ];
            }, [null, null]), idx = _a4[0], filterFunction = _a4[1];
            return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals("");
          };
          Table2.prototype.filter = function(filterFunction) {
            return this.toCollection().and(filterFunction);
          };
          Table2.prototype.count = function(thenShortcut) {
            return this.toCollection().count(thenShortcut);
          };
          Table2.prototype.offset = function(offset) {
            return this.toCollection().offset(offset);
          };
          Table2.prototype.limit = function(numRows) {
            return this.toCollection().limit(numRows);
          };
          Table2.prototype.each = function(callback) {
            return this.toCollection().each(callback);
          };
          Table2.prototype.toArray = function(thenShortcut) {
            return this.toCollection().toArray(thenShortcut);
          };
          Table2.prototype.toCollection = function() {
            return new this.db.Collection(new this.db.WhereClause(this));
          };
          Table2.prototype.orderBy = function(index) {
            return new this.db.Collection(new this.db.WhereClause(this, isArray2(index) ? "[".concat(index.join("+"), "]") : index));
          };
          Table2.prototype.reverse = function() {
            return this.toCollection().reverse();
          };
          Table2.prototype.mapToClass = function(constructor) {
            var _a4 = this, db3 = _a4.db, tableName = _a4.name;
            this.schema.mappedClass = constructor;
            if (constructor.prototype instanceof Entity2) {
              constructor = function(_super) {
                __extends(class_1, _super);
                function class_1() {
                  return _super !== null && _super.apply(this, arguments) || this;
                }
                Object.defineProperty(class_1.prototype, "db", {
                  get: function() {
                    return db3;
                  },
                  enumerable: false,
                  configurable: true
                });
                class_1.prototype.table = function() {
                  return tableName;
                };
                return class_1;
              }(constructor);
            }
            var inheritedProps = /* @__PURE__ */ new Set();
            for (var proto = constructor.prototype; proto; proto = getProto2(proto)) {
              Object.getOwnPropertyNames(proto).forEach(function(propName) {
                return inheritedProps.add(propName);
              });
            }
            var readHook = function(obj) {
              if (!obj)
                return obj;
              var res = Object.create(constructor.prototype);
              for (var m in obj)
                if (!inheritedProps.has(m))
                  try {
                    res[m] = obj[m];
                  } catch (_2) {
                  }
              return res;
            };
            if (this.schema.readHook) {
              this.hook.reading.unsubscribe(this.schema.readHook);
            }
            this.schema.readHook = readHook;
            this.hook("reading", readHook);
            return constructor;
          };
          Table2.prototype.defineClass = function() {
            function Class(content) {
              extend2(this, content);
            }
            return this.mapToClass(Class);
          };
          Table2.prototype.add = function(obj, key) {
            var _this = this;
            var _a4 = this.schema.primKey, auto = _a4.auto, keyPath = _a4.keyPath;
            var objToAdd = obj;
            if (keyPath && auto) {
              objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
            }
            return this._trans("readwrite", function(trans) {
              return _this.core.mutate({ trans, type: "add", keys: key != null ? [key] : null, values: [objToAdd] });
            }).then(function(res) {
              return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;
            }).then(function(lastResult) {
              if (keyPath) {
                try {
                  setByKeyPath(obj, keyPath, lastResult);
                } catch (_2) {
                }
              }
              return lastResult;
            });
          };
          Table2.prototype.update = function(keyOrObject, modifications) {
            if (typeof keyOrObject === "object" && !isArray2(keyOrObject)) {
              var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
              if (key === void 0)
                return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));
              return this.where(":id").equals(key).modify(modifications);
            } else {
              return this.where(":id").equals(keyOrObject).modify(modifications);
            }
          };
          Table2.prototype.put = function(obj, key) {
            var _this = this;
            var _a4 = this.schema.primKey, auto = _a4.auto, keyPath = _a4.keyPath;
            var objToAdd = obj;
            if (keyPath && auto) {
              objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
            }
            return this._trans("readwrite", function(trans) {
              return _this.core.mutate({ trans, type: "put", values: [objToAdd], keys: key != null ? [key] : null });
            }).then(function(res) {
              return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;
            }).then(function(lastResult) {
              if (keyPath) {
                try {
                  setByKeyPath(obj, keyPath, lastResult);
                } catch (_2) {
                }
              }
              return lastResult;
            });
          };
          Table2.prototype.delete = function(key) {
            var _this = this;
            return this._trans("readwrite", function(trans) {
              return _this.core.mutate({ trans, type: "delete", keys: [key] });
            }).then(function(res) {
              return res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0;
            });
          };
          Table2.prototype.clear = function() {
            var _this = this;
            return this._trans("readwrite", function(trans) {
              return _this.core.mutate({ trans, type: "deleteRange", range: AnyRange });
            }).then(function(res) {
              return res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0;
            });
          };
          Table2.prototype.bulkGet = function(keys3) {
            var _this = this;
            return this._trans("readonly", function(trans) {
              return _this.core.getMany({
                keys: keys3,
                trans
              }).then(function(result) {
                return result.map(function(res) {
                  return _this.hook.reading.fire(res);
                });
              });
            });
          };
          Table2.prototype.bulkAdd = function(objects, keysOrOptions, options) {
            var _this = this;
            var keys3 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
            options = options || (keys3 ? void 0 : keysOrOptions);
            var wantResults = options ? options.allKeys : void 0;
            return this._trans("readwrite", function(trans) {
              var _a4 = _this.schema.primKey, auto = _a4.auto, keyPath = _a4.keyPath;
              if (keyPath && keys3)
                throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
              if (keys3 && keys3.length !== objects.length)
                throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
              var numObjects = objects.length;
              var objectsToAdd = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
              return _this.core.mutate({ trans, type: "add", keys: keys3, values: objectsToAdd, wantResults }).then(function(_a5) {
                var numFailures = _a5.numFailures, results = _a5.results, lastResult = _a5.lastResult, failures = _a5.failures;
                var result = wantResults ? results : lastResult;
                if (numFailures === 0)
                  return result;
                throw new BulkError("".concat(_this.name, ".bulkAdd(): ").concat(numFailures, " of ").concat(numObjects, " operations failed"), failures);
              });
            });
          };
          Table2.prototype.bulkPut = function(objects, keysOrOptions, options) {
            var _this = this;
            var keys3 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
            options = options || (keys3 ? void 0 : keysOrOptions);
            var wantResults = options ? options.allKeys : void 0;
            return this._trans("readwrite", function(trans) {
              var _a4 = _this.schema.primKey, auto = _a4.auto, keyPath = _a4.keyPath;
              if (keyPath && keys3)
                throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
              if (keys3 && keys3.length !== objects.length)
                throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
              var numObjects = objects.length;
              var objectsToPut = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
              return _this.core.mutate({ trans, type: "put", keys: keys3, values: objectsToPut, wantResults }).then(function(_a5) {
                var numFailures = _a5.numFailures, results = _a5.results, lastResult = _a5.lastResult, failures = _a5.failures;
                var result = wantResults ? results : lastResult;
                if (numFailures === 0)
                  return result;
                throw new BulkError("".concat(_this.name, ".bulkPut(): ").concat(numFailures, " of ").concat(numObjects, " operations failed"), failures);
              });
            });
          };
          Table2.prototype.bulkUpdate = function(keysAndChanges) {
            var _this = this;
            var coreTable = this.core;
            var keys3 = keysAndChanges.map(function(entry) {
              return entry.key;
            });
            var changeSpecs = keysAndChanges.map(function(entry) {
              return entry.changes;
            });
            var offsetMap = [];
            return this._trans("readwrite", function(trans) {
              return coreTable.getMany({ trans, keys: keys3, cache: "clone" }).then(function(objs) {
                var resultKeys = [];
                var resultObjs = [];
                keysAndChanges.forEach(function(_a4, idx) {
                  var key = _a4.key, changes = _a4.changes;
                  var obj = objs[idx];
                  if (obj) {
                    for (var _i2 = 0, _b = Object.keys(changes); _i2 < _b.length; _i2++) {
                      var keyPath = _b[_i2];
                      var value = changes[keyPath];
                      if (keyPath === _this.schema.primKey.keyPath) {
                        if (cmp2(value, key) !== 0) {
                          throw new exceptions.Constraint("Cannot update primary key in bulkUpdate()");
                        }
                      } else {
                        setByKeyPath(obj, keyPath, value);
                      }
                    }
                    offsetMap.push(idx);
                    resultKeys.push(key);
                    resultObjs.push(obj);
                  }
                });
                var numEntries = resultKeys.length;
                return coreTable.mutate({
                  trans,
                  type: "put",
                  keys: resultKeys,
                  values: resultObjs,
                  updates: {
                    keys: keys3,
                    changeSpecs
                  }
                }).then(function(_a4) {
                  var numFailures = _a4.numFailures, failures = _a4.failures;
                  if (numFailures === 0)
                    return numEntries;
                  for (var _i2 = 0, _b = Object.keys(failures); _i2 < _b.length; _i2++) {
                    var offset = _b[_i2];
                    var mappedOffset = offsetMap[Number(offset)];
                    if (mappedOffset != null) {
                      var failure = failures[offset];
                      delete failures[offset];
                      failures[mappedOffset] = failure;
                    }
                  }
                  throw new BulkError("".concat(_this.name, ".bulkUpdate(): ").concat(numFailures, " of ").concat(numEntries, " operations failed"), failures);
                });
              });
            });
          };
          Table2.prototype.bulkDelete = function(keys3) {
            var _this = this;
            var numKeys = keys3.length;
            return this._trans("readwrite", function(trans) {
              return _this.core.mutate({ trans, type: "delete", keys: keys3 });
            }).then(function(_a4) {
              var numFailures = _a4.numFailures, lastResult = _a4.lastResult, failures = _a4.failures;
              if (numFailures === 0)
                return lastResult;
              throw new BulkError("".concat(_this.name, ".bulkDelete(): ").concat(numFailures, " of ").concat(numKeys, " operations failed"), failures);
            });
          };
          return Table2;
        }();
        function Events(ctx) {
          var evs = {};
          var rv = function(eventName2, subscriber) {
            if (subscriber) {
              var i2 = arguments.length, args = new Array(i2 - 1);
              while (--i2)
                args[i2 - 1] = arguments[i2];
              evs[eventName2].subscribe.apply(null, args);
              return ctx;
            } else if (typeof eventName2 === "string") {
              return evs[eventName2];
            }
          };
          rv.addEventType = add4;
          for (var i = 1, l = arguments.length; i < l; ++i) {
            add4(arguments[i]);
          }
          return rv;
          function add4(eventName2, chainFunction, defaultFunction) {
            if (typeof eventName2 === "object")
              return addConfiguredEvents(eventName2);
            if (!chainFunction)
              chainFunction = reverseStoppableEventChain;
            if (!defaultFunction)
              defaultFunction = nop;
            var context = {
              subscribers: [],
              fire: defaultFunction,
              subscribe: function(cb) {
                if (context.subscribers.indexOf(cb) === -1) {
                  context.subscribers.push(cb);
                  context.fire = chainFunction(context.fire, cb);
                }
              },
              unsubscribe: function(cb) {
                context.subscribers = context.subscribers.filter(function(fn2) {
                  return fn2 !== cb;
                });
                context.fire = context.subscribers.reduce(chainFunction, defaultFunction);
              }
            };
            evs[eventName2] = rv[eventName2] = context;
            return context;
          }
          function addConfiguredEvents(cfg) {
            keys2(cfg).forEach(function(eventName2) {
              var args = cfg[eventName2];
              if (isArray2(args)) {
                add4(eventName2, cfg[eventName2][0], cfg[eventName2][1]);
              } else if (args === "asap") {
                var context = add4(eventName2, mirror, function fire() {
                  var i2 = arguments.length, args2 = new Array(i2);
                  while (i2--)
                    args2[i2] = arguments[i2];
                  context.subscribers.forEach(function(fn2) {
                    asap$1(function fireEvent() {
                      fn2.apply(null, args2);
                    });
                  });
                });
              } else
                throw new exceptions.InvalidArgument("Invalid event config");
            });
          }
        }
        function makeClassConstructor(prototype, constructor) {
          derive(constructor).from({ prototype });
          return constructor;
        }
        function createTableConstructor(db3) {
          return makeClassConstructor(Table.prototype, function Table2(name, tableSchema, trans) {
            this.db = db3;
            this._tx = trans;
            this.name = name;
            this.schema = tableSchema;
            this.hook = db3._allTables[name] ? db3._allTables[name].hook : Events(null, {
              "creating": [hookCreatingChain, nop],
              "reading": [pureFunctionChain, mirror],
              "updating": [hookUpdatingChain, nop],
              "deleting": [hookDeletingChain, nop]
            });
          });
        }
        function isPlainKeyRange(ctx, ignoreLimitFilter) {
          return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
        }
        function addFilter(ctx, fn2) {
          ctx.filter = combine(ctx.filter, fn2);
        }
        function addReplayFilter(ctx, factory, isLimitFilter) {
          var curr = ctx.replayFilter;
          ctx.replayFilter = curr ? function() {
            return combine(curr(), factory());
          } : factory;
          ctx.justLimit = isLimitFilter && !curr;
        }
        function addMatchFilter(ctx, fn2) {
          ctx.isMatch = combine(ctx.isMatch, fn2);
        }
        function getIndexOrStore(ctx, coreSchema) {
          if (ctx.isPrimKey)
            return coreSchema.primaryKey;
          var index = coreSchema.getIndexByKeyPath(ctx.index);
          if (!index)
            throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + coreSchema.name + " is not indexed");
          return index;
        }
        function openCursor(ctx, coreTable, trans) {
          var index = getIndexOrStore(ctx, coreTable.schema);
          return coreTable.openCursor({
            trans,
            values: !ctx.keysOnly,
            reverse: ctx.dir === "prev",
            unique: !!ctx.unique,
            query: {
              index,
              range: ctx.range
            }
          });
        }
        function iter(ctx, fn2, coreTrans, coreTable) {
          var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;
          if (!ctx.or) {
            return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn2, !ctx.keysOnly && ctx.valueMapper);
          } else {
            var set_1 = {};
            var union = function(item, cursor, advance) {
              if (!filter || filter(cursor, advance, function(result) {
                return cursor.stop(result);
              }, function(err) {
                return cursor.fail(err);
              })) {
                var primaryKey = cursor.primaryKey;
                var key = "" + primaryKey;
                if (key === "[object ArrayBuffer]")
                  key = "" + new Uint8Array(primaryKey);
                if (!hasOwn3(set_1, key)) {
                  set_1[key] = true;
                  fn2(item, cursor, advance);
                }
              }
            };
            return Promise.all([
              ctx.or._iterate(union, coreTrans),
              iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)
            ]);
          }
        }
        function iterate(cursorPromise, filter, fn2, valueMapper) {
          var mappedFn = valueMapper ? function(x, c, a) {
            return fn2(valueMapper(x), c, a);
          } : fn2;
          var wrappedFn = wrap(mappedFn);
          return cursorPromise.then(function(cursor) {
            if (cursor) {
              return cursor.start(function() {
                var c = function() {
                  return cursor.continue();
                };
                if (!filter || filter(cursor, function(advancer) {
                  return c = advancer;
                }, function(val) {
                  cursor.stop(val);
                  c = nop;
                }, function(e) {
                  cursor.fail(e);
                  c = nop;
                }))
                  wrappedFn(cursor.value, cursor, function(advancer) {
                    return c = advancer;
                  });
                c();
              });
            }
          });
        }
        var PropModification2 = function() {
          function PropModification3(spec) {
            this["@@propmod"] = spec;
          }
          PropModification3.prototype.execute = function(value) {
            var _a4;
            var spec = this["@@propmod"];
            if (spec.add !== void 0) {
              var term = spec.add;
              if (isArray2(term)) {
                return __spreadArray(__spreadArray([], isArray2(value) ? value : [], true), term, true).sort();
              }
              if (typeof term === "number")
                return (Number(value) || 0) + term;
              if (typeof term === "bigint") {
                try {
                  return BigInt(value) + term;
                } catch (_b) {
                  return BigInt(0) + term;
                }
              }
              throw new TypeError("Invalid term ".concat(term));
            }
            if (spec.remove !== void 0) {
              var subtrahend_1 = spec.remove;
              if (isArray2(subtrahend_1)) {
                return isArray2(value) ? value.filter(function(item) {
                  return !subtrahend_1.includes(item);
                }).sort() : [];
              }
              if (typeof subtrahend_1 === "number")
                return Number(value) - subtrahend_1;
              if (typeof subtrahend_1 === "bigint") {
                try {
                  return BigInt(value) - subtrahend_1;
                } catch (_c) {
                  return BigInt(0) - subtrahend_1;
                }
              }
              throw new TypeError("Invalid subtrahend ".concat(subtrahend_1));
            }
            var prefixToReplace = (_a4 = spec.replacePrefix) === null || _a4 === void 0 ? void 0 : _a4[0];
            if (prefixToReplace && typeof value === "string" && value.startsWith(prefixToReplace)) {
              return spec.replacePrefix[1] + value.substring(prefixToReplace.length);
            }
            return value;
          };
          return PropModification3;
        }();
        var Collection = function() {
          function Collection2() {
          }
          Collection2.prototype._read = function(fn2, cb) {
            var ctx = this._ctx;
            return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readonly", fn2).then(cb);
          };
          Collection2.prototype._write = function(fn2) {
            var ctx = this._ctx;
            return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readwrite", fn2, "locked");
          };
          Collection2.prototype._addAlgorithm = function(fn2) {
            var ctx = this._ctx;
            ctx.algorithm = combine(ctx.algorithm, fn2);
          };
          Collection2.prototype._iterate = function(fn2, coreTrans) {
            return iter(this._ctx, fn2, coreTrans, this._ctx.table.core);
          };
          Collection2.prototype.clone = function(props2) {
            var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);
            if (props2)
              extend2(ctx, props2);
            rv._ctx = ctx;
            return rv;
          };
          Collection2.prototype.raw = function() {
            this._ctx.valueMapper = null;
            return this;
          };
          Collection2.prototype.each = function(fn2) {
            var ctx = this._ctx;
            return this._read(function(trans) {
              return iter(ctx, fn2, trans, ctx.table.core);
            });
          };
          Collection2.prototype.count = function(cb) {
            var _this = this;
            return this._read(function(trans) {
              var ctx = _this._ctx;
              var coreTable = ctx.table.core;
              if (isPlainKeyRange(ctx, true)) {
                return coreTable.count({
                  trans,
                  query: {
                    index: getIndexOrStore(ctx, coreTable.schema),
                    range: ctx.range
                  }
                }).then(function(count2) {
                  return Math.min(count2, ctx.limit);
                });
              } else {
                var count = 0;
                return iter(ctx, function() {
                  ++count;
                  return false;
                }, trans, coreTable).then(function() {
                  return count;
                });
              }
            }).then(cb);
          };
          Collection2.prototype.sortBy = function(keyPath, cb) {
            var parts = keyPath.split(".").reverse(), lastPart = parts[0], lastIndex = parts.length - 1;
            function getval(obj, i) {
              if (i)
                return getval(obj[parts[i]], i - 1);
              return obj[lastPart];
            }
            var order = this._ctx.dir === "next" ? 1 : -1;
            function sorter(a, b) {
              var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);
              return cmp2(aVal, bVal) * order;
            }
            return this.toArray(function(a) {
              return a.sort(sorter);
            }).then(cb);
          };
          Collection2.prototype.toArray = function(cb) {
            var _this = this;
            return this._read(function(trans) {
              var ctx = _this._ctx;
              if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
                var valueMapper_1 = ctx.valueMapper;
                var index = getIndexOrStore(ctx, ctx.table.core.schema);
                return ctx.table.core.query({
                  trans,
                  limit: ctx.limit,
                  values: true,
                  query: {
                    index,
                    range: ctx.range
                  }
                }).then(function(_a4) {
                  var result = _a4.result;
                  return valueMapper_1 ? result.map(valueMapper_1) : result;
                });
              } else {
                var a_1 = [];
                return iter(ctx, function(item) {
                  return a_1.push(item);
                }, trans, ctx.table.core).then(function() {
                  return a_1;
                });
              }
            }, cb);
          };
          Collection2.prototype.offset = function(offset) {
            var ctx = this._ctx;
            if (offset <= 0)
              return this;
            ctx.offset += offset;
            if (isPlainKeyRange(ctx)) {
              addReplayFilter(ctx, function() {
                var offsetLeft = offset;
                return function(cursor, advance) {
                  if (offsetLeft === 0)
                    return true;
                  if (offsetLeft === 1) {
                    --offsetLeft;
                    return false;
                  }
                  advance(function() {
                    cursor.advance(offsetLeft);
                    offsetLeft = 0;
                  });
                  return false;
                };
              });
            } else {
              addReplayFilter(ctx, function() {
                var offsetLeft = offset;
                return function() {
                  return --offsetLeft < 0;
                };
              });
            }
            return this;
          };
          Collection2.prototype.limit = function(numRows) {
            this._ctx.limit = Math.min(this._ctx.limit, numRows);
            addReplayFilter(this._ctx, function() {
              var rowsLeft = numRows;
              return function(cursor, advance, resolve2) {
                if (--rowsLeft <= 0)
                  advance(resolve2);
                return rowsLeft >= 0;
              };
            }, true);
            return this;
          };
          Collection2.prototype.until = function(filterFunction, bIncludeStopEntry) {
            addFilter(this._ctx, function(cursor, advance, resolve2) {
              if (filterFunction(cursor.value)) {
                advance(resolve2);
                return bIncludeStopEntry;
              } else {
                return true;
              }
            });
            return this;
          };
          Collection2.prototype.first = function(cb) {
            return this.limit(1).toArray(function(a) {
              return a[0];
            }).then(cb);
          };
          Collection2.prototype.last = function(cb) {
            return this.reverse().first(cb);
          };
          Collection2.prototype.filter = function(filterFunction) {
            addFilter(this._ctx, function(cursor) {
              return filterFunction(cursor.value);
            });
            addMatchFilter(this._ctx, filterFunction);
            return this;
          };
          Collection2.prototype.and = function(filter) {
            return this.filter(filter);
          };
          Collection2.prototype.or = function(indexName) {
            return new this.db.WhereClause(this._ctx.table, indexName, this);
          };
          Collection2.prototype.reverse = function() {
            this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev";
            if (this._ondirectionchange)
              this._ondirectionchange(this._ctx.dir);
            return this;
          };
          Collection2.prototype.desc = function() {
            return this.reverse();
          };
          Collection2.prototype.eachKey = function(cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            return this.each(function(val, cursor) {
              cb(cursor.key, cursor);
            });
          };
          Collection2.prototype.eachUniqueKey = function(cb) {
            this._ctx.unique = "unique";
            return this.eachKey(cb);
          };
          Collection2.prototype.eachPrimaryKey = function(cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            return this.each(function(val, cursor) {
              cb(cursor.primaryKey, cursor);
            });
          };
          Collection2.prototype.keys = function(cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            var a = [];
            return this.each(function(item, cursor) {
              a.push(cursor.key);
            }).then(function() {
              return a;
            }).then(cb);
          };
          Collection2.prototype.primaryKeys = function(cb) {
            var ctx = this._ctx;
            if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
              return this._read(function(trans) {
                var index = getIndexOrStore(ctx, ctx.table.core.schema);
                return ctx.table.core.query({
                  trans,
                  values: false,
                  limit: ctx.limit,
                  query: {
                    index,
                    range: ctx.range
                  }
                });
              }).then(function(_a4) {
                var result = _a4.result;
                return result;
              }).then(cb);
            }
            ctx.keysOnly = !ctx.isMatch;
            var a = [];
            return this.each(function(item, cursor) {
              a.push(cursor.primaryKey);
            }).then(function() {
              return a;
            }).then(cb);
          };
          Collection2.prototype.uniqueKeys = function(cb) {
            this._ctx.unique = "unique";
            return this.keys(cb);
          };
          Collection2.prototype.firstKey = function(cb) {
            return this.limit(1).keys(function(a) {
              return a[0];
            }).then(cb);
          };
          Collection2.prototype.lastKey = function(cb) {
            return this.reverse().firstKey(cb);
          };
          Collection2.prototype.distinct = function() {
            var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
            if (!idx || !idx.multi)
              return this;
            var set2 = {};
            addFilter(this._ctx, function(cursor) {
              var strKey = cursor.primaryKey.toString();
              var found = hasOwn3(set2, strKey);
              set2[strKey] = true;
              return !found;
            });
            return this;
          };
          Collection2.prototype.modify = function(changes) {
            var _this = this;
            var ctx = this._ctx;
            return this._write(function(trans) {
              var modifyer;
              if (typeof changes === "function") {
                modifyer = changes;
              } else {
                var keyPaths = keys2(changes);
                var numKeys = keyPaths.length;
                modifyer = function(item) {
                  var anythingModified = false;
                  for (var i = 0; i < numKeys; ++i) {
                    var keyPath = keyPaths[i];
                    var val = changes[keyPath];
                    var origVal = getByKeyPath(item, keyPath);
                    if (val instanceof PropModification2) {
                      setByKeyPath(item, keyPath, val.execute(origVal));
                      anythingModified = true;
                    } else if (origVal !== val) {
                      setByKeyPath(item, keyPath, val);
                      anythingModified = true;
                    }
                  }
                  return anythingModified;
                };
              }
              var coreTable = ctx.table.core;
              var _a4 = coreTable.schema.primaryKey, outbound = _a4.outbound, extractKey = _a4.extractKey;
              var limit = 200;
              var modifyChunkSize = _this.db._options.modifyChunkSize;
              if (modifyChunkSize) {
                if (typeof modifyChunkSize == "object") {
                  limit = modifyChunkSize[coreTable.name] || modifyChunkSize["*"] || 200;
                } else {
                  limit = modifyChunkSize;
                }
              }
              var totalFailures = [];
              var successCount = 0;
              var failedKeys = [];
              var applyMutateResult = function(expectedCount, res) {
                var failures = res.failures, numFailures = res.numFailures;
                successCount += expectedCount - numFailures;
                for (var _i2 = 0, _a5 = keys2(failures); _i2 < _a5.length; _i2++) {
                  var pos = _a5[_i2];
                  totalFailures.push(failures[pos]);
                }
              };
              return _this.clone().primaryKeys().then(function(keys3) {
                var criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== "function" || changes === deleteCallback) && {
                  index: ctx.index,
                  range: ctx.range
                };
                var nextChunk = function(offset) {
                  var count = Math.min(limit, keys3.length - offset);
                  return coreTable.getMany({
                    trans,
                    keys: keys3.slice(offset, offset + count),
                    cache: "immutable"
                  }).then(function(values) {
                    var addValues = [];
                    var putValues = [];
                    var putKeys = outbound ? [] : null;
                    var deleteKeys = [];
                    for (var i = 0; i < count; ++i) {
                      var origValue = values[i];
                      var ctx_1 = {
                        value: deepClone(origValue),
                        primKey: keys3[offset + i]
                      };
                      if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {
                        if (ctx_1.value == null) {
                          deleteKeys.push(keys3[offset + i]);
                        } else if (!outbound && cmp2(extractKey(origValue), extractKey(ctx_1.value)) !== 0) {
                          deleteKeys.push(keys3[offset + i]);
                          addValues.push(ctx_1.value);
                        } else {
                          putValues.push(ctx_1.value);
                          if (outbound)
                            putKeys.push(keys3[offset + i]);
                        }
                      }
                    }
                    return Promise.resolve(addValues.length > 0 && coreTable.mutate({ trans, type: "add", values: addValues }).then(function(res) {
                      for (var pos in res.failures) {
                        deleteKeys.splice(parseInt(pos), 1);
                      }
                      applyMutateResult(addValues.length, res);
                    })).then(function() {
                      return (putValues.length > 0 || criteria && typeof changes === "object") && coreTable.mutate({
                        trans,
                        type: "put",
                        keys: putKeys,
                        values: putValues,
                        criteria,
                        changeSpec: typeof changes !== "function" && changes,
                        isAdditionalChunk: offset > 0
                      }).then(function(res) {
                        return applyMutateResult(putValues.length, res);
                      });
                    }).then(function() {
                      return (deleteKeys.length > 0 || criteria && changes === deleteCallback) && coreTable.mutate({
                        trans,
                        type: "delete",
                        keys: deleteKeys,
                        criteria,
                        isAdditionalChunk: offset > 0
                      }).then(function(res) {
                        return applyMutateResult(deleteKeys.length, res);
                      });
                    }).then(function() {
                      return keys3.length > offset + count && nextChunk(offset + limit);
                    });
                  });
                };
                return nextChunk(0).then(function() {
                  if (totalFailures.length > 0)
                    throw new ModifyError("Error modifying one or more objects", totalFailures, successCount, failedKeys);
                  return keys3.length;
                });
              });
            });
          };
          Collection2.prototype.delete = function() {
            var ctx = this._ctx, range = ctx.range;
            if (isPlainKeyRange(ctx) && (ctx.isPrimKey || range.type === 3)) {
              return this._write(function(trans) {
                var primaryKey = ctx.table.core.schema.primaryKey;
                var coreRange = range;
                return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then(function(count) {
                  return ctx.table.core.mutate({ trans, type: "deleteRange", range: coreRange }).then(function(_a4) {
                    var failures = _a4.failures;
                    _a4.lastResult;
                    _a4.results;
                    var numFailures = _a4.numFailures;
                    if (numFailures)
                      throw new ModifyError("Could not delete some values", Object.keys(failures).map(function(pos) {
                        return failures[pos];
                      }), count - numFailures);
                    return count - numFailures;
                  });
                });
              });
            }
            return this.modify(deleteCallback);
          };
          return Collection2;
        }();
        var deleteCallback = function(value, ctx) {
          return ctx.value = null;
        };
        function createCollectionConstructor(db3) {
          return makeClassConstructor(Collection.prototype, function Collection2(whereClause, keyRangeGenerator) {
            this.db = db3;
            var keyRange = AnyRange, error = null;
            if (keyRangeGenerator)
              try {
                keyRange = keyRangeGenerator();
              } catch (ex) {
                error = ex;
              }
            var whereCtx = whereClause._ctx;
            var table = whereCtx.table;
            var readingHook = table.hook.reading.fire;
            this._ctx = {
              table,
              index: whereCtx.index,
              isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,
              range: keyRange,
              keysOnly: false,
              dir: "next",
              unique: "",
              algorithm: null,
              filter: null,
              replayFilter: null,
              justLimit: true,
              isMatch: null,
              offset: 0,
              limit: Infinity,
              error,
              or: whereCtx.or,
              valueMapper: readingHook !== mirror ? readingHook : null
            };
          });
        }
        function simpleCompare(a, b) {
          return a < b ? -1 : a === b ? 0 : 1;
        }
        function simpleCompareReverse(a, b) {
          return a > b ? -1 : a === b ? 0 : 1;
        }
        function fail(collectionOrWhereClause, err, T) {
          var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;
          collection._ctx.error = T ? new T(err) : new TypeError(err);
          return collection;
        }
        function emptyCollection(whereClause) {
          return new whereClause.Collection(whereClause, function() {
            return rangeEqual("");
          }).limit(0);
        }
        function upperFactory(dir) {
          return dir === "next" ? function(s) {
            return s.toUpperCase();
          } : function(s) {
            return s.toLowerCase();
          };
        }
        function lowerFactory(dir) {
          return dir === "next" ? function(s) {
            return s.toLowerCase();
          } : function(s) {
            return s.toUpperCase();
          };
        }
        function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp3, dir) {
          var length = Math.min(key.length, lowerNeedle.length);
          var llp = -1;
          for (var i = 0; i < length; ++i) {
            var lwrKeyChar = lowerKey[i];
            if (lwrKeyChar !== lowerNeedle[i]) {
              if (cmp3(key[i], upperNeedle[i]) < 0)
                return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
              if (cmp3(key[i], lowerNeedle[i]) < 0)
                return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
              if (llp >= 0)
                return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
              return null;
            }
            if (cmp3(key[i], lwrKeyChar) < 0)
              llp = i;
          }
          if (length < lowerNeedle.length && dir === "next")
            return key + upperNeedle.substr(key.length);
          if (length < key.length && dir === "prev")
            return key.substr(0, upperNeedle.length);
          return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);
        }
        function addIgnoreCaseAlgorithm(whereClause, match2, needles, suffix) {
          var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;
          if (!needles.every(function(s) {
            return typeof s === "string";
          })) {
            return fail(whereClause, STRING_EXPECTED);
          }
          function initDirection(dir) {
            upper = upperFactory(dir);
            lower = lowerFactory(dir);
            compare = dir === "next" ? simpleCompare : simpleCompareReverse;
            var needleBounds = needles.map(function(needle) {
              return { lower: lower(needle), upper: upper(needle) };
            }).sort(function(a, b) {
              return compare(a.lower, b.lower);
            });
            upperNeedles = needleBounds.map(function(nb) {
              return nb.upper;
            });
            lowerNeedles = needleBounds.map(function(nb) {
              return nb.lower;
            });
            direction = dir;
            nextKeySuffix = dir === "next" ? "" : suffix;
          }
          initDirection("next");
          var c = new whereClause.Collection(whereClause, function() {
            return createRange2(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix);
          });
          c._ondirectionchange = function(direction2) {
            initDirection(direction2);
          };
          var firstPossibleNeedle = 0;
          c._addAlgorithm(function(cursor, advance, resolve2) {
            var key = cursor.key;
            if (typeof key !== "string")
              return false;
            var lowerKey = lower(key);
            if (match2(lowerKey, lowerNeedles, firstPossibleNeedle)) {
              return true;
            } else {
              var lowestPossibleCasing = null;
              for (var i = firstPossibleNeedle; i < needlesLen; ++i) {
                var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);
                if (casing === null && lowestPossibleCasing === null)
                  firstPossibleNeedle = i + 1;
                else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {
                  lowestPossibleCasing = casing;
                }
              }
              if (lowestPossibleCasing !== null) {
                advance(function() {
                  cursor.continue(lowestPossibleCasing + nextKeySuffix);
                });
              } else {
                advance(resolve2);
              }
              return false;
            }
          });
          return c;
        }
        function createRange2(lower, upper, lowerOpen, upperOpen) {
          return {
            type: 2,
            lower,
            upper,
            lowerOpen,
            upperOpen
          };
        }
        function rangeEqual(value) {
          return {
            type: 1,
            lower: value,
            upper: value
          };
        }
        var WhereClause = function() {
          function WhereClause2() {
          }
          Object.defineProperty(WhereClause2.prototype, "Collection", {
            get: function() {
              return this._ctx.table.db.Collection;
            },
            enumerable: false,
            configurable: true
          });
          WhereClause2.prototype.between = function(lower, upper, includeLower, includeUpper) {
            includeLower = includeLower !== false;
            includeUpper = includeUpper === true;
            try {
              if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper))
                return emptyCollection(this);
              return new this.Collection(this, function() {
                return createRange2(lower, upper, !includeLower, !includeUpper);
              });
            } catch (e) {
              return fail(this, INVALID_KEY_ARGUMENT);
            }
          };
          WhereClause2.prototype.equals = function(value) {
            if (value == null)
              return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function() {
              return rangeEqual(value);
            });
          };
          WhereClause2.prototype.above = function(value) {
            if (value == null)
              return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function() {
              return createRange2(value, void 0, true);
            });
          };
          WhereClause2.prototype.aboveOrEqual = function(value) {
            if (value == null)
              return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function() {
              return createRange2(value, void 0, false);
            });
          };
          WhereClause2.prototype.below = function(value) {
            if (value == null)
              return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function() {
              return createRange2(void 0, value, false, true);
            });
          };
          WhereClause2.prototype.belowOrEqual = function(value) {
            if (value == null)
              return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function() {
              return createRange2(void 0, value);
            });
          };
          WhereClause2.prototype.startsWith = function(str) {
            if (typeof str !== "string")
              return fail(this, STRING_EXPECTED);
            return this.between(str, str + maxString, true, true);
          };
          WhereClause2.prototype.startsWithIgnoreCase = function(str) {
            if (str === "")
              return this.startsWith(str);
            return addIgnoreCaseAlgorithm(this, function(x, a) {
              return x.indexOf(a[0]) === 0;
            }, [str], maxString);
          };
          WhereClause2.prototype.equalsIgnoreCase = function(str) {
            return addIgnoreCaseAlgorithm(this, function(x, a) {
              return x === a[0];
            }, [str], "");
          };
          WhereClause2.prototype.anyOfIgnoreCase = function() {
            var set2 = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set2.length === 0)
              return emptyCollection(this);
            return addIgnoreCaseAlgorithm(this, function(x, a) {
              return a.indexOf(x) !== -1;
            }, set2, "");
          };
          WhereClause2.prototype.startsWithAnyOfIgnoreCase = function() {
            var set2 = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set2.length === 0)
              return emptyCollection(this);
            return addIgnoreCaseAlgorithm(this, function(x, a) {
              return a.some(function(n) {
                return x.indexOf(n) === 0;
              });
            }, set2, maxString);
          };
          WhereClause2.prototype.anyOf = function() {
            var _this = this;
            var set2 = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            var compare = this._cmp;
            try {
              set2.sort(compare);
            } catch (e) {
              return fail(this, INVALID_KEY_ARGUMENT);
            }
            if (set2.length === 0)
              return emptyCollection(this);
            var c = new this.Collection(this, function() {
              return createRange2(set2[0], set2[set2.length - 1]);
            });
            c._ondirectionchange = function(direction) {
              compare = direction === "next" ? _this._ascending : _this._descending;
              set2.sort(compare);
            };
            var i = 0;
            c._addAlgorithm(function(cursor, advance, resolve2) {
              var key = cursor.key;
              while (compare(key, set2[i]) > 0) {
                ++i;
                if (i === set2.length) {
                  advance(resolve2);
                  return false;
                }
              }
              if (compare(key, set2[i]) === 0) {
                return true;
              } else {
                advance(function() {
                  cursor.continue(set2[i]);
                });
                return false;
              }
            });
            return c;
          };
          WhereClause2.prototype.notEqual = function(value) {
            return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });
          };
          WhereClause2.prototype.noneOf = function() {
            var set2 = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set2.length === 0)
              return new this.Collection(this);
            try {
              set2.sort(this._ascending);
            } catch (e) {
              return fail(this, INVALID_KEY_ARGUMENT);
            }
            var ranges = set2.reduce(function(res, val) {
              return res ? res.concat([[res[res.length - 1][1], val]]) : [[minKey, val]];
            }, null);
            ranges.push([set2[set2.length - 1], this.db._maxKey]);
            return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });
          };
          WhereClause2.prototype.inAnyRange = function(ranges, options) {
            var _this = this;
            var cmp3 = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;
            if (ranges.length === 0)
              return emptyCollection(this);
            if (!ranges.every(function(range) {
              return range[0] !== void 0 && range[1] !== void 0 && ascending(range[0], range[1]) <= 0;
            })) {
              return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
            }
            var includeLowers = !options || options.includeLowers !== false;
            var includeUppers = options && options.includeUppers === true;
            function addRange2(ranges2, newRange) {
              var i = 0, l = ranges2.length;
              for (; i < l; ++i) {
                var range = ranges2[i];
                if (cmp3(newRange[0], range[1]) < 0 && cmp3(newRange[1], range[0]) > 0) {
                  range[0] = min(range[0], newRange[0]);
                  range[1] = max(range[1], newRange[1]);
                  break;
                }
              }
              if (i === l)
                ranges2.push(newRange);
              return ranges2;
            }
            var sortDirection = ascending;
            function rangeSorter(a, b) {
              return sortDirection(a[0], b[0]);
            }
            var set2;
            try {
              set2 = ranges.reduce(addRange2, []);
              set2.sort(rangeSorter);
            } catch (ex) {
              return fail(this, INVALID_KEY_ARGUMENT);
            }
            var rangePos = 0;
            var keyIsBeyondCurrentEntry = includeUppers ? function(key) {
              return ascending(key, set2[rangePos][1]) > 0;
            } : function(key) {
              return ascending(key, set2[rangePos][1]) >= 0;
            };
            var keyIsBeforeCurrentEntry = includeLowers ? function(key) {
              return descending(key, set2[rangePos][0]) > 0;
            } : function(key) {
              return descending(key, set2[rangePos][0]) >= 0;
            };
            function keyWithinCurrentRange(key) {
              return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
            }
            var checkKey = keyIsBeyondCurrentEntry;
            var c = new this.Collection(this, function() {
              return createRange2(set2[0][0], set2[set2.length - 1][1], !includeLowers, !includeUppers);
            });
            c._ondirectionchange = function(direction) {
              if (direction === "next") {
                checkKey = keyIsBeyondCurrentEntry;
                sortDirection = ascending;
              } else {
                checkKey = keyIsBeforeCurrentEntry;
                sortDirection = descending;
              }
              set2.sort(rangeSorter);
            };
            c._addAlgorithm(function(cursor, advance, resolve2) {
              var key = cursor.key;
              while (checkKey(key)) {
                ++rangePos;
                if (rangePos === set2.length) {
                  advance(resolve2);
                  return false;
                }
              }
              if (keyWithinCurrentRange(key)) {
                return true;
              } else if (_this._cmp(key, set2[rangePos][1]) === 0 || _this._cmp(key, set2[rangePos][0]) === 0) {
                return false;
              } else {
                advance(function() {
                  if (sortDirection === ascending)
                    cursor.continue(set2[rangePos][0]);
                  else
                    cursor.continue(set2[rangePos][1]);
                });
                return false;
              }
            });
            return c;
          };
          WhereClause2.prototype.startsWithAnyOf = function() {
            var set2 = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (!set2.every(function(s) {
              return typeof s === "string";
            })) {
              return fail(this, "startsWithAnyOf() only works with strings");
            }
            if (set2.length === 0)
              return emptyCollection(this);
            return this.inAnyRange(set2.map(function(str) {
              return [str, str + maxString];
            }));
          };
          return WhereClause2;
        }();
        function createWhereClauseConstructor(db3) {
          return makeClassConstructor(WhereClause.prototype, function WhereClause2(table, index, orCollection) {
            this.db = db3;
            this._ctx = {
              table,
              index: index === ":id" ? null : index,
              or: orCollection
            };
            this._cmp = this._ascending = cmp2;
            this._descending = function(a, b) {
              return cmp2(b, a);
            };
            this._max = function(a, b) {
              return cmp2(a, b) > 0 ? a : b;
            };
            this._min = function(a, b) {
              return cmp2(a, b) < 0 ? a : b;
            };
            this._IDBKeyRange = db3._deps.IDBKeyRange;
            if (!this._IDBKeyRange)
              throw new exceptions.MissingAPI();
          });
        }
        function eventRejectHandler(reject) {
          return wrap(function(event2) {
            preventDefault(event2);
            reject(event2.target.error);
            return false;
          });
        }
        function preventDefault(event2) {
          if (event2.stopPropagation)
            event2.stopPropagation();
          if (event2.preventDefault)
            event2.preventDefault();
        }
        var DEXIE_STORAGE_MUTATED_EVENT_NAME = "storagemutated";
        var STORAGE_MUTATED_DOM_EVENT_NAME = "x-storagemutated-1";
        var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);
        var Transaction = function() {
          function Transaction2() {
          }
          Transaction2.prototype._lock = function() {
            assert(!PSD.global);
            ++this._reculock;
            if (this._reculock === 1 && !PSD.global)
              PSD.lockOwnerFor = this;
            return this;
          };
          Transaction2.prototype._unlock = function() {
            assert(!PSD.global);
            if (--this._reculock === 0) {
              if (!PSD.global)
                PSD.lockOwnerFor = null;
              while (this._blockedFuncs.length > 0 && !this._locked()) {
                var fnAndPSD = this._blockedFuncs.shift();
                try {
                  usePSD(fnAndPSD[1], fnAndPSD[0]);
                } catch (e) {
                }
              }
            }
            return this;
          };
          Transaction2.prototype._locked = function() {
            return this._reculock && PSD.lockOwnerFor !== this;
          };
          Transaction2.prototype.create = function(idbtrans) {
            var _this = this;
            if (!this.mode)
              return this;
            var idbdb = this.db.idbdb;
            var dbOpenError = this.db._state.dbOpenError;
            assert(!this.idbtrans);
            if (!idbtrans && !idbdb) {
              switch (dbOpenError && dbOpenError.name) {
                case "DatabaseClosedError":
                  throw new exceptions.DatabaseClosed(dbOpenError);
                case "MissingAPIError":
                  throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);
                default:
                  throw new exceptions.OpenFailed(dbOpenError);
              }
            }
            if (!this.active)
              throw new exceptions.TransactionInactive();
            assert(this._completion._state === null);
            idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));
            idbtrans.onerror = wrap(function(ev) {
              preventDefault(ev);
              _this._reject(idbtrans.error);
            });
            idbtrans.onabort = wrap(function(ev) {
              preventDefault(ev);
              _this.active && _this._reject(new exceptions.Abort(idbtrans.error));
              _this.active = false;
              _this.on("abort").fire(ev);
            });
            idbtrans.oncomplete = wrap(function() {
              _this.active = false;
              _this._resolve();
              if ("mutatedParts" in idbtrans) {
                globalEvents.storagemutated.fire(idbtrans["mutatedParts"]);
              }
            });
            return this;
          };
          Transaction2.prototype._promise = function(mode, fn2, bWriteLock) {
            var _this = this;
            if (mode === "readwrite" && this.mode !== "readwrite")
              return rejection(new exceptions.ReadOnly("Transaction is readonly"));
            if (!this.active)
              return rejection(new exceptions.TransactionInactive());
            if (this._locked()) {
              return new DexiePromise(function(resolve2, reject) {
                _this._blockedFuncs.push([function() {
                  _this._promise(mode, fn2, bWriteLock).then(resolve2, reject);
                }, PSD]);
              });
            } else if (bWriteLock) {
              return newScope(function() {
                var p3 = new DexiePromise(function(resolve2, reject) {
                  _this._lock();
                  var rv = fn2(resolve2, reject, _this);
                  if (rv && rv.then)
                    rv.then(resolve2, reject);
                });
                p3.finally(function() {
                  return _this._unlock();
                });
                p3._lib = true;
                return p3;
              });
            } else {
              var p2 = new DexiePromise(function(resolve2, reject) {
                var rv = fn2(resolve2, reject, _this);
                if (rv && rv.then)
                  rv.then(resolve2, reject);
              });
              p2._lib = true;
              return p2;
            }
          };
          Transaction2.prototype._root = function() {
            return this.parent ? this.parent._root() : this;
          };
          Transaction2.prototype.waitFor = function(promiseLike) {
            var root = this._root();
            var promise = DexiePromise.resolve(promiseLike);
            if (root._waitingFor) {
              root._waitingFor = root._waitingFor.then(function() {
                return promise;
              });
            } else {
              root._waitingFor = promise;
              root._waitingQueue = [];
              var store = root.idbtrans.objectStore(root.storeNames[0]);
              (function spin() {
                ++root._spinCount;
                while (root._waitingQueue.length)
                  root._waitingQueue.shift()();
                if (root._waitingFor)
                  store.get(-Infinity).onsuccess = spin;
              })();
            }
            var currentWaitPromise = root._waitingFor;
            return new DexiePromise(function(resolve2, reject) {
              promise.then(function(res) {
                return root._waitingQueue.push(wrap(resolve2.bind(null, res)));
              }, function(err) {
                return root._waitingQueue.push(wrap(reject.bind(null, err)));
              }).finally(function() {
                if (root._waitingFor === currentWaitPromise) {
                  root._waitingFor = null;
                }
              });
            });
          };
          Transaction2.prototype.abort = function() {
            if (this.active) {
              this.active = false;
              if (this.idbtrans)
                this.idbtrans.abort();
              this._reject(new exceptions.Abort());
            }
          };
          Transaction2.prototype.table = function(tableName) {
            var memoizedTables = this._memoizedTables || (this._memoizedTables = {});
            if (hasOwn3(memoizedTables, tableName))
              return memoizedTables[tableName];
            var tableSchema = this.schema[tableName];
            if (!tableSchema) {
              throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
            }
            var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);
            transactionBoundTable.core = this.db.core.table(tableName);
            memoizedTables[tableName] = transactionBoundTable;
            return transactionBoundTable;
          };
          return Transaction2;
        }();
        function createTransactionConstructor(db3) {
          return makeClassConstructor(Transaction.prototype, function Transaction2(mode, storeNames, dbschema, chromeTransactionDurability, parent) {
            var _this = this;
            this.db = db3;
            this.mode = mode;
            this.storeNames = storeNames;
            this.schema = dbschema;
            this.chromeTransactionDurability = chromeTransactionDurability;
            this.idbtrans = null;
            this.on = Events(this, "complete", "error", "abort");
            this.parent = parent || null;
            this.active = true;
            this._reculock = 0;
            this._blockedFuncs = [];
            this._resolve = null;
            this._reject = null;
            this._waitingFor = null;
            this._waitingQueue = null;
            this._spinCount = 0;
            this._completion = new DexiePromise(function(resolve2, reject) {
              _this._resolve = resolve2;
              _this._reject = reject;
            });
            this._completion.then(function() {
              _this.active = false;
              _this.on.complete.fire();
            }, function(e) {
              var wasActive = _this.active;
              _this.active = false;
              _this.on.error.fire(e);
              _this.parent ? _this.parent._reject(e) : wasActive && _this.idbtrans && _this.idbtrans.abort();
              return rejection(e);
            });
          });
        }
        function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {
          return {
            name,
            keyPath,
            unique,
            multi,
            auto,
            compound,
            src: (unique && !isPrimKey ? "&" : "") + (multi ? "*" : "") + (auto ? "++" : "") + nameFromKeyPath(keyPath)
          };
        }
        function nameFromKeyPath(keyPath) {
          return typeof keyPath === "string" ? keyPath : keyPath ? "[" + [].join.call(keyPath, "+") + "]" : "";
        }
        function createTableSchema(name, primKey, indexes) {
          return {
            name,
            primKey,
            indexes,
            mappedClass: null,
            idxByName: arrayToObject(indexes, function(index) {
              return [index.name, index];
            })
          };
        }
        function safariMultiStoreFix(storeNames) {
          return storeNames.length === 1 ? storeNames[0] : storeNames;
        }
        var getMaxKey = function(IdbKeyRange) {
          try {
            IdbKeyRange.only([[]]);
            getMaxKey = function() {
              return [[]];
            };
            return [[]];
          } catch (e) {
            getMaxKey = function() {
              return maxString;
            };
            return maxString;
          }
        };
        function getKeyExtractor(keyPath) {
          if (keyPath == null) {
            return function() {
              return void 0;
            };
          } else if (typeof keyPath === "string") {
            return getSinglePathKeyExtractor(keyPath);
          } else {
            return function(obj) {
              return getByKeyPath(obj, keyPath);
            };
          }
        }
        function getSinglePathKeyExtractor(keyPath) {
          var split = keyPath.split(".");
          if (split.length === 1) {
            return function(obj) {
              return obj[keyPath];
            };
          } else {
            return function(obj) {
              return getByKeyPath(obj, keyPath);
            };
          }
        }
        function arrayify(arrayLike) {
          return [].slice.call(arrayLike);
        }
        var _id_counter = 0;
        function getKeyPathAlias(keyPath) {
          return keyPath == null ? ":id" : typeof keyPath === "string" ? keyPath : "[".concat(keyPath.join("+"), "]");
        }
        function createDBCore(db3, IdbKeyRange, tmpTrans) {
          function extractSchema(db4, trans) {
            var tables2 = arrayify(db4.objectStoreNames);
            return {
              schema: {
                name: db4.name,
                tables: tables2.map(function(table) {
                  return trans.objectStore(table);
                }).map(function(store) {
                  var keyPath = store.keyPath, autoIncrement = store.autoIncrement;
                  var compound = isArray2(keyPath);
                  var outbound = keyPath == null;
                  var indexByKeyPath = {};
                  var result = {
                    name: store.name,
                    primaryKey: {
                      name: null,
                      isPrimaryKey: true,
                      outbound,
                      compound,
                      keyPath,
                      autoIncrement,
                      unique: true,
                      extractKey: getKeyExtractor(keyPath)
                    },
                    indexes: arrayify(store.indexNames).map(function(indexName) {
                      return store.index(indexName);
                    }).map(function(index) {
                      var name = index.name, unique = index.unique, multiEntry = index.multiEntry, keyPath2 = index.keyPath;
                      var compound2 = isArray2(keyPath2);
                      var result2 = {
                        name,
                        compound: compound2,
                        keyPath: keyPath2,
                        unique,
                        multiEntry,
                        extractKey: getKeyExtractor(keyPath2)
                      };
                      indexByKeyPath[getKeyPathAlias(keyPath2)] = result2;
                      return result2;
                    }),
                    getIndexByKeyPath: function(keyPath2) {
                      return indexByKeyPath[getKeyPathAlias(keyPath2)];
                    }
                  };
                  indexByKeyPath[":id"] = result.primaryKey;
                  if (keyPath != null) {
                    indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;
                  }
                  return result;
                })
              },
              hasGetAll: tables2.length > 0 && "getAll" in trans.objectStore(tables2[0]) && !(typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
            };
          }
          function makeIDBKeyRange(range) {
            if (range.type === 3)
              return null;
            if (range.type === 4)
              throw new Error("Cannot convert never type to IDBKeyRange");
            var lower = range.lower, upper = range.upper, lowerOpen = range.lowerOpen, upperOpen = range.upperOpen;
            var idbRange = lower === void 0 ? upper === void 0 ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === void 0 ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);
            return idbRange;
          }
          function createDbCoreTable(tableSchema) {
            var tableName = tableSchema.name;
            function mutate(_a5) {
              var trans = _a5.trans, type2 = _a5.type, keys3 = _a5.keys, values = _a5.values, range = _a5.range;
              return new Promise(function(resolve2, reject) {
                resolve2 = wrap(resolve2);
                var store = trans.objectStore(tableName);
                var outbound = store.keyPath == null;
                var isAddOrPut = type2 === "put" || type2 === "add";
                if (!isAddOrPut && type2 !== "delete" && type2 !== "deleteRange")
                  throw new Error("Invalid operation type: " + type2);
                var length = (keys3 || values || { length: 1 }).length;
                if (keys3 && values && keys3.length !== values.length) {
                  throw new Error("Given keys array must have same length as given values array.");
                }
                if (length === 0)
                  return resolve2({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
                var req;
                var reqs = [];
                var failures = [];
                var numFailures = 0;
                var errorHandler = function(event2) {
                  ++numFailures;
                  preventDefault(event2);
                };
                if (type2 === "deleteRange") {
                  if (range.type === 4)
                    return resolve2({ numFailures, failures, results: [], lastResult: void 0 });
                  if (range.type === 3)
                    reqs.push(req = store.clear());
                  else
                    reqs.push(req = store.delete(makeIDBKeyRange(range)));
                } else {
                  var _a6 = isAddOrPut ? outbound ? [values, keys3] : [values, null] : [keys3, null], args1 = _a6[0], args2 = _a6[1];
                  if (isAddOrPut) {
                    for (var i = 0; i < length; ++i) {
                      reqs.push(req = args2 && args2[i] !== void 0 ? store[type2](args1[i], args2[i]) : store[type2](args1[i]));
                      req.onerror = errorHandler;
                    }
                  } else {
                    for (var i = 0; i < length; ++i) {
                      reqs.push(req = store[type2](args1[i]));
                      req.onerror = errorHandler;
                    }
                  }
                }
                var done = function(event2) {
                  var lastResult = event2.target.result;
                  reqs.forEach(function(req2, i2) {
                    return req2.error != null && (failures[i2] = req2.error);
                  });
                  resolve2({
                    numFailures,
                    failures,
                    results: type2 === "delete" ? keys3 : reqs.map(function(req2) {
                      return req2.result;
                    }),
                    lastResult
                  });
                };
                req.onerror = function(event2) {
                  errorHandler(event2);
                  done(event2);
                };
                req.onsuccess = done;
              });
            }
            function openCursor2(_a5) {
              var trans = _a5.trans, values = _a5.values, query2 = _a5.query, reverse = _a5.reverse, unique = _a5.unique;
              return new Promise(function(resolve2, reject) {
                resolve2 = wrap(resolve2);
                var index = query2.index, range = query2.range;
                var store = trans.objectStore(tableName);
                var source = index.isPrimaryKey ? store : store.index(index.name);
                var direction = reverse ? unique ? "prevunique" : "prev" : unique ? "nextunique" : "next";
                var req = values || !("openKeyCursor" in source) ? source.openCursor(makeIDBKeyRange(range), direction) : source.openKeyCursor(makeIDBKeyRange(range), direction);
                req.onerror = eventRejectHandler(reject);
                req.onsuccess = wrap(function(ev) {
                  var cursor = req.result;
                  if (!cursor) {
                    resolve2(null);
                    return;
                  }
                  cursor.___id = ++_id_counter;
                  cursor.done = false;
                  var _cursorContinue = cursor.continue.bind(cursor);
                  var _cursorContinuePrimaryKey = cursor.continuePrimaryKey;
                  if (_cursorContinuePrimaryKey)
                    _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);
                  var _cursorAdvance = cursor.advance.bind(cursor);
                  var doThrowCursorIsNotStarted = function() {
                    throw new Error("Cursor not started");
                  };
                  var doThrowCursorIsStopped = function() {
                    throw new Error("Cursor not stopped");
                  };
                  cursor.trans = trans;
                  cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;
                  cursor.fail = wrap(reject);
                  cursor.next = function() {
                    var _this = this;
                    var gotOne = 1;
                    return this.start(function() {
                      return gotOne-- ? _this.continue() : _this.stop();
                    }).then(function() {
                      return _this;
                    });
                  };
                  cursor.start = function(callback) {
                    var iterationPromise = new Promise(function(resolveIteration, rejectIteration) {
                      resolveIteration = wrap(resolveIteration);
                      req.onerror = eventRejectHandler(rejectIteration);
                      cursor.fail = rejectIteration;
                      cursor.stop = function(value) {
                        cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;
                        resolveIteration(value);
                      };
                    });
                    var guardedCallback = function() {
                      if (req.result) {
                        try {
                          callback();
                        } catch (err) {
                          cursor.fail(err);
                        }
                      } else {
                        cursor.done = true;
                        cursor.start = function() {
                          throw new Error("Cursor behind last entry");
                        };
                        cursor.stop();
                      }
                    };
                    req.onsuccess = wrap(function(ev2) {
                      req.onsuccess = guardedCallback;
                      guardedCallback();
                    });
                    cursor.continue = _cursorContinue;
                    cursor.continuePrimaryKey = _cursorContinuePrimaryKey;
                    cursor.advance = _cursorAdvance;
                    guardedCallback();
                    return iterationPromise;
                  };
                  resolve2(cursor);
                }, reject);
              });
            }
            function query(hasGetAll2) {
              return function(request) {
                return new Promise(function(resolve2, reject) {
                  resolve2 = wrap(resolve2);
                  var trans = request.trans, values = request.values, limit = request.limit, query2 = request.query;
                  var nonInfinitLimit = limit === Infinity ? void 0 : limit;
                  var index = query2.index, range = query2.range;
                  var store = trans.objectStore(tableName);
                  var source = index.isPrimaryKey ? store : store.index(index.name);
                  var idbKeyRange = makeIDBKeyRange(range);
                  if (limit === 0)
                    return resolve2({ result: [] });
                  if (hasGetAll2) {
                    var req = values ? source.getAll(idbKeyRange, nonInfinitLimit) : source.getAllKeys(idbKeyRange, nonInfinitLimit);
                    req.onsuccess = function(event2) {
                      return resolve2({ result: event2.target.result });
                    };
                    req.onerror = eventRejectHandler(reject);
                  } else {
                    var count_1 = 0;
                    var req_1 = values || !("openKeyCursor" in source) ? source.openCursor(idbKeyRange) : source.openKeyCursor(idbKeyRange);
                    var result_1 = [];
                    req_1.onsuccess = function(event2) {
                      var cursor = req_1.result;
                      if (!cursor)
                        return resolve2({ result: result_1 });
                      result_1.push(values ? cursor.value : cursor.primaryKey);
                      if (++count_1 === limit)
                        return resolve2({ result: result_1 });
                      cursor.continue();
                    };
                    req_1.onerror = eventRejectHandler(reject);
                  }
                });
              };
            }
            return {
              name: tableName,
              schema: tableSchema,
              mutate,
              getMany: function(_a5) {
                var trans = _a5.trans, keys3 = _a5.keys;
                return new Promise(function(resolve2, reject) {
                  resolve2 = wrap(resolve2);
                  var store = trans.objectStore(tableName);
                  var length = keys3.length;
                  var result = new Array(length);
                  var keyCount = 0;
                  var callbackCount = 0;
                  var req;
                  var successHandler = function(event2) {
                    var req2 = event2.target;
                    if ((result[req2._pos] = req2.result) != null)
                      ;
                    if (++callbackCount === keyCount)
                      resolve2(result);
                  };
                  var errorHandler = eventRejectHandler(reject);
                  for (var i = 0; i < length; ++i) {
                    var key = keys3[i];
                    if (key != null) {
                      req = store.get(keys3[i]);
                      req._pos = i;
                      req.onsuccess = successHandler;
                      req.onerror = errorHandler;
                      ++keyCount;
                    }
                  }
                  if (keyCount === 0)
                    resolve2(result);
                });
              },
              get: function(_a5) {
                var trans = _a5.trans, key = _a5.key;
                return new Promise(function(resolve2, reject) {
                  resolve2 = wrap(resolve2);
                  var store = trans.objectStore(tableName);
                  var req = store.get(key);
                  req.onsuccess = function(event2) {
                    return resolve2(event2.target.result);
                  };
                  req.onerror = eventRejectHandler(reject);
                });
              },
              query: query(hasGetAll),
              openCursor: openCursor2,
              count: function(_a5) {
                var query2 = _a5.query, trans = _a5.trans;
                var index = query2.index, range = query2.range;
                return new Promise(function(resolve2, reject) {
                  var store = trans.objectStore(tableName);
                  var source = index.isPrimaryKey ? store : store.index(index.name);
                  var idbKeyRange = makeIDBKeyRange(range);
                  var req = idbKeyRange ? source.count(idbKeyRange) : source.count();
                  req.onsuccess = wrap(function(ev) {
                    return resolve2(ev.target.result);
                  });
                  req.onerror = eventRejectHandler(reject);
                });
              }
            };
          }
          var _a4 = extractSchema(db3, tmpTrans), schema = _a4.schema, hasGetAll = _a4.hasGetAll;
          var tables = schema.tables.map(function(tableSchema) {
            return createDbCoreTable(tableSchema);
          });
          var tableMap = {};
          tables.forEach(function(table) {
            return tableMap[table.name] = table;
          });
          return {
            stack: "dbcore",
            transaction: db3.transaction.bind(db3),
            table: function(name) {
              var result = tableMap[name];
              if (!result)
                throw new Error("Table '".concat(name, "' not found"));
              return tableMap[name];
            },
            MIN_KEY: -Infinity,
            MAX_KEY: getMaxKey(IdbKeyRange),
            schema
          };
        }
        function createMiddlewareStack(stackImpl, middlewares) {
          return middlewares.reduce(function(down, _a4) {
            var create = _a4.create;
            return __assign(__assign({}, down), create(down));
          }, stackImpl);
        }
        function createMiddlewareStacks(middlewares, idbdb, _a4, tmpTrans) {
          var IDBKeyRange = _a4.IDBKeyRange;
          _a4.indexedDB;
          var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);
          return {
            dbcore
          };
        }
        function generateMiddlewareStacks(db3, tmpTrans) {
          var idbdb = tmpTrans.db;
          var stacks = createMiddlewareStacks(db3._middlewares, idbdb, db3._deps, tmpTrans);
          db3.core = stacks.dbcore;
          db3.tables.forEach(function(table) {
            var tableName = table.name;
            if (db3.core.schema.tables.some(function(tbl) {
              return tbl.name === tableName;
            })) {
              table.core = db3.core.table(tableName);
              if (db3[tableName] instanceof db3.Table) {
                db3[tableName].core = table.core;
              }
            }
          });
        }
        function setApiOnPlace(db3, objs, tableNames, dbschema) {
          tableNames.forEach(function(tableName) {
            var schema = dbschema[tableName];
            objs.forEach(function(obj) {
              var propDesc = getPropertyDescriptor(obj, tableName);
              if (!propDesc || "value" in propDesc && propDesc.value === void 0) {
                if (obj === db3.Transaction.prototype || obj instanceof db3.Transaction) {
                  setProp(obj, tableName, {
                    get: function() {
                      return this.table(tableName);
                    },
                    set: function(value) {
                      defineProperty(this, tableName, { value, writable: true, configurable: true, enumerable: true });
                    }
                  });
                } else {
                  obj[tableName] = new db3.Table(tableName, schema);
                }
              }
            });
          });
        }
        function removeTablesApi(db3, objs) {
          objs.forEach(function(obj) {
            for (var key in obj) {
              if (obj[key] instanceof db3.Table)
                delete obj[key];
            }
          });
        }
        function lowerVersionFirst(a, b) {
          return a._cfg.version - b._cfg.version;
        }
        function runUpgraders(db3, oldVersion, idbUpgradeTrans, reject) {
          var globalSchema = db3._dbSchema;
          if (idbUpgradeTrans.objectStoreNames.contains("$meta") && !globalSchema.$meta) {
            globalSchema.$meta = createTableSchema("$meta", parseIndexSyntax("")[0], []);
            db3._storeNames.push("$meta");
          }
          var trans = db3._createTransaction("readwrite", db3._storeNames, globalSchema);
          trans.create(idbUpgradeTrans);
          trans._completion.catch(reject);
          var rejectTransaction = trans._reject.bind(trans);
          var transless = PSD.transless || PSD;
          newScope(function() {
            PSD.trans = trans;
            PSD.transless = transless;
            if (oldVersion === 0) {
              keys2(globalSchema).forEach(function(tableName) {
                createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
              });
              generateMiddlewareStacks(db3, idbUpgradeTrans);
              DexiePromise.follow(function() {
                return db3.on.populate.fire(trans);
              }).catch(rejectTransaction);
            } else {
              generateMiddlewareStacks(db3, idbUpgradeTrans);
              return getExistingVersion(db3, trans, oldVersion).then(function(oldVersion2) {
                return updateTablesAndIndexes(db3, oldVersion2, trans, idbUpgradeTrans);
              }).catch(rejectTransaction);
            }
          });
        }
        function patchCurrentVersion(db3, idbUpgradeTrans) {
          createMissingTables(db3._dbSchema, idbUpgradeTrans);
          if (idbUpgradeTrans.db.version % 10 === 0 && !idbUpgradeTrans.objectStoreNames.contains("$meta")) {
            idbUpgradeTrans.db.createObjectStore("$meta").add(Math.ceil(idbUpgradeTrans.db.version / 10 - 1), "version");
          }
          var globalSchema = buildGlobalSchema(db3, db3.idbdb, idbUpgradeTrans);
          adjustToExistingIndexNames(db3, db3._dbSchema, idbUpgradeTrans);
          var diff = getSchemaDiff(globalSchema, db3._dbSchema);
          var _loop_1 = function(tableChange2) {
            if (tableChange2.change.length || tableChange2.recreate) {
              console.warn("Unable to patch indexes of table ".concat(tableChange2.name, " because it has changes on the type of index or primary key."));
              return { value: void 0 };
            }
            var store = idbUpgradeTrans.objectStore(tableChange2.name);
            tableChange2.add.forEach(function(idx) {
              if (debug)
                console.debug("Dexie upgrade patch: Creating missing index ".concat(tableChange2.name, ".").concat(idx.src));
              addIndex(store, idx);
            });
          };
          for (var _i2 = 0, _a4 = diff.change; _i2 < _a4.length; _i2++) {
            var tableChange = _a4[_i2];
            var state_1 = _loop_1(tableChange);
            if (typeof state_1 === "object")
              return state_1.value;
          }
        }
        function getExistingVersion(db3, trans, oldVersion) {
          if (trans.storeNames.includes("$meta")) {
            return trans.table("$meta").get("version").then(function(metaVersion) {
              return metaVersion != null ? metaVersion : oldVersion;
            });
          } else {
            return DexiePromise.resolve(oldVersion);
          }
        }
        function updateTablesAndIndexes(db3, oldVersion, trans, idbUpgradeTrans) {
          var queue2 = [];
          var versions = db3._versions;
          var globalSchema = db3._dbSchema = buildGlobalSchema(db3, db3.idbdb, idbUpgradeTrans);
          var versToRun = versions.filter(function(v) {
            return v._cfg.version >= oldVersion;
          });
          if (versToRun.length === 0) {
            return DexiePromise.resolve();
          }
          versToRun.forEach(function(version3) {
            queue2.push(function() {
              var oldSchema = globalSchema;
              var newSchema = version3._cfg.dbschema;
              adjustToExistingIndexNames(db3, oldSchema, idbUpgradeTrans);
              adjustToExistingIndexNames(db3, newSchema, idbUpgradeTrans);
              globalSchema = db3._dbSchema = newSchema;
              var diff = getSchemaDiff(oldSchema, newSchema);
              diff.add.forEach(function(tuple) {
                createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
              });
              diff.change.forEach(function(change) {
                if (change.recreate) {
                  throw new exceptions.Upgrade("Not yet support for changing primary key");
                } else {
                  var store_1 = idbUpgradeTrans.objectStore(change.name);
                  change.add.forEach(function(idx) {
                    return addIndex(store_1, idx);
                  });
                  change.change.forEach(function(idx) {
                    store_1.deleteIndex(idx.name);
                    addIndex(store_1, idx);
                  });
                  change.del.forEach(function(idxName) {
                    return store_1.deleteIndex(idxName);
                  });
                }
              });
              var contentUpgrade = version3._cfg.contentUpgrade;
              if (contentUpgrade && version3._cfg.version > oldVersion) {
                generateMiddlewareStacks(db3, idbUpgradeTrans);
                trans._memoizedTables = {};
                var upgradeSchema_1 = shallowClone(newSchema);
                diff.del.forEach(function(table) {
                  upgradeSchema_1[table] = oldSchema[table];
                });
                removeTablesApi(db3, [db3.Transaction.prototype]);
                setApiOnPlace(db3, [db3.Transaction.prototype], keys2(upgradeSchema_1), upgradeSchema_1);
                trans.schema = upgradeSchema_1;
                var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);
                if (contentUpgradeIsAsync_1) {
                  incrementExpectedAwaits();
                }
                var returnValue_1;
                var promiseFollowed = DexiePromise.follow(function() {
                  returnValue_1 = contentUpgrade(trans);
                  if (returnValue_1) {
                    if (contentUpgradeIsAsync_1) {
                      var decrementor = decrementExpectedAwaits.bind(null, null);
                      returnValue_1.then(decrementor, decrementor);
                    }
                  }
                });
                return returnValue_1 && typeof returnValue_1.then === "function" ? DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function() {
                  return returnValue_1;
                });
              }
            });
            queue2.push(function(idbtrans) {
              var newSchema = version3._cfg.dbschema;
              deleteRemovedTables(newSchema, idbtrans);
              removeTablesApi(db3, [db3.Transaction.prototype]);
              setApiOnPlace(db3, [db3.Transaction.prototype], db3._storeNames, db3._dbSchema);
              trans.schema = db3._dbSchema;
            });
            queue2.push(function(idbtrans) {
              if (db3.idbdb.objectStoreNames.contains("$meta")) {
                if (Math.ceil(db3.idbdb.version / 10) === version3._cfg.version) {
                  db3.idbdb.deleteObjectStore("$meta");
                  delete db3._dbSchema.$meta;
                  db3._storeNames = db3._storeNames.filter(function(name) {
                    return name !== "$meta";
                  });
                } else {
                  idbtrans.objectStore("$meta").put(version3._cfg.version, "version");
                }
              }
            });
          });
          function runQueue() {
            return queue2.length ? DexiePromise.resolve(queue2.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();
          }
          return runQueue().then(function() {
            createMissingTables(globalSchema, idbUpgradeTrans);
          });
        }
        function getSchemaDiff(oldSchema, newSchema) {
          var diff = {
            del: [],
            add: [],
            change: []
          };
          var table;
          for (table in oldSchema) {
            if (!newSchema[table])
              diff.del.push(table);
          }
          for (table in newSchema) {
            var oldDef = oldSchema[table], newDef = newSchema[table];
            if (!oldDef) {
              diff.add.push([table, newDef]);
            } else {
              var change = {
                name: table,
                def: newDef,
                recreate: false,
                del: [],
                add: [],
                change: []
              };
              if ("" + (oldDef.primKey.keyPath || "") !== "" + (newDef.primKey.keyPath || "") || oldDef.primKey.auto !== newDef.primKey.auto) {
                change.recreate = true;
                diff.change.push(change);
              } else {
                var oldIndexes = oldDef.idxByName;
                var newIndexes = newDef.idxByName;
                var idxName = void 0;
                for (idxName in oldIndexes) {
                  if (!newIndexes[idxName])
                    change.del.push(idxName);
                }
                for (idxName in newIndexes) {
                  var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];
                  if (!oldIdx)
                    change.add.push(newIdx);
                  else if (oldIdx.src !== newIdx.src)
                    change.change.push(newIdx);
                }
                if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
                  diff.change.push(change);
                }
              }
            }
          }
          return diff;
        }
        function createTable(idbtrans, tableName, primKey, indexes) {
          var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? { keyPath: primKey.keyPath, autoIncrement: primKey.auto } : { autoIncrement: primKey.auto });
          indexes.forEach(function(idx) {
            return addIndex(store, idx);
          });
          return store;
        }
        function createMissingTables(newSchema, idbtrans) {
          keys2(newSchema).forEach(function(tableName) {
            if (!idbtrans.db.objectStoreNames.contains(tableName)) {
              if (debug)
                console.debug("Dexie: Creating missing table", tableName);
              createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
            }
          });
        }
        function deleteRemovedTables(newSchema, idbtrans) {
          [].slice.call(idbtrans.db.objectStoreNames).forEach(function(storeName) {
            return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);
          });
        }
        function addIndex(store, idx) {
          store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });
        }
        function buildGlobalSchema(db3, idbdb, tmpTrans) {
          var globalSchema = {};
          var dbStoreNames = slice(idbdb.objectStoreNames, 0);
          dbStoreNames.forEach(function(storeName) {
            var store = tmpTrans.objectStore(storeName);
            var keyPath = store.keyPath;
            var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || "", true, false, !!store.autoIncrement, keyPath && typeof keyPath !== "string", true);
            var indexes = [];
            for (var j = 0; j < store.indexNames.length; ++j) {
              var idbindex = store.index(store.indexNames[j]);
              keyPath = idbindex.keyPath;
              var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== "string", false);
              indexes.push(index);
            }
            globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);
          });
          return globalSchema;
        }
        function readGlobalSchema(db3, idbdb, tmpTrans) {
          db3.verno = idbdb.version / 10;
          var globalSchema = db3._dbSchema = buildGlobalSchema(db3, idbdb, tmpTrans);
          db3._storeNames = slice(idbdb.objectStoreNames, 0);
          setApiOnPlace(db3, [db3._allTables], keys2(globalSchema), globalSchema);
        }
        function verifyInstalledSchema(db3, tmpTrans) {
          var installedSchema = buildGlobalSchema(db3, db3.idbdb, tmpTrans);
          var diff = getSchemaDiff(installedSchema, db3._dbSchema);
          return !(diff.add.length || diff.change.some(function(ch) {
            return ch.add.length || ch.change.length;
          }));
        }
        function adjustToExistingIndexNames(db3, schema, idbtrans) {
          var storeNames = idbtrans.db.objectStoreNames;
          for (var i = 0; i < storeNames.length; ++i) {
            var storeName = storeNames[i];
            var store = idbtrans.objectStore(storeName);
            db3._hasGetAll = "getAll" in store;
            for (var j = 0; j < store.indexNames.length; ++j) {
              var indexName = store.indexNames[j];
              var keyPath = store.index(indexName).keyPath;
              var dexieName = typeof keyPath === "string" ? keyPath : "[" + slice(keyPath).join("+") + "]";
              if (schema[storeName]) {
                var indexSpec = schema[storeName].idxByName[dexieName];
                if (indexSpec) {
                  indexSpec.name = indexName;
                  delete schema[storeName].idxByName[dexieName];
                  schema[storeName].idxByName[indexName] = indexSpec;
                }
              }
            }
          }
          if (typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && _global2.WorkerGlobalScope && _global2 instanceof _global2.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
            db3._hasGetAll = false;
          }
        }
        function parseIndexSyntax(primKeyAndIndexes) {
          return primKeyAndIndexes.split(",").map(function(index, indexNum) {
            index = index.trim();
            var name = index.replace(/([&*]|\+\+)/g, "");
            var keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split("+") : name;
            return createIndexSpec(name, keyPath || null, /\&/.test(index), /\*/.test(index), /\+\+/.test(index), isArray2(keyPath), indexNum === 0);
          });
        }
        var Version = function() {
          function Version2() {
          }
          Version2.prototype._parseStoresSpec = function(stores, outSchema) {
            keys2(stores).forEach(function(tableName) {
              if (stores[tableName] !== null) {
                var indexes = parseIndexSyntax(stores[tableName]);
                var primKey = indexes.shift();
                primKey.unique = true;
                if (primKey.multi)
                  throw new exceptions.Schema("Primary key cannot be multi-valued");
                indexes.forEach(function(idx) {
                  if (idx.auto)
                    throw new exceptions.Schema("Only primary key can be marked as autoIncrement (++)");
                  if (!idx.keyPath)
                    throw new exceptions.Schema("Index must have a name and cannot be an empty string");
                });
                outSchema[tableName] = createTableSchema(tableName, primKey, indexes);
              }
            });
          };
          Version2.prototype.stores = function(stores) {
            var db3 = this.db;
            this._cfg.storesSource = this._cfg.storesSource ? extend2(this._cfg.storesSource, stores) : stores;
            var versions = db3._versions;
            var storesSpec = {};
            var dbschema = {};
            versions.forEach(function(version3) {
              extend2(storesSpec, version3._cfg.storesSource);
              dbschema = version3._cfg.dbschema = {};
              version3._parseStoresSpec(storesSpec, dbschema);
            });
            db3._dbSchema = dbschema;
            removeTablesApi(db3, [db3._allTables, db3, db3.Transaction.prototype]);
            setApiOnPlace(db3, [db3._allTables, db3, db3.Transaction.prototype, this._cfg.tables], keys2(dbschema), dbschema);
            db3._storeNames = keys2(dbschema);
            return this;
          };
          Version2.prototype.upgrade = function(upgradeFunction) {
            this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);
            return this;
          };
          return Version2;
        }();
        function createVersionConstructor(db3) {
          return makeClassConstructor(Version.prototype, function Version2(versionNumber) {
            this.db = db3;
            this._cfg = {
              version: versionNumber,
              storesSource: null,
              dbschema: {},
              tables: {},
              contentUpgrade: null
            };
          });
        }
        function getDbNamesTable(indexedDB2, IDBKeyRange) {
          var dbNamesDB = indexedDB2["_dbNamesDB"];
          if (!dbNamesDB) {
            dbNamesDB = indexedDB2["_dbNamesDB"] = new Dexie$1(DBNAMES_DB, {
              addons: [],
              indexedDB: indexedDB2,
              IDBKeyRange
            });
            dbNamesDB.version(1).stores({ dbnames: "name" });
          }
          return dbNamesDB.table("dbnames");
        }
        function hasDatabasesNative(indexedDB2) {
          return indexedDB2 && typeof indexedDB2.databases === "function";
        }
        function getDatabaseNames(_a4) {
          var indexedDB2 = _a4.indexedDB, IDBKeyRange = _a4.IDBKeyRange;
          return hasDatabasesNative(indexedDB2) ? Promise.resolve(indexedDB2.databases()).then(function(infos) {
            return infos.map(function(info) {
              return info.name;
            }).filter(function(name) {
              return name !== DBNAMES_DB;
            });
          }) : getDbNamesTable(indexedDB2, IDBKeyRange).toCollection().primaryKeys();
        }
        function _onDatabaseCreated(_a4, name) {
          var indexedDB2 = _a4.indexedDB, IDBKeyRange = _a4.IDBKeyRange;
          !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange).put({ name }).catch(nop);
        }
        function _onDatabaseDeleted(_a4, name) {
          var indexedDB2 = _a4.indexedDB, IDBKeyRange = _a4.IDBKeyRange;
          !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange).delete(name).catch(nop);
        }
        function vip(fn2) {
          return newScope(function() {
            PSD.letThrough = true;
            return fn2();
          });
        }
        function idbReady() {
          var isSafari = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent);
          if (!isSafari || !indexedDB.databases)
            return Promise.resolve();
          var intervalId;
          return new Promise(function(resolve2) {
            var tryIdb = function() {
              return indexedDB.databases().finally(resolve2);
            };
            intervalId = setInterval(tryIdb, 100);
            tryIdb();
          }).finally(function() {
            return clearInterval(intervalId);
          });
        }
        var _a3;
        function isEmptyRange(node) {
          return !("from" in node);
        }
        var RangeSet2 = function(fromOrTree, to2) {
          if (this) {
            extend2(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to2 : fromOrTree } : { d: 0 });
          } else {
            var rv = new RangeSet2();
            if (fromOrTree && "d" in fromOrTree) {
              extend2(rv, fromOrTree);
            }
            return rv;
          }
        };
        props(RangeSet2.prototype, (_a3 = {
          add: function(rangeSet) {
            mergeRanges2(this, rangeSet);
            return this;
          },
          addKey: function(key) {
            addRange(this, key, key);
            return this;
          },
          addKeys: function(keys3) {
            var _this = this;
            keys3.forEach(function(key) {
              return addRange(_this, key, key);
            });
            return this;
          },
          hasKey: function(key) {
            var node = getRangeSetIterator(this).next(key).value;
            return node && cmp2(node.from, key) <= 0 && cmp2(node.to, key) >= 0;
          }
        }, _a3[iteratorSymbol] = function() {
          return getRangeSetIterator(this);
        }, _a3));
        function addRange(target, from, to2) {
          var diff = cmp2(from, to2);
          if (isNaN(diff))
            return;
          if (diff > 0)
            throw RangeError();
          if (isEmptyRange(target))
            return extend2(target, { from, to: to2, d: 1 });
          var left = target.l;
          var right = target.r;
          if (cmp2(to2, target.from) < 0) {
            left ? addRange(left, from, to2) : target.l = { from, to: to2, d: 1, l: null, r: null };
            return rebalance(target);
          }
          if (cmp2(from, target.to) > 0) {
            right ? addRange(right, from, to2) : target.r = { from, to: to2, d: 1, l: null, r: null };
            return rebalance(target);
          }
          if (cmp2(from, target.from) < 0) {
            target.from = from;
            target.l = null;
            target.d = right ? right.d + 1 : 1;
          }
          if (cmp2(to2, target.to) > 0) {
            target.to = to2;
            target.r = null;
            target.d = target.l ? target.l.d + 1 : 1;
          }
          var rightWasCutOff = !target.r;
          if (left && !target.l) {
            mergeRanges2(target, left);
          }
          if (right && rightWasCutOff) {
            mergeRanges2(target, right);
          }
        }
        function mergeRanges2(target, newSet) {
          function _addRangeSet(target2, _a4) {
            var from = _a4.from, to2 = _a4.to, l = _a4.l, r = _a4.r;
            addRange(target2, from, to2);
            if (l)
              _addRangeSet(target2, l);
            if (r)
              _addRangeSet(target2, r);
          }
          if (!isEmptyRange(newSet))
            _addRangeSet(target, newSet);
        }
        function rangesOverlap2(rangeSet1, rangeSet2) {
          var i1 = getRangeSetIterator(rangeSet2);
          var nextResult1 = i1.next();
          if (nextResult1.done)
            return false;
          var a = nextResult1.value;
          var i2 = getRangeSetIterator(rangeSet1);
          var nextResult2 = i2.next(a.from);
          var b = nextResult2.value;
          while (!nextResult1.done && !nextResult2.done) {
            if (cmp2(b.from, a.to) <= 0 && cmp2(b.to, a.from) >= 0)
              return true;
            cmp2(a.from, b.from) < 0 ? a = (nextResult1 = i1.next(b.from)).value : b = (nextResult2 = i2.next(a.from)).value;
          }
          return false;
        }
        function getRangeSetIterator(node) {
          var state = isEmptyRange(node) ? null : { s: 0, n: node };
          return {
            next: function(key) {
              var keyProvided = arguments.length > 0;
              while (state) {
                switch (state.s) {
                  case 0:
                    state.s = 1;
                    if (keyProvided) {
                      while (state.n.l && cmp2(key, state.n.from) < 0)
                        state = { up: state, n: state.n.l, s: 1 };
                    } else {
                      while (state.n.l)
                        state = { up: state, n: state.n.l, s: 1 };
                    }
                  case 1:
                    state.s = 2;
                    if (!keyProvided || cmp2(key, state.n.to) <= 0)
                      return { value: state.n, done: false };
                  case 2:
                    if (state.n.r) {
                      state.s = 3;
                      state = { up: state, n: state.n.r, s: 0 };
                      continue;
                    }
                  case 3:
                    state = state.up;
                }
              }
              return { done: true };
            }
          };
        }
        function rebalance(target) {
          var _a4, _b;
          var diff = (((_a4 = target.r) === null || _a4 === void 0 ? void 0 : _a4.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);
          var r = diff > 1 ? "r" : diff < -1 ? "l" : "";
          if (r) {
            var l = r === "r" ? "l" : "r";
            var rootClone = __assign({}, target);
            var oldRootRight = target[r];
            target.from = oldRootRight.from;
            target.to = oldRootRight.to;
            target[r] = oldRootRight[r];
            rootClone[r] = oldRootRight[l];
            target[l] = rootClone;
            rootClone.d = computeDepth(rootClone);
          }
          target.d = computeDepth(target);
        }
        function computeDepth(_a4) {
          var r = _a4.r, l = _a4.l;
          return (r ? l ? Math.max(r.d, l.d) : r.d : l ? l.d : 0) + 1;
        }
        function extendObservabilitySet(target, newSet) {
          keys2(newSet).forEach(function(part) {
            if (target[part])
              mergeRanges2(target[part], newSet[part]);
            else
              target[part] = cloneSimpleObjectTree(newSet[part]);
          });
          return target;
        }
        function obsSetsOverlap(os1, os2) {
          return os1.all || os2.all || Object.keys(os1).some(function(key) {
            return os2[key] && rangesOverlap2(os2[key], os1[key]);
          });
        }
        var cache = {};
        var unsignaledParts = {};
        var isTaskEnqueued = false;
        function signalSubscribersLazily(part, optimistic) {
          extendObservabilitySet(unsignaledParts, part);
          if (!isTaskEnqueued) {
            isTaskEnqueued = true;
            setTimeout(function() {
              isTaskEnqueued = false;
              var parts = unsignaledParts;
              unsignaledParts = {};
              signalSubscribersNow(parts, false);
            }, 0);
          }
        }
        function signalSubscribersNow(updatedParts, deleteAffectedCacheEntries) {
          if (deleteAffectedCacheEntries === void 0) {
            deleteAffectedCacheEntries = false;
          }
          var queriesToSignal = /* @__PURE__ */ new Set();
          if (updatedParts.all) {
            for (var _i2 = 0, _a4 = Object.values(cache); _i2 < _a4.length; _i2++) {
              var tblCache = _a4[_i2];
              collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);
            }
          } else {
            for (var key in updatedParts) {
              var parts = /^idb\:\/\/(.*)\/(.*)\//.exec(key);
              if (parts) {
                var dbName = parts[1], tableName = parts[2];
                var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
                if (tblCache)
                  collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);
              }
            }
          }
          queriesToSignal.forEach(function(requery) {
            return requery();
          });
        }
        function collectTableSubscribers(tblCache, updatedParts, outQueriesToSignal, deleteAffectedCacheEntries) {
          var updatedEntryLists = [];
          for (var _i2 = 0, _a4 = Object.entries(tblCache.queries.query); _i2 < _a4.length; _i2++) {
            var _b = _a4[_i2], indexName = _b[0], entries = _b[1];
            var filteredEntries = [];
            for (var _c = 0, entries_1 = entries; _c < entries_1.length; _c++) {
              var entry = entries_1[_c];
              if (obsSetsOverlap(updatedParts, entry.obsSet)) {
                entry.subscribers.forEach(function(requery) {
                  return outQueriesToSignal.add(requery);
                });
              } else if (deleteAffectedCacheEntries) {
                filteredEntries.push(entry);
              }
            }
            if (deleteAffectedCacheEntries)
              updatedEntryLists.push([indexName, filteredEntries]);
          }
          if (deleteAffectedCacheEntries) {
            for (var _d = 0, updatedEntryLists_1 = updatedEntryLists; _d < updatedEntryLists_1.length; _d++) {
              var _e = updatedEntryLists_1[_d], indexName = _e[0], filteredEntries = _e[1];
              tblCache.queries.query[indexName] = filteredEntries;
            }
          }
        }
        function dexieOpen(db3) {
          var state = db3._state;
          var indexedDB2 = db3._deps.indexedDB;
          if (state.isBeingOpened || db3.idbdb)
            return state.dbReadyPromise.then(function() {
              return state.dbOpenError ? rejection(state.dbOpenError) : db3;
            });
          state.isBeingOpened = true;
          state.dbOpenError = null;
          state.openComplete = false;
          var openCanceller = state.openCanceller;
          var nativeVerToOpen = Math.round(db3.verno * 10);
          var schemaPatchMode = false;
          function throwIfCancelled() {
            if (state.openCanceller !== openCanceller)
              throw new exceptions.DatabaseClosed("db.open() was cancelled");
          }
          var resolveDbReady = state.dbReadyResolve, upgradeTransaction = null, wasCreated = false;
          var tryOpenDB = function() {
            return new DexiePromise(function(resolve2, reject) {
              throwIfCancelled();
              if (!indexedDB2)
                throw new exceptions.MissingAPI();
              var dbName = db3.name;
              var req = state.autoSchema || !nativeVerToOpen ? indexedDB2.open(dbName) : indexedDB2.open(dbName, nativeVerToOpen);
              if (!req)
                throw new exceptions.MissingAPI();
              req.onerror = eventRejectHandler(reject);
              req.onblocked = wrap(db3._fireOnBlocked);
              req.onupgradeneeded = wrap(function(e) {
                upgradeTransaction = req.transaction;
                if (state.autoSchema && !db3._options.allowEmptyDB) {
                  req.onerror = preventDefault;
                  upgradeTransaction.abort();
                  req.result.close();
                  var delreq = indexedDB2.deleteDatabase(dbName);
                  delreq.onsuccess = delreq.onerror = wrap(function() {
                    reject(new exceptions.NoSuchDatabase("Database ".concat(dbName, " doesnt exist")));
                  });
                } else {
                  upgradeTransaction.onerror = eventRejectHandler(reject);
                  var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;
                  wasCreated = oldVer < 1;
                  db3.idbdb = req.result;
                  if (schemaPatchMode) {
                    patchCurrentVersion(db3, upgradeTransaction);
                  }
                  runUpgraders(db3, oldVer / 10, upgradeTransaction, reject);
                }
              }, reject);
              req.onsuccess = wrap(function() {
                upgradeTransaction = null;
                var idbdb = db3.idbdb = req.result;
                var objectStoreNames = slice(idbdb.objectStoreNames);
                if (objectStoreNames.length > 0)
                  try {
                    var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), "readonly");
                    if (state.autoSchema)
                      readGlobalSchema(db3, idbdb, tmpTrans);
                    else {
                      adjustToExistingIndexNames(db3, db3._dbSchema, tmpTrans);
                      if (!verifyInstalledSchema(db3, tmpTrans) && !schemaPatchMode) {
                        console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this.");
                        idbdb.close();
                        nativeVerToOpen = idbdb.version + 1;
                        schemaPatchMode = true;
                        return resolve2(tryOpenDB());
                      }
                    }
                    generateMiddlewareStacks(db3, tmpTrans);
                  } catch (e) {
                  }
                connections.push(db3);
                idbdb.onversionchange = wrap(function(ev) {
                  state.vcFired = true;
                  db3.on("versionchange").fire(ev);
                });
                idbdb.onclose = wrap(function(ev) {
                  db3.on("close").fire(ev);
                });
                if (wasCreated)
                  _onDatabaseCreated(db3._deps, dbName);
                resolve2();
              }, reject);
            }).catch(function(err) {
              switch (err === null || err === void 0 ? void 0 : err.name) {
                case "UnknownError":
                  if (state.PR1398_maxLoop > 0) {
                    state.PR1398_maxLoop--;
                    console.warn("Dexie: Workaround for Chrome UnknownError on open()");
                    return tryOpenDB();
                  }
                  break;
                case "VersionError":
                  if (nativeVerToOpen > 0) {
                    nativeVerToOpen = 0;
                    return tryOpenDB();
                  }
                  break;
              }
              return DexiePromise.reject(err);
            });
          };
          return DexiePromise.race([
            openCanceller,
            (typeof navigator === "undefined" ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)
          ]).then(function() {
            throwIfCancelled();
            state.onReadyBeingFired = [];
            return DexiePromise.resolve(vip(function() {
              return db3.on.ready.fire(db3.vip);
            })).then(function fireRemainders() {
              if (state.onReadyBeingFired.length > 0) {
                var remainders_1 = state.onReadyBeingFired.reduce(promisableChain, nop);
                state.onReadyBeingFired = [];
                return DexiePromise.resolve(vip(function() {
                  return remainders_1(db3.vip);
                })).then(fireRemainders);
              }
            });
          }).finally(function() {
            if (state.openCanceller === openCanceller) {
              state.onReadyBeingFired = null;
              state.isBeingOpened = false;
            }
          }).catch(function(err) {
            state.dbOpenError = err;
            try {
              upgradeTransaction && upgradeTransaction.abort();
            } catch (_a4) {
            }
            if (openCanceller === state.openCanceller) {
              db3._close();
            }
            return rejection(err);
          }).finally(function() {
            state.openComplete = true;
            resolveDbReady();
          }).then(function() {
            if (wasCreated) {
              var everything_1 = {};
              db3.tables.forEach(function(table) {
                table.schema.indexes.forEach(function(idx) {
                  if (idx.name)
                    everything_1["idb://".concat(db3.name, "/").concat(table.name, "/").concat(idx.name)] = new RangeSet2(-Infinity, [[[]]]);
                });
                everything_1["idb://".concat(db3.name, "/").concat(table.name, "/")] = everything_1["idb://".concat(db3.name, "/").concat(table.name, "/:dels")] = new RangeSet2(-Infinity, [[[]]]);
              });
              globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME).fire(everything_1);
              signalSubscribersNow(everything_1, true);
            }
            return db3;
          });
        }
        function awaitIterator(iterator2) {
          var callNext = function(result) {
            return iterator2.next(result);
          }, doThrow = function(error) {
            return iterator2.throw(error);
          }, onSuccess = step(callNext), onError = step(doThrow);
          function step(getNext) {
            return function(val) {
              var next = getNext(val), value = next.value;
              return next.done ? value : !value || typeof value.then !== "function" ? isArray2(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);
            };
          }
          return step(callNext)();
        }
        function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
          var i = arguments.length;
          if (i < 2)
            throw new exceptions.InvalidArgument("Too few arguments");
          var args = new Array(i - 1);
          while (--i)
            args[i - 1] = arguments[i];
          scopeFunc = args.pop();
          var tables = flatten(args);
          return [mode, tables, scopeFunc];
        }
        function enterTransactionScope(db3, mode, storeNames, parentTransaction, scopeFunc) {
          return DexiePromise.resolve().then(function() {
            var transless = PSD.transless || PSD;
            var trans = db3._createTransaction(mode, storeNames, db3._dbSchema, parentTransaction);
            trans.explicit = true;
            var zoneProps = {
              trans,
              transless
            };
            if (parentTransaction) {
              trans.idbtrans = parentTransaction.idbtrans;
            } else {
              try {
                trans.create();
                trans.idbtrans._explicit = true;
                db3._state.PR1398_maxLoop = 3;
              } catch (ex) {
                if (ex.name === errnames.InvalidState && db3.isOpen() && --db3._state.PR1398_maxLoop > 0) {
                  console.warn("Dexie: Need to reopen db");
                  db3.close({ disableAutoOpen: false });
                  return db3.open().then(function() {
                    return enterTransactionScope(db3, mode, storeNames, null, scopeFunc);
                  });
                }
                return rejection(ex);
              }
            }
            var scopeFuncIsAsync = isAsyncFunction(scopeFunc);
            if (scopeFuncIsAsync) {
              incrementExpectedAwaits();
            }
            var returnValue;
            var promiseFollowed = DexiePromise.follow(function() {
              returnValue = scopeFunc.call(trans, trans);
              if (returnValue) {
                if (scopeFuncIsAsync) {
                  var decrementor = decrementExpectedAwaits.bind(null, null);
                  returnValue.then(decrementor, decrementor);
                } else if (typeof returnValue.next === "function" && typeof returnValue.throw === "function") {
                  returnValue = awaitIterator(returnValue);
                }
              }
            }, zoneProps);
            return (returnValue && typeof returnValue.then === "function" ? DexiePromise.resolve(returnValue).then(function(x) {
              return trans.active ? x : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : promiseFollowed.then(function() {
              return returnValue;
            })).then(function(x) {
              if (parentTransaction)
                trans._resolve();
              return trans._completion.then(function() {
                return x;
              });
            }).catch(function(e) {
              trans._reject(e);
              return rejection(e);
            });
          });
        }
        function pad(a, value, count) {
          var result = isArray2(a) ? a.slice() : [a];
          for (var i = 0; i < count; ++i)
            result.push(value);
          return result;
        }
        function createVirtualIndexMiddleware(down) {
          return __assign(__assign({}, down), { table: function(tableName) {
            var table = down.table(tableName);
            var schema = table.schema;
            var indexLookup = {};
            var allVirtualIndexes = [];
            function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {
              var keyPathAlias = getKeyPathAlias(keyPath);
              var indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];
              var keyLength = keyPath == null ? 0 : typeof keyPath === "string" ? 1 : keyPath.length;
              var isVirtual = keyTail > 0;
              var virtualIndex = __assign(__assign({}, lowLevelIndex), { name: isVirtual ? "".concat(keyPathAlias, "(virtual-from:").concat(lowLevelIndex.name, ")") : lowLevelIndex.name, lowLevelIndex, isVirtual, keyTail, keyLength, extractKey: getKeyExtractor(keyPath), unique: !isVirtual && lowLevelIndex.unique });
              indexList.push(virtualIndex);
              if (!virtualIndex.isPrimaryKey) {
                allVirtualIndexes.push(virtualIndex);
              }
              if (keyLength > 1) {
                var virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);
                addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);
              }
              indexList.sort(function(a, b) {
                return a.keyTail - b.keyTail;
              });
              return virtualIndex;
            }
            var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);
            indexLookup[":id"] = [primaryKey];
            for (var _i2 = 0, _a4 = schema.indexes; _i2 < _a4.length; _i2++) {
              var index = _a4[_i2];
              addVirtualIndexes(index.keyPath, 0, index);
            }
            function findBestIndex(keyPath) {
              var result2 = indexLookup[getKeyPathAlias(keyPath)];
              return result2 && result2[0];
            }
            function translateRange(range, keyTail) {
              return {
                type: range.type === 1 ? 2 : range.type,
                lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),
                lowerOpen: true,
                upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),
                upperOpen: true
              };
            }
            function translateRequest(req) {
              var index2 = req.query.index;
              return index2.isVirtual ? __assign(__assign({}, req), { query: {
                index: index2.lowLevelIndex,
                range: translateRange(req.query.range, index2.keyTail)
              } }) : req;
            }
            var result = __assign(__assign({}, table), { schema: __assign(__assign({}, schema), { primaryKey, indexes: allVirtualIndexes, getIndexByKeyPath: findBestIndex }), count: function(req) {
              return table.count(translateRequest(req));
            }, query: function(req) {
              return table.query(translateRequest(req));
            }, openCursor: function(req) {
              var _a5 = req.query.index, keyTail = _a5.keyTail, isVirtual = _a5.isVirtual, keyLength = _a5.keyLength;
              if (!isVirtual)
                return table.openCursor(req);
              function createVirtualCursor(cursor) {
                function _continue(key) {
                  key != null ? cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor.continue(cursor.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor.continue();
                }
                var virtualCursor = Object.create(cursor, {
                  continue: { value: _continue },
                  continuePrimaryKey: {
                    value: function(key, primaryKey2) {
                      cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey2);
                    }
                  },
                  primaryKey: {
                    get: function() {
                      return cursor.primaryKey;
                    }
                  },
                  key: {
                    get: function() {
                      var key = cursor.key;
                      return keyLength === 1 ? key[0] : key.slice(0, keyLength);
                    }
                  },
                  value: {
                    get: function() {
                      return cursor.value;
                    }
                  }
                });
                return virtualCursor;
              }
              return table.openCursor(translateRequest(req)).then(function(cursor) {
                return cursor && createVirtualCursor(cursor);
              });
            } });
            return result;
          } });
        }
        var virtualIndexMiddleware = {
          stack: "dbcore",
          name: "VirtualIndexMiddleware",
          level: 1,
          create: createVirtualIndexMiddleware
        };
        function getObjectDiff(a, b, rv, prfx) {
          rv = rv || {};
          prfx = prfx || "";
          keys2(a).forEach(function(prop) {
            if (!hasOwn3(b, prop)) {
              rv[prfx + prop] = void 0;
            } else {
              var ap = a[prop], bp = b[prop];
              if (typeof ap === "object" && typeof bp === "object" && ap && bp) {
                var apTypeName = toStringTag(ap);
                var bpTypeName = toStringTag(bp);
                if (apTypeName !== bpTypeName) {
                  rv[prfx + prop] = b[prop];
                } else if (apTypeName === "Object") {
                  getObjectDiff(ap, bp, rv, prfx + prop + ".");
                } else if (ap !== bp) {
                  rv[prfx + prop] = b[prop];
                }
              } else if (ap !== bp)
                rv[prfx + prop] = b[prop];
            }
          });
          keys2(b).forEach(function(prop) {
            if (!hasOwn3(a, prop)) {
              rv[prfx + prop] = b[prop];
            }
          });
          return rv;
        }
        function getEffectiveKeys(primaryKey, req) {
          if (req.type === "delete")
            return req.keys;
          return req.keys || req.values.map(primaryKey.extractKey);
        }
        var hooksMiddleware = {
          stack: "dbcore",
          name: "HooksMiddleware",
          level: 2,
          create: function(downCore) {
            return __assign(__assign({}, downCore), { table: function(tableName) {
              var downTable = downCore.table(tableName);
              var primaryKey = downTable.schema.primaryKey;
              var tableMiddleware = __assign(__assign({}, downTable), { mutate: function(req) {
                var dxTrans = PSD.trans;
                var _a4 = dxTrans.table(tableName).hook, deleting = _a4.deleting, creating = _a4.creating, updating = _a4.updating;
                switch (req.type) {
                  case "add":
                    if (creating.fire === nop)
                      break;
                    return dxTrans._promise("readwrite", function() {
                      return addPutOrDelete(req);
                    }, true);
                  case "put":
                    if (creating.fire === nop && updating.fire === nop)
                      break;
                    return dxTrans._promise("readwrite", function() {
                      return addPutOrDelete(req);
                    }, true);
                  case "delete":
                    if (deleting.fire === nop)
                      break;
                    return dxTrans._promise("readwrite", function() {
                      return addPutOrDelete(req);
                    }, true);
                  case "deleteRange":
                    if (deleting.fire === nop)
                      break;
                    return dxTrans._promise("readwrite", function() {
                      return deleteRange(req);
                    }, true);
                }
                return downTable.mutate(req);
                function addPutOrDelete(req2) {
                  var dxTrans2 = PSD.trans;
                  var keys3 = req2.keys || getEffectiveKeys(primaryKey, req2);
                  if (!keys3)
                    throw new Error("Keys missing");
                  req2 = req2.type === "add" || req2.type === "put" ? __assign(__assign({}, req2), { keys: keys3 }) : __assign({}, req2);
                  if (req2.type !== "delete")
                    req2.values = __spreadArray([], req2.values, true);
                  if (req2.keys)
                    req2.keys = __spreadArray([], req2.keys, true);
                  return getExistingValues(downTable, req2, keys3).then(function(existingValues) {
                    var contexts = keys3.map(function(key, i) {
                      var existingValue = existingValues[i];
                      var ctx = { onerror: null, onsuccess: null };
                      if (req2.type === "delete") {
                        deleting.fire.call(ctx, key, existingValue, dxTrans2);
                      } else if (req2.type === "add" || existingValue === void 0) {
                        var generatedPrimaryKey = creating.fire.call(ctx, key, req2.values[i], dxTrans2);
                        if (key == null && generatedPrimaryKey != null) {
                          key = generatedPrimaryKey;
                          req2.keys[i] = key;
                          if (!primaryKey.outbound) {
                            setByKeyPath(req2.values[i], primaryKey.keyPath, key);
                          }
                        }
                      } else {
                        var objectDiff = getObjectDiff(existingValue, req2.values[i]);
                        var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans2);
                        if (additionalChanges_1) {
                          var requestedValue_1 = req2.values[i];
                          Object.keys(additionalChanges_1).forEach(function(keyPath) {
                            if (hasOwn3(requestedValue_1, keyPath)) {
                              requestedValue_1[keyPath] = additionalChanges_1[keyPath];
                            } else {
                              setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);
                            }
                          });
                        }
                      }
                      return ctx;
                    });
                    return downTable.mutate(req2).then(function(_a5) {
                      var failures = _a5.failures, results = _a5.results, numFailures = _a5.numFailures, lastResult = _a5.lastResult;
                      for (var i = 0; i < keys3.length; ++i) {
                        var primKey = results ? results[i] : keys3[i];
                        var ctx = contexts[i];
                        if (primKey == null) {
                          ctx.onerror && ctx.onerror(failures[i]);
                        } else {
                          ctx.onsuccess && ctx.onsuccess(
                            req2.type === "put" && existingValues[i] ? req2.values[i] : primKey
                          );
                        }
                      }
                      return { failures, results, numFailures, lastResult };
                    }).catch(function(error) {
                      contexts.forEach(function(ctx) {
                        return ctx.onerror && ctx.onerror(error);
                      });
                      return Promise.reject(error);
                    });
                  });
                }
                function deleteRange(req2) {
                  return deleteNextChunk(req2.trans, req2.range, 1e4);
                }
                function deleteNextChunk(trans, range, limit) {
                  return downTable.query({ trans, values: false, query: { index: primaryKey, range }, limit }).then(function(_a5) {
                    var result = _a5.result;
                    return addPutOrDelete({ type: "delete", keys: result, trans }).then(function(res) {
                      if (res.numFailures > 0)
                        return Promise.reject(res.failures[0]);
                      if (result.length < limit) {
                        return { failures: [], numFailures: 0, lastResult: void 0 };
                      } else {
                        return deleteNextChunk(trans, __assign(__assign({}, range), { lower: result[result.length - 1], lowerOpen: true }), limit);
                      }
                    });
                  });
                }
              } });
              return tableMiddleware;
            } });
          }
        };
        function getExistingValues(table, req, effectiveKeys) {
          return req.type === "add" ? Promise.resolve([]) : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: "immutable" });
        }
        function getFromTransactionCache(keys3, cache2, clone) {
          try {
            if (!cache2)
              return null;
            if (cache2.keys.length < keys3.length)
              return null;
            var result = [];
            for (var i = 0, j = 0; i < cache2.keys.length && j < keys3.length; ++i) {
              if (cmp2(cache2.keys[i], keys3[j]) !== 0)
                continue;
              result.push(clone ? deepClone(cache2.values[i]) : cache2.values[i]);
              ++j;
            }
            return result.length === keys3.length ? result : null;
          } catch (_a4) {
            return null;
          }
        }
        var cacheExistingValuesMiddleware = {
          stack: "dbcore",
          level: -1,
          create: function(core) {
            return {
              table: function(tableName) {
                var table = core.table(tableName);
                return __assign(__assign({}, table), { getMany: function(req) {
                  if (!req.cache) {
                    return table.getMany(req);
                  }
                  var cachedResult = getFromTransactionCache(req.keys, req.trans["_cache"], req.cache === "clone");
                  if (cachedResult) {
                    return DexiePromise.resolve(cachedResult);
                  }
                  return table.getMany(req).then(function(res) {
                    req.trans["_cache"] = {
                      keys: req.keys,
                      values: req.cache === "clone" ? deepClone(res) : res
                    };
                    return res;
                  });
                }, mutate: function(req) {
                  if (req.type !== "add")
                    req.trans["_cache"] = null;
                  return table.mutate(req);
                } });
              }
            };
          }
        };
        function isCachableContext(ctx, table) {
          return ctx.trans.mode === "readonly" && !!ctx.subscr && !ctx.trans.explicit && ctx.trans.db._options.cache !== "disabled" && !table.schema.primaryKey.outbound;
        }
        function isCachableRequest(type2, req) {
          switch (type2) {
            case "query":
              return req.values && !req.unique;
            case "get":
              return false;
            case "getMany":
              return false;
            case "count":
              return false;
            case "openCursor":
              return false;
          }
        }
        var observabilityMiddleware = {
          stack: "dbcore",
          level: 0,
          name: "Observability",
          create: function(core) {
            var dbName = core.schema.name;
            var FULL_RANGE = new RangeSet2(core.MIN_KEY, core.MAX_KEY);
            return __assign(__assign({}, core), { transaction: function(stores, mode, options) {
              if (PSD.subscr && mode !== "readonly") {
                throw new exceptions.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(PSD.querier));
              }
              return core.transaction(stores, mode, options);
            }, table: function(tableName) {
              var table = core.table(tableName);
              var schema = table.schema;
              var primaryKey = schema.primaryKey, indexes = schema.indexes;
              var extractKey = primaryKey.extractKey, outbound = primaryKey.outbound;
              var indexesWithAutoIncPK = primaryKey.autoIncrement && indexes.filter(function(index) {
                return index.compound && index.keyPath.includes(primaryKey.keyPath);
              });
              var tableClone = __assign(__assign({}, table), { mutate: function(req) {
                var _a4, _b;
                var trans = req.trans;
                var mutatedParts = req.mutatedParts || (req.mutatedParts = {});
                var getRangeSet = function(indexName) {
                  var part = "idb://".concat(dbName, "/").concat(tableName, "/").concat(indexName);
                  return mutatedParts[part] || (mutatedParts[part] = new RangeSet2());
                };
                var pkRangeSet = getRangeSet("");
                var delsRangeSet = getRangeSet(":dels");
                var type2 = req.type;
                var _c = req.type === "deleteRange" ? [req.range] : req.type === "delete" ? [req.keys] : req.values.length < 50 ? [getEffectiveKeys(primaryKey, req).filter(function(id) {
                  return id;
                }), req.values] : [], keys3 = _c[0], newObjs = _c[1];
                var oldCache = req.trans["_cache"];
                if (isArray2(keys3)) {
                  pkRangeSet.addKeys(keys3);
                  var oldObjs = type2 === "delete" || keys3.length === newObjs.length ? getFromTransactionCache(keys3, oldCache) : null;
                  if (!oldObjs) {
                    delsRangeSet.addKeys(keys3);
                  }
                  if (oldObjs || newObjs) {
                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);
                  }
                } else if (keys3) {
                  var range = {
                    from: (_a4 = keys3.lower) !== null && _a4 !== void 0 ? _a4 : core.MIN_KEY,
                    to: (_b = keys3.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY
                  };
                  delsRangeSet.add(range);
                  pkRangeSet.add(range);
                } else {
                  pkRangeSet.add(FULL_RANGE);
                  delsRangeSet.add(FULL_RANGE);
                  schema.indexes.forEach(function(idx) {
                    return getRangeSet(idx.name).add(FULL_RANGE);
                  });
                }
                return table.mutate(req).then(function(res) {
                  if (keys3 && (req.type === "add" || req.type === "put")) {
                    pkRangeSet.addKeys(res.results);
                    if (indexesWithAutoIncPK) {
                      indexesWithAutoIncPK.forEach(function(idx) {
                        var idxVals = req.values.map(function(v) {
                          return idx.extractKey(v);
                        });
                        var pkPos = idx.keyPath.findIndex(function(prop) {
                          return prop === primaryKey.keyPath;
                        });
                        for (var i = 0, len = res.results.length; i < len; ++i) {
                          idxVals[i][pkPos] = res.results[i];
                        }
                        getRangeSet(idx.name).addKeys(idxVals);
                      });
                    }
                  }
                  trans.mutatedParts = extendObservabilitySet(trans.mutatedParts || {}, mutatedParts);
                  return res;
                });
              } });
              var getRange = function(_a4) {
                var _b, _c;
                var _d = _a4.query, index = _d.index, range = _d.range;
                return [
                  index,
                  new RangeSet2((_b = range.lower) !== null && _b !== void 0 ? _b : core.MIN_KEY, (_c = range.upper) !== null && _c !== void 0 ? _c : core.MAX_KEY)
                ];
              };
              var readSubscribers = {
                get: function(req) {
                  return [primaryKey, new RangeSet2(req.key)];
                },
                getMany: function(req) {
                  return [primaryKey, new RangeSet2().addKeys(req.keys)];
                },
                count: getRange,
                query: getRange,
                openCursor: getRange
              };
              keys2(readSubscribers).forEach(function(method) {
                tableClone[method] = function(req) {
                  var subscr = PSD.subscr;
                  var isLiveQuery = !!subscr;
                  var cachable = isCachableContext(PSD, table) && isCachableRequest(method, req);
                  var obsSet = cachable ? req.obsSet = {} : subscr;
                  if (isLiveQuery) {
                    var getRangeSet = function(indexName) {
                      var part = "idb://".concat(dbName, "/").concat(tableName, "/").concat(indexName);
                      return obsSet[part] || (obsSet[part] = new RangeSet2());
                    };
                    var pkRangeSet_1 = getRangeSet("");
                    var delsRangeSet_1 = getRangeSet(":dels");
                    var _a4 = readSubscribers[method](req), queriedIndex = _a4[0], queriedRanges = _a4[1];
                    if (method === "query" && queriedIndex.isPrimaryKey && !req.values) {
                      delsRangeSet_1.add(queriedRanges);
                    } else {
                      getRangeSet(queriedIndex.name || "").add(queriedRanges);
                    }
                    if (!queriedIndex.isPrimaryKey) {
                      if (method === "count") {
                        delsRangeSet_1.add(FULL_RANGE);
                      } else {
                        var keysPromise_1 = method === "query" && outbound && req.values && table.query(__assign(__assign({}, req), { values: false }));
                        return table[method].apply(this, arguments).then(function(res) {
                          if (method === "query") {
                            if (outbound && req.values) {
                              return keysPromise_1.then(function(_a5) {
                                var resultingKeys = _a5.result;
                                pkRangeSet_1.addKeys(resultingKeys);
                                return res;
                              });
                            }
                            var pKeys = req.values ? res.result.map(extractKey) : res.result;
                            if (req.values) {
                              pkRangeSet_1.addKeys(pKeys);
                            } else {
                              delsRangeSet_1.addKeys(pKeys);
                            }
                          } else if (method === "openCursor") {
                            var cursor_1 = res;
                            var wantValues_1 = req.values;
                            return cursor_1 && Object.create(cursor_1, {
                              key: {
                                get: function() {
                                  delsRangeSet_1.addKey(cursor_1.primaryKey);
                                  return cursor_1.key;
                                }
                              },
                              primaryKey: {
                                get: function() {
                                  var pkey = cursor_1.primaryKey;
                                  delsRangeSet_1.addKey(pkey);
                                  return pkey;
                                }
                              },
                              value: {
                                get: function() {
                                  wantValues_1 && pkRangeSet_1.addKey(cursor_1.primaryKey);
                                  return cursor_1.value;
                                }
                              }
                            });
                          }
                          return res;
                        });
                      }
                    }
                  }
                  return table[method].apply(this, arguments);
                };
              });
              return tableClone;
            } });
          }
        };
        function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {
          function addAffectedIndex(ix) {
            var rangeSet = getRangeSet(ix.name || "");
            function extractKey(obj) {
              return obj != null ? ix.extractKey(obj) : null;
            }
            var addKeyOrKeys = function(key) {
              return ix.multiEntry && isArray2(key) ? key.forEach(function(key2) {
                return rangeSet.addKey(key2);
              }) : rangeSet.addKey(key);
            };
            (oldObjs || newObjs).forEach(function(_2, i) {
              var oldKey = oldObjs && extractKey(oldObjs[i]);
              var newKey = newObjs && extractKey(newObjs[i]);
              if (cmp2(oldKey, newKey) !== 0) {
                if (oldKey != null)
                  addKeyOrKeys(oldKey);
                if (newKey != null)
                  addKeyOrKeys(newKey);
              }
            });
          }
          schema.indexes.forEach(addAffectedIndex);
        }
        function adjustOptimisticFromFailures(tblCache, req, res) {
          if (res.numFailures === 0)
            return req;
          if (req.type === "deleteRange") {
            return null;
          }
          var numBulkOps = req.keys ? req.keys.length : "values" in req && req.values ? req.values.length : 1;
          if (res.numFailures === numBulkOps) {
            return null;
          }
          var clone = __assign({}, req);
          if (isArray2(clone.keys)) {
            clone.keys = clone.keys.filter(function(_2, i) {
              return !(i in res.failures);
            });
          }
          if ("values" in clone && isArray2(clone.values)) {
            clone.values = clone.values.filter(function(_2, i) {
              return !(i in res.failures);
            });
          }
          return clone;
        }
        function isAboveLower(key, range) {
          return range.lower === void 0 ? true : range.lowerOpen ? cmp2(key, range.lower) > 0 : cmp2(key, range.lower) >= 0;
        }
        function isBelowUpper(key, range) {
          return range.upper === void 0 ? true : range.upperOpen ? cmp2(key, range.upper) < 0 : cmp2(key, range.upper) <= 0;
        }
        function isWithinRange2(key, range) {
          return isAboveLower(key, range) && isBelowUpper(key, range);
        }
        function applyOptimisticOps(result, req, ops, table, cacheEntry, immutable) {
          if (!ops || ops.length === 0)
            return result;
          var index = req.query.index;
          var multiEntry = index.multiEntry;
          var queryRange = req.query.range;
          var primaryKey = table.schema.primaryKey;
          var extractPrimKey = primaryKey.extractKey;
          var extractIndex = index.extractKey;
          var extractLowLevelIndex = (index.lowLevelIndex || index).extractKey;
          var finalResult = ops.reduce(function(result2, op) {
            var modifedResult = result2;
            var includedValues = [];
            if (op.type === "add" || op.type === "put") {
              var includedPKs = new RangeSet2();
              for (var i = op.values.length - 1; i >= 0; --i) {
                var value = op.values[i];
                var pk = extractPrimKey(value);
                if (includedPKs.hasKey(pk))
                  continue;
                var key = extractIndex(value);
                if (multiEntry && isArray2(key) ? key.some(function(k) {
                  return isWithinRange2(k, queryRange);
                }) : isWithinRange2(key, queryRange)) {
                  includedPKs.addKey(pk);
                  includedValues.push(value);
                }
              }
            }
            switch (op.type) {
              case "add": {
                var existingKeys_1 = new RangeSet2().addKeys(req.values ? result2.map(function(v) {
                  return extractPrimKey(v);
                }) : result2);
                modifedResult = result2.concat(req.values ? includedValues.filter(function(v) {
                  var key2 = extractPrimKey(v);
                  if (existingKeys_1.hasKey(key2))
                    return false;
                  existingKeys_1.addKey(key2);
                  return true;
                }) : includedValues.map(function(v) {
                  return extractPrimKey(v);
                }).filter(function(k) {
                  if (existingKeys_1.hasKey(k))
                    return false;
                  existingKeys_1.addKey(k);
                  return true;
                }));
                break;
              }
              case "put": {
                var keySet_1 = new RangeSet2().addKeys(op.values.map(function(v) {
                  return extractPrimKey(v);
                }));
                modifedResult = result2.filter(
                  function(item) {
                    return !keySet_1.hasKey(req.values ? extractPrimKey(item) : item);
                  }
                ).concat(
                  req.values ? includedValues : includedValues.map(function(v) {
                    return extractPrimKey(v);
                  })
                );
                break;
              }
              case "delete":
                var keysToDelete_1 = new RangeSet2().addKeys(op.keys);
                modifedResult = result2.filter(function(item) {
                  return !keysToDelete_1.hasKey(req.values ? extractPrimKey(item) : item);
                });
                break;
              case "deleteRange":
                var range_1 = op.range;
                modifedResult = result2.filter(function(item) {
                  return !isWithinRange2(extractPrimKey(item), range_1);
                });
                break;
            }
            return modifedResult;
          }, result);
          if (finalResult === result)
            return result;
          finalResult.sort(function(a, b) {
            return cmp2(extractLowLevelIndex(a), extractLowLevelIndex(b)) || cmp2(extractPrimKey(a), extractPrimKey(b));
          });
          if (req.limit && req.limit < Infinity) {
            if (finalResult.length > req.limit) {
              finalResult.length = req.limit;
            } else if (result.length === req.limit && finalResult.length < req.limit) {
              cacheEntry.dirty = true;
            }
          }
          return immutable ? Object.freeze(finalResult) : finalResult;
        }
        function areRangesEqual(r1, r2) {
          return cmp2(r1.lower, r2.lower) === 0 && cmp2(r1.upper, r2.upper) === 0 && !!r1.lowerOpen === !!r2.lowerOpen && !!r1.upperOpen === !!r2.upperOpen;
        }
        function compareLowers(lower1, lower2, lowerOpen1, lowerOpen2) {
          if (lower1 === void 0)
            return lower2 !== void 0 ? -1 : 0;
          if (lower2 === void 0)
            return 1;
          var c = cmp2(lower1, lower2);
          if (c === 0) {
            if (lowerOpen1 && lowerOpen2)
              return 0;
            if (lowerOpen1)
              return 1;
            if (lowerOpen2)
              return -1;
          }
          return c;
        }
        function compareUppers(upper1, upper2, upperOpen1, upperOpen2) {
          if (upper1 === void 0)
            return upper2 !== void 0 ? 1 : 0;
          if (upper2 === void 0)
            return -1;
          var c = cmp2(upper1, upper2);
          if (c === 0) {
            if (upperOpen1 && upperOpen2)
              return 0;
            if (upperOpen1)
              return -1;
            if (upperOpen2)
              return 1;
          }
          return c;
        }
        function isSuperRange(r1, r2) {
          return compareLowers(r1.lower, r2.lower, r1.lowerOpen, r2.lowerOpen) <= 0 && compareUppers(r1.upper, r2.upper, r1.upperOpen, r2.upperOpen) >= 0;
        }
        function findCompatibleQuery(dbName, tableName, type2, req) {
          var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
          if (!tblCache)
            return [];
          var queries = tblCache.queries[type2];
          if (!queries)
            return [null, false, tblCache, null];
          var indexName = req.query ? req.query.index.name : null;
          var entries = queries[indexName || ""];
          if (!entries)
            return [null, false, tblCache, null];
          switch (type2) {
            case "query":
              var equalEntry = entries.find(function(entry) {
                return entry.req.limit === req.limit && entry.req.values === req.values && areRangesEqual(entry.req.query.range, req.query.range);
              });
              if (equalEntry)
                return [
                  equalEntry,
                  true,
                  tblCache,
                  entries
                ];
              var superEntry = entries.find(function(entry) {
                var limit = "limit" in entry.req ? entry.req.limit : Infinity;
                return limit >= req.limit && (req.values ? entry.req.values : true) && isSuperRange(entry.req.query.range, req.query.range);
              });
              return [superEntry, false, tblCache, entries];
            case "count":
              var countQuery = entries.find(function(entry) {
                return areRangesEqual(entry.req.query.range, req.query.range);
              });
              return [countQuery, !!countQuery, tblCache, entries];
          }
        }
        function subscribeToCacheEntry(cacheEntry, container, requery, signal) {
          cacheEntry.subscribers.add(requery);
          signal.addEventListener("abort", function() {
            cacheEntry.subscribers.delete(requery);
            if (cacheEntry.subscribers.size === 0) {
              enqueForDeletion(cacheEntry, container);
            }
          });
        }
        function enqueForDeletion(cacheEntry, container) {
          setTimeout(function() {
            if (cacheEntry.subscribers.size === 0) {
              delArrayItem(container, cacheEntry);
            }
          }, 3e3);
        }
        var cacheMiddleware = {
          stack: "dbcore",
          level: 0,
          name: "Cache",
          create: function(core) {
            var dbName = core.schema.name;
            var coreMW = __assign(__assign({}, core), { transaction: function(stores, mode, options) {
              var idbtrans = core.transaction(stores, mode, options);
              if (mode === "readwrite") {
                var ac_1 = new AbortController();
                var signal = ac_1.signal;
                var endTransaction = function(wasCommitted) {
                  return function() {
                    ac_1.abort();
                    if (mode === "readwrite") {
                      var affectedSubscribers_1 = /* @__PURE__ */ new Set();
                      for (var _i2 = 0, stores_1 = stores; _i2 < stores_1.length; _i2++) {
                        var storeName = stores_1[_i2];
                        var tblCache = cache["idb://".concat(dbName, "/").concat(storeName)];
                        if (tblCache) {
                          var table = core.table(storeName);
                          var ops = tblCache.optimisticOps.filter(function(op) {
                            return op.trans === idbtrans;
                          });
                          if (idbtrans._explicit && wasCommitted && idbtrans.mutatedParts) {
                            for (var _a4 = 0, _b = Object.values(tblCache.queries.query); _a4 < _b.length; _a4++) {
                              var entries = _b[_a4];
                              for (var _c = 0, _d = entries.slice(); _c < _d.length; _c++) {
                                var entry = _d[_c];
                                if (obsSetsOverlap(entry.obsSet, idbtrans.mutatedParts)) {
                                  delArrayItem(entries, entry);
                                  entry.subscribers.forEach(function(requery) {
                                    return affectedSubscribers_1.add(requery);
                                  });
                                }
                              }
                            }
                          } else if (ops.length > 0) {
                            tblCache.optimisticOps = tblCache.optimisticOps.filter(function(op) {
                              return op.trans !== idbtrans;
                            });
                            for (var _e = 0, _f = Object.values(tblCache.queries.query); _e < _f.length; _e++) {
                              var entries = _f[_e];
                              for (var _g = 0, _h = entries.slice(); _g < _h.length; _g++) {
                                var entry = _h[_g];
                                if (entry.res != null && idbtrans.mutatedParts) {
                                  if (wasCommitted && !entry.dirty) {
                                    var freezeResults = Object.isFrozen(entry.res);
                                    var modRes = applyOptimisticOps(entry.res, entry.req, ops, table, entry, freezeResults);
                                    if (entry.dirty) {
                                      delArrayItem(entries, entry);
                                      entry.subscribers.forEach(function(requery) {
                                        return affectedSubscribers_1.add(requery);
                                      });
                                    } else if (modRes !== entry.res) {
                                      entry.res = modRes;
                                      entry.promise = DexiePromise.resolve({ result: modRes });
                                    }
                                  } else {
                                    if (entry.dirty) {
                                      delArrayItem(entries, entry);
                                    }
                                    entry.subscribers.forEach(function(requery) {
                                      return affectedSubscribers_1.add(requery);
                                    });
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                      affectedSubscribers_1.forEach(function(requery) {
                        return requery();
                      });
                    }
                  };
                };
                idbtrans.addEventListener("abort", endTransaction(false), {
                  signal
                });
                idbtrans.addEventListener("error", endTransaction(false), {
                  signal
                });
                idbtrans.addEventListener("complete", endTransaction(true), {
                  signal
                });
              }
              return idbtrans;
            }, table: function(tableName) {
              var downTable = core.table(tableName);
              var primKey = downTable.schema.primaryKey;
              var tableMW = __assign(__assign({}, downTable), { mutate: function(req) {
                var trans = PSD.trans;
                if (primKey.outbound || trans.db._options.cache === "disabled" || trans.explicit || trans.idbtrans.mode !== "readwrite") {
                  return downTable.mutate(req);
                }
                var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
                if (!tblCache)
                  return downTable.mutate(req);
                var promise = downTable.mutate(req);
                if ((req.type === "add" || req.type === "put") && (req.values.length >= 50 || getEffectiveKeys(primKey, req).some(function(key) {
                  return key == null;
                }))) {
                  promise.then(function(res) {
                    var reqWithResolvedKeys = __assign(__assign({}, req), { values: req.values.map(function(value, i) {
                      var _a4;
                      if (res.failures[i])
                        return value;
                      var valueWithKey = ((_a4 = primKey.keyPath) === null || _a4 === void 0 ? void 0 : _a4.includes(".")) ? deepClone(value) : __assign({}, value);
                      setByKeyPath(valueWithKey, primKey.keyPath, res.results[i]);
                      return valueWithKey;
                    }) });
                    var adjustedReq = adjustOptimisticFromFailures(tblCache, reqWithResolvedKeys, res);
                    tblCache.optimisticOps.push(adjustedReq);
                    queueMicrotask(function() {
                      return req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                    });
                  });
                } else {
                  tblCache.optimisticOps.push(req);
                  req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                  promise.then(function(res) {
                    if (res.numFailures > 0) {
                      delArrayItem(tblCache.optimisticOps, req);
                      var adjustedReq = adjustOptimisticFromFailures(tblCache, req, res);
                      if (adjustedReq) {
                        tblCache.optimisticOps.push(adjustedReq);
                      }
                      req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                    }
                  });
                  promise.catch(function() {
                    delArrayItem(tblCache.optimisticOps, req);
                    req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                  });
                }
                return promise;
              }, query: function(req) {
                var _a4;
                if (!isCachableContext(PSD, downTable) || !isCachableRequest("query", req))
                  return downTable.query(req);
                var freezeResults = ((_a4 = PSD.trans) === null || _a4 === void 0 ? void 0 : _a4.db._options.cache) === "immutable";
                var _b = PSD, requery = _b.requery, signal = _b.signal;
                var _c = findCompatibleQuery(dbName, tableName, "query", req), cacheEntry = _c[0], exactMatch = _c[1], tblCache = _c[2], container = _c[3];
                if (cacheEntry && exactMatch) {
                  cacheEntry.obsSet = req.obsSet;
                } else {
                  var promise = downTable.query(req).then(function(res) {
                    var result = res.result;
                    if (cacheEntry)
                      cacheEntry.res = result;
                    if (freezeResults) {
                      for (var i = 0, l = result.length; i < l; ++i) {
                        Object.freeze(result[i]);
                      }
                      Object.freeze(result);
                    } else {
                      res.result = deepClone(result);
                    }
                    return res;
                  }).catch(function(error) {
                    if (container && cacheEntry)
                      delArrayItem(container, cacheEntry);
                    return Promise.reject(error);
                  });
                  cacheEntry = {
                    obsSet: req.obsSet,
                    promise,
                    subscribers: /* @__PURE__ */ new Set(),
                    type: "query",
                    req,
                    dirty: false
                  };
                  if (container) {
                    container.push(cacheEntry);
                  } else {
                    container = [cacheEntry];
                    if (!tblCache) {
                      tblCache = cache["idb://".concat(dbName, "/").concat(tableName)] = {
                        queries: {
                          query: {},
                          count: {}
                        },
                        objs: /* @__PURE__ */ new Map(),
                        optimisticOps: [],
                        unsignaledParts: {}
                      };
                    }
                    tblCache.queries.query[req.query.index.name || ""] = container;
                  }
                }
                subscribeToCacheEntry(cacheEntry, container, requery, signal);
                return cacheEntry.promise.then(function(res) {
                  return {
                    result: applyOptimisticOps(res.result, req, tblCache === null || tblCache === void 0 ? void 0 : tblCache.optimisticOps, downTable, cacheEntry, freezeResults)
                  };
                });
              } });
              return tableMW;
            } });
            return coreMW;
          }
        };
        function vipify(target, vipDb) {
          return new Proxy(target, {
            get: function(target2, prop, receiver) {
              if (prop === "db")
                return vipDb;
              return Reflect.get(target2, prop, receiver);
            }
          });
        }
        var Dexie$1 = function() {
          function Dexie4(name, options) {
            var _this = this;
            this._middlewares = {};
            this.verno = 0;
            var deps = Dexie4.dependencies;
            this._options = options = __assign({
              addons: Dexie4.addons,
              autoOpen: true,
              indexedDB: deps.indexedDB,
              IDBKeyRange: deps.IDBKeyRange,
              cache: "cloned"
            }, options);
            this._deps = {
              indexedDB: options.indexedDB,
              IDBKeyRange: options.IDBKeyRange
            };
            var addons = options.addons;
            this._dbSchema = {};
            this._versions = [];
            this._storeNames = [];
            this._allTables = {};
            this.idbdb = null;
            this._novip = this;
            var state = {
              dbOpenError: null,
              isBeingOpened: false,
              onReadyBeingFired: null,
              openComplete: false,
              dbReadyResolve: nop,
              dbReadyPromise: null,
              cancelOpen: nop,
              openCanceller: null,
              autoSchema: true,
              PR1398_maxLoop: 3,
              autoOpen: options.autoOpen
            };
            state.dbReadyPromise = new DexiePromise(function(resolve2) {
              state.dbReadyResolve = resolve2;
            });
            state.openCanceller = new DexiePromise(function(_2, reject) {
              state.cancelOpen = reject;
            });
            this._state = state;
            this.name = name;
            this.on = Events(this, "populate", "blocked", "versionchange", "close", { ready: [promisableChain, nop] });
            this.on.ready.subscribe = override(this.on.ready.subscribe, function(subscribe) {
              return function(subscriber, bSticky) {
                Dexie4.vip(function() {
                  var state2 = _this._state;
                  if (state2.openComplete) {
                    if (!state2.dbOpenError)
                      DexiePromise.resolve().then(subscriber);
                    if (bSticky)
                      subscribe(subscriber);
                  } else if (state2.onReadyBeingFired) {
                    state2.onReadyBeingFired.push(subscriber);
                    if (bSticky)
                      subscribe(subscriber);
                  } else {
                    subscribe(subscriber);
                    var db_1 = _this;
                    if (!bSticky)
                      subscribe(function unsubscribe() {
                        db_1.on.ready.unsubscribe(subscriber);
                        db_1.on.ready.unsubscribe(unsubscribe);
                      });
                  }
                });
              };
            });
            this.Collection = createCollectionConstructor(this);
            this.Table = createTableConstructor(this);
            this.Transaction = createTransactionConstructor(this);
            this.Version = createVersionConstructor(this);
            this.WhereClause = createWhereClauseConstructor(this);
            this.on("versionchange", function(ev) {
              if (ev.newVersion > 0)
                console.warn("Another connection wants to upgrade database '".concat(_this.name, "'. Closing db now to resume the upgrade."));
              else
                console.warn("Another connection wants to delete database '".concat(_this.name, "'. Closing db now to resume the delete request."));
              _this.close({ disableAutoOpen: false });
            });
            this.on("blocked", function(ev) {
              if (!ev.newVersion || ev.newVersion < ev.oldVersion)
                console.warn("Dexie.delete('".concat(_this.name, "') was blocked"));
              else
                console.warn("Upgrade '".concat(_this.name, "' blocked by other connection holding version ").concat(ev.oldVersion / 10));
            });
            this._maxKey = getMaxKey(options.IDBKeyRange);
            this._createTransaction = function(mode, storeNames, dbschema, parentTransaction) {
              return new _this.Transaction(mode, storeNames, dbschema, _this._options.chromeTransactionDurability, parentTransaction);
            };
            this._fireOnBlocked = function(ev) {
              _this.on("blocked").fire(ev);
              connections.filter(function(c) {
                return c.name === _this.name && c !== _this && !c._state.vcFired;
              }).map(function(c) {
                return c.on("versionchange").fire(ev);
              });
            };
            this.use(cacheExistingValuesMiddleware);
            this.use(cacheMiddleware);
            this.use(observabilityMiddleware);
            this.use(virtualIndexMiddleware);
            this.use(hooksMiddleware);
            var vipDB = new Proxy(this, {
              get: function(_2, prop, receiver) {
                if (prop === "_vip")
                  return true;
                if (prop === "table")
                  return function(tableName) {
                    return vipify(_this.table(tableName), vipDB);
                  };
                var rv = Reflect.get(_2, prop, receiver);
                if (rv instanceof Table)
                  return vipify(rv, vipDB);
                if (prop === "tables")
                  return rv.map(function(t) {
                    return vipify(t, vipDB);
                  });
                if (prop === "_createTransaction")
                  return function() {
                    var tx = rv.apply(this, arguments);
                    return vipify(tx, vipDB);
                  };
                return rv;
              }
            });
            this.vip = vipDB;
            addons.forEach(function(addon) {
              return addon(_this);
            });
          }
          Dexie4.prototype.version = function(versionNumber) {
            if (isNaN(versionNumber) || versionNumber < 0.1)
              throw new exceptions.Type("Given version is not a positive number");
            versionNumber = Math.round(versionNumber * 10) / 10;
            if (this.idbdb || this._state.isBeingOpened)
              throw new exceptions.Schema("Cannot add version when database is open");
            this.verno = Math.max(this.verno, versionNumber);
            var versions = this._versions;
            var versionInstance = versions.filter(function(v) {
              return v._cfg.version === versionNumber;
            })[0];
            if (versionInstance)
              return versionInstance;
            versionInstance = new this.Version(versionNumber);
            versions.push(versionInstance);
            versions.sort(lowerVersionFirst);
            versionInstance.stores({});
            this._state.autoSchema = false;
            return versionInstance;
          };
          Dexie4.prototype._whenReady = function(fn2) {
            var _this = this;
            return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn2() : new DexiePromise(function(resolve2, reject) {
              if (_this._state.openComplete) {
                return reject(new exceptions.DatabaseClosed(_this._state.dbOpenError));
              }
              if (!_this._state.isBeingOpened) {
                if (!_this._state.autoOpen) {
                  reject(new exceptions.DatabaseClosed());
                  return;
                }
                _this.open().catch(nop);
              }
              _this._state.dbReadyPromise.then(resolve2, reject);
            }).then(fn2);
          };
          Dexie4.prototype.use = function(_a4) {
            var stack2 = _a4.stack, create = _a4.create, level = _a4.level, name = _a4.name;
            if (name)
              this.unuse({ stack: stack2, name });
            var middlewares = this._middlewares[stack2] || (this._middlewares[stack2] = []);
            middlewares.push({ stack: stack2, create, level: level == null ? 10 : level, name });
            middlewares.sort(function(a, b) {
              return a.level - b.level;
            });
            return this;
          };
          Dexie4.prototype.unuse = function(_a4) {
            var stack2 = _a4.stack, name = _a4.name, create = _a4.create;
            if (stack2 && this._middlewares[stack2]) {
              this._middlewares[stack2] = this._middlewares[stack2].filter(function(mw) {
                return create ? mw.create !== create : name ? mw.name !== name : false;
              });
            }
            return this;
          };
          Dexie4.prototype.open = function() {
            var _this = this;
            return usePSD(
              globalPSD,
              function() {
                return dexieOpen(_this);
              }
            );
          };
          Dexie4.prototype._close = function() {
            var state = this._state;
            var idx = connections.indexOf(this);
            if (idx >= 0)
              connections.splice(idx, 1);
            if (this.idbdb) {
              try {
                this.idbdb.close();
              } catch (e) {
              }
              this.idbdb = null;
            }
            if (!state.isBeingOpened) {
              state.dbReadyPromise = new DexiePromise(function(resolve2) {
                state.dbReadyResolve = resolve2;
              });
              state.openCanceller = new DexiePromise(function(_2, reject) {
                state.cancelOpen = reject;
              });
            }
          };
          Dexie4.prototype.close = function(_a4) {
            var _b = _a4 === void 0 ? { disableAutoOpen: true } : _a4, disableAutoOpen = _b.disableAutoOpen;
            var state = this._state;
            if (disableAutoOpen) {
              if (state.isBeingOpened) {
                state.cancelOpen(new exceptions.DatabaseClosed());
              }
              this._close();
              state.autoOpen = false;
              state.dbOpenError = new exceptions.DatabaseClosed();
            } else {
              this._close();
              state.autoOpen = this._options.autoOpen || state.isBeingOpened;
              state.openComplete = false;
              state.dbOpenError = null;
            }
          };
          Dexie4.prototype.delete = function(closeOptions) {
            var _this = this;
            if (closeOptions === void 0) {
              closeOptions = { disableAutoOpen: true };
            }
            var hasInvalidArguments = arguments.length > 0 && typeof arguments[0] !== "object";
            var state = this._state;
            return new DexiePromise(function(resolve2, reject) {
              var doDelete = function() {
                _this.close(closeOptions);
                var req = _this._deps.indexedDB.deleteDatabase(_this.name);
                req.onsuccess = wrap(function() {
                  _onDatabaseDeleted(_this._deps, _this.name);
                  resolve2();
                });
                req.onerror = eventRejectHandler(reject);
                req.onblocked = _this._fireOnBlocked;
              };
              if (hasInvalidArguments)
                throw new exceptions.InvalidArgument("Invalid closeOptions argument to db.delete()");
              if (state.isBeingOpened) {
                state.dbReadyPromise.then(doDelete);
              } else {
                doDelete();
              }
            });
          };
          Dexie4.prototype.backendDB = function() {
            return this.idbdb;
          };
          Dexie4.prototype.isOpen = function() {
            return this.idbdb !== null;
          };
          Dexie4.prototype.hasBeenClosed = function() {
            var dbOpenError = this._state.dbOpenError;
            return dbOpenError && dbOpenError.name === "DatabaseClosed";
          };
          Dexie4.prototype.hasFailed = function() {
            return this._state.dbOpenError !== null;
          };
          Dexie4.prototype.dynamicallyOpened = function() {
            return this._state.autoSchema;
          };
          Object.defineProperty(Dexie4.prototype, "tables", {
            get: function() {
              var _this = this;
              return keys2(this._allTables).map(function(name) {
                return _this._allTables[name];
              });
            },
            enumerable: false,
            configurable: true
          });
          Dexie4.prototype.transaction = function() {
            var args = extractTransactionArgs.apply(this, arguments);
            return this._transaction.apply(this, args);
          };
          Dexie4.prototype._transaction = function(mode, tables, scopeFunc) {
            var _this = this;
            var parentTransaction = PSD.trans;
            if (!parentTransaction || parentTransaction.db !== this || mode.indexOf("!") !== -1)
              parentTransaction = null;
            var onlyIfCompatible = mode.indexOf("?") !== -1;
            mode = mode.replace("!", "").replace("?", "");
            var idbMode, storeNames;
            try {
              storeNames = tables.map(function(table) {
                var storeName = table instanceof _this.Table ? table.name : table;
                if (typeof storeName !== "string")
                  throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
                return storeName;
              });
              if (mode == "r" || mode === READONLY)
                idbMode = READONLY;
              else if (mode == "rw" || mode == READWRITE)
                idbMode = READWRITE;
              else
                throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);
              if (parentTransaction) {
                if (parentTransaction.mode === READONLY && idbMode === READWRITE) {
                  if (onlyIfCompatible) {
                    parentTransaction = null;
                  } else
                    throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
                }
                if (parentTransaction) {
                  storeNames.forEach(function(storeName) {
                    if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
                      if (onlyIfCompatible) {
                        parentTransaction = null;
                      } else
                        throw new exceptions.SubTransaction("Table " + storeName + " not included in parent transaction.");
                    }
                  });
                }
                if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
                  parentTransaction = null;
                }
              }
            } catch (e) {
              return parentTransaction ? parentTransaction._promise(null, function(_2, reject) {
                reject(e);
              }) : rejection(e);
            }
            var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);
            return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, "lock") : PSD.trans ? usePSD(PSD.transless, function() {
              return _this._whenReady(enterTransaction);
            }) : this._whenReady(enterTransaction);
          };
          Dexie4.prototype.table = function(tableName) {
            if (!hasOwn3(this._allTables, tableName)) {
              throw new exceptions.InvalidTable("Table ".concat(tableName, " does not exist"));
            }
            return this._allTables[tableName];
          };
          return Dexie4;
        }();
        var symbolObservable = typeof Symbol !== "undefined" && "observable" in Symbol ? Symbol.observable : "@@observable";
        var Observable = function() {
          function Observable2(subscribe) {
            this._subscribe = subscribe;
          }
          Observable2.prototype.subscribe = function(x, error, complete) {
            return this._subscribe(!x || typeof x === "function" ? { next: x, error, complete } : x);
          };
          Observable2.prototype[symbolObservable] = function() {
            return this;
          };
          return Observable2;
        }();
        var domDeps;
        try {
          domDeps = {
            indexedDB: _global2.indexedDB || _global2.mozIndexedDB || _global2.webkitIndexedDB || _global2.msIndexedDB,
            IDBKeyRange: _global2.IDBKeyRange || _global2.webkitIDBKeyRange
          };
        } catch (e) {
          domDeps = { indexedDB: null, IDBKeyRange: null };
        }
        function liveQuery2(querier) {
          var hasValue = false;
          var currentValue;
          var observable = new Observable(function(observer) {
            var scopeFuncIsAsync = isAsyncFunction(querier);
            function execute(ctx) {
              var wasRootExec = beginMicroTickScope();
              try {
                if (scopeFuncIsAsync) {
                  incrementExpectedAwaits();
                }
                var rv = newScope(querier, ctx);
                if (scopeFuncIsAsync) {
                  rv = rv.finally(decrementExpectedAwaits);
                }
                return rv;
              } finally {
                wasRootExec && endMicroTickScope();
              }
            }
            var closed = false;
            var abortController;
            var accumMuts = {};
            var currentObs = {};
            var subscription = {
              get closed() {
                return closed;
              },
              unsubscribe: function() {
                if (closed)
                  return;
                closed = true;
                if (abortController)
                  abortController.abort();
                if (startedListening)
                  globalEvents.storagemutated.unsubscribe(mutationListener);
              }
            };
            observer.start && observer.start(subscription);
            var startedListening = false;
            var doQuery = function() {
              return execInGlobalContext(_doQuery);
            };
            function shouldNotify() {
              return obsSetsOverlap(currentObs, accumMuts);
            }
            var mutationListener = function(parts) {
              extendObservabilitySet(accumMuts, parts);
              if (shouldNotify()) {
                doQuery();
              }
            };
            var _doQuery = function() {
              if (closed || !domDeps.indexedDB) {
                return;
              }
              accumMuts = {};
              var subscr = {};
              if (abortController)
                abortController.abort();
              abortController = new AbortController();
              var ctx = {
                subscr,
                signal: abortController.signal,
                requery: doQuery,
                querier,
                trans: null
              };
              var ret = execute(ctx);
              Promise.resolve(ret).then(function(result) {
                hasValue = true;
                currentValue = result;
                if (closed || ctx.signal.aborted) {
                  return;
                }
                accumMuts = {};
                currentObs = subscr;
                if (!objectIsEmpty(currentObs) && !startedListening) {
                  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);
                  startedListening = true;
                }
                execInGlobalContext(function() {
                  return !closed && observer.next && observer.next(result);
                });
              }, function(err) {
                hasValue = false;
                if (!["DatabaseClosedError", "AbortError"].includes(err === null || err === void 0 ? void 0 : err.name)) {
                  if (!closed)
                    execInGlobalContext(function() {
                      if (closed)
                        return;
                      observer.error && observer.error(err);
                    });
                }
              });
            };
            setTimeout(doQuery, 0);
            return subscription;
          });
          observable.hasValue = function() {
            return hasValue;
          };
          observable.getValue = function() {
            return currentValue;
          };
          return observable;
        }
        var Dexie3 = Dexie$1;
        props(Dexie3, __assign(__assign({}, fullNameExceptions), {
          delete: function(databaseName) {
            var db3 = new Dexie3(databaseName, { addons: [] });
            return db3.delete();
          },
          exists: function(name) {
            return new Dexie3(name, { addons: [] }).open().then(function(db3) {
              db3.close();
              return true;
            }).catch("NoSuchDatabaseError", function() {
              return false;
            });
          },
          getDatabaseNames: function(cb) {
            try {
              return getDatabaseNames(Dexie3.dependencies).then(cb);
            } catch (_a4) {
              return rejection(new exceptions.MissingAPI());
            }
          },
          defineClass: function() {
            function Class(content) {
              extend2(this, content);
            }
            return Class;
          },
          ignoreTransaction: function(scopeFunc) {
            return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();
          },
          vip,
          async: function(generatorFn) {
            return function() {
              try {
                var rv = awaitIterator(generatorFn.apply(this, arguments));
                if (!rv || typeof rv.then !== "function")
                  return DexiePromise.resolve(rv);
                return rv;
              } catch (e) {
                return rejection(e);
              }
            };
          },
          spawn: function(generatorFn, args, thiz) {
            try {
              var rv = awaitIterator(generatorFn.apply(thiz, args || []));
              if (!rv || typeof rv.then !== "function")
                return DexiePromise.resolve(rv);
              return rv;
            } catch (e) {
              return rejection(e);
            }
          },
          currentTransaction: {
            get: function() {
              return PSD.trans || null;
            }
          },
          waitFor: function(promiseOrFunction, optionalTimeout) {
            var promise = DexiePromise.resolve(typeof promiseOrFunction === "function" ? Dexie3.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 6e4);
            return PSD.trans ? PSD.trans.waitFor(promise) : promise;
          },
          Promise: DexiePromise,
          debug: {
            get: function() {
              return debug;
            },
            set: function(value) {
              setDebug(value);
            }
          },
          derive,
          extend: extend2,
          props,
          override,
          Events,
          on: globalEvents,
          liveQuery: liveQuery2,
          extendObservabilitySet,
          getByKeyPath,
          setByKeyPath,
          delByKeyPath,
          shallowClone,
          deepClone,
          getObjectDiff,
          cmp: cmp2,
          asap: asap$1,
          minKey,
          addons: [],
          connections,
          errnames,
          dependencies: domDeps,
          cache,
          semVer: DEXIE_VERSION,
          version: DEXIE_VERSION.split(".").map(function(n) {
            return parseInt(n);
          }).reduce(function(p2, c, i) {
            return p2 + c / Math.pow(10, i * 2);
          })
        }));
        Dexie3.maxKey = getMaxKey(Dexie3.dependencies.IDBKeyRange);
        if (typeof dispatchEvent !== "undefined" && typeof addEventListener !== "undefined") {
          globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function(updatedParts) {
            if (!propagatingLocally) {
              var event_1;
              event_1 = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {
                detail: updatedParts
              });
              propagatingLocally = true;
              dispatchEvent(event_1);
              propagatingLocally = false;
            }
          });
          addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function(_a4) {
            var detail = _a4.detail;
            if (!propagatingLocally) {
              propagateLocally(detail);
            }
          });
        }
        function propagateLocally(updateParts) {
          var wasMe = propagatingLocally;
          try {
            propagatingLocally = true;
            globalEvents.storagemutated.fire(updateParts);
            signalSubscribersNow(updateParts, true);
          } finally {
            propagatingLocally = wasMe;
          }
        }
        var propagatingLocally = false;
        var bc;
        var createBC = function() {
        };
        if (typeof BroadcastChannel !== "undefined") {
          createBC = function() {
            bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);
            bc.onmessage = function(ev) {
              return ev.data && propagateLocally(ev.data);
            };
          };
          createBC();
          if (typeof bc.unref === "function") {
            bc.unref();
          }
          globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function(changedParts) {
            if (!propagatingLocally) {
              bc.postMessage(changedParts);
            }
          });
        }
        if (typeof addEventListener !== "undefined") {
          addEventListener("pagehide", function(event2) {
            if (!Dexie$1.disableBfCache && event2.persisted) {
              if (debug)
                console.debug("Dexie: handling persisted pagehide");
              bc === null || bc === void 0 ? void 0 : bc.close();
              for (var _i2 = 0, connections_1 = connections; _i2 < connections_1.length; _i2++) {
                var db3 = connections_1[_i2];
                db3.close({ disableAutoOpen: false });
              }
            }
          });
          addEventListener("pageshow", function(event2) {
            if (!Dexie$1.disableBfCache && event2.persisted) {
              if (debug)
                console.debug("Dexie: handling persisted pageshow");
              createBC();
              propagateLocally({ all: new RangeSet2(-Infinity, [[]]) });
            }
          });
        }
        function add3(value) {
          return new PropModification2({ add: value });
        }
        function remove3(value) {
          return new PropModification2({ remove: value });
        }
        function replacePrefix2(a, b) {
          return new PropModification2({ replacePrefix: [a, b] });
        }
        DexiePromise.rejectionMapper = mapError;
        setDebug(debug);
        var namedExports = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          Dexie: Dexie$1,
          liveQuery: liveQuery2,
          Entity: Entity2,
          cmp: cmp2,
          PropModification: PropModification2,
          replacePrefix: replacePrefix2,
          add: add3,
          remove: remove3,
          "default": Dexie$1,
          RangeSet: RangeSet2,
          mergeRanges: mergeRanges2,
          rangesOverlap: rangesOverlap2
        });
        __assign(Dexie$1, namedExports, { default: Dexie$1 });
        return Dexie$1;
      });
    }
  });

  // ../posawesome/node_modules/lodash/lodash.js
  var require_lodash = __commonJS({
    "../posawesome/node_modules/lodash/lodash.js"(exports, module) {
      (function() {
        var undefined2;
        var VERSION = "4.17.21";
        var LARGE_ARRAY_SIZE = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
          ["ary", WRAP_ARY_FLAG],
          ["bind", WRAP_BIND_FLAG],
          ["bindKey", WRAP_BIND_KEY_FLAG],
          ["curry", WRAP_CURRY_FLAG],
          ["curryRight", WRAP_CURRY_RIGHT_FLAG],
          ["flip", WRAP_FLIP_FLAG],
          ["partial", WRAP_PARTIAL_FLAG],
          ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
          ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
        var reTrimStart = /^\s+/;
        var reWhitespace = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
          rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
          rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var deburredLetters = {
          "\xC0": "A",
          "\xC1": "A",
          "\xC2": "A",
          "\xC3": "A",
          "\xC4": "A",
          "\xC5": "A",
          "\xE0": "a",
          "\xE1": "a",
          "\xE2": "a",
          "\xE3": "a",
          "\xE4": "a",
          "\xE5": "a",
          "\xC7": "C",
          "\xE7": "c",
          "\xD0": "D",
          "\xF0": "d",
          "\xC8": "E",
          "\xC9": "E",
          "\xCA": "E",
          "\xCB": "E",
          "\xE8": "e",
          "\xE9": "e",
          "\xEA": "e",
          "\xEB": "e",
          "\xCC": "I",
          "\xCD": "I",
          "\xCE": "I",
          "\xCF": "I",
          "\xEC": "i",
          "\xED": "i",
          "\xEE": "i",
          "\xEF": "i",
          "\xD1": "N",
          "\xF1": "n",
          "\xD2": "O",
          "\xD3": "O",
          "\xD4": "O",
          "\xD5": "O",
          "\xD6": "O",
          "\xD8": "O",
          "\xF2": "o",
          "\xF3": "o",
          "\xF4": "o",
          "\xF5": "o",
          "\xF6": "o",
          "\xF8": "o",
          "\xD9": "U",
          "\xDA": "U",
          "\xDB": "U",
          "\xDC": "U",
          "\xF9": "u",
          "\xFA": "u",
          "\xFB": "u",
          "\xFC": "u",
          "\xDD": "Y",
          "\xFD": "y",
          "\xFF": "y",
          "\xC6": "Ae",
          "\xE6": "ae",
          "\xDE": "Th",
          "\xFE": "th",
          "\xDF": "ss",
          "\u0100": "A",
          "\u0102": "A",
          "\u0104": "A",
          "\u0101": "a",
          "\u0103": "a",
          "\u0105": "a",
          "\u0106": "C",
          "\u0108": "C",
          "\u010A": "C",
          "\u010C": "C",
          "\u0107": "c",
          "\u0109": "c",
          "\u010B": "c",
          "\u010D": "c",
          "\u010E": "D",
          "\u0110": "D",
          "\u010F": "d",
          "\u0111": "d",
          "\u0112": "E",
          "\u0114": "E",
          "\u0116": "E",
          "\u0118": "E",
          "\u011A": "E",
          "\u0113": "e",
          "\u0115": "e",
          "\u0117": "e",
          "\u0119": "e",
          "\u011B": "e",
          "\u011C": "G",
          "\u011E": "G",
          "\u0120": "G",
          "\u0122": "G",
          "\u011D": "g",
          "\u011F": "g",
          "\u0121": "g",
          "\u0123": "g",
          "\u0124": "H",
          "\u0126": "H",
          "\u0125": "h",
          "\u0127": "h",
          "\u0128": "I",
          "\u012A": "I",
          "\u012C": "I",
          "\u012E": "I",
          "\u0130": "I",
          "\u0129": "i",
          "\u012B": "i",
          "\u012D": "i",
          "\u012F": "i",
          "\u0131": "i",
          "\u0134": "J",
          "\u0135": "j",
          "\u0136": "K",
          "\u0137": "k",
          "\u0138": "k",
          "\u0139": "L",
          "\u013B": "L",
          "\u013D": "L",
          "\u013F": "L",
          "\u0141": "L",
          "\u013A": "l",
          "\u013C": "l",
          "\u013E": "l",
          "\u0140": "l",
          "\u0142": "l",
          "\u0143": "N",
          "\u0145": "N",
          "\u0147": "N",
          "\u014A": "N",
          "\u0144": "n",
          "\u0146": "n",
          "\u0148": "n",
          "\u014B": "n",
          "\u014C": "O",
          "\u014E": "O",
          "\u0150": "O",
          "\u014D": "o",
          "\u014F": "o",
          "\u0151": "o",
          "\u0154": "R",
          "\u0156": "R",
          "\u0158": "R",
          "\u0155": "r",
          "\u0157": "r",
          "\u0159": "r",
          "\u015A": "S",
          "\u015C": "S",
          "\u015E": "S",
          "\u0160": "S",
          "\u015B": "s",
          "\u015D": "s",
          "\u015F": "s",
          "\u0161": "s",
          "\u0162": "T",
          "\u0164": "T",
          "\u0166": "T",
          "\u0163": "t",
          "\u0165": "t",
          "\u0167": "t",
          "\u0168": "U",
          "\u016A": "U",
          "\u016C": "U",
          "\u016E": "U",
          "\u0170": "U",
          "\u0172": "U",
          "\u0169": "u",
          "\u016B": "u",
          "\u016D": "u",
          "\u016F": "u",
          "\u0171": "u",
          "\u0173": "u",
          "\u0174": "W",
          "\u0175": "w",
          "\u0176": "Y",
          "\u0177": "y",
          "\u0178": "Y",
          "\u0179": "Z",
          "\u017B": "Z",
          "\u017D": "Z",
          "\u017A": "z",
          "\u017C": "z",
          "\u017E": "z",
          "\u0132": "IJ",
          "\u0133": "ij",
          "\u0152": "Oe",
          "\u0153": "oe",
          "\u0149": "'n",
          "\u017F": "s"
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt = parseInt;
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            var types = freeModule && freeModule.require && freeModule.require("util").types;
            if (types) {
              return types;
            }
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e) {
          }
        }();
        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function apply2(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator(array, setter, iteratee, accumulator) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            var value = array[index];
            setter(accumulator, value, iteratee(value), array);
          }
          return accumulator;
        }
        function arrayEach(array, iteratee) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length = array == null ? 0 : array.length;
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function arrayIncludes(array, value) {
          var length = array == null ? 0 : array.length;
          return !!length && baseIndexOf(array, value, 0) > -1;
        }
        function arrayIncludesWith(array, value, comparator) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (comparator(value, array[index])) {
              return true;
            }
          }
          return false;
        }
        function arrayMap(array, iteratee) {
          var index = -1, length = array == null ? 0 : array.length, result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
        function arrayPush(array, values) {
          var index = -1, length = values.length, offset = array.length;
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }
        function arrayReduce(array, iteratee, accumulator, initAccum) {
          var index = -1, length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
          var length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        var asciiSize = baseProperty("length");
        function asciiToArray(string) {
          return string.split("");
        }
        function asciiWords(string) {
          return string.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value, key, collection2) {
            if (predicate(value, key, collection2)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index-- : ++index < length) {
            if (predicate(array[index], index, array)) {
              return index;
            }
          }
          return -1;
        }
        function baseIndexOf(array, value, fromIndex) {
          return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array, value, fromIndex, comparator) {
          var index = fromIndex - 1, length = array.length;
          while (++index < length) {
            if (comparator(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function baseMean(array, iteratee) {
          var length = array == null ? 0 : array.length;
          return length ? baseSum(array, iteratee) / length : NAN;
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined2 : object[key];
          };
        }
        function basePropertyOf(object) {
          return function(key) {
            return object == null ? undefined2 : object[key];
          };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value, index, collection2) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
          });
          return accumulator;
        }
        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }
        function baseSum(array, iteratee) {
          var result, index = -1, length = array.length;
          while (++index < length) {
            var current = iteratee(array[index]);
            if (current !== undefined2) {
              result = result === undefined2 ? current : result + current;
            }
          }
          return result;
        }
        function baseTimes(n, iteratee) {
          var index = -1, result = Array(n);
          while (++index < n) {
            result[index] = iteratee(index);
          }
          return result;
        }
        function baseToPairs(object, props) {
          return arrayMap(props, function(key) {
            return [key, object[key]];
          });
        }
        function baseTrim(string) {
          return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function baseValues(object, props) {
          return arrayMap(props, function(key) {
            return object[key];
          });
        }
        function cacheHas(cache, key) {
          return cache.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index = -1, length = strSymbols.length;
          while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index = strSymbols.length;
          while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function countHolders(array, placeholder) {
          var length = array.length, result = 0;
          while (length--) {
            if (array[length] === placeholder) {
              ++result;
            }
          }
          return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue(object, key) {
          return object == null ? undefined2 : object[key];
        }
        function hasUnicode(string) {
          return reHasUnicode.test(string);
        }
        function hasUnicodeWord(string) {
          return reHasUnicodeWord.test(string);
        }
        function iteratorToArray(iterator2) {
          var data, result = [];
          while (!(data = iterator2.next()).done) {
            result.push(data.value);
          }
          return result;
        }
        function mapToArray(map2) {
          var index = -1, result = Array(map2.size);
          map2.forEach(function(value, key) {
            result[++index] = [key, value];
          });
          return result;
        }
        function overArg(func, transform2) {
          return function(arg) {
            return func(transform2(arg));
          };
        }
        function replaceHolders(array, placeholder) {
          var index = -1, length = array.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (value === placeholder || value === PLACEHOLDER) {
              array[index] = PLACEHOLDER;
              result[resIndex++] = index;
            }
          }
          return result;
        }
        function setToArray(set2) {
          var index = -1, result = Array(set2.size);
          set2.forEach(function(value) {
            result[++index] = value;
          });
          return result;
        }
        function setToPairs(set2) {
          var index = -1, result = Array(set2.size);
          set2.forEach(function(value) {
            result[++index] = [value, value];
          });
          return result;
        }
        function strictIndexOf(array, value, fromIndex) {
          var index = fromIndex - 1, length = array.length;
          while (++index < length) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function strictLastIndexOf(array, value, fromIndex) {
          var index = fromIndex + 1;
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return index;
        }
        function stringSize(string) {
          return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
        }
        function stringToArray(string) {
          return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        }
        function trimmedEndIndex(string) {
          var index = string.length;
          while (index-- && reWhitespace.test(string.charAt(index))) {
          }
          return index;
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string)) {
            ++result;
          }
          return result;
        }
        function unicodeToArray(string) {
          return string.match(reUnicode) || [];
        }
        function unicodeWords(string) {
          return string.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context) {
          context = context == null ? root : _2.defaults(root.Object(), context, _2.pick(root, contextProps));
          var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
          var arrayProto2 = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
          var coreJsData = context["__core-js_shared__"];
          var funcToString = funcProto.toString;
          var hasOwnProperty3 = objectProto.hasOwnProperty;
          var idCounter = 0;
          var maskSrcKey = function() {
            var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid2 ? "Symbol(src)_1." + uid2 : "";
          }();
          var nativeObjectToString = objectProto.toString;
          var objectCtorString = funcToString.call(Object2);
          var oldDash = root._;
          var reIsNative = RegExp2(
            "^" + funcToString.call(hasOwnProperty3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
          );
          var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto2.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
          var defineProperty = function() {
            try {
              var func = getNative(Object2, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e) {
            }
          }();
          var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
          var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto2.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto2.reverse;
          var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
          var metaMap = WeakMap2 && new WeakMap2();
          var realNames = {};
          var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
          var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
          function lodash(value) {
            if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty3.call(value, "__wrapped__")) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }
          var baseCreate = function() {
            function object() {
            }
            return function(proto) {
              if (!isObject4(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object.prototype = proto;
              var result2 = new object();
              object.prototype = undefined2;
              return result2;
            };
          }();
          function baseLodash() {
          }
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined2;
          }
          lodash.templateSettings = {
            "escape": reEscape,
            "evaluate": reEvaluate,
            "interpolate": reInterpolate,
            "variable": "",
            "imports": {
              "_": lodash
            }
          };
          lodash.prototype = baseLodash.prototype;
          lodash.prototype.constructor = lodash;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result2 = new LazyWrapper(this.__wrapped__);
            result2.__actions__ = copyArray(this.__actions__);
            result2.__dir__ = this.__dir__;
            result2.__filtered__ = this.__filtered__;
            result2.__iteratees__ = copyArray(this.__iteratees__);
            result2.__takeCount__ = this.__takeCount__;
            result2.__views__ = copyArray(this.__views__);
            return result2;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result2 = new LazyWrapper(this);
              result2.__dir__ = -1;
              result2.__filtered__ = true;
            } else {
              result2 = this.clone();
              result2.__dir__ *= -1;
            }
            return result2;
          }
          function lazyValue() {
            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length && takeCount == length) {
              return baseWrapperValue(array, this.__actions__);
            }
            var result2 = [];
            outer:
              while (length-- && resIndex < takeCount) {
                index += dir;
                var iterIndex = -1, value = array[index];
                while (++iterIndex < iterLength) {
                  var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed3 = iteratee2(value);
                  if (type == LAZY_MAP_FLAG) {
                    value = computed3;
                  } else if (!computed3) {
                    if (type == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
                result2[resIndex++] = value;
              }
            return result2;
          }
          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          function hashDelete(key) {
            var result2 = this.has(key) && delete this.__data__[key];
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result2 = data[key];
              return result2 === HASH_UNDEFINED ? undefined2 : result2;
            }
            return hasOwnProperty3.call(data, key) ? data[key] : undefined2;
          }
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined2 : hasOwnProperty3.call(data, key);
          }
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
            return this;
          }
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          function ListCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return index < 0 ? undefined2 : data[index][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }
            return this;
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          function MapCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash(),
              "map": new (Map2 || ListCache)(),
              "string": new Hash()
            };
          }
          function mapCacheDelete(key) {
            var result2 = getMapData(this, key)["delete"](key);
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            var data = getMapData(this, key), size2 = data.size;
            data.set(key, value);
            this.size += data.size == size2 ? 0 : 1;
            return this;
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          function SetCache(values2) {
            var index = -1, length = values2 == null ? 0 : values2.length;
            this.__data__ = new MapCache();
            while (++index < length) {
              this.add(values2[index]);
            }
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          function stackDelete(key) {
            var data = this.__data__, result2 = data["delete"](key);
            this.size = data.size;
            return result2;
          }
          function stackGet(key) {
            return this.__data__.get(key);
          }
          function stackHas(key) {
            return this.__data__.has(key);
          }
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          Stack.prototype.clear = stackClear;
          Stack.prototype["delete"] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty3.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function arraySample(array) {
            var length = array.length;
            return length ? array[baseRandom(0, length - 1)] : undefined2;
          }
          function arraySampleSize(array, n) {
            return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
          }
          function arrayShuffle(array) {
            return shuffleSelf(copyArray(array));
          }
          function assignMergeValue(object, key, value) {
            if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty3.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          function baseAggregator(collection, setter, iteratee2, accumulator) {
            baseEach(collection, function(value, key, collection2) {
              setter(accumulator, value, iteratee2(value), collection2);
            });
            return accumulator;
          }
          function baseAssign(object, source) {
            return object && copyObject(source, keys2(source), object);
          }
          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }
          function baseAssignValue(object, key, value) {
            if (key == "__proto__" && defineProperty) {
              defineProperty(object, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object[key] = value;
            }
          }
          function baseAt(object, paths) {
            var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
            while (++index < length) {
              result2[index] = skip ? undefined2 : get(object, paths[index]);
            }
            return result2;
          }
          function baseClamp(number, lower, upper) {
            if (number === number) {
              if (upper !== undefined2) {
                number = number <= upper ? number : upper;
              }
              if (lower !== undefined2) {
                number = number >= lower ? number : lower;
              }
            }
            return number;
          }
          function baseClone(value, bitmask, customizer, key, object, stack2) {
            var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
              result2 = object ? customizer(value, key, object, stack2) : customizer(value);
            }
            if (result2 !== undefined2) {
              return result2;
            }
            if (!isObject4(value)) {
              return value;
            }
            var isArr = isArray2(value);
            if (isArr) {
              result2 = initCloneArray(value);
              if (!isDeep) {
                return copyArray(value, result2);
              }
            } else {
              var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag == objectTag || tag == argsTag || isFunc && !object) {
                result2 = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {};
                }
                result2 = initCloneByTag(value, tag, isDeep);
              }
            }
            stack2 || (stack2 = new Stack());
            var stacked = stack2.get(value);
            if (stacked) {
              return stacked;
            }
            stack2.set(value, result2);
            if (isSet2(value)) {
              value.forEach(function(subValue) {
                result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
              });
            } else if (isMap2(value)) {
              value.forEach(function(subValue, key2) {
                result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
            var props = isArr ? undefined2 : keysFunc(value);
            arrayEach(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
            });
            return result2;
          }
          function baseConforms(source) {
            var props = keys2(source);
            return function(object) {
              return baseConformsTo(object, source, props);
            };
          }
          function baseConformsTo(object, source, props) {
            var length = props.length;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (length--) {
              var key = props[length], predicate = source[key], value = object[key];
              if (value === undefined2 && !(key in object) || !predicate(value)) {
                return false;
              }
            }
            return true;
          }
          function baseDelay(func, wait, args) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return setTimeout2(function() {
              func.apply(undefined2, args);
            }, wait);
          }
          function baseDifference(array, values2, iteratee2, comparator) {
            var index = -1, includes3 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
            if (!length) {
              return result2;
            }
            if (iteratee2) {
              values2 = arrayMap(values2, baseUnary(iteratee2));
            }
            if (comparator) {
              includes3 = arrayIncludesWith;
              isCommon = false;
            } else if (values2.length >= LARGE_ARRAY_SIZE) {
              includes3 = cacheHas;
              isCommon = false;
              values2 = new SetCache(values2);
            }
            outer:
              while (++index < length) {
                var value = array[index], computed3 = iteratee2 == null ? value : iteratee2(value);
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed3 === computed3) {
                  var valuesIndex = valuesLength;
                  while (valuesIndex--) {
                    if (values2[valuesIndex] === computed3) {
                      continue outer;
                    }
                  }
                  result2.push(value);
                } else if (!includes3(values2, computed3, comparator)) {
                  result2.push(value);
                }
              }
            return result2;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseEachRight = createBaseEach(baseForOwnRight, true);
          function baseEvery(collection, predicate) {
            var result2 = true;
            baseEach(collection, function(value, index, collection2) {
              result2 = !!predicate(value, index, collection2);
              return result2;
            });
            return result2;
          }
          function baseExtremum(array, iteratee2, comparator) {
            var index = -1, length = array.length;
            while (++index < length) {
              var value = array[index], current = iteratee2(value);
              if (current != null && (computed3 === undefined2 ? current === current && !isSymbol2(current) : comparator(current, computed3))) {
                var computed3 = current, result2 = value;
              }
            }
            return result2;
          }
          function baseFill(array, value, start, end) {
            var length = array.length;
            start = toInteger(start);
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end === undefined2 || end > length ? length : toInteger(end);
            if (end < 0) {
              end += length;
            }
            end = start > end ? 0 : toLength(end);
            while (start < end) {
              array[start++] = value;
            }
            return array;
          }
          function baseFilter(collection, predicate) {
            var result2 = [];
            baseEach(collection, function(value, index, collection2) {
              if (predicate(value, index, collection2)) {
                result2.push(value);
              }
            });
            return result2;
          }
          function baseFlatten(array, depth, predicate, isStrict, result2) {
            var index = -1, length = array.length;
            predicate || (predicate = isFlattenable);
            result2 || (result2 = []);
            while (++index < length) {
              var value = array[index];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten(value, depth - 1, predicate, isStrict, result2);
                } else {
                  arrayPush(result2, value);
                }
              } else if (!isStrict) {
                result2[result2.length] = value;
              }
            }
            return result2;
          }
          var baseFor = createBaseFor();
          var baseForRight = createBaseFor(true);
          function baseForOwn(object, iteratee2) {
            return object && baseFor(object, iteratee2, keys2);
          }
          function baseForOwnRight(object, iteratee2) {
            return object && baseForRight(object, iteratee2, keys2);
          }
          function baseFunctions(object, props) {
            return arrayFilter(props, function(key) {
              return isFunction2(object[key]);
            });
          }
          function baseGet(object, path) {
            path = castPath(path, object);
            var index = 0, length = path.length;
            while (object != null && index < length) {
              object = object[toKey(path[index++])];
            }
            return index && index == length ? object : undefined2;
          }
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result2 = keysFunc(object);
            return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
          }
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined2 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString2(value);
          }
          function baseGt(value, other) {
            return value > other;
          }
          function baseHas(object, key) {
            return object != null && hasOwnProperty3.call(object, key);
          }
          function baseHasIn(object, key) {
            return object != null && key in Object2(object);
          }
          function baseInRange(number, start, end) {
            return number >= nativeMin(start, end) && number < nativeMax(start, end);
          }
          function baseIntersection(arrays, iteratee2, comparator) {
            var includes3 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
            while (othIndex--) {
              var array = arrays[othIndex];
              if (othIndex && iteratee2) {
                array = arrayMap(array, baseUnary(iteratee2));
              }
              maxLength = nativeMin(array.length, maxLength);
              caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
            }
            array = arrays[0];
            var index = -1, seen = caches[0];
            outer:
              while (++index < length && result2.length < maxLength) {
                var value = array[index], computed3 = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas(seen, computed3) : includes3(result2, computed3, comparator))) {
                  othIndex = othLength;
                  while (--othIndex) {
                    var cache = caches[othIndex];
                    if (!(cache ? cacheHas(cache, computed3) : includes3(arrays[othIndex], computed3, comparator))) {
                      continue outer;
                    }
                  }
                  if (seen) {
                    seen.push(computed3);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseInverter(object, setter, iteratee2, accumulator) {
            baseForOwn(object, function(value, key, object2) {
              setter(accumulator, iteratee2(value), key, object2);
            });
            return accumulator;
          }
          function baseInvoke(object, path, args) {
            path = castPath(path, object);
            object = parent(object, path);
            var func = object == null ? object : object[toKey(last(path))];
            return func == null ? undefined2 : apply2(func, object, args);
          }
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
          }
          function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
          }
          function baseIsEqual(value, other, bitmask, customizer, stack2) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
          }
          function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
            var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack2 || (stack2 = new Stack());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty3.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty3.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack2 || (stack2 = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack2 || (stack2 = new Stack());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
          }
          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
          }
          function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length, length = index, noCustomizer = !customizer;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (index--) {
              var data = matchData[index];
              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }
            while (++index < length) {
              data = matchData[index];
              var key = data[0], objValue = object[key], srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined2 && !(key in object)) {
                  return false;
                }
              } else {
                var stack2 = new Stack();
                if (customizer) {
                  var result2 = customizer(objValue, srcValue, key, object, source, stack2);
                }
                if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack2) : result2)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative(value) {
            if (!isObject4(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
          }
          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
          }
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity2;
            }
            if (typeof value == "object") {
              return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
          }
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result2 = [];
            for (var key in Object2(object)) {
              if (hasOwnProperty3.call(object, key) && key != "constructor") {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseKeysIn(object) {
            if (!isObject4(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object), result2 = [];
            for (var key in object) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty3.call(object, key)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseLt(value, other) {
            return value < other;
          }
          function baseMap(collection, iteratee2) {
            var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value, key, collection2) {
              result2[++index] = iteratee2(value, key, collection2);
            });
            return result2;
          }
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }
          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path), srcValue);
            }
            return function(object) {
              var objValue = get(object, path);
              return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          function baseMerge(object, source, srcIndex, customizer, stack2) {
            if (object === source) {
              return;
            }
            baseFor(source, function(srcValue, key) {
              stack2 || (stack2 = new Stack());
              if (isObject4(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack2);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack2) : undefined2;
                if (newValue === undefined2) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack2) {
            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack2) : undefined2;
            var isCommon = newValue === undefined2;
            if (isCommon) {
              var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray2(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject3(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject4(objValue) || isFunction2(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack2.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
              stack2["delete"](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }
          function baseNth(array, n) {
            var length = array.length;
            if (!length) {
              return;
            }
            n += n < 0 ? length : 0;
            return isIndex(n, length) ? array[n] : undefined2;
          }
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap(iteratees, function(iteratee2) {
                if (isArray2(iteratee2)) {
                  return function(value) {
                    return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                  };
                }
                return iteratee2;
              });
            } else {
              iteratees = [identity2];
            }
            var index = -1;
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            var result2 = baseMap(collection, function(value, key, collection2) {
              var criteria = arrayMap(iteratees, function(iteratee2) {
                return iteratee2(value);
              });
              return { "criteria": criteria, "index": ++index, "value": value };
            });
            return baseSortBy(result2, function(object, other) {
              return compareMultiple(object, other, orders);
            });
          }
          function basePick(object, paths) {
            return basePickBy(object, paths, function(value, path) {
              return hasIn(object, path);
            });
          }
          function basePickBy(object, paths, predicate) {
            var index = -1, length = paths.length, result2 = {};
            while (++index < length) {
              var path = paths[index], value = baseGet(object, path);
              if (predicate(value, path)) {
                baseSet(result2, castPath(path, object), value);
              }
            }
            return result2;
          }
          function basePropertyDeep(path) {
            return function(object) {
              return baseGet(object, path);
            };
          }
          function basePullAll(array, values2, iteratee2, comparator) {
            var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
            if (array === values2) {
              values2 = copyArray(values2);
            }
            if (iteratee2) {
              seen = arrayMap(array, baseUnary(iteratee2));
            }
            while (++index < length) {
              var fromIndex = 0, value = values2[index], computed3 = iteratee2 ? iteratee2(value) : value;
              while ((fromIndex = indexOf2(seen, computed3, fromIndex, comparator)) > -1) {
                if (seen !== array) {
                  splice.call(seen, fromIndex, 1);
                }
                splice.call(array, fromIndex, 1);
              }
            }
            return array;
          }
          function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0, lastIndex = length - 1;
            while (length--) {
              var index = indexes[length];
              if (length == lastIndex || index !== previous) {
                var previous = index;
                if (isIndex(index)) {
                  splice.call(array, index, 1);
                } else {
                  baseUnset(array, index);
                }
              }
            }
            return array;
          }
          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
          }
          function baseRange(start, end, step, fromRight) {
            var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
            while (length--) {
              result2[fromRight ? length : ++index] = start;
              start += step;
            }
            return result2;
          }
          function baseRepeat(string, n) {
            var result2 = "";
            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
              return result2;
            }
            do {
              if (n % 2) {
                result2 += string;
              }
              n = nativeFloor(n / 2);
              if (n) {
                string += string;
              }
            } while (n);
            return result2;
          }
          function baseRest(func, start) {
            return setToString(overRest(func, start, identity2), func + "");
          }
          function baseSample(collection) {
            return arraySample(values(collection));
          }
          function baseSampleSize(collection, n) {
            var array = values(collection);
            return shuffleSelf(array, baseClamp(n, 0, array.length));
          }
          function baseSet(object, path, value, customizer) {
            if (!isObject4(object)) {
              return object;
            }
            path = castPath(path, object);
            var index = -1, length = path.length, lastIndex = length - 1, nested = object;
            while (nested != null && ++index < length) {
              var key = toKey(path[index]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object;
              }
              if (index != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                if (newValue === undefined2) {
                  newValue = isObject4(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }
          var baseSetData = !metaMap ? identity2 : function(func, data) {
            metaMap.set(func, data);
            return func;
          };
          var baseSetToString = !defineProperty ? identity2 : function(func, string) {
            return defineProperty(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant(string),
              "writable": true
            });
          };
          function baseShuffle(collection) {
            return shuffleSelf(values(collection));
          }
          function baseSlice(array, start, end) {
            var index = -1, length = array.length;
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end > length ? length : end;
            if (end < 0) {
              end += length;
            }
            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result2 = Array2(length);
            while (++index < length) {
              result2[index] = array[index + start];
            }
            return result2;
          }
          function baseSome(collection, predicate) {
            var result2;
            baseEach(collection, function(value, index, collection2) {
              result2 = predicate(value, index, collection2);
              return !result2;
            });
            return !!result2;
          }
          function baseSortedIndex(array, value, retHighest) {
            var low = 0, high = array == null ? low : array.length;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed3 = array[mid];
                if (computed3 !== null && !isSymbol2(computed3) && (retHighest ? computed3 <= value : computed3 < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array, value, identity2, retHighest);
          }
          function baseSortedIndexBy(array, value, iteratee2, retHighest) {
            var low = 0, high = array == null ? 0 : array.length;
            if (high === 0) {
              return 0;
            }
            value = iteratee2(value);
            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined2;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed3 = iteratee2(array[mid]), othIsDefined = computed3 !== undefined2, othIsNull = computed3 === null, othIsReflexive = computed3 === computed3, othIsSymbol = isSymbol2(computed3);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed3 <= value : computed3 < value;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array, iteratee2) {
            var index = -1, length = array.length, resIndex = 0, result2 = [];
            while (++index < length) {
              var value = array[index], computed3 = iteratee2 ? iteratee2(value) : value;
              if (!index || !eq(computed3, seen)) {
                var seen = computed3;
                result2[resIndex++] = value === 0 ? 0 : value;
              }
            }
            return result2;
          }
          function baseToNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol2(value)) {
              return NAN;
            }
            return +value;
          }
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray2(value)) {
              return arrayMap(value, baseToString) + "";
            }
            if (isSymbol2(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function baseUniq(array, iteratee2, comparator) {
            var index = -1, includes3 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
            if (comparator) {
              isCommon = false;
              includes3 = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set3 = iteratee2 ? null : createSet(array);
              if (set3) {
                return setToArray(set3);
              }
              isCommon = false;
              includes3 = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee2 ? [] : result2;
            }
            outer:
              while (++index < length) {
                var value = array[index], computed3 = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed3 === computed3) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed3) {
                      continue outer;
                    }
                  }
                  if (iteratee2) {
                    seen.push(computed3);
                  }
                  result2.push(value);
                } else if (!includes3(seen, computed3, comparator)) {
                  if (seen !== result2) {
                    seen.push(computed3);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseUnset(object, path) {
            path = castPath(path, object);
            object = parent(object, path);
            return object == null || delete object[toKey(last(path))];
          }
          function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer);
          }
          function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length, index = fromRight ? length : -1;
            while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
            }
            return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
          }
          function baseWrapperValue(value, actions) {
            var result2 = value;
            if (result2 instanceof LazyWrapper) {
              result2 = result2.value();
            }
            return arrayReduce(actions, function(result3, action) {
              return action.func.apply(action.thisArg, arrayPush([result3], action.args));
            }, result2);
          }
          function baseXor(arrays, iteratee2, comparator) {
            var length = arrays.length;
            if (length < 2) {
              return length ? baseUniq(arrays[0]) : [];
            }
            var index = -1, result2 = Array2(length);
            while (++index < length) {
              var array = arrays[index], othIndex = -1;
              while (++othIndex < length) {
                if (othIndex != index) {
                  result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
                }
              }
            }
            return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
          }
          function baseZipObject(props, values2, assignFunc) {
            var index = -1, length = props.length, valsLength = values2.length, result2 = {};
            while (++index < length) {
              var value = index < valsLength ? values2[index] : undefined2;
              assignFunc(result2, props[index], value);
            }
            return result2;
          }
          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }
          function castFunction(value) {
            return typeof value == "function" ? value : identity2;
          }
          function castPath(value, object) {
            if (isArray2(value)) {
              return value;
            }
            return isKey(value, object) ? [value] : stringToPath(toString2(value));
          }
          var castRest = baseRest;
          function castSlice(array, start, end) {
            var length = array.length;
            end = end === undefined2 ? length : end;
            return !start && end >= length ? array : baseSlice(array, start, end);
          }
          var clearTimeout2 = ctxClearTimeout || function(id) {
            return root.clearTimeout(id);
          };
          function cloneBuffer(buffer2, isDeep) {
            if (isDeep) {
              return buffer2.slice();
            }
            var length = buffer2.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
            buffer2.copy(result2);
            return result2;
          }
          function cloneArrayBuffer(arrayBuffer) {
            var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
            return result2;
          }
          function cloneDataView(dataView, isDeep) {
            var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
          }
          function cloneRegExp(regexp) {
            var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result2.lastIndex = regexp.lastIndex;
            return result2;
          }
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
          }
          function cloneTypedArray(typedArray, isDeep) {
            var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
              var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          function compareMultiple(object, other, orders) {
            var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
            while (++index < length) {
              var result2 = compareAscending(objCriteria[index], othCriteria[index]);
              if (result2) {
                if (index >= ordersLength) {
                  return result2;
                }
                var order = orders[index];
                return result2 * (order == "desc" ? -1 : 1);
              }
            }
            return object.index - other.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result2[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result2[leftIndex++] = args[argsIndex++];
            }
            return result2;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result2[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
              result2[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[offset + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result2;
          }
          function copyArray(source, array) {
            var index = -1, length = source.length;
            array || (array = Array2(length));
            while (++index < length) {
              array[index] = source[index];
            }
            return array;
          }
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1, length = props.length;
            while (++index < length) {
              var key = props[index];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
              if (newValue === undefined2) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }
            return object;
          }
          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }
          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee2) {
              var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
            };
          }
          function createAssigner(assigner) {
            return baseRest(function(object, sources) {
              var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined2 : customizer;
                length = 1;
              }
              object = Object2(object);
              while (++index < length) {
                var source = sources[index];
                if (source) {
                  assigner(object, source, index, customizer);
                }
              }
              return object;
            });
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee2) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee2);
              }
              var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
              while (fromRight ? index-- : ++index < length) {
                if (iteratee2(iterable[index], index, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor(fromRight) {
            return function(object, iteratee2, keysFunc) {
              var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
              while (length--) {
                var key = props[fromRight ? length : ++index];
                if (iteratee2(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
              return fn2.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
          }
          function createCaseFirst(methodName) {
            return function(string) {
              string = toString2(string);
              var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
              var chr = strSymbols ? strSymbols[0] : string.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder(callback) {
            return function(string) {
              return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
              return isObject4(result2) ? result2 : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
              while (index--) {
                args[index] = arguments[index];
              }
              var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length -= holders.length;
              if (length < arity) {
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  undefined2,
                  args,
                  holders,
                  undefined2,
                  undefined2,
                  arity - length
                );
              }
              var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
              return apply2(fn2, this, args);
            }
            return wrapper;
          }
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object2(collection);
              if (!isArrayLike(collection)) {
                var iteratee2 = getIteratee(predicate, 3);
                collection = keys2(collection);
                predicate = function(key) {
                  return iteratee2(iterable[key], key, iterable);
                };
              }
              var index = findIndexFunc(collection, predicate, fromIndex);
              return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index--) {
                var func = funcs[index];
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                  var wrapper = new LodashWrapper([], true);
                }
              }
              index = wrapper ? index : length;
              while (++index < length) {
                func = funcs[index];
                var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                } else {
                  wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }
              return function() {
                var args = arguments, value = args[0];
                if (wrapper && args.length == 1 && isArray2(value)) {
                  return wrapper.plant(value).value();
                }
                var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
                while (++index2 < length) {
                  result2 = funcs[index2].call(this, result2);
                }
                return result2;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index = length;
              while (index--) {
                args[index] = arguments[index];
              }
              if (isCurried) {
                var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length -= holdersCount;
              if (isCurried && length < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  thisArg,
                  args,
                  newHolders,
                  argPos,
                  ary2,
                  arity - length
                );
              }
              var thisBinding = isBind ? thisArg : this, fn2 = isBindKey ? thisBinding[func] : func;
              length = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length > 1) {
                args.reverse();
              }
              if (isAry && ary2 < length) {
                args.length = ary2;
              }
              if (this && this !== root && this instanceof wrapper) {
                fn2 = Ctor || createCtor(fn2);
              }
              return fn2.apply(thisBinding, args);
            }
            return wrapper;
          }
          function createInverter(setter, toIteratee) {
            return function(object, iteratee2) {
              return baseInverter(object, setter, toIteratee(iteratee2), {});
            };
          }
          function createMathOperation(operator, defaultValue) {
            return function(value, other) {
              var result2;
              if (value === undefined2 && other === undefined2) {
                return defaultValue;
              }
              if (value !== undefined2) {
                result2 = value;
              }
              if (other !== undefined2) {
                if (result2 === undefined2) {
                  return other;
                }
                if (typeof value == "string" || typeof other == "string") {
                  value = baseToString(value);
                  other = baseToString(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }
                result2 = operator(value, other);
              }
              return result2;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
              return baseRest(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee2) {
                  return apply2(iteratee2, thisArg, args);
                });
              });
            });
          }
          function createPadding(length, chars) {
            chars = chars === undefined2 ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length) : chars;
            }
            var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply2(fn2, isBind ? thisArg : this, args);
            }
            return wrapper;
          }
          function createRange2(fromRight) {
            return function(start, end, step) {
              if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                end = step = undefined2;
              }
              start = toFinite(start);
              if (end === undefined2) {
                end = start;
                start = 0;
              } else {
                end = toFinite(end);
              }
              step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
              return baseRange(start, end, step, fromRight);
            };
          }
          function createRelationalOperation(operator) {
            return function(value, other) {
              if (!(typeof value == "string" && typeof other == "string")) {
                value = toNumber2(value);
                other = toNumber2(other);
              }
              return operator(value, other);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary2,
              arity
            ];
            var result2 = wrapFunc.apply(undefined2, newData);
            if (isLaziable(func)) {
              setData(result2, newData);
            }
            result2.placeholder = placeholder;
            return setWrapToString(result2, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math2[methodName];
            return function(number, precision) {
              number = toNumber2(number);
              precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
              if (precision && nativeIsFinite(number)) {
                var pair = (toString2(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                pair = (toString2(value) + "e").split("e");
                return +(pair[0] + "e" + (+pair[1] - precision));
              }
              return func(number);
            };
          }
          var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop3 : function(values2) {
            return new Set2(values2);
          };
          function createToPairs(keysFunc) {
            return function(object) {
              var tag = getTag(object);
              if (tag == mapTag) {
                return mapToArray(object);
              }
              if (tag == setTag) {
                return setToPairs(object);
              }
              return baseToPairs(object, keysFunc(object));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined2;
            }
            ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
            arity = arity === undefined2 ? arity : toInteger(arity);
            length -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined2;
            }
            var data = isBindKey ? undefined2 : getData(func);
            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary2,
              arity
            ];
            if (data) {
              mergeData(newData, data);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result2 = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result2 = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result2 = createPartial(func, bitmask, thisArg, partials);
            } else {
              result2 = createHybrid.apply(undefined2, newData);
            }
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result2, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty3.call(object, key)) {
              return srcValue;
            }
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key, object, source, stack2) {
            if (isObject4(objValue) && isObject4(srcValue)) {
              stack2.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack2);
              stack2["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value) {
            return isPlainObject3(value) ? undefined2 : value;
          }
          function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack2.get(array);
            var othStacked = stack2.get(other);
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array;
            }
            var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
            stack2.set(array, other);
            stack2.set(other, array);
            while (++index < arrLength) {
              var arrValue = array[index], othValue = other[index];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack2) : customizer(arrValue, othValue, index, array, other, stack2);
              }
              if (compared !== undefined2) {
                if (compared) {
                  continue;
                }
                result2 = false;
                break;
              }
              if (seen) {
                if (!arraySome(other, function(othValue2, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result2 = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
                result2 = false;
                break;
              }
            }
            stack2["delete"](array);
            stack2["delete"](other);
            return result2;
          }
          function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other = other.buffer;
              case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                  return false;
                }
                return true;
              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object, +other);
              case errorTag:
                return object.name == other.name && object.message == other.message;
              case regexpTag:
              case stringTag:
                return object == other + "";
              case mapTag:
                var convert = mapToArray;
              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack2.get(object);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                stack2.set(object, other);
                var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
                stack2["delete"](object);
                return result2;
              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
            }
            return false;
          }
          function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index = objLength;
            while (index--) {
              var key = objProps[index];
              if (!(isPartial ? key in other : hasOwnProperty3.call(other, key))) {
                return false;
              }
            }
            var objStacked = stack2.get(object);
            var othStacked = stack2.get(other);
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object;
            }
            var result2 = true;
            stack2.set(object, other);
            stack2.set(other, object);
            var skipCtor = isPartial;
            while (++index < objLength) {
              key = objProps[index];
              var objValue = object[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
              }
              if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
                result2 = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result2 && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result2 = false;
              }
            }
            stack2["delete"](object);
            stack2["delete"](other);
            return result2;
          }
          function flatRest(func) {
            return setToString(overRest(func, undefined2, flatten), func + "");
          }
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys2, getSymbols);
          }
          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
          }
          var getData = !metaMap ? noop3 : function(func) {
            return metaMap.get(func);
          };
          function getFuncName(func) {
            var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty3.call(realNames, result2) ? array.length : 0;
            while (length--) {
              var data = array[length], otherFunc = data.func;
              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }
            return result2;
          }
          function getHolder(func) {
            var object = hasOwnProperty3.call(lodash, "placeholder") ? lodash : func;
            return object.placeholder;
          }
          function getIteratee() {
            var result2 = lodash.iteratee || iteratee;
            result2 = result2 === iteratee ? baseIteratee : result2;
            return arguments.length ? result2(arguments[0], arguments[1]) : result2;
          }
          function getMapData(map3, key) {
            var data = map3.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function getMatchData(object) {
            var result2 = keys2(object), length = result2.length;
            while (length--) {
              var key = result2[length], value = object[key];
              result2[length] = [key, value, isStrictComparable(value)];
            }
            return result2;
          }
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined2;
          }
          function getRawTag(value) {
            var isOwn = hasOwnProperty3.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined2;
              var unmasked = true;
            } catch (e) {
            }
            var result2 = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result2;
          }
          var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
            if (object == null) {
              return [];
            }
            object = Object2(object);
            return arrayFilter(nativeGetSymbols(object), function(symbol) {
              return propertyIsEnumerable.call(object, symbol);
            });
          };
          var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
            var result2 = [];
            while (object) {
              arrayPush(result2, getSymbols(object));
              object = getPrototype(object);
            }
            return result2;
          };
          var getTag = baseGetTag;
          if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
            getTag = function(value) {
              var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result2;
            };
          }
          function getView(start, end, transforms) {
            var index = -1, length = transforms.length;
            while (++index < length) {
              var data = transforms[index], size2 = data.size;
              switch (data.type) {
                case "drop":
                  start += size2;
                  break;
                case "dropRight":
                  end -= size2;
                  break;
                case "take":
                  end = nativeMin(end, start + size2);
                  break;
                case "takeRight":
                  start = nativeMax(start, end - size2);
                  break;
              }
            }
            return { "start": start, "end": end };
          }
          function getWrapDetails(source) {
            var match2 = source.match(reWrapDetails);
            return match2 ? match2[1].split(reSplitDetails) : [];
          }
          function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            var index = -1, length = path.length, result2 = false;
            while (++index < length) {
              var key = toKey(path[index]);
              if (!(result2 = object != null && hasFunc(object, key))) {
                break;
              }
              object = object[key];
            }
            if (result2 || ++index != length) {
              return result2;
            }
            length = object == null ? 0 : object.length;
            return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
          }
          function initCloneArray(array) {
            var length = array.length, result2 = new array.constructor(length);
            if (length && typeof array[0] == "string" && hasOwnProperty3.call(array, "index")) {
              result2.index = array.index;
              result2.input = array.input;
            }
            return result2;
          }
          function initCloneObject(object) {
            return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);
              case boolTag:
              case dateTag:
                return new Ctor(+object);
              case dataViewTag:
                return cloneDataView(object, isDeep);
              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);
              case mapTag:
                return new Ctor();
              case numberTag:
              case stringTag:
                return new Ctor(object);
              case regexpTag:
                return cloneRegExp(object);
              case setTag:
                return new Ctor();
              case symbolTag:
                return cloneSymbol(object);
            }
          }
          function insertWrapDetails(source, details) {
            var length = details.length;
            if (!length) {
              return source;
            }
            var lastIndex = length - 1;
            details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
            details = details.join(length > 2 ? ", " : " ");
            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable(value) {
            return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
          }
          function isIterateeCall(value, index, object) {
            if (!isObject4(object)) {
              return false;
            }
            var type = typeof index;
            if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
              return eq(object[index], value);
            }
            return false;
          }
          function isKey(value, object) {
            if (isArray2(value)) {
              return false;
            }
            var type = typeof value;
            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol2(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
          }
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash[funcName];
            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other) {
              return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
          }
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          var isMaskable = coreJsData ? isFunction2 : stubFalse;
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto;
          }
          function isStrictComparable(value) {
            return value === value && !isObject4(value);
          }
          function matchesStrictComparable(key, srcValue) {
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
            };
          }
          function memoizeCapped(func) {
            var result2 = memoize(func, function(key) {
              if (cache.size === MAX_MEMOIZE_SIZE) {
                cache.clear();
              }
              return key;
            });
            var cache = result2.cache;
            return result2;
          }
          function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) {
              return data;
            }
            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            if (value) {
              data[7] = value;
            }
            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
              data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }
          function nativeKeysIn(object) {
            var result2 = [];
            if (object != null) {
              for (var key in Object2(object)) {
                result2.push(key);
              }
            }
            return result2;
          }
          function objectToString2(value) {
            return nativeObjectToString.call(value);
          }
          function overRest(func, start, transform3) {
            start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
            return function() {
              var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
              while (++index < length) {
                array[index] = args[start + index];
              }
              index = -1;
              var otherArgs = Array2(start + 1);
              while (++index < start) {
                otherArgs[index] = args[index];
              }
              otherArgs[start] = transform3(array);
              return apply2(func, this, otherArgs);
            };
          }
          function parent(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
          }
          function reorder(array, indexes) {
            var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
            while (length--) {
              var index = indexes[length];
              array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
            }
            return array;
          }
          function safeGet(object, key) {
            if (key === "constructor" && typeof object[key] === "function") {
              return;
            }
            if (key == "__proto__") {
              return;
            }
            return object[key];
          }
          var setData = shortOut(baseSetData);
          var setTimeout2 = ctxSetTimeout || function(func, wait) {
            return root.setTimeout(func, wait);
          };
          var setToString = shortOut(baseSetToString);
          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + "";
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined2, arguments);
            };
          }
          function shuffleSelf(array, size2) {
            var index = -1, length = array.length, lastIndex = length - 1;
            size2 = size2 === undefined2 ? length : size2;
            while (++index < size2) {
              var rand = baseRandom(index, lastIndex), value = array[rand];
              array[rand] = array[index];
              array[index] = value;
            }
            array.length = size2;
            return array;
          }
          var stringToPath = memoizeCapped(function(string) {
            var result2 = [];
            if (string.charCodeAt(0) === 46) {
              result2.push("");
            }
            string.replace(rePropName, function(match2, number, quote, subString) {
              result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
            });
            return result2;
          });
          function toKey(value) {
            if (typeof value == "string" || isSymbol2(value)) {
              return value;
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {
              }
              try {
                return func + "";
              } catch (e) {
              }
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function(pair) {
              var value = "_." + pair[0];
              if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone();
            }
            var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result2.__actions__ = copyArray(wrapper.__actions__);
            result2.__index__ = wrapper.__index__;
            result2.__values__ = wrapper.__values__;
            return result2;
          }
          function chunk2(array, size2, guard) {
            if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
              size2 = 1;
            } else {
              size2 = nativeMax(toInteger(size2), 0);
            }
            var length = array == null ? 0 : array.length;
            if (!length || size2 < 1) {
              return [];
            }
            var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
            while (index < length) {
              result2[resIndex++] = baseSlice(array, index, index += size2);
            }
            return result2;
          }
          function compact(array) {
            var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
            while (++index < length) {
              var value = array[index];
              if (value) {
                result2[resIndex++] = value;
              }
            }
            return result2;
          }
          function concat() {
            var length = arguments.length;
            if (!length) {
              return [];
            }
            var args = Array2(length - 1), array = arguments[0], index = length;
            while (index--) {
              args[index - 1] = arguments[index];
            }
            return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
          }
          var difference = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
          });
          var differenceBy = baseRest(function(array, values2) {
            var iteratee2 = last(values2);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
          });
          var differenceWith = baseRest(function(array, values2) {
            var comparator = last(values2);
            if (isArrayLikeObject(comparator)) {
              comparator = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
          });
          function drop(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array, n < 0 ? 0 : n, length);
          }
          function dropRight(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }
          function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
          }
          function fill(array, value, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
              start = 0;
              end = length;
            }
            return baseFill(array, value, start, end);
          }
          function findIndex2(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length + index, 0);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index);
          }
          function findLastIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = length - 1;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index, true);
          }
          function flatten(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, 1) : [];
          }
          function flattenDeep(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, INFINITY) : [];
          }
          function flattenDepth(array, depth) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(array, depth);
          }
          function fromPairs(pairs) {
            var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
            while (++index < length) {
              var pair = pairs[index];
              result2[pair[0]] = pair[1];
            }
            return result2;
          }
          function head(array) {
            return array && array.length ? array[0] : undefined2;
          }
          function indexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length + index, 0);
            }
            return baseIndexOf(array, value, index);
          }
          function initial(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 0, -1) : [];
          }
          var intersection = baseRest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee2 === last(mapped)) {
              iteratee2 = undefined2;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
          });
          var intersectionWith = baseRest(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
          });
          function join(array, separator) {
            return array == null ? "" : nativeJoin.call(array, separator);
          }
          function last(array) {
            var length = array == null ? 0 : array.length;
            return length ? array[length - 1] : undefined2;
          }
          function lastIndexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = length;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
          }
          function nth(array, n) {
            return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
          }
          var pull = baseRest(pullAll);
          function pullAll(array, values2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
          }
          function pullAllBy(array, values2, iteratee2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
          }
          function pullAllWith(array, values2, comparator) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
          }
          var pullAt = flatRest(function(array, indexes) {
            var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
            basePullAt(array, arrayMap(indexes, function(index) {
              return isIndex(index, length) ? +index : index;
            }).sort(compareAscending));
            return result2;
          });
          function remove3(array, predicate) {
            var result2 = [];
            if (!(array && array.length)) {
              return result2;
            }
            var index = -1, indexes = [], length = array.length;
            predicate = getIteratee(predicate, 3);
            while (++index < length) {
              var value = array[index];
              if (predicate(value, index, array)) {
                result2.push(value);
                indexes.push(index);
              }
            }
            basePullAt(array, indexes);
            return result2;
          }
          function reverse(array) {
            return array == null ? array : nativeReverse.call(array);
          }
          function slice(array, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
              start = 0;
              end = length;
            } else {
              start = start == null ? 0 : toInteger(start);
              end = end === undefined2 ? length : toInteger(end);
            }
            return baseSlice(array, start, end);
          }
          function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
          }
          function sortedIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
          }
          function sortedIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index = baseSortedIndex(array, value);
              if (index < length && eq(array[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true);
          }
          function sortedLastIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
          }
          function sortedLastIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index = baseSortedIndex(array, value, true) - 1;
              if (eq(array[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
          }
          function sortedUniqBy(array, iteratee2) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function tail(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 1, length) : [];
          }
          function take(array, n, guard) {
            if (!(array && array.length)) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }
          function takeRight(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, n < 0 ? 0 : n, length);
          }
          function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
          }
          var union = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          var unionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
          });
          var unionWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
          });
          function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
          }
          function uniqBy(array, iteratee2) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function uniqWith(array, comparator) {
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return array && array.length ? baseUniq(array, undefined2, comparator) : [];
          }
          function unzip(array) {
            if (!(array && array.length)) {
              return [];
            }
            var length = 0;
            array = arrayFilter(array, function(group) {
              if (isArrayLikeObject(group)) {
                length = nativeMax(group.length, length);
                return true;
              }
            });
            return baseTimes(length, function(index) {
              return arrayMap(array, baseProperty(index));
            });
          }
          function unzipWith(array, iteratee2) {
            if (!(array && array.length)) {
              return [];
            }
            var result2 = unzip(array);
            if (iteratee2 == null) {
              return result2;
            }
            return arrayMap(result2, function(group) {
              return apply2(iteratee2, undefined2, group);
            });
          }
          var without = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
          });
          var xor = baseRest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
          });
          var xorBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
          });
          var xorWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
          });
          var zip = baseRest(unzip);
          function zipObject(props, values2) {
            return baseZipObject(props || [], values2 || [], assignValue);
          }
          function zipObjectDeep(props, values2) {
            return baseZipObject(props || [], values2 || [], baseSet);
          }
          var zipWith = baseRest(function(arrays) {
            var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
            iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
            return unzipWith(arrays, iteratee2);
          });
          function chain(value) {
            var result2 = lodash(value);
            result2.__chain__ = true;
            return result2;
          }
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          function thru(value, interceptor) {
            return interceptor(value);
          }
          var wrapperAt = flatRest(function(paths) {
            var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
              return baseAt(object, paths);
            };
            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
              return this.thru(interceptor);
            }
            value = value.slice(start, +start + (length ? 1 : 0));
            value.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined2
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array) {
              if (length && !array.length) {
                array.push(undefined2);
              }
              return array;
            });
          });
          function wrapperChain() {
            return chain(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            if (this.__values__ === undefined2) {
              this.__values__ = toArray2(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
            return { "done": done, "value": value };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value) {
            var result2, parent2 = this;
            while (parent2 instanceof baseLodash) {
              var clone2 = wrapperClone(parent2);
              clone2.__index__ = 0;
              clone2.__values__ = undefined2;
              if (result2) {
                previous.__wrapped__ = clone2;
              } else {
                result2 = clone2;
              }
              var previous = clone2;
              parent2 = parent2.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result2;
          }
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                "func": thru,
                "args": [reverse],
                "thisArg": undefined2
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty3.call(result2, key)) {
              ++result2[key];
            } else {
              baseAssignValue(result2, key, 1);
            }
          });
          function every(collection, predicate, guard) {
            var func = isArray2(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          function filter(collection, predicate) {
            var func = isArray2(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          var find = createFind(findIndex2);
          var findLast = createFind(findLastIndex);
          function flatMap(collection, iteratee2) {
            return baseFlatten(map2(collection, iteratee2), 1);
          }
          function flatMapDeep(collection, iteratee2) {
            return baseFlatten(map2(collection, iteratee2), INFINITY);
          }
          function flatMapDepth(collection, iteratee2, depth) {
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(map2(collection, iteratee2), depth);
          }
          function forEach(collection, iteratee2) {
            var func = isArray2(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function forEachRight(collection, iteratee2) {
            var func = isArray2(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee2, 3));
          }
          var groupBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty3.call(result2, key)) {
              result2[key].push(value);
            } else {
              baseAssignValue(result2, key, [value]);
            }
          });
          function includes2(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax(length + fromIndex, 0);
            }
            return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
          }
          var invokeMap = baseRest(function(collection, path, args) {
            var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value) {
              result2[++index] = isFunc ? apply2(path, value, args) : baseInvoke(value, path, args);
            });
            return result2;
          });
          var keyBy = createAggregator(function(result2, value, key) {
            baseAssignValue(result2, key, value);
          });
          function map2(collection, iteratee2) {
            var func = isArray2(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray2(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined2 : orders;
            if (!isArray2(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
          }
          var partition = createAggregator(function(result2, value, key) {
            result2[key ? 0 : 1].push(value);
          }, function() {
            return [[], []];
          });
          function reduce2(collection, iteratee2, accumulator) {
            var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
          }
          function reduceRight(collection, iteratee2, accumulator) {
            var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
          }
          function reject(collection, predicate) {
            var func = isArray2(collection) ? arrayFilter : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }
          function sample(collection) {
            var func = isArray2(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n, guard) {
            if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n);
          }
          function shuffle(collection) {
            var func = isArray2(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike(collection)) {
              return isString2(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag(collection);
            if (tag == mapTag || tag == setTag) {
              return collection.size;
            }
            return baseKeys(collection).length;
          }
          function some(collection, predicate, guard) {
            var func = isArray2(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length = iteratees.length;
            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          var now = ctxNow || function() {
            return root.Date.now();
          };
          function after(n, func) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          function ary(func, n, guard) {
            n = guard ? undefined2 : n;
            n = func && n == null ? func.length : n;
            return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
          }
          function before(n, func) {
            var result2;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n > 0) {
                result2 = func.apply(this, arguments);
              }
              if (n <= 1) {
                func = undefined2;
              }
              return result2;
            };
          }
          var bind = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey = baseRest(function(object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curry.placeholder;
            return result2;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curryRight.placeholder;
            return result2;
          }
          function debounce2(func, wait, options) {
            var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            wait = toNumber2(wait) || 0;
            if (isObject4(options)) {
              leading = !!options.leading;
              maxing = "maxWait" in options;
              maxWait = maxing ? nativeMax(toNumber2(options.maxWait) || 0, wait) : maxWait;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined2;
              lastInvokeTime = time;
              result2 = func.apply(thisArg, args);
              return result2;
            }
            function leadingEdge(time) {
              lastInvokeTime = time;
              timerId = setTimeout2(timerExpired, wait);
              return leading ? invokeFunc(time) : result2;
            }
            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
              return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time = now();
              if (shouldInvoke(time)) {
                return trailingEdge(time);
              }
              timerId = setTimeout2(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
              timerId = undefined2;
              if (trailing && lastArgs) {
                return invokeFunc(time);
              }
              lastArgs = lastThis = undefined2;
              return result2;
            }
            function cancel() {
              if (timerId !== undefined2) {
                clearTimeout2(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined2;
            }
            function flush() {
              return timerId === undefined2 ? result2 : trailingEdge(now());
            }
            function debounced() {
              var time = now(), isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;
              if (isInvoking) {
                if (timerId === undefined2) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout2(timerId);
                  timerId = setTimeout2(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined2) {
                timerId = setTimeout2(timerExpired, wait);
              }
              return result2;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
          }
          var defer2 = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay = baseRest(function(func, wait, args) {
            return baseDelay(func, toNumber2(wait) || 0, args);
          });
          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
              if (cache.has(key)) {
                return cache.get(key);
              }
              var result2 = func.apply(this, args);
              memoized.cache = cache.set(key, result2) || cache;
              return result2;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }
          memoize.Cache = MapCache;
          function negate(predicate) {
            if (typeof predicate != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once(func) {
            return before(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
              var index = -1, length = nativeMin(args.length, funcsLength);
              while (++index < length) {
                args[index] = transforms[index].call(this, args[index]);
              }
              return apply2(func, this, args);
            });
          });
          var partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
          });
          var partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
          });
          var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
          });
          function rest(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start === undefined2 ? start : toInteger(start);
            return baseRest(func, start);
          }
          function spread(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start == null ? 0 : nativeMax(toInteger(start), 0);
            return baseRest(function(args) {
              var array = args[start], otherArgs = castSlice(args, 0, start);
              if (array) {
                arrayPush(otherArgs, array);
              }
              return apply2(func, this, otherArgs);
            });
          }
          function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (isObject4(options)) {
              leading = "leading" in options ? !!options.leading : leading;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce2(func, wait, {
              "leading": leading,
              "maxWait": wait,
              "trailing": trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap(value, wrapper) {
            return partial(castFunction(wrapper), value);
          }
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray2(value) ? value : [value];
          }
          function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          function cloneWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }
          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys2(source));
          }
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          var gt2 = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value, other) {
            return value >= other;
          });
          var isArguments = baseIsArguments(function() {
            return arguments;
          }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty3.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
          };
          var isArray2 = Array2.isArray;
          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction2(value);
          }
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          function isBoolean2(value) {
            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
          }
          var isBuffer = nativeIsBuffer || stubFalse;
          var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
          function isElement(value) {
            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject3(value);
          }
          function isEmpty2(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }
            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty3.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          function isEqual3(value, other) {
            return baseIsEqual(value, other);
          }
          function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            var result2 = customizer ? customizer(value, other) : undefined2;
            return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
          }
          function isError(value) {
            if (!isObjectLike(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject3(value);
          }
          function isFinite2(value) {
            return typeof value == "number" && nativeIsFinite(value);
          }
          function isFunction2(value) {
            if (!isObject4(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          function isInteger(value) {
            return typeof value == "number" && value == toInteger(value);
          }
          function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          function isObject4(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
          }
          function isObjectLike(value) {
            return value != null && typeof value == "object";
          }
          var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
          }
          function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseIsMatch(object, source, getMatchData(source), customizer);
          }
          function isNaN2(value) {
            return isNumber(value) && value != +value;
          }
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error2(CORE_ERROR_TEXT);
            }
            return baseIsNative(value);
          }
          function isNull(value) {
            return value === null;
          }
          function isNil(value) {
            return value == null;
          }
          function isNumber(value) {
            return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
          }
          function isPlainObject3(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty3.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          var isRegExp2 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
          }
          var isSet2 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          function isString2(value) {
            return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
          }
          function isSymbol2(value) {
            return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
          }
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          function isUndefined(value) {
            return value === undefined2;
          }
          function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
          }
          function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
          }
          var lt2 = createRelationalOperation(baseLt);
          var lte = createRelationalOperation(function(value, other) {
            return value <= other;
          });
          function toArray2(value) {
            if (!value) {
              return [];
            }
            if (isArrayLike(value)) {
              return isString2(value) ? stringToArray(value) : copyArray(value);
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }
            var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
            return func(value);
          }
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber2(value);
            if (value === INFINITY || value === -INFINITY) {
              var sign = value < 0 ? -1 : 1;
              return sign * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }
          function toInteger(value) {
            var result2 = toFinite(value), remainder = result2 % 1;
            return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
          }
          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber2(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol2(value)) {
              return NAN;
            }
            if (isObject4(value)) {
              var other = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject4(other) ? other + "" : other;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
          }
          function toString2(value) {
            return value == null ? "" : baseToString(value);
          }
          var assign = createAssigner(function(object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
              copyObject(source, keys2(source), object);
              return;
            }
            for (var key in source) {
              if (hasOwnProperty3.call(source, key)) {
                assignValue(object, key, source[key]);
              }
            }
          });
          var assignIn = createAssigner(function(object, source) {
            copyObject(source, keysIn(source), object);
          });
          var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
          });
          var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys2(source), object, customizer);
          });
          var at2 = flatRest(baseAt);
          function create(prototype, properties) {
            var result2 = baseCreate(prototype);
            return properties == null ? result2 : baseAssign(result2, properties);
          }
          var defaults = baseRest(function(object, sources) {
            object = Object2(object);
            var index = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length = 1;
            }
            while (++index < length) {
              var source = sources[index];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];
                if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty3.call(object, key)) {
                  object[key] = source[key];
                }
              }
            }
            return object;
          });
          var defaultsDeep = baseRest(function(args) {
            args.push(undefined2, customDefaultsMerge);
            return apply2(mergeWith, undefined2, args);
          });
          function findKey2(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
          }
          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object, iteratee2) {
            return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forInRight(object, iteratee2) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forOwn(object, iteratee2) {
            return object && baseForOwn(object, getIteratee(iteratee2, 3));
          }
          function forOwnRight(object, iteratee2) {
            return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
          }
          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys2(object));
          }
          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
          }
          function get(object, path, defaultValue) {
            var result2 = object == null ? undefined2 : baseGet(object, path);
            return result2 === undefined2 ? defaultValue : result2;
          }
          function has2(object, path) {
            return object != null && hasPath(object, path, baseHas);
          }
          function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
          }
          var invert = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            result2[value] = key;
          }, constant(identity2));
          var invertBy = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            if (hasOwnProperty3.call(result2, value)) {
              result2[value].push(key);
            } else {
              result2[value] = [key];
            }
          }, getIteratee);
          var invoke = baseRest(baseInvoke);
          function keys2(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }
          function mapKeys(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, iteratee2(value, key, object2), value);
            });
            return result2;
          }
          function mapValues(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, key, iteratee2(value, key, object2));
            });
            return result2;
          }
          var merge = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });
          var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });
          var omit2 = flatRest(function(object, paths) {
            var result2 = {};
            if (object == null) {
              return result2;
            }
            var isDeep = false;
            paths = arrayMap(paths, function(path) {
              path = castPath(path, object);
              isDeep || (isDeep = path.length > 1);
              return path;
            });
            copyObject(object, getAllKeysIn(object), result2);
            if (isDeep) {
              result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length = paths.length;
            while (length--) {
              baseUnset(result2, paths[length]);
            }
            return result2;
          });
          function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
          }
          var pick2 = flatRest(function(object, paths) {
            return object == null ? {} : basePick(object, paths);
          });
          function pickBy(object, predicate) {
            if (object == null) {
              return {};
            }
            var props = arrayMap(getAllKeysIn(object), function(prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object, props, function(value, path) {
              return predicate(value, path[0]);
            });
          }
          function result(object, path, defaultValue) {
            path = castPath(path, object);
            var index = -1, length = path.length;
            if (!length) {
              length = 1;
              object = undefined2;
            }
            while (++index < length) {
              var value = object == null ? undefined2 : object[toKey(path[index])];
              if (value === undefined2) {
                index = length;
                value = defaultValue;
              }
              object = isFunction2(value) ? value.call(object) : value;
            }
            return object;
          }
          function set2(object, path, value) {
            return object == null ? object : baseSet(object, path, value);
          }
          function setWith(object, path, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseSet(object, path, value, customizer);
          }
          var toPairs = createToPairs(keys2);
          var toPairsIn = createToPairs(keysIn);
          function transform2(object, iteratee2, accumulator) {
            var isArr = isArray2(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
            iteratee2 = getIteratee(iteratee2, 4);
            if (accumulator == null) {
              var Ctor = object && object.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject4(object)) {
                accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
              return iteratee2(accumulator, value, index, object2);
            });
            return accumulator;
          }
          function unset(object, path) {
            return object == null ? true : baseUnset(object, path);
          }
          function update(object, path, updater) {
            return object == null ? object : baseUpdate(object, path, castFunction(updater));
          }
          function updateWith(object, path, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
          }
          function values(object) {
            return object == null ? [] : baseValues(object, keys2(object));
          }
          function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
          }
          function clamp3(number, lower, upper) {
            if (upper === undefined2) {
              upper = lower;
              lower = undefined2;
            }
            if (upper !== undefined2) {
              upper = toNumber2(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined2) {
              lower = toNumber2(lower);
              lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber2(number), lower, upper);
          }
          function inRange(number, start, end) {
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            number = toNumber2(number);
            return baseInRange(number, start, end);
          }
          function random(lower, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
              upper = floating = undefined2;
            }
            if (floating === undefined2) {
              if (typeof upper == "boolean") {
                floating = upper;
                upper = undefined2;
              } else if (typeof lower == "boolean") {
                floating = lower;
                lower = undefined2;
              }
            }
            if (lower === undefined2 && upper === undefined2) {
              lower = 0;
              upper = 1;
            } else {
              lower = toFinite(lower);
              if (upper === undefined2) {
                upper = lower;
                lower = 0;
              } else {
                upper = toFinite(upper);
              }
            }
            if (lower > upper) {
              var temp = lower;
              lower = upper;
              upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower, upper);
          }
          var camelCase = createCompounder(function(result2, word, index) {
            word = word.toLowerCase();
            return result2 + (index ? capitalize2(word) : word);
          });
          function capitalize2(string) {
            return upperFirst(toString2(string).toLowerCase());
          }
          function deburr(string) {
            string = toString2(string);
            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith(string, target, position) {
            string = toString2(string);
            target = baseToString(target);
            var length = string.length;
            position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
            var end = position;
            position -= target.length;
            return position >= 0 && string.slice(position, end) == target;
          }
          function escape(string) {
            string = toString2(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
          }
          function escapeRegExp(string) {
            string = toString2(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
          }
          var kebabCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "-" : "") + word.toLowerCase();
          });
          var lowerCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad(string, length, chars) {
            string = toString2(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            if (!length || strLength >= length) {
              return string;
            }
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
          }
          function padEnd2(string, length, chars) {
            string = toString2(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
          }
          function padStart2(string, length, chars) {
            string = toString2(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
          }
          function parseInt2(string, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            return nativeParseInt(toString2(string).replace(reTrimStart, ""), radix || 0);
          }
          function repeat(string, n, guard) {
            if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            return baseRepeat(toString2(string), n);
          }
          function replace2() {
            var args = arguments, string = toString2(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "_" : "") + word.toLowerCase();
          });
          function split(string, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
              separator = limit = undefined2;
            }
            limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string = toString2(string);
            if (string && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
              separator = baseToString(separator);
              if (!separator && hasUnicode(string)) {
                return castSlice(stringToArray(string), 0, limit);
              }
            }
            return string.split(separator, limit);
          }
          var startCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + upperFirst(word);
          });
          function startsWith(string, target, position) {
            string = toString2(string);
            position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
            target = baseToString(target);
            return string.slice(position, position + target.length) == target;
          }
          function template(string, options, guard) {
            var settings = lodash.templateSettings;
            if (guard && isIterateeCall(string, options, guard)) {
              options = undefined2;
            }
            string = toString2(string);
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp2(
              (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
              "g"
            );
            var sourceURL = "//# sourceURL=" + (hasOwnProperty3.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index = offset + match2.length;
              return match2;
            });
            source += "';\n";
            var variable = hasOwnProperty3.call(options, "variable") && options.variable;
            if (!variable) {
              source = "with (obj) {\n" + source + "\n}\n";
            } else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result2 = attempt(function() {
              return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
            });
            result2.source = source;
            if (isError(result2)) {
              throw result2;
            }
            return result2;
          }
          function toLower(value) {
            return toString2(value).toLowerCase();
          }
          function toUpper(value) {
            return toString2(value).toUpperCase();
          }
          function trim(string, chars, guard) {
            string = toString2(string);
            if (string && (guard || chars === undefined2)) {
              return baseTrim(string);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join("");
          }
          function trimEnd(string, chars, guard) {
            string = toString2(string);
            if (string && (guard || chars === undefined2)) {
              return string.slice(0, trimmedEndIndex(string) + 1);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join("");
          }
          function trimStart(string, chars, guard) {
            string = toString2(string);
            if (string && (guard || chars === undefined2)) {
              return string.replace(reTrimStart, "");
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start).join("");
          }
          function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject4(options)) {
              var separator = "separator" in options ? options.separator : separator;
              length = "length" in options ? toInteger(options.length) : length;
              omission = "omission" in options ? baseToString(options.omission) : omission;
            }
            string = toString2(string);
            var strLength = string.length;
            if (hasUnicode(string)) {
              var strSymbols = stringToArray(string);
              strLength = strSymbols.length;
            }
            if (length >= strLength) {
              return string;
            }
            var end = length - stringSize(omission);
            if (end < 1) {
              return omission;
            }
            var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
            if (separator === undefined2) {
              return result2 + omission;
            }
            if (strSymbols) {
              end += result2.length - end;
            }
            if (isRegExp2(separator)) {
              if (string.slice(end).search(separator)) {
                var match2, substring = result2;
                if (!separator.global) {
                  separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
                }
                separator.lastIndex = 0;
                while (match2 = separator.exec(substring)) {
                  var newEnd = match2.index;
                }
                result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
              }
            } else if (string.indexOf(baseToString(separator), end) != end) {
              var index = result2.lastIndexOf(separator);
              if (index > -1) {
                result2 = result2.slice(0, index);
              }
            }
            return result2 + omission;
          }
          function unescape(string) {
            string = toString2(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
          }
          var upperCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toUpperCase();
          });
          var upperFirst = createCaseFirst("toUpperCase");
          function words(string, pattern, guard) {
            string = toString2(string);
            pattern = guard ? undefined2 : pattern;
            if (pattern === undefined2) {
              return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
            }
            return string.match(pattern) || [];
          }
          var attempt = baseRest(function(func, args) {
            try {
              return apply2(func, undefined2, args);
            } catch (e) {
              return isError(e) ? e : new Error2(e);
            }
          });
          var bindAll = flatRest(function(object, methodNames) {
            arrayEach(methodNames, function(key) {
              key = toKey(key);
              baseAssignValue(object, key, bind(object[key], object));
            });
            return object;
          });
          function cond(pairs) {
            var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap(pairs, function(pair) {
              if (typeof pair[1] != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              return [toIteratee(pair[0]), pair[1]];
            });
            return baseRest(function(args) {
              var index = -1;
              while (++index < length) {
                var pair = pairs[index];
                if (apply2(pair[0], this, args)) {
                  return apply2(pair[1], this, args);
                }
              }
            });
          }
          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }
          function constant(value) {
            return function() {
              return value;
            };
          }
          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }
          var flow = createFlow();
          var flowRight = createFlow(true);
          function identity2(value) {
            return value;
          }
          function iteratee(func) {
            return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
          }
          function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          var method = baseRest(function(path, args) {
            return function(object) {
              return baseInvoke(object, path, args);
            };
          });
          var methodOf = baseRest(function(object, args) {
            return function(path) {
              return baseInvoke(object, path, args);
            };
          });
          function mixin(object, source, options) {
            var props = keys2(source), methodNames = baseFunctions(source, props);
            if (options == null && !(isObject4(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys2(source));
            }
            var chain2 = !(isObject4(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
            arrayEach(methodNames, function(methodName) {
              var func = source[methodName];
              object[methodName] = func;
              if (isFunc) {
                object.prototype[methodName] = function() {
                  var chainAll = this.__chain__;
                  if (chain2 || chainAll) {
                    var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                    actions.push({ "func": func, "args": arguments, "thisArg": object });
                    result2.__chain__ = chainAll;
                    return result2;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }
            });
            return object;
          }
          function noConflict() {
            if (root._ === this) {
              root._ = oldDash;
            }
            return this;
          }
          function noop3() {
          }
          function nthArg(n) {
            n = toInteger(n);
            return baseRest(function(args) {
              return baseNth(args, n);
            });
          }
          var over = createOver(arrayMap);
          var overEvery = createOver(arrayEvery);
          var overSome = createOver(arraySome);
          function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
          }
          function propertyOf(object) {
            return function(path) {
              return object == null ? undefined2 : baseGet(object, path);
            };
          }
          var range = createRange2();
          var rangeRight = createRange2(true);
          function stubArray() {
            return [];
          }
          function stubFalse() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n, iteratee2) {
            n = toInteger(n);
            if (n < 1 || n > MAX_SAFE_INTEGER) {
              return [];
            }
            var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee2 = getIteratee(iteratee2);
            n -= MAX_ARRAY_LENGTH;
            var result2 = baseTimes(length, iteratee2);
            while (++index < n) {
              iteratee2(index);
            }
            return result2;
          }
          function toPath(value) {
            if (isArray2(value)) {
              return arrayMap(value, toKey);
            }
            return isSymbol2(value) ? [value] : copyArray(stringToPath(toString2(value)));
          }
          function uniqueId(prefix) {
            var id = ++idCounter;
            return toString2(prefix) + id;
          }
          var add3 = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil = createRound("ceil");
          var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor2 = createRound("floor");
          function max(array) {
            return array && array.length ? baseExtremum(array, identity2, baseGt) : undefined2;
          }
          function maxBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
          }
          function mean(array) {
            return baseMean(array, identity2);
          }
          function meanBy(array, iteratee2) {
            return baseMean(array, getIteratee(iteratee2, 2));
          }
          function min(array) {
            return array && array.length ? baseExtremum(array, identity2, baseLt) : undefined2;
          }
          function minBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
          }
          var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round = createRound("round");
          var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum(array) {
            return array && array.length ? baseSum(array, identity2) : 0;
          }
          function sumBy(array, iteratee2) {
            return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
          }
          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign;
          lodash.assignIn = assignIn;
          lodash.assignInWith = assignInWith;
          lodash.assignWith = assignWith;
          lodash.at = at2;
          lodash.before = before;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.castArray = castArray;
          lodash.chain = chain;
          lodash.chunk = chunk2;
          lodash.compact = compact;
          lodash.concat = concat;
          lodash.cond = cond;
          lodash.conforms = conforms;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce2;
          lodash.defaults = defaults;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer2;
          lodash.delay = delay;
          lodash.difference = difference;
          lodash.differenceBy = differenceBy;
          lodash.differenceWith = differenceWith;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill;
          lodash.filter = filter;
          lodash.flatMap = flatMap;
          lodash.flatMapDeep = flatMapDeep;
          lodash.flatMapDepth = flatMapDepth;
          lodash.flatten = flatten;
          lodash.flattenDeep = flattenDeep;
          lodash.flattenDepth = flattenDepth;
          lodash.flip = flip;
          lodash.flow = flow;
          lodash.flowRight = flowRight;
          lodash.fromPairs = fromPairs;
          lodash.functions = functions;
          lodash.functionsIn = functionsIn;
          lodash.groupBy = groupBy;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.intersectionBy = intersectionBy;
          lodash.intersectionWith = intersectionWith;
          lodash.invert = invert;
          lodash.invertBy = invertBy;
          lodash.invokeMap = invokeMap;
          lodash.iteratee = iteratee;
          lodash.keyBy = keyBy;
          lodash.keys = keys2;
          lodash.keysIn = keysIn;
          lodash.map = map2;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues;
          lodash.matches = matches;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize;
          lodash.merge = merge;
          lodash.mergeWith = mergeWith;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate;
          lodash.nthArg = nthArg;
          lodash.omit = omit2;
          lodash.omitBy = omitBy;
          lodash.once = once;
          lodash.orderBy = orderBy;
          lodash.over = over;
          lodash.overArgs = overArgs;
          lodash.overEvery = overEvery;
          lodash.overSome = overSome;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick2;
          lodash.pickBy = pickBy;
          lodash.property = property;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAll = pullAll;
          lodash.pullAllBy = pullAllBy;
          lodash.pullAllWith = pullAllWith;
          lodash.pullAt = pullAt;
          lodash.range = range;
          lodash.rangeRight = rangeRight;
          lodash.rearg = rearg;
          lodash.reject = reject;
          lodash.remove = remove3;
          lodash.rest = rest;
          lodash.reverse = reverse;
          lodash.sampleSize = sampleSize;
          lodash.set = set2;
          lodash.setWith = setWith;
          lodash.shuffle = shuffle;
          lodash.slice = slice;
          lodash.sortBy = sortBy;
          lodash.sortedUniq = sortedUniq;
          lodash.sortedUniqBy = sortedUniqBy;
          lodash.split = split;
          lodash.spread = spread;
          lodash.tail = tail;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.thru = thru;
          lodash.toArray = toArray2;
          lodash.toPairs = toPairs;
          lodash.toPairsIn = toPairsIn;
          lodash.toPath = toPath;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform2;
          lodash.unary = unary;
          lodash.union = union;
          lodash.unionBy = unionBy;
          lodash.unionWith = unionWith;
          lodash.uniq = uniq;
          lodash.uniqBy = uniqBy;
          lodash.uniqWith = uniqWith;
          lodash.unset = unset;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.update = update;
          lodash.updateWith = updateWith;
          lodash.values = values;
          lodash.valuesIn = valuesIn;
          lodash.without = without;
          lodash.words = words;
          lodash.wrap = wrap;
          lodash.xor = xor;
          lodash.xorBy = xorBy;
          lodash.xorWith = xorWith;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
          lodash.zipObjectDeep = zipObjectDeep;
          lodash.zipWith = zipWith;
          lodash.entries = toPairs;
          lodash.entriesIn = toPairsIn;
          lodash.extend = assignIn;
          lodash.extendWith = assignInWith;
          mixin(lodash, lodash);
          lodash.add = add3;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize2;
          lodash.ceil = ceil;
          lodash.clamp = clamp3;
          lodash.clone = clone;
          lodash.cloneDeep = cloneDeep;
          lodash.cloneDeepWith = cloneDeepWith;
          lodash.cloneWith = cloneWith;
          lodash.conformsTo = conformsTo;
          lodash.deburr = deburr;
          lodash.defaultTo = defaultTo;
          lodash.divide = divide;
          lodash.endsWith = endsWith;
          lodash.eq = eq;
          lodash.escape = escape;
          lodash.escapeRegExp = escapeRegExp;
          lodash.every = every;
          lodash.find = find;
          lodash.findIndex = findIndex2;
          lodash.findKey = findKey2;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.floor = floor2;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.get = get;
          lodash.gt = gt2;
          lodash.gte = gte;
          lodash.has = has2;
          lodash.hasIn = hasIn;
          lodash.head = head;
          lodash.identity = identity2;
          lodash.includes = includes2;
          lodash.indexOf = indexOf;
          lodash.inRange = inRange;
          lodash.invoke = invoke;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray2;
          lodash.isArrayBuffer = isArrayBuffer;
          lodash.isArrayLike = isArrayLike;
          lodash.isArrayLikeObject = isArrayLikeObject;
          lodash.isBoolean = isBoolean2;
          lodash.isBuffer = isBuffer;
          lodash.isDate = isDate2;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty2;
          lodash.isEqual = isEqual3;
          lodash.isEqualWith = isEqualWith;
          lodash.isError = isError;
          lodash.isFinite = isFinite2;
          lodash.isFunction = isFunction2;
          lodash.isInteger = isInteger;
          lodash.isLength = isLength;
          lodash.isMap = isMap2;
          lodash.isMatch = isMatch;
          lodash.isMatchWith = isMatchWith;
          lodash.isNaN = isNaN2;
          lodash.isNative = isNative;
          lodash.isNil = isNil;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber;
          lodash.isObject = isObject4;
          lodash.isObjectLike = isObjectLike;
          lodash.isPlainObject = isPlainObject3;
          lodash.isRegExp = isRegExp2;
          lodash.isSafeInteger = isSafeInteger;
          lodash.isSet = isSet2;
          lodash.isString = isString2;
          lodash.isSymbol = isSymbol2;
          lodash.isTypedArray = isTypedArray;
          lodash.isUndefined = isUndefined;
          lodash.isWeakMap = isWeakMap;
          lodash.isWeakSet = isWeakSet;
          lodash.join = join;
          lodash.kebabCase = kebabCase;
          lodash.last = last;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lowerCase = lowerCase;
          lodash.lowerFirst = lowerFirst;
          lodash.lt = lt2;
          lodash.lte = lte;
          lodash.max = max;
          lodash.maxBy = maxBy;
          lodash.mean = mean;
          lodash.meanBy = meanBy;
          lodash.min = min;
          lodash.minBy = minBy;
          lodash.stubArray = stubArray;
          lodash.stubFalse = stubFalse;
          lodash.stubObject = stubObject;
          lodash.stubString = stubString;
          lodash.stubTrue = stubTrue;
          lodash.multiply = multiply;
          lodash.nth = nth;
          lodash.noConflict = noConflict;
          lodash.noop = noop3;
          lodash.now = now;
          lodash.pad = pad;
          lodash.padEnd = padEnd2;
          lodash.padStart = padStart2;
          lodash.parseInt = parseInt2;
          lodash.random = random;
          lodash.reduce = reduce2;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.replace = replace2;
          lodash.result = result;
          lodash.round = round;
          lodash.runInContext = runInContext2;
          lodash.sample = sample;
          lodash.size = size;
          lodash.snakeCase = snakeCase;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedIndexBy = sortedIndexBy;
          lodash.sortedIndexOf = sortedIndexOf;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.sortedLastIndexBy = sortedLastIndexBy;
          lodash.sortedLastIndexOf = sortedLastIndexOf;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.subtract = subtract;
          lodash.sum = sum;
          lodash.sumBy = sumBy;
          lodash.template = template;
          lodash.times = times;
          lodash.toFinite = toFinite;
          lodash.toInteger = toInteger;
          lodash.toLength = toLength;
          lodash.toLower = toLower;
          lodash.toNumber = toNumber2;
          lodash.toSafeInteger = toSafeInteger;
          lodash.toString = toString2;
          lodash.toUpper = toUpper;
          lodash.trim = trim;
          lodash.trimEnd = trimEnd;
          lodash.trimStart = trimStart;
          lodash.truncate = truncate;
          lodash.unescape = unescape;
          lodash.uniqueId = uniqueId;
          lodash.upperCase = upperCase;
          lodash.upperFirst = upperFirst;
          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.first = head;
          mixin(lodash, function() {
            var source = {};
            baseForOwn(lodash, function(func, methodName) {
              if (!hasOwnProperty3.call(lodash.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), { "chain": false });
          lodash.VERSION = VERSION;
          arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash[methodName].placeholder = lodash;
          });
          arrayEach(["drop", "take"], function(methodName, index) {
            LazyWrapper.prototype[methodName] = function(n) {
              n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
              var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
              if (result2.__filtered__) {
                result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
              } else {
                result2.__views__.push({
                  "size": nativeMin(n, MAX_ARRAY_LENGTH),
                  "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                });
              }
              return result2;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n) {
              return this.reverse()[methodName](n).reverse();
            };
          });
          arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
            var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee2) {
              var result2 = this.clone();
              result2.__iteratees__.push({
                "iteratee": getIteratee(iteratee2, 3),
                "type": type
              });
              result2.__filtered__ = result2.__filtered__ || isFilter;
              return result2;
            };
          });
          arrayEach(["head", "last"], function(methodName, index) {
            var takeName = "take" + (index ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach(["initial", "tail"], function(methodName, index) {
            var dropName = "drop" + (index ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity2);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
            if (typeof path == "function") {
              return new LazyWrapper(this);
            }
            return this.map(function(value) {
              return baseInvoke(value, path, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start, end) {
            start = toInteger(start);
            var result2 = this;
            if (result2.__filtered__ && (start > 0 || end < 0)) {
              return new LazyWrapper(result2);
            }
            if (start < 0) {
              result2 = result2.takeRight(-start);
            } else if (start) {
              result2 = result2.drop(start);
            }
            if (end !== undefined2) {
              end = toInteger(end);
              result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
            }
            return result2;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash.prototype[methodName] = function() {
              var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy2 = isLazy || isArray2(value);
              var interceptor = function(value2) {
                var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
                return isTaker && chainAll ? result3[0] : result3;
              };
              if (useLazy2 && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                isLazy = useLazy2 = false;
              }
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy2) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result2 = func.apply(value, args);
                result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                return new LodashWrapper(result2, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result2 = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
            };
          });
          arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto2[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray2(value) ? value : [], args);
              }
              return this[chainName](function(value2) {
                return func.apply(isArray2(value2) ? value2 : [], args);
              });
            };
          });
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              if (!hasOwnProperty3.call(realNames, key)) {
                realNames[key] = [];
              }
              realNames[key].push({ "name": methodName, "func": lodashFunc });
            }
          });
          realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined2
          }];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash.prototype.at = wrapperAt;
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.next = wrapperNext;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
          lodash.prototype.first = lodash.prototype.head;
          if (symIterator) {
            lodash.prototype[symIterator] = wrapperToIterator;
          }
          return lodash;
        };
        var _2 = runInContext();
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          root._ = _2;
          define(function() {
            return _2;
          });
        } else if (freeModule) {
          (freeModule.exports = _2)._ = _2;
          freeExports._ = _2;
        } else {
          root._ = _2;
        }
      }).call(exports);
    }
  });

  // ../posawesome/posawesome/public/js/toConsole.js
  $(function() {
    frappe.realtime.on("toconsole", function(data) {
      data.forEach((element) => {
        console.log(element);
      });
    });
  });

  // ../posawesome/node_modules/@vue/shared/dist/shared.esm-bundler.js
  function makeMap(str) {
    const map2 = /* @__PURE__ */ Object.create(null);
    for (const key of str.split(","))
      map2[key] = 1;
    return (val) => val in map2;
  }
  var EMPTY_OBJ = true ? Object.freeze({}) : {};
  var EMPTY_ARR = true ? Object.freeze([]) : [];
  var NOOP = () => {
  };
  var NO = () => false;
  var isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
  var isModelListener = (key) => key.startsWith("onUpdate:");
  var extend = Object.assign;
  var remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
      arr.splice(i, 1);
    }
  };
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var hasOwn = (val, key) => hasOwnProperty.call(val, key);
  var isArray = Array.isArray;
  var isMap = (val) => toTypeString(val) === "[object Map]";
  var isSet = (val) => toTypeString(val) === "[object Set]";
  var isFunction = (val) => typeof val === "function";
  var isString = (val) => typeof val === "string";
  var isSymbol = (val) => typeof val === "symbol";
  var isObject = (val) => val !== null && typeof val === "object";
  var isPromise = (val) => {
    return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
  };
  var objectToString = Object.prototype.toString;
  var toTypeString = (value) => objectToString.call(value);
  var toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  var isPlainObject = (val) => toTypeString(val) === "[object Object]";
  var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  var isReservedProp = /* @__PURE__ */ makeMap(
    ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
  );
  var isBuiltInDirective = /* @__PURE__ */ makeMap(
    "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
  );
  var cacheStringFunction = (fn2) => {
    const cache = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn2(str));
    };
  };
  var camelizeRE = /-(\w)/g;
  var camelize = cacheStringFunction(
    (str) => {
      return str.replace(camelizeRE, (_2, c) => c ? c.toUpperCase() : "");
    }
  );
  var hyphenateRE = /\B([A-Z])/g;
  var hyphenate = cacheStringFunction(
    (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
  );
  var capitalize = cacheStringFunction((str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });
  var toHandlerKey = cacheStringFunction(
    (str) => {
      const s = str ? `on${capitalize(str)}` : ``;
      return s;
    }
  );
  var hasChanged = (value, oldValue) => !Object.is(value, oldValue);
  var invokeArrayFns = (fns, ...arg) => {
    for (let i = 0; i < fns.length; i++) {
      fns[i](...arg);
    }
  };
  var def = (obj, key, value, writable = false) => {
    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: false,
      writable,
      value
    });
  };
  var looseToNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
  };
  var toNumber = (val) => {
    const n = isString(val) ? Number(val) : NaN;
    return isNaN(n) ? val : n;
  };
  var _globalThis;
  var getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
  function normalizeStyle(value) {
    if (isArray(value)) {
      const res = {};
      for (let i = 0; i < value.length; i++) {
        const item = value[i];
        const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
        if (normalized) {
          for (const key in normalized) {
            res[key] = normalized[key];
          }
        }
      }
      return res;
    } else if (isString(value) || isObject(value)) {
      return value;
    }
  }
  var listDelimiterRE = /;(?![^(]*\))/g;
  var propertyDelimiterRE = /:([^]+)/;
  var styleCommentRE = /\/\*[^]*?\*\//g;
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function normalizeClass(value) {
    let res = "";
    if (isString(value)) {
      res = value;
    } else if (isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        const normalized = normalizeClass(value[i]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject(value)) {
      for (const name in value) {
        if (value[name]) {
          res += name + " ";
        }
      }
    }
    return res.trim();
  }
  function normalizeProps(props) {
    if (!props)
      return null;
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (style) {
      props.style = normalizeStyle(style);
    }
    return props;
  }
  var HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
  var SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
  var MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
  var isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
  var isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
  var isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
  var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  var isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
  var isBooleanAttr = /* @__PURE__ */ makeMap(
    specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`
  );
  function includeBooleanAttr(value) {
    return !!value || value === "";
  }
  var isRef = (val) => {
    return !!(val && val["__v_isRef"] === true);
  };
  var toDisplayString = (val) => {
    return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
  };
  var replacer = (_key, val) => {
    if (isRef(val)) {
      return replacer(_key, val.value);
    } else if (isMap(val)) {
      return {
        [`Map(${val.size})`]: [...val.entries()].reduce(
          (entries, [key, val2], i) => {
            entries[stringifySymbol(key, i) + " =>"] = val2;
            return entries;
          },
          {}
        )
      };
    } else if (isSet(val)) {
      return {
        [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
      };
    } else if (isSymbol(val)) {
      return stringifySymbol(val);
    } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
      return String(val);
    }
    return val;
  };
  var stringifySymbol = (v, i = "") => {
    var _a3;
    return isSymbol(v) ? `Symbol(${(_a3 = v.description) != null ? _a3 : i})` : v;
  };

  // ../posawesome/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js
  function warn(msg, ...args) {
    console.warn(`[Vue warn] ${msg}`, ...args);
  }
  var activeEffectScope;
  var EffectScope = class {
    constructor(detached = false) {
      this.detached = detached;
      this._active = true;
      this._on = 0;
      this.effects = [];
      this.cleanups = [];
      this._isPaused = false;
      this.parent = activeEffectScope;
      if (!detached && activeEffectScope) {
        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
          this
        ) - 1;
      }
    }
    get active() {
      return this._active;
    }
    pause() {
      if (this._active) {
        this._isPaused = true;
        let i, l;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].pause();
          }
        }
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].pause();
        }
      }
    }
    resume() {
      if (this._active) {
        if (this._isPaused) {
          this._isPaused = false;
          let i, l;
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].resume();
            }
          }
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].resume();
          }
        }
      }
    }
    run(fn2) {
      if (this._active) {
        const currentEffectScope = activeEffectScope;
        try {
          activeEffectScope = this;
          return fn2();
        } finally {
          activeEffectScope = currentEffectScope;
        }
      } else if (true) {
        warn(`cannot run an inactive effect scope.`);
      }
    }
    on() {
      if (++this._on === 1) {
        this.prevScope = activeEffectScope;
        activeEffectScope = this;
      }
    }
    off() {
      if (this._on > 0 && --this._on === 0) {
        activeEffectScope = this.prevScope;
        this.prevScope = void 0;
      }
    }
    stop(fromParent) {
      if (this._active) {
        this._active = false;
        let i, l;
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].stop();
        }
        this.effects.length = 0;
        for (i = 0, l = this.cleanups.length; i < l; i++) {
          this.cleanups[i]();
        }
        this.cleanups.length = 0;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].stop(true);
          }
          this.scopes.length = 0;
        }
        if (!this.detached && this.parent && !fromParent) {
          const last = this.parent.scopes.pop();
          if (last && last !== this) {
            this.parent.scopes[this.index] = last;
            last.index = this.index;
          }
        }
        this.parent = void 0;
      }
    }
  };
  function effectScope(detached) {
    return new EffectScope(detached);
  }
  function getCurrentScope() {
    return activeEffectScope;
  }
  function onScopeDispose(fn2, failSilently = false) {
    if (activeEffectScope) {
      activeEffectScope.cleanups.push(fn2);
    } else if (!failSilently) {
      warn(
        `onScopeDispose() is called when there is no active effect scope to be associated with.`
      );
    }
  }
  var activeSub;
  var pausedQueueEffects = /* @__PURE__ */ new WeakSet();
  var ReactiveEffect = class {
    constructor(fn2) {
      this.fn = fn2;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 1 | 4;
      this.next = void 0;
      this.cleanup = void 0;
      this.scheduler = void 0;
      if (activeEffectScope && activeEffectScope.active) {
        activeEffectScope.effects.push(this);
      }
    }
    pause() {
      this.flags |= 64;
    }
    resume() {
      if (this.flags & 64) {
        this.flags &= -65;
        if (pausedQueueEffects.has(this)) {
          pausedQueueEffects.delete(this);
          this.trigger();
        }
      }
    }
    notify() {
      if (this.flags & 2 && !(this.flags & 32)) {
        return;
      }
      if (!(this.flags & 8)) {
        batch(this);
      }
    }
    run() {
      if (!(this.flags & 1)) {
        return this.fn();
      }
      this.flags |= 2;
      cleanupEffect(this);
      prepareDeps(this);
      const prevEffect = activeSub;
      const prevShouldTrack = shouldTrack;
      activeSub = this;
      shouldTrack = true;
      try {
        return this.fn();
      } finally {
        if (activeSub !== this) {
          warn(
            "Active effect was not restored correctly - this is likely a Vue internal bug."
          );
        }
        cleanupDeps(this);
        activeSub = prevEffect;
        shouldTrack = prevShouldTrack;
        this.flags &= -3;
      }
    }
    stop() {
      if (this.flags & 1) {
        for (let link = this.deps; link; link = link.nextDep) {
          removeSub(link);
        }
        this.deps = this.depsTail = void 0;
        cleanupEffect(this);
        this.onStop && this.onStop();
        this.flags &= -2;
      }
    }
    trigger() {
      if (this.flags & 64) {
        pausedQueueEffects.add(this);
      } else if (this.scheduler) {
        this.scheduler();
      } else {
        this.runIfDirty();
      }
    }
    runIfDirty() {
      if (isDirty(this)) {
        this.run();
      }
    }
    get dirty() {
      return isDirty(this);
    }
  };
  var batchDepth = 0;
  var batchedSub;
  var batchedComputed;
  function batch(sub2, isComputed = false) {
    sub2.flags |= 8;
    if (isComputed) {
      sub2.next = batchedComputed;
      batchedComputed = sub2;
      return;
    }
    sub2.next = batchedSub;
    batchedSub = sub2;
  }
  function startBatch() {
    batchDepth++;
  }
  function endBatch() {
    if (--batchDepth > 0) {
      return;
    }
    if (batchedComputed) {
      let e = batchedComputed;
      batchedComputed = void 0;
      while (e) {
        const next = e.next;
        e.next = void 0;
        e.flags &= -9;
        e = next;
      }
    }
    let error;
    while (batchedSub) {
      let e = batchedSub;
      batchedSub = void 0;
      while (e) {
        const next = e.next;
        e.next = void 0;
        e.flags &= -9;
        if (e.flags & 1) {
          try {
            ;
            e.trigger();
          } catch (err) {
            if (!error)
              error = err;
          }
        }
        e = next;
      }
    }
    if (error)
      throw error;
  }
  function prepareDeps(sub2) {
    for (let link = sub2.deps; link; link = link.nextDep) {
      link.version = -1;
      link.prevActiveLink = link.dep.activeLink;
      link.dep.activeLink = link;
    }
  }
  function cleanupDeps(sub2) {
    let head;
    let tail = sub2.depsTail;
    let link = tail;
    while (link) {
      const prev = link.prevDep;
      if (link.version === -1) {
        if (link === tail)
          tail = prev;
        removeSub(link);
        removeDep(link);
      } else {
        head = link;
      }
      link.dep.activeLink = link.prevActiveLink;
      link.prevActiveLink = void 0;
      link = prev;
    }
    sub2.deps = head;
    sub2.depsTail = tail;
  }
  function isDirty(sub2) {
    for (let link = sub2.deps; link; link = link.nextDep) {
      if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
        return true;
      }
    }
    if (sub2._dirty) {
      return true;
    }
    return false;
  }
  function refreshComputed(computed3) {
    if (computed3.flags & 4 && !(computed3.flags & 16)) {
      return;
    }
    computed3.flags &= -17;
    if (computed3.globalVersion === globalVersion) {
      return;
    }
    computed3.globalVersion = globalVersion;
    if (!computed3.isSSR && computed3.flags & 128 && (!computed3.deps && !computed3._dirty || !isDirty(computed3))) {
      return;
    }
    computed3.flags |= 2;
    const dep = computed3.dep;
    const prevSub = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = computed3;
    shouldTrack = true;
    try {
      prepareDeps(computed3);
      const value = computed3.fn(computed3._value);
      if (dep.version === 0 || hasChanged(value, computed3._value)) {
        computed3.flags |= 128;
        computed3._value = value;
        dep.version++;
      }
    } catch (err) {
      dep.version++;
      throw err;
    } finally {
      activeSub = prevSub;
      shouldTrack = prevShouldTrack;
      cleanupDeps(computed3);
      computed3.flags &= -3;
    }
  }
  function removeSub(link, soft = false) {
    const { dep, prevSub, nextSub } = link;
    if (prevSub) {
      prevSub.nextSub = nextSub;
      link.prevSub = void 0;
    }
    if (nextSub) {
      nextSub.prevSub = prevSub;
      link.nextSub = void 0;
    }
    if (dep.subsHead === link) {
      dep.subsHead = nextSub;
    }
    if (dep.subs === link) {
      dep.subs = prevSub;
      if (!prevSub && dep.computed) {
        dep.computed.flags &= -5;
        for (let l = dep.computed.deps; l; l = l.nextDep) {
          removeSub(l, true);
        }
      }
    }
    if (!soft && !--dep.sc && dep.map) {
      dep.map.delete(dep.key);
    }
  }
  function removeDep(link) {
    const { prevDep, nextDep } = link;
    if (prevDep) {
      prevDep.nextDep = nextDep;
      link.prevDep = void 0;
    }
    if (nextDep) {
      nextDep.prevDep = prevDep;
      link.nextDep = void 0;
    }
  }
  var shouldTrack = true;
  var trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function cleanupEffect(e) {
    const { cleanup } = e;
    e.cleanup = void 0;
    if (cleanup) {
      const prevSub = activeSub;
      activeSub = void 0;
      try {
        cleanup();
      } finally {
        activeSub = prevSub;
      }
    }
  }
  var globalVersion = 0;
  var Link = class {
    constructor(sub2, dep) {
      this.sub = sub2;
      this.dep = dep;
      this.version = dep.version;
      this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
    }
  };
  var Dep = class {
    constructor(computed3) {
      this.computed = computed3;
      this.version = 0;
      this.activeLink = void 0;
      this.subs = void 0;
      this.map = void 0;
      this.key = void 0;
      this.sc = 0;
      this.__v_skip = true;
      if (true) {
        this.subsHead = void 0;
      }
    }
    track(debugInfo) {
      if (!activeSub || !shouldTrack || activeSub === this.computed) {
        return;
      }
      let link = this.activeLink;
      if (link === void 0 || link.sub !== activeSub) {
        link = this.activeLink = new Link(activeSub, this);
        if (!activeSub.deps) {
          activeSub.deps = activeSub.depsTail = link;
        } else {
          link.prevDep = activeSub.depsTail;
          activeSub.depsTail.nextDep = link;
          activeSub.depsTail = link;
        }
        addSub(link);
      } else if (link.version === -1) {
        link.version = this.version;
        if (link.nextDep) {
          const next = link.nextDep;
          next.prevDep = link.prevDep;
          if (link.prevDep) {
            link.prevDep.nextDep = next;
          }
          link.prevDep = activeSub.depsTail;
          link.nextDep = void 0;
          activeSub.depsTail.nextDep = link;
          activeSub.depsTail = link;
          if (activeSub.deps === link) {
            activeSub.deps = next;
          }
        }
      }
      if (activeSub.onTrack) {
        activeSub.onTrack(
          extend(
            {
              effect: activeSub
            },
            debugInfo
          )
        );
      }
      return link;
    }
    trigger(debugInfo) {
      this.version++;
      globalVersion++;
      this.notify(debugInfo);
    }
    notify(debugInfo) {
      startBatch();
      try {
        if (true) {
          for (let head = this.subsHead; head; head = head.nextSub) {
            if (head.sub.onTrigger && !(head.sub.flags & 8)) {
              head.sub.onTrigger(
                extend(
                  {
                    effect: head.sub
                  },
                  debugInfo
                )
              );
            }
          }
        }
        for (let link = this.subs; link; link = link.prevSub) {
          if (link.sub.notify()) {
            ;
            link.sub.dep.notify();
          }
        }
      } finally {
        endBatch();
      }
    }
  };
  function addSub(link) {
    link.dep.sc++;
    if (link.sub.flags & 4) {
      const computed3 = link.dep.computed;
      if (computed3 && !link.dep.subs) {
        computed3.flags |= 4 | 16;
        for (let l = computed3.deps; l; l = l.nextDep) {
          addSub(l);
        }
      }
      const currentTail = link.dep.subs;
      if (currentTail !== link) {
        link.prevSub = currentTail;
        if (currentTail)
          currentTail.nextSub = link;
      }
      if (link.dep.subsHead === void 0) {
        link.dep.subsHead = link;
      }
      link.dep.subs = link;
    }
  }
  var targetMap = /* @__PURE__ */ new WeakMap();
  var ITERATE_KEY = Symbol(
    true ? "Object iterate" : ""
  );
  var MAP_KEY_ITERATE_KEY = Symbol(
    true ? "Map keys iterate" : ""
  );
  var ARRAY_ITERATE_KEY = Symbol(
    true ? "Array iterate" : ""
  );
  function track(target, type, key) {
    if (shouldTrack && activeSub) {
      let depsMap = targetMap.get(target);
      if (!depsMap) {
        targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
      }
      let dep = depsMap.get(key);
      if (!dep) {
        depsMap.set(key, dep = new Dep());
        dep.map = depsMap;
        dep.key = key;
      }
      if (true) {
        dep.track({
          target,
          type,
          key
        });
      } else {
        dep.track();
      }
    }
  }
  function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      globalVersion++;
      return;
    }
    const run2 = (dep) => {
      if (dep) {
        if (true) {
          dep.trigger({
            target,
            type,
            key,
            newValue,
            oldValue,
            oldTarget
          });
        } else {
          dep.trigger();
        }
      }
    };
    startBatch();
    if (type === "clear") {
      depsMap.forEach(run2);
    } else {
      const targetIsArray = isArray(target);
      const isArrayIndex = targetIsArray && isIntegerKey(key);
      if (targetIsArray && key === "length") {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
            run2(dep);
          }
        });
      } else {
        if (key !== void 0 || depsMap.has(void 0)) {
          run2(depsMap.get(key));
        }
        if (isArrayIndex) {
          run2(depsMap.get(ARRAY_ITERATE_KEY));
        }
        switch (type) {
          case "add":
            if (!targetIsArray) {
              run2(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                run2(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isArrayIndex) {
              run2(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!targetIsArray) {
              run2(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                run2(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap(target)) {
              run2(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
    }
    endBatch();
  }
  function getDepFromReactive(object, key) {
    const depMap = targetMap.get(object);
    return depMap && depMap.get(key);
  }
  function reactiveReadArray(array) {
    const raw = toRaw(array);
    if (raw === array)
      return raw;
    track(raw, "iterate", ARRAY_ITERATE_KEY);
    return isShallow(array) ? raw : raw.map(toReactive);
  }
  function shallowReadArray(arr) {
    track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
    return arr;
  }
  var arrayInstrumentations = {
    __proto__: null,
    [Symbol.iterator]() {
      return iterator(this, Symbol.iterator, toReactive);
    },
    concat(...args) {
      return reactiveReadArray(this).concat(
        ...args.map((x) => isArray(x) ? reactiveReadArray(x) : x)
      );
    },
    entries() {
      return iterator(this, "entries", (value) => {
        value[1] = toReactive(value[1]);
        return value;
      });
    },
    every(fn2, thisArg) {
      return apply(this, "every", fn2, thisArg, void 0, arguments);
    },
    filter(fn2, thisArg) {
      return apply(this, "filter", fn2, thisArg, (v) => v.map(toReactive), arguments);
    },
    find(fn2, thisArg) {
      return apply(this, "find", fn2, thisArg, toReactive, arguments);
    },
    findIndex(fn2, thisArg) {
      return apply(this, "findIndex", fn2, thisArg, void 0, arguments);
    },
    findLast(fn2, thisArg) {
      return apply(this, "findLast", fn2, thisArg, toReactive, arguments);
    },
    findLastIndex(fn2, thisArg) {
      return apply(this, "findLastIndex", fn2, thisArg, void 0, arguments);
    },
    forEach(fn2, thisArg) {
      return apply(this, "forEach", fn2, thisArg, void 0, arguments);
    },
    includes(...args) {
      return searchProxy(this, "includes", args);
    },
    indexOf(...args) {
      return searchProxy(this, "indexOf", args);
    },
    join(separator) {
      return reactiveReadArray(this).join(separator);
    },
    lastIndexOf(...args) {
      return searchProxy(this, "lastIndexOf", args);
    },
    map(fn2, thisArg) {
      return apply(this, "map", fn2, thisArg, void 0, arguments);
    },
    pop() {
      return noTracking(this, "pop");
    },
    push(...args) {
      return noTracking(this, "push", args);
    },
    reduce(fn2, ...args) {
      return reduce(this, "reduce", fn2, args);
    },
    reduceRight(fn2, ...args) {
      return reduce(this, "reduceRight", fn2, args);
    },
    shift() {
      return noTracking(this, "shift");
    },
    some(fn2, thisArg) {
      return apply(this, "some", fn2, thisArg, void 0, arguments);
    },
    splice(...args) {
      return noTracking(this, "splice", args);
    },
    toReversed() {
      return reactiveReadArray(this).toReversed();
    },
    toSorted(comparer) {
      return reactiveReadArray(this).toSorted(comparer);
    },
    toSpliced(...args) {
      return reactiveReadArray(this).toSpliced(...args);
    },
    unshift(...args) {
      return noTracking(this, "unshift", args);
    },
    values() {
      return iterator(this, "values", toReactive);
    }
  };
  function iterator(self2, method, wrapValue) {
    const arr = shallowReadArray(self2);
    const iter = arr[method]();
    if (arr !== self2 && !isShallow(self2)) {
      iter._next = iter.next;
      iter.next = () => {
        const result = iter._next();
        if (result.value) {
          result.value = wrapValue(result.value);
        }
        return result;
      };
    }
    return iter;
  }
  var arrayProto = Array.prototype;
  function apply(self2, method, fn2, thisArg, wrappedRetFn, args) {
    const arr = shallowReadArray(self2);
    const needsWrap = arr !== self2 && !isShallow(self2);
    const methodFn = arr[method];
    if (methodFn !== arrayProto[method]) {
      const result2 = methodFn.apply(self2, args);
      return needsWrap ? toReactive(result2) : result2;
    }
    let wrappedFn = fn2;
    if (arr !== self2) {
      if (needsWrap) {
        wrappedFn = function(item, index) {
          return fn2.call(this, toReactive(item), index, self2);
        };
      } else if (fn2.length > 2) {
        wrappedFn = function(item, index) {
          return fn2.call(this, item, index, self2);
        };
      }
    }
    const result = methodFn.call(arr, wrappedFn, thisArg);
    return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
  }
  function reduce(self2, method, fn2, args) {
    const arr = shallowReadArray(self2);
    let wrappedFn = fn2;
    if (arr !== self2) {
      if (!isShallow(self2)) {
        wrappedFn = function(acc, item, index) {
          return fn2.call(this, acc, toReactive(item), index, self2);
        };
      } else if (fn2.length > 3) {
        wrappedFn = function(acc, item, index) {
          return fn2.call(this, acc, item, index, self2);
        };
      }
    }
    return arr[method](wrappedFn, ...args);
  }
  function searchProxy(self2, method, args) {
    const arr = toRaw(self2);
    track(arr, "iterate", ARRAY_ITERATE_KEY);
    const res = arr[method](...args);
    if ((res === -1 || res === false) && isProxy(args[0])) {
      args[0] = toRaw(args[0]);
      return arr[method](...args);
    }
    return res;
  }
  function noTracking(self2, method, args = []) {
    pauseTracking();
    startBatch();
    const res = toRaw(self2)[method].apply(self2, args);
    endBatch();
    resetTracking();
    return res;
  }
  var isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  var builtInSymbols = new Set(
    /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
  );
  function hasOwnProperty2(key) {
    if (!isSymbol(key))
      key = String(key);
    const obj = toRaw(this);
    track(obj, "has", key);
    return obj.hasOwnProperty(key);
  }
  var BaseReactiveHandler = class {
    constructor(_isReadonly = false, _isShallow = false) {
      this._isReadonly = _isReadonly;
      this._isShallow = _isShallow;
    }
    get(target, key, receiver) {
      if (key === "__v_skip")
        return target["__v_skip"];
      const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_isShallow") {
        return isShallow2;
      } else if (key === "__v_raw") {
        if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
          return target;
        }
        return;
      }
      const targetIsArray = isArray(target);
      if (!isReadonly2) {
        let fn2;
        if (targetIsArray && (fn2 = arrayInstrumentations[key])) {
          return fn2;
        }
        if (key === "hasOwnProperty") {
          return hasOwnProperty2;
        }
      }
      const res = Reflect.get(
        target,
        key,
        isRef2(target) ? target : receiver
      );
      if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly2) {
        track(target, "get", key);
      }
      if (isShallow2) {
        return res;
      }
      if (isRef2(res)) {
        return targetIsArray && isIntegerKey(key) ? res : res.value;
      }
      if (isObject(res)) {
        return isReadonly2 ? readonly(res) : reactive(res);
      }
      return res;
    }
  };
  var MutableReactiveHandler = class extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(false, isShallow2);
    }
    set(target, key, value, receiver) {
      let oldValue = target[key];
      if (!this._isShallow) {
        const isOldValueReadonly = isReadonly(oldValue);
        if (!isShallow(value) && !isReadonly(value)) {
          oldValue = toRaw(oldValue);
          value = toRaw(value);
        }
        if (!isArray(target) && isRef2(oldValue) && !isRef2(value)) {
          if (isOldValueReadonly) {
            return false;
          } else {
            oldValue.value = value;
            return true;
          }
        }
      }
      const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
      const result = Reflect.set(
        target,
        key,
        value,
        isRef2(target) ? target : receiver
      );
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
      }
      return result;
    }
    deleteProperty(target, key) {
      const hadKey = hasOwn(target, key);
      const oldValue = target[key];
      const result = Reflect.deleteProperty(target, key);
      if (result && hadKey) {
        trigger(target, "delete", key, void 0, oldValue);
      }
      return result;
    }
    has(target, key) {
      const result = Reflect.has(target, key);
      if (!isSymbol(key) || !builtInSymbols.has(key)) {
        track(target, "has", key);
      }
      return result;
    }
    ownKeys(target) {
      track(
        target,
        "iterate",
        isArray(target) ? "length" : ITERATE_KEY
      );
      return Reflect.ownKeys(target);
    }
  };
  var ReadonlyReactiveHandler = class extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(true, isShallow2);
    }
    set(target, key) {
      if (true) {
        warn(
          `Set operation on key "${String(key)}" failed: target is readonly.`,
          target
        );
      }
      return true;
    }
    deleteProperty(target, key) {
      if (true) {
        warn(
          `Delete operation on key "${String(key)}" failed: target is readonly.`,
          target
        );
      }
      return true;
    }
  };
  var mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
  var readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
  var shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
  var shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
  var toShallow = (value) => value;
  var getProto = (v) => Reflect.getPrototypeOf(v);
  function createIterableMethod(method, isReadonly2, isShallow2) {
    return function(...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(
        rawTarget,
        "iterate",
        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
      );
      return {
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type) {
    return function(...args) {
      if (true) {
        const key = args[0] ? `on key "${args[0]}" ` : ``;
        warn(
          `${capitalize(type)} operation ${key}failed: target is readonly.`,
          toRaw(this)
        );
      }
      return type === "delete" ? false : type === "clear" ? void 0 : this;
    };
  }
  function createInstrumentations(readonly2, shallow) {
    const instrumentations = {
      get(key) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!readonly2) {
          if (hasChanged(key, rawKey)) {
            track(rawTarget, "get", key);
          }
          track(rawTarget, "get", rawKey);
        }
        const { has: has2 } = getProto(rawTarget);
        const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
        if (has2.call(rawTarget, key)) {
          return wrap(target.get(key));
        } else if (has2.call(rawTarget, rawKey)) {
          return wrap(target.get(rawKey));
        } else if (target !== rawTarget) {
          target.get(key);
        }
      },
      get size() {
        const target = this["__v_raw"];
        !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
        return Reflect.get(target, "size", target);
      },
      has(key) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!readonly2) {
          if (hasChanged(key, rawKey)) {
            track(rawTarget, "has", key);
          }
          track(rawTarget, "has", rawKey);
        }
        return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
      },
      forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
        !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key) => {
          return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
      }
    };
    extend(
      instrumentations,
      readonly2 ? {
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear")
      } : {
        add(value) {
          if (!shallow && !isShallow(value) && !isReadonly(value)) {
            value = toRaw(value);
          }
          const target = toRaw(this);
          const proto = getProto(target);
          const hadKey = proto.has.call(target, value);
          if (!hadKey) {
            target.add(value);
            trigger(target, "add", value, value);
          }
          return this;
        },
        set(key, value) {
          if (!shallow && !isShallow(value) && !isReadonly(value)) {
            value = toRaw(value);
          }
          const target = toRaw(this);
          const { has: has2, get } = getProto(target);
          let hadKey = has2.call(target, key);
          if (!hadKey) {
            key = toRaw(key);
            hadKey = has2.call(target, key);
          } else if (true) {
            checkIdentityKeys(target, has2, key);
          }
          const oldValue = get.call(target, key);
          target.set(key, value);
          if (!hadKey) {
            trigger(target, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger(target, "set", key, value, oldValue);
          }
          return this;
        },
        delete(key) {
          const target = toRaw(this);
          const { has: has2, get } = getProto(target);
          let hadKey = has2.call(target, key);
          if (!hadKey) {
            key = toRaw(key);
            hadKey = has2.call(target, key);
          } else if (true) {
            checkIdentityKeys(target, has2, key);
          }
          const oldValue = get ? get.call(target, key) : void 0;
          const result = target.delete(key);
          if (hadKey) {
            trigger(target, "delete", key, void 0, oldValue);
          }
          return result;
        },
        clear() {
          const target = toRaw(this);
          const hadItems = target.size !== 0;
          const oldTarget = true ? isMap(target) ? new Map(target) : new Set(target) : void 0;
          const result = target.clear();
          if (hadItems) {
            trigger(
              target,
              "clear",
              void 0,
              void 0,
              oldTarget
            );
          }
          return result;
        }
      }
    );
    const iteratorMethods = [
      "keys",
      "values",
      "entries",
      Symbol.iterator
    ];
    iteratorMethods.forEach((method) => {
      instrumentations[method] = createIterableMethod(method, readonly2, shallow);
    });
    return instrumentations;
  }
  function createInstrumentationGetter(isReadonly2, shallow) {
    const instrumentations = createInstrumentations(isReadonly2, shallow);
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(
        hasOwn(instrumentations, key) && key in target ? instrumentations : target,
        key,
        receiver
      );
    };
  }
  var mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
  };
  var shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
  };
  var readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
  };
  var shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, true)
  };
  function checkIdentityKeys(target, has2, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has2.call(target, rawKey)) {
      const type = toRawType(target);
      warn(
        `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
      );
    }
  }
  var reactiveMap = /* @__PURE__ */ new WeakMap();
  var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  var readonlyMap = /* @__PURE__ */ new WeakMap();
  var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive(target) {
    if (isReadonly(target)) {
      return target;
    }
    return createReactiveObject(
      target,
      false,
      mutableHandlers,
      mutableCollectionHandlers,
      reactiveMap
    );
  }
  function shallowReactive(target) {
    return createReactiveObject(
      target,
      false,
      shallowReactiveHandlers,
      shallowCollectionHandlers,
      shallowReactiveMap
    );
  }
  function readonly(target) {
    return createReactiveObject(
      target,
      true,
      readonlyHandlers,
      readonlyCollectionHandlers,
      readonlyMap
    );
  }
  function shallowReadonly(target) {
    return createReactiveObject(
      target,
      true,
      shallowReadonlyHandlers,
      shallowReadonlyCollectionHandlers,
      shallowReadonlyMap
    );
  }
  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject(target)) {
      if (true) {
        warn(
          `value cannot be made ${isReadonly2 ? "readonly" : "reactive"}: ${String(
            target
          )}`
        );
      }
      return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
      return target;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const proxy = new Proxy(
      target,
      targetType === 2 ? collectionHandlers : baseHandlers
    );
    proxyMap.set(target, proxy);
    return proxy;
  }
  function isReactive(value) {
    if (isReadonly(value)) {
      return isReactive(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
  }
  function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
  }
  function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
  }
  function isProxy(value) {
    return value ? !!value["__v_raw"] : false;
  }
  function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
  }
  function markRaw(value) {
    if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
      def(value, "__v_skip", true);
    }
    return value;
  }
  var toReactive = (value) => isObject(value) ? reactive(value) : value;
  var toReadonly = (value) => isObject(value) ? readonly(value) : value;
  function isRef2(r) {
    return r ? r["__v_isRef"] === true : false;
  }
  function ref(value) {
    return createRef(value, false);
  }
  function shallowRef(value) {
    return createRef(value, true);
  }
  function createRef(rawValue, shallow) {
    if (isRef2(rawValue)) {
      return rawValue;
    }
    return new RefImpl(rawValue, shallow);
  }
  var RefImpl = class {
    constructor(value, isShallow2) {
      this.dep = new Dep();
      this["__v_isRef"] = true;
      this["__v_isShallow"] = false;
      this._rawValue = isShallow2 ? value : toRaw(value);
      this._value = isShallow2 ? value : toReactive(value);
      this["__v_isShallow"] = isShallow2;
    }
    get value() {
      if (true) {
        this.dep.track({
          target: this,
          type: "get",
          key: "value"
        });
      } else {
        this.dep.track();
      }
      return this._value;
    }
    set value(newValue) {
      const oldValue = this._rawValue;
      const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
      newValue = useDirectValue ? newValue : toRaw(newValue);
      if (hasChanged(newValue, oldValue)) {
        this._rawValue = newValue;
        this._value = useDirectValue ? newValue : toReactive(newValue);
        if (true) {
          this.dep.trigger({
            target: this,
            type: "set",
            key: "value",
            newValue,
            oldValue
          });
        } else {
          this.dep.trigger();
        }
      }
    }
  };
  function unref(ref2) {
    return isRef2(ref2) ? ref2.value : ref2;
  }
  function toValue(source) {
    return isFunction(source) ? source() : unref(source);
  }
  var shallowUnwrapHandlers = {
    get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
      const oldValue = target[key];
      if (isRef2(oldValue) && !isRef2(value)) {
        oldValue.value = value;
        return true;
      } else {
        return Reflect.set(target, key, value, receiver);
      }
    }
  };
  function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  var CustomRefImpl = class {
    constructor(factory) {
      this["__v_isRef"] = true;
      this._value = void 0;
      const dep = this.dep = new Dep();
      const { get, set: set2 } = factory(dep.track.bind(dep), dep.trigger.bind(dep));
      this._get = get;
      this._set = set2;
    }
    get value() {
      return this._value = this._get();
    }
    set value(newVal) {
      this._set(newVal);
    }
  };
  function customRef(factory) {
    return new CustomRefImpl(factory);
  }
  function toRefs(object) {
    if (!isProxy(object)) {
      warn(`toRefs() expects a reactive object but received a plain one.`);
    }
    const ret = isArray(object) ? new Array(object.length) : {};
    for (const key in object) {
      ret[key] = propertyToRef(object, key);
    }
    return ret;
  }
  var ObjectRefImpl = class {
    constructor(_object, _key, _defaultValue) {
      this._object = _object;
      this._key = _key;
      this._defaultValue = _defaultValue;
      this["__v_isRef"] = true;
      this._value = void 0;
    }
    get value() {
      const val = this._object[this._key];
      return this._value = val === void 0 ? this._defaultValue : val;
    }
    set value(newVal) {
      this._object[this._key] = newVal;
    }
    get dep() {
      return getDepFromReactive(toRaw(this._object), this._key);
    }
  };
  var GetterRefImpl = class {
    constructor(_getter) {
      this._getter = _getter;
      this["__v_isRef"] = true;
      this["__v_isReadonly"] = true;
      this._value = void 0;
    }
    get value() {
      return this._value = this._getter();
    }
  };
  function toRef(source, key, defaultValue) {
    if (isRef2(source)) {
      return source;
    } else if (isFunction(source)) {
      return new GetterRefImpl(source);
    } else if (isObject(source) && arguments.length > 1) {
      return propertyToRef(source, key, defaultValue);
    } else {
      return ref(source);
    }
  }
  function propertyToRef(source, key, defaultValue) {
    const val = source[key];
    return isRef2(val) ? val : new ObjectRefImpl(source, key, defaultValue);
  }
  var ComputedRefImpl = class {
    constructor(fn2, setter, isSSR) {
      this.fn = fn2;
      this.setter = setter;
      this._value = void 0;
      this.dep = new Dep(this);
      this.__v_isRef = true;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 16;
      this.globalVersion = globalVersion - 1;
      this.next = void 0;
      this.effect = this;
      this["__v_isReadonly"] = !setter;
      this.isSSR = isSSR;
    }
    notify() {
      this.flags |= 16;
      if (!(this.flags & 8) && activeSub !== this) {
        batch(this, true);
        return true;
      } else if (true)
        ;
    }
    get value() {
      const link = true ? this.dep.track({
        target: this,
        type: "get",
        key: "value"
      }) : this.dep.track();
      refreshComputed(this);
      if (link) {
        link.version = this.dep.version;
      }
      return this._value;
    }
    set value(newValue) {
      if (this.setter) {
        this.setter(newValue);
      } else if (true) {
        warn("Write operation failed: computed value is readonly");
      }
    }
  };
  function computed(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    if (isFunction(getterOrOptions)) {
      getter = getterOrOptions;
    } else {
      getter = getterOrOptions.get;
      setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, isSSR);
    if (debugOptions && !isSSR) {
      cRef.onTrack = debugOptions.onTrack;
      cRef.onTrigger = debugOptions.onTrigger;
    }
    return cRef;
  }
  var INITIAL_WATCHER_VALUE = {};
  var cleanupMap = /* @__PURE__ */ new WeakMap();
  var activeWatcher = void 0;
  function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
    if (owner) {
      let cleanups = cleanupMap.get(owner);
      if (!cleanups)
        cleanupMap.set(owner, cleanups = []);
      cleanups.push(cleanupFn);
    } else if (!failSilently) {
      warn(
        `onWatcherCleanup() was called when there was no active watcher to associate with.`
      );
    }
  }
  function watch(source, cb, options = EMPTY_OBJ) {
    const { immediate, deep, once, scheduler, augmentJob, call } = options;
    const warnInvalidSource = (s) => {
      (options.onWarn || warn)(
        `Invalid watch source: `,
        s,
        `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`
      );
    };
    const reactiveGetter = (source2) => {
      if (deep)
        return source2;
      if (isShallow(source2) || deep === false || deep === 0)
        return traverse(source2, 1);
      return traverse(source2);
    };
    let effect2;
    let getter;
    let cleanup;
    let boundCleanup;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef2(source)) {
      getter = () => source.value;
      forceTrigger = isShallow(source);
    } else if (isReactive(source)) {
      getter = () => reactiveGetter(source);
      forceTrigger = true;
    } else if (isArray(source)) {
      isMultiSource = true;
      forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
      getter = () => source.map((s) => {
        if (isRef2(s)) {
          return s.value;
        } else if (isReactive(s)) {
          return reactiveGetter(s);
        } else if (isFunction(s)) {
          return call ? call(s, 2) : s();
        } else {
          warnInvalidSource(s);
        }
      });
    } else if (isFunction(source)) {
      if (cb) {
        getter = call ? () => call(source, 2) : source;
      } else {
        getter = () => {
          if (cleanup) {
            pauseTracking();
            try {
              cleanup();
            } finally {
              resetTracking();
            }
          }
          const currentEffect = activeWatcher;
          activeWatcher = effect2;
          try {
            return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
          } finally {
            activeWatcher = currentEffect;
          }
        };
      }
    } else {
      getter = NOOP;
      warnInvalidSource(source);
    }
    if (cb && deep) {
      const baseGetter = getter;
      const depth = deep === true ? Infinity : deep;
      getter = () => traverse(baseGetter(), depth);
    }
    const scope = getCurrentScope();
    const watchHandle = () => {
      effect2.stop();
      if (scope && scope.active) {
        remove(scope.effects, effect2);
      }
    };
    if (once && cb) {
      const _cb = cb;
      cb = (...args) => {
        _cb(...args);
        watchHandle();
      };
    }
    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = (immediateFirstRun) => {
      if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
        return;
      }
      if (cb) {
        const newValue = effect2.run();
        if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
          if (cleanup) {
            cleanup();
          }
          const currentWatcher = activeWatcher;
          activeWatcher = effect2;
          try {
            const args = [
              newValue,
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
              boundCleanup
            ];
            oldValue = newValue;
            call ? call(cb, 3, args) : cb(...args);
          } finally {
            activeWatcher = currentWatcher;
          }
        }
      } else {
        effect2.run();
      }
    };
    if (augmentJob) {
      augmentJob(job);
    }
    effect2 = new ReactiveEffect(getter);
    effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
    boundCleanup = (fn2) => onWatcherCleanup(fn2, false, effect2);
    cleanup = effect2.onStop = () => {
      const cleanups = cleanupMap.get(effect2);
      if (cleanups) {
        if (call) {
          call(cleanups, 4);
        } else {
          for (const cleanup2 of cleanups)
            cleanup2();
        }
        cleanupMap.delete(effect2);
      }
    };
    if (true) {
      effect2.onTrack = options.onTrack;
      effect2.onTrigger = options.onTrigger;
    }
    if (cb) {
      if (immediate) {
        job(true);
      } else {
        oldValue = effect2.run();
      }
    } else if (scheduler) {
      scheduler(job.bind(null, true), true);
    } else {
      effect2.run();
    }
    watchHandle.pause = effect2.pause.bind(effect2);
    watchHandle.resume = effect2.resume.bind(effect2);
    watchHandle.stop = watchHandle;
    return watchHandle;
  }
  function traverse(value, depth = Infinity, seen) {
    if (depth <= 0 || !isObject(value) || value["__v_skip"]) {
      return value;
    }
    seen = seen || /* @__PURE__ */ new Set();
    if (seen.has(value)) {
      return value;
    }
    seen.add(value);
    depth--;
    if (isRef2(value)) {
      traverse(value.value, depth, seen);
    } else if (isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        traverse(value[i], depth, seen);
      }
    } else if (isSet(value) || isMap(value)) {
      value.forEach((v) => {
        traverse(v, depth, seen);
      });
    } else if (isPlainObject(value)) {
      for (const key in value) {
        traverse(value[key], depth, seen);
      }
      for (const key of Object.getOwnPropertySymbols(value)) {
        if (Object.prototype.propertyIsEnumerable.call(value, key)) {
          traverse(value[key], depth, seen);
        }
      }
    }
    return value;
  }

  // ../posawesome/node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js
  var stack = [];
  function pushWarningContext(vnode) {
    stack.push(vnode);
  }
  function popWarningContext() {
    stack.pop();
  }
  var isWarning = false;
  function warn$1(msg, ...args) {
    if (isWarning)
      return;
    isWarning = true;
    pauseTracking();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
      callWithErrorHandling(
        appWarnHandler,
        instance,
        11,
        [
          msg + args.map((a) => {
            var _a3, _b;
            return (_b = (_a3 = a.toString) == null ? void 0 : _a3.call(a)) != null ? _b : JSON.stringify(a);
          }).join(""),
          instance && instance.proxy,
          trace.map(
            ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
          ).join("\n"),
          trace
        ]
      );
    } else {
      const warnArgs = [`[Vue warn]: ${msg}`, ...args];
      if (trace.length && true) {
        warnArgs.push(`
`, ...formatTrace(trace));
      }
      console.warn(...warnArgs);
    }
    resetTracking();
    isWarning = false;
  }
  function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
      return [];
    }
    const normalizedStack = [];
    while (currentVNode) {
      const last = normalizedStack[0];
      if (last && last.vnode === currentVNode) {
        last.recurseCount++;
      } else {
        normalizedStack.push({
          vnode: currentVNode,
          recurseCount: 0
        });
      }
      const parentInstance = currentVNode.component && currentVNode.component.parent;
      currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
  }
  function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
      logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
    });
    return logs;
  }
  function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(
      vnode.component,
      vnode.type,
      isRoot
    )}`;
    const close = `>` + postfix;
    return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
  }
  function formatProps(props) {
    const res = [];
    const keys2 = Object.keys(props);
    keys2.slice(0, 3).forEach((key) => {
      res.push(...formatProp(key, props[key]));
    });
    if (keys2.length > 3) {
      res.push(` ...`);
    }
    return res;
  }
  function formatProp(key, value, raw) {
    if (isString(value)) {
      value = JSON.stringify(value);
      return raw ? value : [`${key}=${value}`];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
      return raw ? value : [`${key}=${value}`];
    } else if (isRef2(value)) {
      value = formatProp(key, toRaw(value.value), true);
      return raw ? value : [`${key}=Ref<`, value, `>`];
    } else if (isFunction(value)) {
      return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    } else {
      value = toRaw(value);
      return raw ? value : [`${key}=`, value];
    }
  }
  function assertNumber(val, type) {
    if (false)
      return;
    if (val === void 0) {
      return;
    } else if (typeof val !== "number") {
      warn$1(`${type} is not a valid number - got ${JSON.stringify(val)}.`);
    } else if (isNaN(val)) {
      warn$1(`${type} is NaN - the duration expression might be incorrect.`);
    }
  }
  var ErrorTypeStrings$1 = {
    ["sp"]: "serverPrefetch hook",
    ["bc"]: "beforeCreate hook",
    ["c"]: "created hook",
    ["bm"]: "beforeMount hook",
    ["m"]: "mounted hook",
    ["bu"]: "beforeUpdate hook",
    ["u"]: "updated",
    ["bum"]: "beforeUnmount hook",
    ["um"]: "unmounted hook",
    ["a"]: "activated hook",
    ["da"]: "deactivated hook",
    ["ec"]: "errorCaptured hook",
    ["rtc"]: "renderTracked hook",
    ["rtg"]: "renderTriggered hook",
    [0]: "setup function",
    [1]: "render function",
    [2]: "watcher getter",
    [3]: "watcher callback",
    [4]: "watcher cleanup function",
    [5]: "native event handler",
    [6]: "component event handler",
    [7]: "vnode hook",
    [8]: "directive hook",
    [9]: "transition hook",
    [10]: "app errorHandler",
    [11]: "app warnHandler",
    [12]: "ref function",
    [13]: "async component loader",
    [14]: "scheduler flush",
    [15]: "component update",
    [16]: "app unmount cleanup function"
  };
  function callWithErrorHandling(fn2, instance, type, args) {
    try {
      return args ? fn2(...args) : fn2();
    } catch (err) {
      handleError(err, instance, type);
    }
  }
  function callWithAsyncErrorHandling(fn2, instance, type, args) {
    if (isFunction(fn2)) {
      const res = callWithErrorHandling(fn2, instance, type, args);
      if (res && isPromise(res)) {
        res.catch((err) => {
          handleError(err, instance, type);
        });
      }
      return res;
    }
    if (isArray(fn2)) {
      const values = [];
      for (let i = 0; i < fn2.length; i++) {
        values.push(callWithAsyncErrorHandling(fn2[i], instance, type, args));
      }
      return values;
    } else if (true) {
      warn$1(
        `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof fn2}`
      );
    }
  }
  function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
    if (instance) {
      let cur = instance.parent;
      const exposedInstance = instance.proxy;
      const errorInfo = true ? ErrorTypeStrings$1[type] : `https://vuejs.org/error-reference/#runtime-${type}`;
      while (cur) {
        const errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (let i = 0; i < errorCapturedHooks.length; i++) {
            if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      if (errorHandler) {
        pauseTracking();
        callWithErrorHandling(errorHandler, null, 10, [
          err,
          exposedInstance,
          errorInfo
        ]);
        resetTracking();
        return;
      }
    }
    logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
  }
  function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
    if (true) {
      const info = ErrorTypeStrings$1[type];
      if (contextVNode) {
        pushWarningContext(contextVNode);
      }
      warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
      if (contextVNode) {
        popWarningContext();
      }
      if (throwInDev) {
        throw err;
      } else {
        console.error(err);
      }
    } else if (throwInProd) {
      throw err;
    } else {
      console.error(err);
    }
  }
  var queue = [];
  var flushIndex = -1;
  var pendingPostFlushCbs = [];
  var activePostFlushCbs = null;
  var postFlushIndex = 0;
  var resolvedPromise = /* @__PURE__ */ Promise.resolve();
  var currentFlushPromise = null;
  var RECURSION_LIMIT = 100;
  function nextTick(fn2) {
    const p2 = currentFlushPromise || resolvedPromise;
    return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
  }
  function findInsertionIndex(id) {
    let start = flushIndex + 1;
    let end = queue.length;
    while (start < end) {
      const middle = start + end >>> 1;
      const middleJob = queue[middle];
      const middleJobId = getId(middleJob);
      if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
        start = middle + 1;
      } else {
        end = middle;
      }
    }
    return start;
  }
  function queueJob(job) {
    if (!(job.flags & 1)) {
      const jobId = getId(job);
      const lastJob = queue[queue.length - 1];
      if (!lastJob || !(job.flags & 2) && jobId >= getId(lastJob)) {
        queue.push(job);
      } else {
        queue.splice(findInsertionIndex(jobId), 0, job);
      }
      job.flags |= 1;
      queueFlush();
    }
  }
  function queueFlush() {
    if (!currentFlushPromise) {
      currentFlushPromise = resolvedPromise.then(flushJobs);
    }
  }
  function queuePostFlushCb(cb) {
    if (!isArray(cb)) {
      if (activePostFlushCbs && cb.id === -1) {
        activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
      } else if (!(cb.flags & 1)) {
        pendingPostFlushCbs.push(cb);
        cb.flags |= 1;
      }
    } else {
      pendingPostFlushCbs.push(...cb);
    }
    queueFlush();
  }
  function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
    if (true) {
      seen = seen || /* @__PURE__ */ new Map();
    }
    for (; i < queue.length; i++) {
      const cb = queue[i];
      if (cb && cb.flags & 2) {
        if (instance && cb.id !== instance.uid) {
          continue;
        }
        if (checkRecursiveUpdates(seen, cb)) {
          continue;
        }
        queue.splice(i, 1);
        i--;
        if (cb.flags & 4) {
          cb.flags &= -2;
        }
        cb();
        if (!(cb.flags & 4)) {
          cb.flags &= -2;
        }
      }
    }
  }
  function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
      const deduped = [...new Set(pendingPostFlushCbs)].sort(
        (a, b) => getId(a) - getId(b)
      );
      pendingPostFlushCbs.length = 0;
      if (activePostFlushCbs) {
        activePostFlushCbs.push(...deduped);
        return;
      }
      activePostFlushCbs = deduped;
      if (true) {
        seen = seen || /* @__PURE__ */ new Map();
      }
      for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
        const cb = activePostFlushCbs[postFlushIndex];
        if (checkRecursiveUpdates(seen, cb)) {
          continue;
        }
        if (cb.flags & 4) {
          cb.flags &= -2;
        }
        if (!(cb.flags & 8))
          cb();
        cb.flags &= -2;
      }
      activePostFlushCbs = null;
      postFlushIndex = 0;
    }
  }
  var getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
  function flushJobs(seen) {
    if (true) {
      seen = seen || /* @__PURE__ */ new Map();
    }
    const check = true ? (job) => checkRecursiveUpdates(seen, job) : NOOP;
    try {
      for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job && !(job.flags & 8)) {
          if (check(job)) {
            continue;
          }
          if (job.flags & 4) {
            job.flags &= ~1;
          }
          callWithErrorHandling(
            job,
            job.i,
            job.i ? 15 : 14
          );
          if (!(job.flags & 4)) {
            job.flags &= ~1;
          }
        }
      }
    } finally {
      for (; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job) {
          job.flags &= -2;
        }
      }
      flushIndex = -1;
      queue.length = 0;
      flushPostFlushCbs(seen);
      currentFlushPromise = null;
      if (queue.length || pendingPostFlushCbs.length) {
        flushJobs(seen);
      }
    }
  }
  function checkRecursiveUpdates(seen, fn2) {
    const count = seen.get(fn2) || 0;
    if (count > RECURSION_LIMIT) {
      const instance = fn2.i;
      const componentName = instance && getComponentName(instance.type);
      handleError(
        `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
        null,
        10
      );
      return true;
    }
    seen.set(fn2, count + 1);
    return false;
  }
  var isHmrUpdating = false;
  var hmrDirtyComponents = /* @__PURE__ */ new Map();
  if (true) {
    getGlobalThis().__VUE_HMR_RUNTIME__ = {
      createRecord: tryWrap(createRecord),
      rerender: tryWrap(rerender),
      reload: tryWrap(reload)
    };
  }
  var map = /* @__PURE__ */ new Map();
  function registerHMR(instance) {
    const id = instance.type.__hmrId;
    let record = map.get(id);
    if (!record) {
      createRecord(id, instance.type);
      record = map.get(id);
    }
    record.instances.add(instance);
  }
  function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).instances.delete(instance);
  }
  function createRecord(id, initialDef) {
    if (map.has(id)) {
      return false;
    }
    map.set(id, {
      initialDef: normalizeClassComponent(initialDef),
      instances: /* @__PURE__ */ new Set()
    });
    return true;
  }
  function normalizeClassComponent(component) {
    return isClassComponent(component) ? component.__vccOpts : component;
  }
  function rerender(id, newRender) {
    const record = map.get(id);
    if (!record) {
      return;
    }
    record.initialDef.render = newRender;
    [...record.instances].forEach((instance) => {
      if (newRender) {
        instance.render = newRender;
        normalizeClassComponent(instance.type).render = newRender;
      }
      instance.renderCache = [];
      isHmrUpdating = true;
      instance.update();
      isHmrUpdating = false;
    });
  }
  function reload(id, newComp) {
    const record = map.get(id);
    if (!record)
      return;
    newComp = normalizeClassComponent(newComp);
    updateComponentDef(record.initialDef, newComp);
    const instances = [...record.instances];
    for (let i = 0; i < instances.length; i++) {
      const instance = instances[i];
      const oldComp = normalizeClassComponent(instance.type);
      let dirtyInstances = hmrDirtyComponents.get(oldComp);
      if (!dirtyInstances) {
        if (oldComp !== record.initialDef) {
          updateComponentDef(oldComp, newComp);
        }
        hmrDirtyComponents.set(oldComp, dirtyInstances = /* @__PURE__ */ new Set());
      }
      dirtyInstances.add(instance);
      instance.appContext.propsCache.delete(instance.type);
      instance.appContext.emitsCache.delete(instance.type);
      instance.appContext.optionsCache.delete(instance.type);
      if (instance.ceReload) {
        dirtyInstances.add(instance);
        instance.ceReload(newComp.styles);
        dirtyInstances.delete(instance);
      } else if (instance.parent) {
        queueJob(() => {
          isHmrUpdating = true;
          instance.parent.update();
          isHmrUpdating = false;
          dirtyInstances.delete(instance);
        });
      } else if (instance.appContext.reload) {
        instance.appContext.reload();
      } else if (typeof window !== "undefined") {
        window.location.reload();
      } else {
        console.warn(
          "[HMR] Root or manually mounted instance modified. Full reload required."
        );
      }
      if (instance.root.ce && instance !== instance.root) {
        instance.root.ce._removeChildStyle(oldComp);
      }
    }
    queuePostFlushCb(() => {
      hmrDirtyComponents.clear();
    });
  }
  function updateComponentDef(oldComp, newComp) {
    extend(oldComp, newComp);
    for (const key in oldComp) {
      if (key !== "__file" && !(key in newComp)) {
        delete oldComp[key];
      }
    }
  }
  function tryWrap(fn2) {
    return (id, arg) => {
      try {
        return fn2(id, arg);
      } catch (e) {
        console.error(e);
        console.warn(
          `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`
        );
      }
    };
  }
  var devtools$1;
  var buffer = [];
  var devtoolsNotInstalled = false;
  function emit$1(event2, ...args) {
    if (devtools$1) {
      devtools$1.emit(event2, ...args);
    } else if (!devtoolsNotInstalled) {
      buffer.push({ event: event2, args });
    }
  }
  function setDevtoolsHook$1(hook, target) {
    var _a3, _b;
    devtools$1 = hook;
    if (devtools$1) {
      devtools$1.enabled = true;
      buffer.forEach(({ event: event2, args }) => devtools$1.emit(event2, ...args));
      buffer = [];
    } else if (typeof window !== "undefined" && window.HTMLElement && !((_b = (_a3 = window.navigator) == null ? void 0 : _a3.userAgent) == null ? void 0 : _b.includes("jsdom"))) {
      const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
      replay.push((newHook) => {
        setDevtoolsHook$1(newHook, target);
      });
      setTimeout(() => {
        if (!devtools$1) {
          target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
          devtoolsNotInstalled = true;
          buffer = [];
        }
      }, 3e3);
    } else {
      devtoolsNotInstalled = true;
      buffer = [];
    }
  }
  function devtoolsInitApp(app, version3) {
    emit$1("app:init", app, version3, {
      Fragment,
      Text,
      Comment,
      Static
    });
  }
  function devtoolsUnmountApp(app) {
    emit$1("app:unmount", app);
  }
  var devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook("component:added");
  var devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook("component:updated");
  var _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(
    "component:removed"
  );
  var devtoolsComponentRemoved = (component) => {
    if (devtools$1 && typeof devtools$1.cleanupBuffer === "function" && !devtools$1.cleanupBuffer(component)) {
      _devtoolsComponentRemoved(component);
    }
  };
  function createDevtoolsComponentHook(hook) {
    return (component) => {
      emit$1(
        hook,
        component.appContext.app,
        component.uid,
        component.parent ? component.parent.uid : void 0,
        component
      );
    };
  }
  var devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:start");
  var devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:end");
  function createDevtoolsPerformanceHook(hook) {
    return (component, type, time) => {
      emit$1(hook, component.appContext.app, component.uid, component, type, time);
    };
  }
  function devtoolsComponentEmit(component, event2, params) {
    emit$1(
      "component:emit",
      component.appContext.app,
      component,
      event2,
      params
    );
  }
  var currentRenderingInstance = null;
  var currentScopeId = null;
  function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
  }
  function pushScopeId(id) {
    currentScopeId = id;
  }
  function popScopeId() {
    currentScopeId = null;
  }
  function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx)
      return fn2;
    if (fn2._n) {
      return fn2;
    }
    const renderFnWithContext = (...args) => {
      if (renderFnWithContext._d) {
        setBlockTracking(-1);
      }
      const prevInstance = setCurrentRenderingInstance(ctx);
      let res;
      try {
        res = fn2(...args);
      } finally {
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
          setBlockTracking(1);
        }
      }
      if (true) {
        devtoolsComponentUpdated(ctx);
      }
      return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
  }
  function validateDirectiveName(name) {
    if (isBuiltInDirective(name)) {
      warn$1("Do not use built-in directive ids as custom directive id: " + name);
    }
  }
  function withDirectives(vnode, directives) {
    if (currentRenderingInstance === null) {
      warn$1(`withDirectives can only be used inside render functions.`);
      return vnode;
    }
    const instance = getComponentPublicInstance(currentRenderingInstance);
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i = 0; i < directives.length; i++) {
      let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
      if (dir) {
        if (isFunction(dir)) {
          dir = {
            mounted: dir,
            updated: dir
          };
        }
        if (dir.deep) {
          traverse(value);
        }
        bindings.push({
          dir,
          instance,
          value,
          oldValue: void 0,
          arg,
          modifiers
        });
      }
    }
    return vnode;
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
      const binding = bindings[i];
      if (oldBindings) {
        binding.oldValue = oldBindings[i].value;
      }
      let hook = binding.dir[name];
      if (hook) {
        pauseTracking();
        callWithAsyncErrorHandling(hook, instance, 8, [
          vnode.el,
          binding,
          vnode,
          prevVNode
        ]);
        resetTracking();
      }
    }
  }
  var TeleportEndKey = Symbol("_vte");
  var isTeleport = (type) => type.__isTeleport;
  var isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
  var isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
  var isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
  var isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
  var resolveTarget = (props, select) => {
    const targetSelector = props && props.to;
    if (isString(targetSelector)) {
      if (!select) {
        warn$1(
          `Current renderer does not support string target for Teleports. (missing querySelector renderer option)`
        );
        return null;
      } else {
        const target = select(targetSelector);
        if (!target && !isTeleportDisabled(props)) {
          warn$1(
            `Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
          );
        }
        return target;
      }
    } else {
      if (!targetSelector && !isTeleportDisabled(props)) {
        warn$1(`Invalid Teleport target: ${targetSelector}`);
      }
      return targetSelector;
    }
  };
  var TeleportImpl = {
    name: "Teleport",
    __isTeleport: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
      const {
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        o: { insert, querySelector, createText, createComment }
      } = internals;
      const disabled = isTeleportDisabled(n2.props);
      let { shapeFlag, children, dynamicChildren } = n2;
      if (isHmrUpdating) {
        optimized = false;
        dynamicChildren = null;
      }
      if (n1 == null) {
        const placeholder = n2.el = true ? createComment("teleport start") : createText("");
        const mainAnchor = n2.anchor = true ? createComment("teleport end") : createText("");
        insert(placeholder, container, anchor);
        insert(mainAnchor, container, anchor);
        const mount = (container2, anchor2) => {
          if (shapeFlag & 16) {
            if (parentComponent && parentComponent.isCE) {
              parentComponent.ce._teleportTarget = container2;
            }
            mountChildren(
              children,
              container2,
              anchor2,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        };
        const mountToTarget = () => {
          const target = n2.target = resolveTarget(n2.props, querySelector);
          const targetAnchor = prepareAnchor(target, n2, createText, insert);
          if (target) {
            if (namespace !== "svg" && isTargetSVG(target)) {
              namespace = "svg";
            } else if (namespace !== "mathml" && isTargetMathML(target)) {
              namespace = "mathml";
            }
            if (!disabled) {
              mount(target, targetAnchor);
              updateCssVars(n2, false);
            }
          } else if (!disabled) {
            warn$1(
              "Invalid Teleport target on mount:",
              target,
              `(${typeof target})`
            );
          }
        };
        if (disabled) {
          mount(container, mainAnchor);
          updateCssVars(n2, true);
        }
        if (isTeleportDeferred(n2.props)) {
          n2.el.__isMounted = false;
          queuePostRenderEffect(() => {
            mountToTarget();
            delete n2.el.__isMounted;
          }, parentSuspense);
        } else {
          mountToTarget();
        }
      } else {
        if (isTeleportDeferred(n2.props) && n1.el.__isMounted === false) {
          queuePostRenderEffect(() => {
            TeleportImpl.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          }, parentSuspense);
          return;
        }
        n2.el = n1.el;
        n2.targetStart = n1.targetStart;
        const mainAnchor = n2.anchor = n1.anchor;
        const target = n2.target = n1.target;
        const targetAnchor = n2.targetAnchor = n1.targetAnchor;
        const wasDisabled = isTeleportDisabled(n1.props);
        const currentContainer = wasDisabled ? container : target;
        const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
        if (namespace === "svg" || isTargetSVG(target)) {
          namespace = "svg";
        } else if (namespace === "mathml" || isTargetMathML(target)) {
          namespace = "mathml";
        }
        if (dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            currentContainer,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds
          );
          traverseStaticChildren(n1, n2, false);
        } else if (!optimized) {
          patchChildren(
            n1,
            n2,
            currentContainer,
            currentAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            false
          );
        }
        if (disabled) {
          if (!wasDisabled) {
            moveTeleport(
              n2,
              container,
              mainAnchor,
              internals,
              1
            );
          } else {
            if (n2.props && n1.props && n2.props.to !== n1.props.to) {
              n2.props.to = n1.props.to;
            }
          }
        } else {
          if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
            const nextTarget = n2.target = resolveTarget(
              n2.props,
              querySelector
            );
            if (nextTarget) {
              moveTeleport(
                n2,
                nextTarget,
                null,
                internals,
                0
              );
            } else if (true) {
              warn$1(
                "Invalid Teleport target on update:",
                target,
                `(${typeof target})`
              );
            }
          } else if (wasDisabled) {
            moveTeleport(
              n2,
              target,
              targetAnchor,
              internals,
              1
            );
          }
        }
        updateCssVars(n2, disabled);
      }
    },
    remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
      const {
        shapeFlag,
        children,
        anchor,
        targetStart,
        targetAnchor,
        target,
        props
      } = vnode;
      if (target) {
        hostRemove(targetStart);
        hostRemove(targetAnchor);
      }
      doRemove && hostRemove(anchor);
      if (shapeFlag & 16) {
        const shouldRemove = doRemove || !isTeleportDisabled(props);
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          unmount(
            child,
            parentComponent,
            parentSuspense,
            shouldRemove,
            !!child.dynamicChildren
          );
        }
      }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
  };
  function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
    if (moveType === 0) {
      insert(vnode.targetAnchor, container, parentAnchor);
    }
    const { el, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2;
    if (isReorder) {
      insert(el, container, parentAnchor);
    }
    if (!isReorder || isTeleportDisabled(props)) {
      if (shapeFlag & 16) {
        for (let i = 0; i < children.length; i++) {
          move(
            children[i],
            container,
            parentAnchor,
            2
          );
        }
      }
    }
    if (isReorder) {
      insert(anchor, container, parentAnchor);
    }
  }
  function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
    o: { nextSibling, parentNode, querySelector, insert, createText }
  }, hydrateChildren) {
    const target = vnode.target = resolveTarget(
      vnode.props,
      querySelector
    );
    if (target) {
      const disabled = isTeleportDisabled(vnode.props);
      const targetNode = target._lpa || target.firstChild;
      if (vnode.shapeFlag & 16) {
        if (disabled) {
          vnode.anchor = hydrateChildren(
            nextSibling(node),
            vnode,
            parentNode(node),
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
          vnode.targetStart = targetNode;
          vnode.targetAnchor = targetNode && nextSibling(targetNode);
        } else {
          vnode.anchor = nextSibling(node);
          let targetAnchor = targetNode;
          while (targetAnchor) {
            if (targetAnchor && targetAnchor.nodeType === 8) {
              if (targetAnchor.data === "teleport start anchor") {
                vnode.targetStart = targetAnchor;
              } else if (targetAnchor.data === "teleport anchor") {
                vnode.targetAnchor = targetAnchor;
                target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                break;
              }
            }
            targetAnchor = nextSibling(targetAnchor);
          }
          if (!vnode.targetAnchor) {
            prepareAnchor(target, vnode, createText, insert);
          }
          hydrateChildren(
            targetNode && nextSibling(targetNode),
            vnode,
            target,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
      }
      updateCssVars(vnode, disabled);
    }
    return vnode.anchor && nextSibling(vnode.anchor);
  }
  var Teleport = TeleportImpl;
  function updateCssVars(vnode, isDisabled) {
    const ctx = vnode.ctx;
    if (ctx && ctx.ut) {
      let node, anchor;
      if (isDisabled) {
        node = vnode.el;
        anchor = vnode.anchor;
      } else {
        node = vnode.targetStart;
        anchor = vnode.targetAnchor;
      }
      while (node && node !== anchor) {
        if (node.nodeType === 1)
          node.setAttribute("data-v-owner", ctx.uid);
        node = node.nextSibling;
      }
      ctx.ut();
    }
  }
  function prepareAnchor(target, vnode, createText, insert) {
    const targetStart = vnode.targetStart = createText("");
    const targetAnchor = vnode.targetAnchor = createText("");
    targetStart[TeleportEndKey] = targetAnchor;
    if (target) {
      insert(targetStart, target);
      insert(targetAnchor, target);
    }
    return targetAnchor;
  }
  var leaveCbKey = Symbol("_leaveCb");
  var enterCbKey = Symbol("_enterCb");
  function useTransitionState() {
    const state = {
      isMounted: false,
      isLeaving: false,
      isUnmounting: false,
      leavingVNodes: /* @__PURE__ */ new Map()
    };
    onMounted(() => {
      state.isMounted = true;
    });
    onBeforeUnmount(() => {
      state.isUnmounting = true;
    });
    return state;
  }
  var TransitionHookValidator = [Function, Array];
  var BaseTransitionPropsValidators = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  };
  var recursiveGetSubtree = (instance) => {
    const subTree = instance.subTree;
    return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
  };
  var BaseTransitionImpl = {
    name: `BaseTransition`,
    props: BaseTransitionPropsValidators,
    setup(props, { slots }) {
      const instance = getCurrentInstance();
      const state = useTransitionState();
      return () => {
        const children = slots.default && getTransitionRawChildren(slots.default(), true);
        if (!children || !children.length) {
          return;
        }
        const child = findNonCommentChild(children);
        const rawProps = toRaw(props);
        const { mode } = rawProps;
        if (mode && mode !== "in-out" && mode !== "out-in" && mode !== "default") {
          warn$1(`invalid <transition> mode: ${mode}`);
        }
        if (state.isLeaving) {
          return emptyPlaceholder(child);
        }
        const innerChild = getInnerChild$1(child);
        if (!innerChild) {
          return emptyPlaceholder(child);
        }
        let enterHooks = resolveTransitionHooks(
          innerChild,
          rawProps,
          state,
          instance,
          (hooks) => enterHooks = hooks
        );
        if (innerChild.type !== Comment) {
          setTransitionHooks(innerChild, enterHooks);
        }
        let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
        if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
          let leavingHooks = resolveTransitionHooks(
            oldInnerChild,
            rawProps,
            state,
            instance
          );
          setTransitionHooks(oldInnerChild, leavingHooks);
          if (mode === "out-in" && innerChild.type !== Comment) {
            state.isLeaving = true;
            leavingHooks.afterLeave = () => {
              state.isLeaving = false;
              if (!(instance.job.flags & 8)) {
                instance.update();
              }
              delete leavingHooks.afterLeave;
              oldInnerChild = void 0;
            };
            return emptyPlaceholder(child);
          } else if (mode === "in-out" && innerChild.type !== Comment) {
            leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
              const leavingVNodesCache = getLeavingNodesForType(
                state,
                oldInnerChild
              );
              leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
              el[leaveCbKey] = () => {
                earlyRemove();
                el[leaveCbKey] = void 0;
                delete enterHooks.delayedLeave;
                oldInnerChild = void 0;
              };
              enterHooks.delayedLeave = () => {
                delayedLeave();
                delete enterHooks.delayedLeave;
                oldInnerChild = void 0;
              };
            };
          } else {
            oldInnerChild = void 0;
          }
        } else if (oldInnerChild) {
          oldInnerChild = void 0;
        }
        return child;
      };
    }
  };
  function findNonCommentChild(children) {
    let child = children[0];
    if (children.length > 1) {
      let hasFound = false;
      for (const c of children) {
        if (c.type !== Comment) {
          if (hasFound) {
            warn$1(
              "<transition> can only be used on a single element or component. Use <transition-group> for lists."
            );
            break;
          }
          child = c;
          hasFound = true;
          if (false)
            break;
        }
      }
    }
    return child;
  }
  var BaseTransition = BaseTransitionImpl;
  function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
      leavingVNodesCache = /* @__PURE__ */ Object.create(null);
      leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
  }
  function resolveTransitionHooks(vnode, props, state, instance, postClone) {
    const {
      appear,
      mode,
      persisted = false,
      onBeforeEnter,
      onEnter,
      onAfterEnter,
      onEnterCancelled,
      onBeforeLeave,
      onLeave,
      onAfterLeave,
      onLeaveCancelled,
      onBeforeAppear,
      onAppear,
      onAfterAppear,
      onAppearCancelled
    } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook3 = (hook, args) => {
      hook && callWithAsyncErrorHandling(
        hook,
        instance,
        9,
        args
      );
    };
    const callAsyncHook = (hook, args) => {
      const done = args[1];
      callHook3(hook, args);
      if (isArray(hook)) {
        if (hook.every((hook2) => hook2.length <= 1))
          done();
      } else if (hook.length <= 1) {
        done();
      }
    };
    const hooks = {
      mode,
      persisted,
      beforeEnter(el) {
        let hook = onBeforeEnter;
        if (!state.isMounted) {
          if (appear) {
            hook = onBeforeAppear || onBeforeEnter;
          } else {
            return;
          }
        }
        if (el[leaveCbKey]) {
          el[leaveCbKey](
            true
          );
        }
        const leavingVNode = leavingVNodesCache[key];
        if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
          leavingVNode.el[leaveCbKey]();
        }
        callHook3(hook, [el]);
      },
      enter(el) {
        let hook = onEnter;
        let afterHook = onAfterEnter;
        let cancelHook = onEnterCancelled;
        if (!state.isMounted) {
          if (appear) {
            hook = onAppear || onEnter;
            afterHook = onAfterAppear || onAfterEnter;
            cancelHook = onAppearCancelled || onEnterCancelled;
          } else {
            return;
          }
        }
        let called = false;
        const done = el[enterCbKey] = (cancelled) => {
          if (called)
            return;
          called = true;
          if (cancelled) {
            callHook3(cancelHook, [el]);
          } else {
            callHook3(afterHook, [el]);
          }
          if (hooks.delayedLeave) {
            hooks.delayedLeave();
          }
          el[enterCbKey] = void 0;
        };
        if (hook) {
          callAsyncHook(hook, [el, done]);
        } else {
          done();
        }
      },
      leave(el, remove3) {
        const key2 = String(vnode.key);
        if (el[enterCbKey]) {
          el[enterCbKey](
            true
          );
        }
        if (state.isUnmounting) {
          return remove3();
        }
        callHook3(onBeforeLeave, [el]);
        let called = false;
        const done = el[leaveCbKey] = (cancelled) => {
          if (called)
            return;
          called = true;
          remove3();
          if (cancelled) {
            callHook3(onLeaveCancelled, [el]);
          } else {
            callHook3(onAfterLeave, [el]);
          }
          el[leaveCbKey] = void 0;
          if (leavingVNodesCache[key2] === vnode) {
            delete leavingVNodesCache[key2];
          }
        };
        leavingVNodesCache[key2] = vnode;
        if (onLeave) {
          callAsyncHook(onLeave, [el, done]);
        } else {
          done();
        }
      },
      clone(vnode2) {
        const hooks2 = resolveTransitionHooks(
          vnode2,
          props,
          state,
          instance,
          postClone
        );
        if (postClone)
          postClone(hooks2);
        return hooks2;
      }
    };
    return hooks;
  }
  function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
      vnode = cloneVNode(vnode);
      vnode.children = null;
      return vnode;
    }
  }
  function getInnerChild$1(vnode) {
    if (!isKeepAlive(vnode)) {
      if (isTeleport(vnode.type) && vnode.children) {
        return findNonCommentChild(vnode.children);
      }
      return vnode;
    }
    if (vnode.component) {
      return vnode.component.subTree;
    }
    const { shapeFlag, children } = vnode;
    if (children) {
      if (shapeFlag & 16) {
        return children[0];
      }
      if (shapeFlag & 32 && isFunction(children.default)) {
        return children.default();
      }
    }
  }
  function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
      vnode.transition = hooks;
      setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
      vnode.transition = hooks;
    }
  }
  function getTransitionRawChildren(children, keepComment = false, parentKey) {
    let ret = [];
    let keyedFragmentCount = 0;
    for (let i = 0; i < children.length; i++) {
      let child = children[i];
      const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
      if (child.type === Fragment) {
        if (child.patchFlag & 128)
          keyedFragmentCount++;
        ret = ret.concat(
          getTransitionRawChildren(child.children, keepComment, key)
        );
      } else if (keepComment || child.type !== Comment) {
        ret.push(key != null ? cloneVNode(child, { key }) : child);
      }
    }
    if (keyedFragmentCount > 1) {
      for (let i = 0; i < ret.length; i++) {
        ret[i].patchFlag = -2;
      }
    }
    return ret;
  }
  function defineComponent(options, extraOptions) {
    return isFunction(options) ? /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))() : options;
  }
  function useId() {
    const i = getCurrentInstance();
    if (i) {
      return (i.appContext.config.idPrefix || "v") + "-" + i.ids[0] + i.ids[1]++;
    } else if (true) {
      warn$1(
        `useId() is called when there is no active component instance to be associated with.`
      );
    }
    return "";
  }
  function markAsyncBoundary(instance) {
    instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
  }
  var knownTemplateRefs = /* @__PURE__ */ new WeakSet();
  function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (isArray(rawRef)) {
      rawRef.forEach(
        (r, i) => setRef(
          r,
          oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
          parentSuspense,
          vnode,
          isUnmount
        )
      );
      return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
      if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
        setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
      }
      return;
    }
    const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref2 } = rawRef;
    if (!owner) {
      warn$1(
        `Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`
      );
      return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    const rawSetupState = toRaw(setupState);
    const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
      if (true) {
        if (hasOwn(rawSetupState, key) && !isRef2(rawSetupState[key])) {
          warn$1(
            `Template ref "${key}" used on a non-ref value. It will not work in the production build.`
          );
        }
        if (knownTemplateRefs.has(rawSetupState[key])) {
          return false;
        }
      }
      return hasOwn(rawSetupState, key);
    };
    if (oldRef != null && oldRef !== ref2) {
      if (isString(oldRef)) {
        refs[oldRef] = null;
        if (canSetSetupRef(oldRef)) {
          setupState[oldRef] = null;
        }
      } else if (isRef2(oldRef)) {
        oldRef.value = null;
      }
    }
    if (isFunction(ref2)) {
      callWithErrorHandling(ref2, owner, 12, [value, refs]);
    } else {
      const _isString = isString(ref2);
      const _isRef = isRef2(ref2);
      if (_isString || _isRef) {
        const doSet = () => {
          if (rawRef.f) {
            const existing = _isString ? canSetSetupRef(ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
            if (isUnmount) {
              isArray(existing) && remove(existing, refValue);
            } else {
              if (!isArray(existing)) {
                if (_isString) {
                  refs[ref2] = [refValue];
                  if (canSetSetupRef(ref2)) {
                    setupState[ref2] = refs[ref2];
                  }
                } else {
                  ref2.value = [refValue];
                  if (rawRef.k)
                    refs[rawRef.k] = ref2.value;
                }
              } else if (!existing.includes(refValue)) {
                existing.push(refValue);
              }
            }
          } else if (_isString) {
            refs[ref2] = value;
            if (canSetSetupRef(ref2)) {
              setupState[ref2] = value;
            }
          } else if (_isRef) {
            ref2.value = value;
            if (rawRef.k)
              refs[rawRef.k] = value;
          } else if (true) {
            warn$1("Invalid template ref type:", ref2, `(${typeof ref2})`);
          }
        };
        if (value) {
          doSet.id = -1;
          queuePostRenderEffect(doSet, parentSuspense);
        } else {
          doSet();
        }
      } else if (true) {
        warn$1("Invalid template ref type:", ref2, `(${typeof ref2})`);
      }
    }
  }
  var requestIdleCallback2 = getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
  var cancelIdleCallback2 = getGlobalThis().cancelIdleCallback || ((id) => clearTimeout(id));
  var isAsyncWrapper = (i) => !!i.type.__asyncLoader;
  var isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
  function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
  }
  function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
  }
  function registerKeepAliveHook(hook, type, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = () => {
      let current = target;
      while (current) {
        if (current.isDeactivated) {
          return;
        }
        current = current.parent;
      }
      return hook();
    });
    injectHook(type, wrappedHook, target);
    if (target) {
      let current = target.parent;
      while (current && current.parent) {
        if (isKeepAlive(current.parent.vnode)) {
          injectToKeepAliveRoot(wrappedHook, type, target, current);
        }
        current = current.parent;
      }
    }
  }
  function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    const injected = injectHook(
      type,
      hook,
      keepAliveRoot,
      true
    );
    onUnmounted(() => {
      remove(keepAliveRoot[type], injected);
    }, target);
  }
  function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
      const hooks = target[type] || (target[type] = []);
      const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
        pauseTracking();
        const reset = setCurrentInstance(target);
        const res = callWithAsyncErrorHandling(hook, target, type, args);
        reset();
        resetTracking();
        return res;
      });
      if (prepend) {
        hooks.unshift(wrappedHook);
      } else {
        hooks.push(wrappedHook);
      }
      return wrappedHook;
    } else if (true) {
      const apiName = toHandlerKey(ErrorTypeStrings$1[type].replace(/ hook$/, ""));
      warn$1(
        `${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
      );
    }
  }
  var createHook = (lifecycle) => (hook, target = currentInstance) => {
    if (!isInSSRComponentSetup || lifecycle === "sp") {
      injectHook(lifecycle, (...args) => hook(...args), target);
    }
  };
  var onBeforeMount = createHook("bm");
  var onMounted = createHook("m");
  var onBeforeUpdate = createHook(
    "bu"
  );
  var onUpdated = createHook("u");
  var onBeforeUnmount = createHook(
    "bum"
  );
  var onUnmounted = createHook("um");
  var onServerPrefetch = createHook(
    "sp"
  );
  var onRenderTriggered = createHook("rtg");
  var onRenderTracked = createHook("rtc");
  function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
  }
  var COMPONENTS = "components";
  function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
  }
  var NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
  function resolveDynamicComponent(component) {
    if (isString(component)) {
      return resolveAsset(COMPONENTS, component, false) || component;
    } else {
      return component || NULL_DYNAMIC_COMPONENT;
    }
  }
  function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
      const Component = instance.type;
      if (type === COMPONENTS) {
        const selfName = getComponentName(
          Component,
          false
        );
        if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
          return Component;
        }
      }
      const res = resolve(instance[type] || Component[type], name) || resolve(instance.appContext[type], name);
      if (!res && maybeSelfReference) {
        return Component;
      }
      if (warnMissing && !res) {
        const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
        warn$1(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
      }
      return res;
    } else if (true) {
      warn$1(
        `resolve${capitalize(type.slice(0, -1))} can only be used in render() or setup().`
      );
    }
  }
  function resolve(registry, name) {
    return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
  }
  function renderList(source, renderItem, cache, index) {
    let ret;
    const cached = cache && cache[index];
    const sourceIsArray = isArray(source);
    if (sourceIsArray || isString(source)) {
      const sourceIsReactiveArray = sourceIsArray && isReactive(source);
      let needsWrap = false;
      let isReadonlySource = false;
      if (sourceIsReactiveArray) {
        needsWrap = !isShallow(source);
        isReadonlySource = isReadonly(source);
        source = shallowReadArray(source);
      }
      ret = new Array(source.length);
      for (let i = 0, l = source.length; i < l; i++) {
        ret[i] = renderItem(
          needsWrap ? isReadonlySource ? toReadonly(toReactive(source[i])) : toReactive(source[i]) : source[i],
          i,
          void 0,
          cached && cached[i]
        );
      }
    } else if (typeof source === "number") {
      if (!Number.isInteger(source)) {
        warn$1(`The v-for range expect an integer value but got ${source}.`);
      }
      ret = new Array(source);
      for (let i = 0; i < source; i++) {
        ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
      }
    } else if (isObject(source)) {
      if (source[Symbol.iterator]) {
        ret = Array.from(
          source,
          (item, i) => renderItem(item, i, void 0, cached && cached[i])
        );
      } else {
        const keys2 = Object.keys(source);
        ret = new Array(keys2.length);
        for (let i = 0, l = keys2.length; i < l; i++) {
          const key = keys2[i];
          ret[i] = renderItem(source[key], key, i, cached && cached[i]);
        }
      }
    } else {
      ret = [];
    }
    if (cache) {
      cache[index] = ret;
    }
    return ret;
  }
  function createSlots(slots, dynamicSlots) {
    for (let i = 0; i < dynamicSlots.length; i++) {
      const slot = dynamicSlots[i];
      if (isArray(slot)) {
        for (let j = 0; j < slot.length; j++) {
          slots[slot[j].name] = slot[j].fn;
        }
      } else if (slot) {
        slots[slot.name] = slot.key ? (...args) => {
          const res = slot.fn(...args);
          if (res)
            res.key = slot.key;
          return res;
        } : slot.fn;
      }
    }
    return slots;
  }
  function renderSlot(slots, name, props = {}, fallback, noSlotted) {
    if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
      if (name !== "default")
        props.name = name;
      return openBlock(), createBlock(
        Fragment,
        null,
        [createVNode("slot", props, fallback && fallback())],
        64
      );
    }
    let slot = slots[name];
    if (slot && slot.length > 1) {
      warn$1(
        `SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`
      );
      slot = () => [];
    }
    if (slot && slot._c) {
      slot._d = false;
    }
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props));
    const slotKey = props.key || validSlotContent && validSlotContent.key;
    const rendered = createBlock(
      Fragment,
      {
        key: (slotKey && !isSymbol(slotKey) ? slotKey : `_${name}`) + (!validSlotContent && fallback ? "_fb" : "")
      },
      validSlotContent || (fallback ? fallback() : []),
      validSlotContent && slots._ === 1 ? 64 : -2
    );
    if (!noSlotted && rendered.scopeId) {
      rendered.slotScopeIds = [rendered.scopeId + "-s"];
    }
    if (slot && slot._c) {
      slot._d = true;
    }
    return rendered;
  }
  function ensureValidVNode(vnodes) {
    return vnodes.some((child) => {
      if (!isVNode(child))
        return true;
      if (child.type === Comment)
        return false;
      if (child.type === Fragment && !ensureValidVNode(child.children))
        return false;
      return true;
    }) ? vnodes : null;
  }
  var getPublicInstance = (i) => {
    if (!i)
      return null;
    if (isStatefulComponent(i))
      return getComponentPublicInstance(i);
    return getPublicInstance(i.parent);
  };
  var publicPropertiesMap = /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => true ? shallowReadonly(i.props) : i.props,
    $attrs: (i) => true ? shallowReadonly(i.attrs) : i.attrs,
    $slots: (i) => true ? shallowReadonly(i.slots) : i.slots,
    $refs: (i) => true ? shallowReadonly(i.refs) : i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $host: (i) => i.ce,
    $emit: (i) => i.emit,
    $options: (i) => true ? resolveMergedOptions(i) : i.type,
    $forceUpdate: (i) => i.f || (i.f = () => {
      queueJob(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => true ? instanceWatch.bind(i) : NOOP
  });
  var isReservedPrefix = (key) => key === "_" || key === "$";
  var hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
  var PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
      if (key === "__v_skip") {
        return true;
      }
      const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
      if (key === "__isVue") {
        return true;
      }
      let normalizedProps;
      if (key[0] !== "$") {
        const n = accessCache[key];
        if (n !== void 0) {
          switch (n) {
            case 1:
              return setupState[key];
            case 2:
              return data[key];
            case 4:
              return ctx[key];
            case 3:
              return props[key];
          }
        } else if (hasSetupBinding(setupState, key)) {
          accessCache[key] = 1;
          return setupState[key];
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          accessCache[key] = 2;
          return data[key];
        } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)) {
          accessCache[key] = 3;
          return props[key];
        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (shouldCacheAccess) {
          accessCache[key] = 0;
        }
      }
      const publicGetter = publicPropertiesMap[key];
      let cssModule, globalProperties;
      if (publicGetter) {
        if (key === "$attrs") {
          track(instance.attrs, "get", "");
          markAttrsAccessed();
        } else if (key === "$slots") {
          track(instance, "get", key);
        }
        return publicGetter(instance);
      } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
        return cssModule;
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)) {
        {
          return globalProperties[key];
        }
      } else if (currentRenderingInstance && (!isString(key) || key.indexOf("__v") !== 0)) {
        if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {
          warn$1(
            `Property ${JSON.stringify(
              key
            )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
          );
        } else if (instance === currentRenderingInstance) {
          warn$1(
            `Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`
          );
        }
      }
    },
    set({ _: instance }, key, value) {
      const { data, setupState, ctx } = instance;
      if (hasSetupBinding(setupState, key)) {
        setupState[key] = value;
        return true;
      } else if (setupState.__isScriptSetup && hasOwn(setupState, key)) {
        warn$1(`Cannot mutate <script setup> binding "${key}" from Options API.`);
        return false;
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        data[key] = value;
        return true;
      } else if (hasOwn(instance.props, key)) {
        warn$1(`Attempting to mutate prop "${key}". Props are readonly.`);
        return false;
      }
      if (key[0] === "$" && key.slice(1) in instance) {
        warn$1(
          `Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`
        );
        return false;
      } else {
        if (key in instance.appContext.config.globalProperties) {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            value
          });
        } else {
          ctx[key] = value;
        }
      }
      return true;
    },
    has({
      _: { data, setupState, accessCache, ctx, appContext, propsOptions }
    }, key) {
      let normalizedProps;
      return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
    },
    defineProperty(target, key, descriptor) {
      if (descriptor.get != null) {
        target._.accessCache[key] = 0;
      } else if (hasOwn(descriptor, "value")) {
        this.set(target, key, descriptor.value, null);
      }
      return Reflect.defineProperty(target, key, descriptor);
    }
  };
  if (true) {
    PublicInstanceProxyHandlers.ownKeys = (target) => {
      warn$1(
        `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`
      );
      return Reflect.ownKeys(target);
    };
  }
  function createDevRenderContext(instance) {
    const target = {};
    Object.defineProperty(target, `_`, {
      configurable: true,
      enumerable: false,
      get: () => instance
    });
    Object.keys(publicPropertiesMap).forEach((key) => {
      Object.defineProperty(target, key, {
        configurable: true,
        enumerable: false,
        get: () => publicPropertiesMap[key](instance),
        set: NOOP
      });
    });
    return target;
  }
  function exposePropsOnRenderContext(instance) {
    const {
      ctx,
      propsOptions: [propsOptions]
    } = instance;
    if (propsOptions) {
      Object.keys(propsOptions).forEach((key) => {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => instance.props[key],
          set: NOOP
        });
      });
    }
  }
  function exposeSetupStateOnRenderContext(instance) {
    const { ctx, setupState } = instance;
    Object.keys(toRaw(setupState)).forEach((key) => {
      if (!setupState.__isScriptSetup) {
        if (isReservedPrefix(key[0])) {
          warn$1(
            `setup() return property ${JSON.stringify(
              key
            )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
          );
          return;
        }
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => setupState[key],
          set: NOOP
        });
      }
    });
  }
  function useSlots() {
    return getContext().slots;
  }
  function useAttrs() {
    return getContext().attrs;
  }
  function getContext() {
    const i = getCurrentInstance();
    if (!i) {
      warn$1(`useContext() called without active instance.`);
    }
    return i.setupContext || (i.setupContext = createSetupContext(i));
  }
  function normalizePropsOrEmits(props) {
    return isArray(props) ? props.reduce(
      (normalized, p2) => (normalized[p2] = null, normalized),
      {}
    ) : props;
  }
  function createDuplicateChecker() {
    const cache = /* @__PURE__ */ Object.create(null);
    return (type, key) => {
      if (cache[key]) {
        warn$1(`${type} property "${key}" is already defined in ${cache[key]}.`);
      } else {
        cache[key] = type;
      }
    };
  }
  var shouldCacheAccess = true;
  function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) {
      callHook(options.beforeCreate, instance, "bc");
    }
    const {
      data: dataOptions,
      computed: computedOptions,
      methods,
      watch: watchOptions,
      provide: provideOptions,
      inject: injectOptions,
      created,
      beforeMount,
      mounted: mounted7,
      beforeUpdate,
      updated: updated3,
      activated,
      deactivated,
      beforeDestroy,
      beforeUnmount,
      destroyed,
      unmounted: unmounted7,
      render: render35,
      renderTracked,
      renderTriggered,
      errorCaptured,
      serverPrefetch,
      expose,
      inheritAttrs,
      components,
      directives,
      filters
    } = options;
    const checkDuplicateProperties = true ? createDuplicateChecker() : null;
    if (true) {
      const [propsOptions] = instance.propsOptions;
      if (propsOptions) {
        for (const key in propsOptions) {
          checkDuplicateProperties("Props", key);
        }
      }
    }
    if (injectOptions) {
      resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    }
    if (methods) {
      for (const key in methods) {
        const methodHandler = methods[key];
        if (isFunction(methodHandler)) {
          if (true) {
            Object.defineProperty(ctx, key, {
              value: methodHandler.bind(publicThis),
              configurable: true,
              enumerable: true,
              writable: true
            });
          } else {
            ctx[key] = methodHandler.bind(publicThis);
          }
          if (true) {
            checkDuplicateProperties("Methods", key);
          }
        } else if (true) {
          warn$1(
            `Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`
          );
        }
      }
    }
    if (dataOptions) {
      if (!isFunction(dataOptions)) {
        warn$1(
          `The data option must be a function. Plain object usage is no longer supported.`
        );
      }
      const data = dataOptions.call(publicThis, publicThis);
      if (isPromise(data)) {
        warn$1(
          `data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`
        );
      }
      if (!isObject(data)) {
        warn$1(`data() should return an object.`);
      } else {
        instance.data = reactive(data);
        if (true) {
          for (const key in data) {
            checkDuplicateProperties("Data", key);
            if (!isReservedPrefix(key[0])) {
              Object.defineProperty(ctx, key, {
                configurable: true,
                enumerable: true,
                get: () => data[key],
                set: NOOP
              });
            }
          }
        }
      }
    }
    shouldCacheAccess = true;
    if (computedOptions) {
      for (const key in computedOptions) {
        const opt = computedOptions[key];
        const get = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
        if (get === NOOP) {
          warn$1(`Computed property "${key}" has no getter.`);
        }
        const set2 = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : true ? () => {
          warn$1(
            `Write operation failed: computed property "${key}" is readonly.`
          );
        } : NOOP;
        const c = computed2({
          get,
          set: set2
        });
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => c.value,
          set: (v) => c.value = v
        });
        if (true) {
          checkDuplicateProperties("Computed", key);
        }
      }
    }
    if (watchOptions) {
      for (const key in watchOptions) {
        createWatcher(watchOptions[key], ctx, publicThis, key);
      }
    }
    if (provideOptions) {
      const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key) => {
        provide(key, provides[key]);
      });
    }
    if (created) {
      callHook(created, instance, "c");
    }
    function registerLifecycleHook(register, hook) {
      if (isArray(hook)) {
        hook.forEach((_hook) => register(_hook.bind(publicThis)));
      } else if (hook) {
        register(hook.bind(publicThis));
      }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted7);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated3);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted7);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray(expose)) {
      if (expose.length) {
        const exposed = instance.exposed || (instance.exposed = {});
        expose.forEach((key) => {
          Object.defineProperty(exposed, key, {
            get: () => publicThis[key],
            set: (val) => publicThis[key] = val
          });
        });
      } else if (!instance.exposed) {
        instance.exposed = {};
      }
    }
    if (render35 && instance.render === NOOP) {
      instance.render = render35;
    }
    if (inheritAttrs != null) {
      instance.inheritAttrs = inheritAttrs;
    }
    if (components)
      instance.components = components;
    if (directives)
      instance.directives = directives;
    if (serverPrefetch) {
      markAsyncBoundary(instance);
    }
  }
  function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
    if (isArray(injectOptions)) {
      injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
      const opt = injectOptions[key];
      let injected;
      if (isObject(opt)) {
        if ("default" in opt) {
          injected = inject(
            opt.from || key,
            opt.default,
            true
          );
        } else {
          injected = inject(opt.from || key);
        }
      } else {
        injected = inject(opt);
      }
      if (isRef2(injected)) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        ctx[key] = injected;
      }
      if (true) {
        checkDuplicateProperties("Inject", key);
      }
    }
  }
  function callHook(hook, instance, type) {
    callWithAsyncErrorHandling(
      isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
      instance,
      type
    );
  }
  function createWatcher(raw, ctx, publicThis, key) {
    let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
    if (isString(raw)) {
      const handler = ctx[raw];
      if (isFunction(handler)) {
        {
          watch2(getter, handler);
        }
      } else if (true) {
        warn$1(`Invalid watch handler specified by key "${raw}"`, handler);
      }
    } else if (isFunction(raw)) {
      {
        watch2(getter, raw.bind(publicThis));
      }
    } else if (isObject(raw)) {
      if (isArray(raw)) {
        raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
      } else {
        const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
        if (isFunction(handler)) {
          watch2(getter, handler, raw);
        } else if (true) {
          warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler);
        }
      }
    } else if (true) {
      warn$1(`Invalid watch option: "${key}"`, raw);
    }
  }
  function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const {
      mixins: globalMixins,
      optionsCache: cache,
      config: { optionMergeStrategies }
    } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) {
      resolved = cached;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
      {
        resolved = base;
      }
    } else {
      resolved = {};
      if (globalMixins.length) {
        globalMixins.forEach(
          (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
        );
      }
      mergeOptions(resolved, base, optionMergeStrategies);
    }
    if (isObject(base)) {
      cache.set(base, resolved);
    }
    return resolved;
  }
  function mergeOptions(to2, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
      mergeOptions(to2, extendsOptions, strats, true);
    }
    if (mixins) {
      mixins.forEach(
        (m) => mergeOptions(to2, m, strats, true)
      );
    }
    for (const key in from) {
      if (asMixin && key === "expose") {
        warn$1(
          `"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`
        );
      } else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to2[key] = strat ? strat(to2[key], from[key]) : from[key];
      }
    }
    return to2;
  }
  var internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    watch: mergeWatchOptions,
    provide: mergeDataFn,
    inject: mergeInject
  };
  function mergeDataFn(to2, from) {
    if (!from) {
      return to2;
    }
    if (!to2) {
      return from;
    }
    return function mergedDataFn() {
      return extend(
        isFunction(to2) ? to2.call(this, this) : to2,
        isFunction(from) ? from.call(this, this) : from
      );
    };
  }
  function mergeInject(to2, from) {
    return mergeObjectOptions(normalizeInject(to2), normalizeInject(from));
  }
  function normalizeInject(raw) {
    if (isArray(raw)) {
      const res = {};
      for (let i = 0; i < raw.length; i++) {
        res[raw[i]] = raw[i];
      }
      return res;
    }
    return raw;
  }
  function mergeAsArray(to2, from) {
    return to2 ? [...new Set([].concat(to2, from))] : from;
  }
  function mergeObjectOptions(to2, from) {
    return to2 ? extend(/* @__PURE__ */ Object.create(null), to2, from) : from;
  }
  function mergeEmitsOrPropsOptions(to2, from) {
    if (to2) {
      if (isArray(to2) && isArray(from)) {
        return [.../* @__PURE__ */ new Set([...to2, ...from])];
      }
      return extend(
        /* @__PURE__ */ Object.create(null),
        normalizePropsOrEmits(to2),
        normalizePropsOrEmits(from != null ? from : {})
      );
    } else {
      return from;
    }
  }
  function mergeWatchOptions(to2, from) {
    if (!to2)
      return from;
    if (!from)
      return to2;
    const merged = extend(/* @__PURE__ */ Object.create(null), to2);
    for (const key in from) {
      merged[key] = mergeAsArray(to2[key], from[key]);
    }
    return merged;
  }
  function createAppContext() {
    return {
      app: null,
      config: {
        isNativeTag: NO,
        performance: false,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: /* @__PURE__ */ Object.create(null),
      optionsCache: /* @__PURE__ */ new WeakMap(),
      propsCache: /* @__PURE__ */ new WeakMap(),
      emitsCache: /* @__PURE__ */ new WeakMap()
    };
  }
  var uid$1 = 0;
  function createAppAPI(render35, hydrate) {
    return function createApp2(rootComponent, rootProps = null) {
      if (!isFunction(rootComponent)) {
        rootComponent = extend({}, rootComponent);
      }
      if (rootProps != null && !isObject(rootProps)) {
        warn$1(`root props passed to app.mount() must be an object.`);
        rootProps = null;
      }
      const context = createAppContext();
      const installedPlugins = /* @__PURE__ */ new WeakSet();
      const pluginCleanupFns = [];
      let isMounted = false;
      const app = context.app = {
        _uid: uid$1++,
        _component: rootComponent,
        _props: rootProps,
        _container: null,
        _context: context,
        _instance: null,
        version,
        get config() {
          return context.config;
        },
        set config(v) {
          if (true) {
            warn$1(
              `app.config cannot be replaced. Modify individual options instead.`
            );
          }
        },
        use(plugin, ...options) {
          if (installedPlugins.has(plugin)) {
            warn$1(`Plugin has already been applied to target app.`);
          } else if (plugin && isFunction(plugin.install)) {
            installedPlugins.add(plugin);
            plugin.install(app, ...options);
          } else if (isFunction(plugin)) {
            installedPlugins.add(plugin);
            plugin(app, ...options);
          } else if (true) {
            warn$1(
              `A plugin must either be a function or an object with an "install" function.`
            );
          }
          return app;
        },
        mixin(mixin) {
          if (true) {
            if (!context.mixins.includes(mixin)) {
              context.mixins.push(mixin);
            } else if (true) {
              warn$1(
                "Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : "")
              );
            }
          } else if (true) {
            warn$1("Mixins are only available in builds supporting Options API");
          }
          return app;
        },
        component(name, component) {
          if (true) {
            validateComponentName(name, context.config);
          }
          if (!component) {
            return context.components[name];
          }
          if (context.components[name]) {
            warn$1(`Component "${name}" has already been registered in target app.`);
          }
          context.components[name] = component;
          return app;
        },
        directive(name, directive2) {
          if (true) {
            validateDirectiveName(name);
          }
          if (!directive2) {
            return context.directives[name];
          }
          if (context.directives[name]) {
            warn$1(`Directive "${name}" has already been registered in target app.`);
          }
          context.directives[name] = directive2;
          return app;
        },
        mount(rootContainer, isHydrate, namespace) {
          if (!isMounted) {
            if (rootContainer.__vue_app__) {
              warn$1(
                `There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`
              );
            }
            const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
            vnode.appContext = context;
            if (namespace === true) {
              namespace = "svg";
            } else if (namespace === false) {
              namespace = void 0;
            }
            if (true) {
              context.reload = () => {
                const cloned = cloneVNode(vnode);
                cloned.el = null;
                render35(cloned, rootContainer, namespace);
              };
            }
            if (isHydrate && hydrate) {
              hydrate(vnode, rootContainer);
            } else {
              render35(vnode, rootContainer, namespace);
            }
            isMounted = true;
            app._container = rootContainer;
            rootContainer.__vue_app__ = app;
            if (true) {
              app._instance = vnode.component;
              devtoolsInitApp(app, version);
            }
            return getComponentPublicInstance(vnode.component);
          } else if (true) {
            warn$1(
              `App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``
            );
          }
        },
        onUnmount(cleanupFn) {
          if (typeof cleanupFn !== "function") {
            warn$1(
              `Expected function as first argument to app.onUnmount(), but got ${typeof cleanupFn}`
            );
          }
          pluginCleanupFns.push(cleanupFn);
        },
        unmount() {
          if (isMounted) {
            callWithAsyncErrorHandling(
              pluginCleanupFns,
              app._instance,
              16
            );
            render35(null, app._container);
            if (true) {
              app._instance = null;
              devtoolsUnmountApp(app);
            }
            delete app._container.__vue_app__;
          } else if (true) {
            warn$1(`Cannot unmount an app that is not mounted.`);
          }
        },
        provide(key, value) {
          if (key in context.provides) {
            if (hasOwn(context.provides, key)) {
              warn$1(
                `App already provides property with key "${String(key)}". It will be overwritten with the new value.`
              );
            } else {
              warn$1(
                `App already provides property with key "${String(key)}" inherited from its parent element. It will be overwritten with the new value.`
              );
            }
          }
          context.provides[key] = value;
          return app;
        },
        runWithContext(fn2) {
          const lastApp = currentApp;
          currentApp = app;
          try {
            return fn2();
          } finally {
            currentApp = lastApp;
          }
        }
      };
      return app;
    };
  }
  var currentApp = null;
  function provide(key, value) {
    if (!currentInstance) {
      if (true) {
        warn$1(`provide() can only be used inside setup().`);
      }
    } else {
      let provides = currentInstance.provides;
      const parentProvides = currentInstance.parent && currentInstance.parent.provides;
      if (parentProvides === provides) {
        provides = currentInstance.provides = Object.create(parentProvides);
      }
      provides[key] = value;
    }
  }
  function inject(key, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
      let provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null || instance.ce ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
      if (provides && key in provides) {
        return provides[key];
      } else if (arguments.length > 1) {
        return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
      } else if (true) {
        warn$1(`injection "${String(key)}" not found.`);
      }
    } else if (true) {
      warn$1(`inject() can only be used inside setup() or functional components.`);
    }
  }
  function hasInjectionContext() {
    return !!(currentInstance || currentRenderingInstance || currentApp);
  }
  var internalObjectProto = {};
  var createInternalObject = () => Object.create(internalObjectProto);
  var isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
  function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = createInternalObject();
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for (const key in instance.propsOptions[0]) {
      if (!(key in props)) {
        props[key] = void 0;
      }
    }
    if (true) {
      validateProps(rawProps || {}, props, instance);
    }
    if (isStateful) {
      instance.props = isSSR ? props : shallowReactive(props);
    } else {
      if (!instance.type.props) {
        instance.props = attrs;
      } else {
        instance.props = props;
      }
    }
    instance.attrs = attrs;
  }
  function isInHmrContext(instance) {
    while (instance) {
      if (instance.type.__hmrId)
        return true;
      instance = instance.parent;
    }
  }
  function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const {
      props,
      attrs,
      vnode: { patchFlag }
    } = instance;
    const rawCurrentProps = toRaw(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (!isInHmrContext(instance) && (optimized || patchFlag > 0) && !(patchFlag & 16)) {
      if (patchFlag & 8) {
        const propsToUpdate = instance.vnode.dynamicProps;
        for (let i = 0; i < propsToUpdate.length; i++) {
          let key = propsToUpdate[i];
          if (isEmitListener(instance.emitsOptions, key)) {
            continue;
          }
          const value = rawProps[key];
          if (options) {
            if (hasOwn(attrs, key)) {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            } else {
              const camelizedKey = camelize(key);
              props[camelizedKey] = resolvePropValue(
                options,
                rawCurrentProps,
                camelizedKey,
                value,
                instance,
                false
              );
            }
          } else {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
    } else {
      if (setFullProps(instance, rawProps, props, attrs)) {
        hasAttrsChanged = true;
      }
      let kebabKey;
      for (const key in rawCurrentProps) {
        if (!rawProps || !hasOwn(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
          if (options) {
            if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
              props[key] = resolvePropValue(
                options,
                rawCurrentProps,
                key,
                void 0,
                instance,
                true
              );
            }
          } else {
            delete props[key];
          }
        }
      }
      if (attrs !== rawCurrentProps) {
        for (const key in attrs) {
          if (!rawProps || !hasOwn(rawProps, key) && true) {
            delete attrs[key];
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (hasAttrsChanged) {
      trigger(instance.attrs, "set", "");
    }
    if (true) {
      validateProps(rawProps || {}, props, instance);
    }
  }
  function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
      for (let key in rawProps) {
        if (isReservedProp(key)) {
          continue;
        }
        const value = rawProps[key];
        let camelKey;
        if (options && hasOwn(options, camelKey = camelize(key))) {
          if (!needCastKeys || !needCastKeys.includes(camelKey)) {
            props[camelKey] = value;
          } else {
            (rawCastValues || (rawCastValues = {}))[camelKey] = value;
          }
        } else if (!isEmitListener(instance.emitsOptions, key)) {
          if (!(key in attrs) || value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (needCastKeys) {
      const rawCurrentProps = toRaw(props);
      const castValues = rawCastValues || EMPTY_OBJ;
      for (let i = 0; i < needCastKeys.length; i++) {
        const key = needCastKeys[i];
        props[key] = resolvePropValue(
          options,
          rawCurrentProps,
          key,
          castValues[key],
          instance,
          !hasOwn(castValues, key)
        );
      }
    }
    return hasAttrsChanged;
  }
  function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
      const hasDefault = hasOwn(opt, "default");
      if (hasDefault && value === void 0) {
        const defaultValue = opt.default;
        if (opt.type !== Function && !opt.skipFactory && isFunction(defaultValue)) {
          const { propsDefaults } = instance;
          if (key in propsDefaults) {
            value = propsDefaults[key];
          } else {
            const reset = setCurrentInstance(instance);
            value = propsDefaults[key] = defaultValue.call(
              null,
              props
            );
            reset();
          }
        } else {
          value = defaultValue;
        }
        if (instance.ce) {
          instance.ce._setProp(key, value);
        }
      }
      if (opt[0]) {
        if (isAbsent && !hasDefault) {
          value = false;
        } else if (opt[1] && (value === "" || value === hyphenate(key))) {
          value = true;
        }
      }
    }
    return value;
  }
  var mixinPropsCache = /* @__PURE__ */ new WeakMap();
  function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = asMixin ? mixinPropsCache : appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) {
      return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (!isFunction(comp)) {
      const extendProps = (raw2) => {
        hasExtends = true;
        const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
        extend(normalized, props);
        if (keys2)
          needCastKeys.push(...keys2);
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendProps);
      }
      if (comp.extends) {
        extendProps(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendProps);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject(comp)) {
        cache.set(comp, EMPTY_ARR);
      }
      return EMPTY_ARR;
    }
    if (isArray(raw)) {
      for (let i = 0; i < raw.length; i++) {
        if (!isString(raw[i])) {
          warn$1(`props must be strings when using array syntax.`, raw[i]);
        }
        const normalizedKey = camelize(raw[i]);
        if (validatePropName(normalizedKey)) {
          normalized[normalizedKey] = EMPTY_OBJ;
        }
      }
    } else if (raw) {
      if (!isObject(raw)) {
        warn$1(`invalid props options`, raw);
      }
      for (const key in raw) {
        const normalizedKey = camelize(key);
        if (validatePropName(normalizedKey)) {
          const opt = raw[key];
          const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : extend({}, opt);
          const propType = prop.type;
          let shouldCast = false;
          let shouldCastTrue = true;
          if (isArray(propType)) {
            for (let index = 0; index < propType.length; ++index) {
              const type = propType[index];
              const typeName = isFunction(type) && type.name;
              if (typeName === "Boolean") {
                shouldCast = true;
                break;
              } else if (typeName === "String") {
                shouldCastTrue = false;
              }
            }
          } else {
            shouldCast = isFunction(propType) && propType.name === "Boolean";
          }
          prop[0] = shouldCast;
          prop[1] = shouldCastTrue;
          if (shouldCast || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
    const res = [normalized, needCastKeys];
    if (isObject(comp)) {
      cache.set(comp, res);
    }
    return res;
  }
  function validatePropName(key) {
    if (key[0] !== "$" && !isReservedProp(key)) {
      return true;
    } else if (true) {
      warn$1(`Invalid prop name: "${key}" is a reserved property.`);
    }
    return false;
  }
  function getType(ctor) {
    if (ctor === null) {
      return "null";
    }
    if (typeof ctor === "function") {
      return ctor.name || "";
    } else if (typeof ctor === "object") {
      const name = ctor.constructor && ctor.constructor.name;
      return name || "";
    }
    return "";
  }
  function validateProps(rawProps, props, instance) {
    const resolvedValues = toRaw(props);
    const options = instance.propsOptions[0];
    const camelizePropsKey = Object.keys(rawProps).map((key) => camelize(key));
    for (const key in options) {
      let opt = options[key];
      if (opt == null)
        continue;
      validateProp(
        key,
        resolvedValues[key],
        opt,
        true ? shallowReadonly(resolvedValues) : resolvedValues,
        !camelizePropsKey.includes(key)
      );
    }
  }
  function validateProp(name, value, prop, props, isAbsent) {
    const { type, required, validator, skipCheck } = prop;
    if (required && isAbsent) {
      warn$1('Missing required prop: "' + name + '"');
      return;
    }
    if (value == null && !required) {
      return;
    }
    if (type != null && type !== true && !skipCheck) {
      let isValid3 = false;
      const types = isArray(type) ? type : [type];
      const expectedTypes = [];
      for (let i = 0; i < types.length && !isValid3; i++) {
        const { valid, expectedType } = assertType(value, types[i]);
        expectedTypes.push(expectedType || "");
        isValid3 = valid;
      }
      if (!isValid3) {
        warn$1(getInvalidTypeMessage(name, value, expectedTypes));
        return;
      }
    }
    if (validator && !validator(value, props)) {
      warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
    }
  }
  var isSimpleType = /* @__PURE__ */ makeMap(
    "String,Number,Boolean,Function,Symbol,BigInt"
  );
  function assertType(value, type) {
    let valid;
    const expectedType = getType(type);
    if (expectedType === "null") {
      valid = value === null;
    } else if (isSimpleType(expectedType)) {
      const t = typeof value;
      valid = t === expectedType.toLowerCase();
      if (!valid && t === "object") {
        valid = value instanceof type;
      }
    } else if (expectedType === "Object") {
      valid = isObject(value);
    } else if (expectedType === "Array") {
      valid = isArray(value);
    } else {
      valid = value instanceof type;
    }
    return {
      valid,
      expectedType
    };
  }
  function getInvalidTypeMessage(name, value, expectedTypes) {
    if (expectedTypes.length === 0) {
      return `Prop type [] for prop "${name}" won't match anything. Did you mean to use type Array instead?`;
    }
    let message2 = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize).join(" | ")}`;
    const expectedType = expectedTypes[0];
    const receivedType = toRawType(value);
    const expectedValue = styleValue(value, expectedType);
    const receivedValue = styleValue(value, receivedType);
    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
      message2 += ` with value ${expectedValue}`;
    }
    message2 += `, got ${receivedType} `;
    if (isExplicable(receivedType)) {
      message2 += `with value ${receivedValue}.`;
    }
    return message2;
  }
  function styleValue(value, type) {
    if (type === "String") {
      return `"${value}"`;
    } else if (type === "Number") {
      return `${Number(value)}`;
    } else {
      return `${value}`;
    }
  }
  function isExplicable(type) {
    const explicitTypes = ["string", "number", "boolean"];
    return explicitTypes.some((elem) => type.toLowerCase() === elem);
  }
  function isBoolean(...args) {
    return args.some((elem) => elem.toLowerCase() === "boolean");
  }
  var isInternalKey = (key) => key[0] === "_" || key === "$stable";
  var normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
  var normalizeSlot = (key, rawSlot, ctx) => {
    if (rawSlot._n) {
      return rawSlot;
    }
    const normalized = withCtx((...args) => {
      if (currentInstance && !(ctx === null && currentRenderingInstance) && !(ctx && ctx.root !== currentInstance.root)) {
        warn$1(
          `Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
        );
      }
      return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
  };
  var normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
      if (isInternalKey(key))
        continue;
      const value = rawSlots[key];
      if (isFunction(value)) {
        slots[key] = normalizeSlot(key, value, ctx);
      } else if (value != null) {
        if (true) {
          warn$1(
            `Non-function value encountered for slot "${key}". Prefer function slots for better performance.`
          );
        }
        const normalized = normalizeSlotValue(value);
        slots[key] = () => normalized;
      }
    }
  };
  var normalizeVNodeSlots = (instance, children) => {
    if (!isKeepAlive(instance.vnode) && true) {
      warn$1(
        `Non-function value encountered for default slot. Prefer function slots for better performance.`
      );
    }
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
  };
  var assignSlots = (slots, children, optimized) => {
    for (const key in children) {
      if (optimized || !isInternalKey(key)) {
        slots[key] = children[key];
      }
    }
  };
  var initSlots = (instance, children, optimized) => {
    const slots = instance.slots = createInternalObject();
    if (instance.vnode.shapeFlag & 32) {
      const cacheIndexes = children.__;
      if (cacheIndexes)
        def(slots, "__", cacheIndexes, true);
      const type = children._;
      if (type) {
        assignSlots(slots, children, optimized);
        if (optimized) {
          def(slots, "_", type, true);
        }
      } else {
        normalizeObjectSlots(children, slots);
      }
    } else if (children) {
      normalizeVNodeSlots(instance, children);
    }
  };
  var updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = EMPTY_OBJ;
    if (vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        if (isHmrUpdating) {
          assignSlots(slots, children, optimized);
          trigger(instance, "set", "$slots");
        } else if (optimized && type === 1) {
          needDeletionCheck = false;
        } else {
          assignSlots(slots, children, optimized);
        }
      } else {
        needDeletionCheck = !children.$stable;
        normalizeObjectSlots(children, slots);
      }
      deletionComparisonTarget = children;
    } else if (children) {
      normalizeVNodeSlots(instance, children);
      deletionComparisonTarget = { default: 1 };
    }
    if (needDeletionCheck) {
      for (const key in slots) {
        if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
          delete slots[key];
        }
      }
    }
  };
  var supported;
  var perf;
  function startMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
      perf.mark(`vue-${type}-${instance.uid}`);
    }
    if (true) {
      devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
    }
  }
  function endMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
      const startTag = `vue-${type}-${instance.uid}`;
      const endTag = startTag + `:end`;
      perf.mark(endTag);
      perf.measure(
        `<${formatComponentName(instance, instance.type)}> ${type}`,
        startTag,
        endTag
      );
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
    }
    if (true) {
      devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
    }
  }
  function isSupported() {
    if (supported !== void 0) {
      return supported;
    }
    if (typeof window !== "undefined" && window.performance) {
      supported = true;
      perf = window.performance;
    } else {
      supported = false;
    }
    return supported;
  }
  function initFeatureFlags() {
    const needWarn = [];
    if (false) {
      needWarn.push(`__VUE_OPTIONS_API__`);
      getGlobalThis().__VUE_OPTIONS_API__ = true;
    }
    if (false) {
      needWarn.push(`__VUE_PROD_DEVTOOLS__`);
      getGlobalThis().__VUE_PROD_DEVTOOLS__ = false;
    }
    if (typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ !== "boolean") {
      needWarn.push(`__VUE_PROD_HYDRATION_MISMATCH_DETAILS__`);
      getGlobalThis().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = false;
    }
    if (needWarn.length) {
      const multi = needWarn.length > 1;
      console.warn(
        `Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
      );
    }
  }
  var queuePostRenderEffect = queueEffectWithSuspense;
  function createRenderer(options) {
    return baseCreateRenderer(options);
  }
  function baseCreateRenderer(options, createHydrationFns) {
    {
      initFeatureFlags();
    }
    const target = getGlobalThis();
    target.__VUE__ = true;
    if (true) {
      setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
    }
    const {
      insert: hostInsert,
      remove: hostRemove,
      patchProp: hostPatchProp,
      createElement: hostCreateElement,
      createText: hostCreateText,
      createComment: hostCreateComment,
      setText: hostSetText,
      setElementText: hostSetElementText,
      parentNode: hostParentNode,
      nextSibling: hostNextSibling,
      setScopeId: hostSetScopeId = NOOP,
      insertStaticContent: hostInsertStaticContent
    } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren) => {
      if (n1 === n2) {
        return;
      }
      if (n1 && !isSameVNodeType(n1, n2)) {
        anchor = getNextHostNode(n1);
        unmount(n1, parentComponent, parentSuspense, true);
        n1 = null;
      }
      if (n2.patchFlag === -2) {
        optimized = false;
        n2.dynamicChildren = null;
      }
      const { type, ref: ref2, shapeFlag } = n2;
      switch (type) {
        case Text:
          processText(n1, n2, container, anchor);
          break;
        case Comment:
          processCommentNode(n1, n2, container, anchor);
          break;
        case Static:
          if (n1 == null) {
            mountStaticNode(n2, container, anchor, namespace);
          } else if (true) {
            patchStaticNode(n1, n2, container, namespace);
          }
          break;
        case Fragment:
          processFragment(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          break;
        default:
          if (shapeFlag & 1) {
            processElement(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 6) {
            processComponent(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 64) {
            type.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else if (shapeFlag & 128) {
            type.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else if (true) {
            warn$1("Invalid VNode type:", type, `(${typeof type})`);
          }
      }
      if (ref2 != null && parentComponent) {
        setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
      } else if (ref2 == null && n1 && n1.ref != null) {
        setRef(n1.ref, null, parentSuspense, n1, true);
      }
    };
    const processText = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateText(n2.children),
          container,
          anchor
        );
      } else {
        const el = n2.el = n1.el;
        if (n2.children !== n1.children) {
          hostSetText(el, n2.children);
        }
      }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateComment(n2.children || ""),
          container,
          anchor
        );
      } else {
        n2.el = n1.el;
      }
    };
    const mountStaticNode = (n2, container, anchor, namespace) => {
      [n2.el, n2.anchor] = hostInsertStaticContent(
        n2.children,
        container,
        anchor,
        namespace,
        n2.el,
        n2.anchor
      );
    };
    const patchStaticNode = (n1, n2, container, namespace) => {
      if (n2.children !== n1.children) {
        const anchor = hostNextSibling(n1.anchor);
        removeStaticNode(n1);
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor,
          namespace
        );
      } else {
        n2.el = n1.el;
        n2.anchor = n1.anchor;
      }
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostInsert(el, container, nextSibling);
        el = next;
      }
      hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostRemove(el);
        el = next;
      }
      hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      if (n2.type === "svg") {
        namespace = "svg";
      } else if (n2.type === "math") {
        namespace = "mathml";
      }
      if (n1 == null) {
        mountElement(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        patchElement(
          n1,
          n2,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let el;
      let vnodeHook;
      const { props, shapeFlag, transition, dirs } = vnode;
      el = vnode.el = hostCreateElement(
        vnode.type,
        namespace,
        props && props.is,
        props
      );
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(
          vnode.children,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(vnode, namespace),
          slotScopeIds,
          optimized
        );
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
      if (props) {
        for (const key in props) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(el, key, null, props[key], namespace, parentComponent);
          }
        }
        if ("value" in props) {
          hostPatchProp(el, "value", null, props.value, namespace);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      if (true) {
        def(el, "__vnode", vnode, true);
        def(el, "__vueParentComponent", parentComponent, true);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      const needCallTransitionHooks = needTransition(parentSuspense, transition);
      if (needCallTransitionHooks) {
        transition.beforeEnter(el);
      }
      hostInsert(el, container, anchor);
      if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
      if (scopeId) {
        hostSetScopeId(el, scopeId);
      }
      if (slotScopeIds) {
        for (let i = 0; i < slotScopeIds.length; i++) {
          hostSetScopeId(el, slotScopeIds[i]);
        }
      }
      if (parentComponent) {
        let subTree = parentComponent.subTree;
        if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
          subTree = filterSingleRoot(subTree.children) || subTree;
        }
        if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
          const parentVNode = parentComponent.vnode;
          setScopeId(
            el,
            parentVNode,
            parentVNode.scopeId,
            parentVNode.slotScopeIds,
            parentComponent.parent
          );
        }
      }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
      for (let i = start; i < children.length; i++) {
        const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
        patch(
          null,
          child,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const el = n2.el = n1.el;
      if (true) {
        el.__vnode = n2;
      }
      let { patchFlag, dynamicChildren, dirs } = n2;
      patchFlag |= n1.patchFlag & 16;
      const oldProps = n1.props || EMPTY_OBJ;
      const newProps = n2.props || EMPTY_OBJ;
      let vnodeHook;
      parentComponent && toggleRecurse(parentComponent, false);
      if (vnodeHook = newProps.onVnodeBeforeUpdate) {
        invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
      }
      if (dirs) {
        invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
      }
      parentComponent && toggleRecurse(parentComponent, true);
      if (isHmrUpdating) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
        hostSetElementText(el, "");
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          el,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds
        );
        if (true) {
          traverseStaticChildren(n1, n2);
        }
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds,
          false
        );
      }
      if (patchFlag > 0) {
        if (patchFlag & 16) {
          patchProps(el, oldProps, newProps, parentComponent, namespace);
        } else {
          if (patchFlag & 2) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, "class", null, newProps.class, namespace);
            }
          }
          if (patchFlag & 4) {
            hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
          }
          if (patchFlag & 8) {
            const propsToUpdate = n2.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
              const key = propsToUpdate[i];
              const prev = oldProps[key];
              const next = newProps[key];
              if (next !== prev || key === "value") {
                hostPatchProp(el, key, prev, next, namespace, parentComponent);
              }
            }
          }
        }
        if (patchFlag & 1) {
          if (n1.children !== n2.children) {
            hostSetElementText(el, n2.children);
          }
        }
      } else if (!optimized && dynamicChildren == null) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      }
      if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
      }
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
      for (let i = 0; i < newChildren.length; i++) {
        const oldVNode = oldChildren[i];
        const newVNode = newChildren[i];
        const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64 | 128)) ? hostParentNode(oldVNode.el) : fallbackContainer;
        patch(
          oldVNode,
          newVNode,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          true
        );
      }
    };
    const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
      if (oldProps !== newProps) {
        if (oldProps !== EMPTY_OBJ) {
          for (const key in oldProps) {
            if (!isReservedProp(key) && !(key in newProps)) {
              hostPatchProp(
                el,
                key,
                oldProps[key],
                null,
                namespace,
                parentComponent
              );
            }
          }
        }
        for (const key in newProps) {
          if (isReservedProp(key))
            continue;
          const next = newProps[key];
          const prev = oldProps[key];
          if (next !== prev && key !== "value") {
            hostPatchProp(el, key, prev, next, namespace, parentComponent);
          }
        }
        if ("value" in newProps) {
          hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
        }
      }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
      const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
      let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
      if (isHmrUpdating || patchFlag & 2048) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      if (n1 == null) {
        hostInsert(fragmentStartAnchor, container, anchor);
        hostInsert(fragmentEndAnchor, container, anchor);
        mountChildren(
          n2.children || [],
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            container,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds
          );
          if (true) {
            traverseStaticChildren(n1, n2);
          } else if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
            traverseStaticChildren(
              n1,
              n2,
              true
            );
          }
        } else {
          patchChildren(
            n1,
            n2,
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      n2.slotScopeIds = slotScopeIds;
      if (n1 == null) {
        if (n2.shapeFlag & 512) {
          parentComponent.ctx.activate(
            n2,
            container,
            anchor,
            namespace,
            optimized
          );
        } else {
          mountComponent2(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            optimized
          );
        }
      } else {
        updateComponent(n1, n2, optimized);
      }
    };
    const mountComponent2 = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
      const instance = initialVNode.component = createComponentInstance(
        initialVNode,
        parentComponent,
        parentSuspense
      );
      if (instance.type.__hmrId) {
        registerHMR(instance);
      }
      if (true) {
        pushWarningContext(initialVNode);
        startMeasure(instance, `mount`);
      }
      if (isKeepAlive(initialVNode)) {
        instance.ctx.renderer = internals;
      }
      {
        if (true) {
          startMeasure(instance, `init`);
        }
        setupComponent(instance, false, optimized);
        if (true) {
          endMeasure(instance, `init`);
        }
      }
      if (isHmrUpdating)
        initialVNode.el = null;
      if (instance.asyncDep) {
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
        if (!initialVNode.el) {
          const placeholder = instance.subTree = createVNode(Comment);
          processCommentNode(null, placeholder, container, anchor);
        }
      } else {
        setupRenderEffect(
          instance,
          initialVNode,
          container,
          anchor,
          parentSuspense,
          namespace,
          optimized
        );
      }
      if (true) {
        popWarningContext();
        endMeasure(instance, `mount`);
      }
    };
    const updateComponent = (n1, n2, optimized) => {
      const instance = n2.component = n1.component;
      if (shouldUpdateComponent(n1, n2, optimized)) {
        if (instance.asyncDep && !instance.asyncResolved) {
          if (true) {
            pushWarningContext(n2);
          }
          updateComponentPreRender(instance, n2, optimized);
          if (true) {
            popWarningContext();
          }
          return;
        } else {
          instance.next = n2;
          instance.update();
        }
      } else {
        n2.el = n1.el;
        instance.vnode = n2;
      }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
      const componentUpdateFn = () => {
        if (!instance.isMounted) {
          let vnodeHook;
          const { el, props } = initialVNode;
          const { bm, m, parent, root, type } = instance;
          const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
          toggleRecurse(instance, false);
          if (bm) {
            invokeArrayFns(bm);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
            invokeVNodeHook(vnodeHook, parent, initialVNode);
          }
          toggleRecurse(instance, true);
          if (el && hydrateNode) {
            const hydrateSubTree = () => {
              if (true) {
                startMeasure(instance, `render`);
              }
              instance.subTree = renderComponentRoot(instance);
              if (true) {
                endMeasure(instance, `render`);
              }
              if (true) {
                startMeasure(instance, `hydrate`);
              }
              hydrateNode(
                el,
                instance.subTree,
                instance,
                parentSuspense,
                null
              );
              if (true) {
                endMeasure(instance, `hydrate`);
              }
            };
            if (isAsyncWrapperVNode && type.__asyncHydrate) {
              type.__asyncHydrate(
                el,
                instance,
                hydrateSubTree
              );
            } else {
              hydrateSubTree();
            }
          } else {
            if (root.ce && root.ce._def.shadowRoot !== false) {
              root.ce._injectChildStyle(type);
            }
            if (true) {
              startMeasure(instance, `render`);
            }
            const subTree = instance.subTree = renderComponentRoot(instance);
            if (true) {
              endMeasure(instance, `render`);
            }
            if (true) {
              startMeasure(instance, `patch`);
            }
            patch(
              null,
              subTree,
              container,
              anchor,
              instance,
              parentSuspense,
              namespace
            );
            if (true) {
              endMeasure(instance, `patch`);
            }
            initialVNode.el = subTree.el;
          }
          if (m) {
            queuePostRenderEffect(m, parentSuspense);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
            const scopedInitialVNode = initialVNode;
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
              parentSuspense
            );
          }
          if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }
          instance.isMounted = true;
          if (true) {
            devtoolsComponentAdded(instance);
          }
          initialVNode = container = anchor = null;
        } else {
          let { next, bu, u, parent, vnode } = instance;
          {
            const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
            if (nonHydratedAsyncRoot) {
              if (next) {
                next.el = vnode.el;
                updateComponentPreRender(instance, next, optimized);
              }
              nonHydratedAsyncRoot.asyncDep.then(() => {
                if (!instance.isUnmounted) {
                  componentUpdateFn();
                }
              });
              return;
            }
          }
          let originNext = next;
          let vnodeHook;
          if (true) {
            pushWarningContext(next || instance.vnode);
          }
          toggleRecurse(instance, false);
          if (next) {
            next.el = vnode.el;
            updateComponentPreRender(instance, next, optimized);
          } else {
            next = vnode;
          }
          if (bu) {
            invokeArrayFns(bu);
          }
          if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parent, next, vnode);
          }
          toggleRecurse(instance, true);
          if (true) {
            startMeasure(instance, `render`);
          }
          const nextTree = renderComponentRoot(instance);
          if (true) {
            endMeasure(instance, `render`);
          }
          const prevTree = instance.subTree;
          instance.subTree = nextTree;
          if (true) {
            startMeasure(instance, `patch`);
          }
          patch(
            prevTree,
            nextTree,
            hostParentNode(prevTree.el),
            getNextHostNode(prevTree),
            instance,
            parentSuspense,
            namespace
          );
          if (true) {
            endMeasure(instance, `patch`);
          }
          next.el = nextTree.el;
          if (originNext === null) {
            updateHOCHostEl(instance, nextTree.el);
          }
          if (u) {
            queuePostRenderEffect(u, parentSuspense);
          }
          if (vnodeHook = next.props && next.props.onVnodeUpdated) {
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, next, vnode),
              parentSuspense
            );
          }
          if (true) {
            devtoolsComponentUpdated(instance);
          }
          if (true) {
            popWarningContext();
          }
        }
      };
      instance.scope.on();
      const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
      instance.scope.off();
      const update = instance.update = effect2.run.bind(effect2);
      const job = instance.job = effect2.runIfDirty.bind(effect2);
      job.i = instance;
      job.id = instance.uid;
      effect2.scheduler = () => queueJob(job);
      toggleRecurse(instance, true);
      if (true) {
        effect2.onTrack = instance.rtc ? (e) => invokeArrayFns(instance.rtc, e) : void 0;
        effect2.onTrigger = instance.rtg ? (e) => invokeArrayFns(instance.rtg, e) : void 0;
      }
      update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
      nextVNode.component = instance;
      const prevProps = instance.vnode.props;
      instance.vnode = nextVNode;
      instance.next = null;
      updateProps(instance, nextVNode.props, prevProps, optimized);
      updateSlots(instance, nextVNode.children, optimized);
      pauseTracking();
      flushPreFlushCbs(instance);
      resetTracking();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
      const c1 = n1 && n1.children;
      const prevShapeFlag = n1 ? n1.shapeFlag : 0;
      const c2 = n2.children;
      const { patchFlag, shapeFlag } = n2;
      if (patchFlag > 0) {
        if (patchFlag & 128) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        } else if (patchFlag & 256) {
          patchUnkeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        }
      }
      if (shapeFlag & 8) {
        if (prevShapeFlag & 16) {
          unmountChildren(c1, parentComponent, parentSuspense);
        }
        if (c2 !== c1) {
          hostSetElementText(container, c2);
        }
      } else {
        if (prevShapeFlag & 16) {
          if (shapeFlag & 16) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
          if (prevShapeFlag & 8) {
            hostSetElementText(container, "");
          }
          if (shapeFlag & 16) {
            mountChildren(
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      c1 = c1 || EMPTY_ARR;
      c2 = c2 || EMPTY_ARR;
      const oldLength = c1.length;
      const newLength = c2.length;
      const commonLength = Math.min(oldLength, newLength);
      let i;
      for (i = 0; i < commonLength; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        patch(
          c1[i],
          nextChild,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
      if (oldLength > newLength) {
        unmountChildren(
          c1,
          parentComponent,
          parentSuspense,
          true,
          false,
          commonLength
        );
      } else {
        mountChildren(
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized,
          commonLength
        );
      }
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let i = 0;
      const l2 = c2.length;
      let e1 = c1.length - 1;
      let e2 = l2 - 1;
      while (i <= e1 && i <= e2) {
        const n1 = c1[i];
        const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        i++;
      }
      while (i <= e1 && i <= e2) {
        const n1 = c1[e1];
        const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        e1--;
        e2--;
      }
      if (i > e1) {
        if (i <= e2) {
          const nextPos = e2 + 1;
          const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
          while (i <= e2) {
            patch(
              null,
              c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            i++;
          }
        }
      } else if (i > e2) {
        while (i <= e1) {
          unmount(c1[i], parentComponent, parentSuspense, true);
          i++;
        }
      } else {
        const s1 = i;
        const s2 = i;
        const keyToNewIndexMap = /* @__PURE__ */ new Map();
        for (i = s2; i <= e2; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (nextChild.key != null) {
            if (keyToNewIndexMap.has(nextChild.key)) {
              warn$1(
                `Duplicate keys found during update:`,
                JSON.stringify(nextChild.key),
                `Make sure keys are unique.`
              );
            }
            keyToNewIndexMap.set(nextChild.key, i);
          }
        }
        let j;
        let patched = 0;
        const toBePatched = e2 - s2 + 1;
        let moved = false;
        let maxNewIndexSoFar = 0;
        const newIndexToOldIndexMap = new Array(toBePatched);
        for (i = 0; i < toBePatched; i++)
          newIndexToOldIndexMap[i] = 0;
        for (i = s1; i <= e1; i++) {
          const prevChild = c1[i];
          if (patched >= toBePatched) {
            unmount(prevChild, parentComponent, parentSuspense, true);
            continue;
          }
          let newIndex;
          if (prevChild.key != null) {
            newIndex = keyToNewIndexMap.get(prevChild.key);
          } else {
            for (j = s2; j <= e2; j++) {
              if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                newIndex = j;
                break;
              }
            }
          }
          if (newIndex === void 0) {
            unmount(prevChild, parentComponent, parentSuspense, true);
          } else {
            newIndexToOldIndexMap[newIndex - s2] = i + 1;
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            patch(
              prevChild,
              c2[newIndex],
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            patched++;
          }
        }
        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
        j = increasingNewIndexSequence.length - 1;
        for (i = toBePatched - 1; i >= 0; i--) {
          const nextIndex = s2 + i;
          const nextChild = c2[nextIndex];
          const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
          if (newIndexToOldIndexMap[i] === 0) {
            patch(
              null,
              nextChild,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (moved) {
            if (j < 0 || i !== increasingNewIndexSequence[j]) {
              move(nextChild, container, anchor, 2);
            } else {
              j--;
            }
          }
        }
      }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
      const { el, type, transition, children, shapeFlag } = vnode;
      if (shapeFlag & 6) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }
      if (shapeFlag & 128) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }
      if (shapeFlag & 64) {
        type.move(vnode, container, anchor, internals);
        return;
      }
      if (type === Fragment) {
        hostInsert(el, container, anchor);
        for (let i = 0; i < children.length; i++) {
          move(children[i], container, anchor, moveType);
        }
        hostInsert(vnode.anchor, container, anchor);
        return;
      }
      if (type === Static) {
        moveStaticNode(vnode, container, anchor);
        return;
      }
      const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
      if (needTransition2) {
        if (moveType === 0) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(() => transition.enter(el), parentSuspense);
        } else {
          const { leave, delayLeave, afterLeave } = transition;
          const remove22 = () => {
            if (vnode.ctx.isUnmounted) {
              hostRemove(el);
            } else {
              hostInsert(el, container, anchor);
            }
          };
          const performLeave = () => {
            leave(el, () => {
              remove22();
              afterLeave && afterLeave();
            });
          };
          if (delayLeave) {
            delayLeave(el, remove22, performLeave);
          } else {
            performLeave();
          }
        }
      } else {
        hostInsert(el, container, anchor);
      }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
      const {
        type,
        props,
        ref: ref2,
        children,
        dynamicChildren,
        shapeFlag,
        patchFlag,
        dirs,
        cacheIndex
      } = vnode;
      if (patchFlag === -2) {
        optimized = false;
      }
      if (ref2 != null) {
        pauseTracking();
        setRef(ref2, null, parentSuspense, vnode, true);
        resetTracking();
      }
      if (cacheIndex != null) {
        parentComponent.renderCache[cacheIndex] = void 0;
      }
      if (shapeFlag & 256) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }
      const shouldInvokeDirs = shapeFlag & 1 && dirs;
      const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
      let vnodeHook;
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
      if (shapeFlag & 6) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
        if (shapeFlag & 128) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }
        if (shouldInvokeDirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
        }
        if (shapeFlag & 64) {
          vnode.type.remove(
            vnode,
            parentComponent,
            parentSuspense,
            internals,
            doRemove
          );
        } else if (dynamicChildren && !dynamicChildren.hasOnce && (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
          unmountChildren(
            dynamicChildren,
            parentComponent,
            parentSuspense,
            false,
            true
          );
        } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
          unmountChildren(children, parentComponent, parentSuspense);
        }
        if (doRemove) {
          remove3(vnode);
        }
      }
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
      }
    };
    const remove3 = (vnode) => {
      const { type, el, anchor, transition } = vnode;
      if (type === Fragment) {
        if (vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {
          vnode.children.forEach((child) => {
            if (child.type === Comment) {
              hostRemove(child.el);
            } else {
              remove3(child);
            }
          });
        } else {
          removeFragment(el, anchor);
        }
        return;
      }
      if (type === Static) {
        removeStaticNode(vnode);
        return;
      }
      const performRemove = () => {
        hostRemove(el);
        if (transition && !transition.persisted && transition.afterLeave) {
          transition.afterLeave();
        }
      };
      if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
        const { leave, delayLeave } = transition;
        const performLeave = () => leave(el, performRemove);
        if (delayLeave) {
          delayLeave(vnode.el, performRemove, performLeave);
        } else {
          performLeave();
        }
      } else {
        performRemove();
      }
    };
    const removeFragment = (cur, end) => {
      let next;
      while (cur !== end) {
        next = hostNextSibling(cur);
        hostRemove(cur);
        cur = next;
      }
      hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
      if (instance.type.__hmrId) {
        unregisterHMR(instance);
      }
      const {
        bum,
        scope,
        job,
        subTree,
        um,
        m,
        a,
        parent,
        slots: { __: slotCacheKeys }
      } = instance;
      invalidateMount(m);
      invalidateMount(a);
      if (bum) {
        invokeArrayFns(bum);
      }
      if (parent && isArray(slotCacheKeys)) {
        slotCacheKeys.forEach((v) => {
          parent.renderCache[v] = void 0;
        });
      }
      scope.stop();
      if (job) {
        job.flags |= 8;
        unmount(subTree, instance, parentSuspense, doRemove);
      }
      if (um) {
        queuePostRenderEffect(um, parentSuspense);
      }
      queuePostRenderEffect(() => {
        instance.isUnmounted = true;
      }, parentSuspense);
      if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
        parentSuspense.deps--;
        if (parentSuspense.deps === 0) {
          parentSuspense.resolve();
        }
      }
      if (true) {
        devtoolsComponentRemoved(instance);
      }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
      for (let i = start; i < children.length; i++) {
        unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
      }
    };
    const getNextHostNode = (vnode) => {
      if (vnode.shapeFlag & 6) {
        return getNextHostNode(vnode.component.subTree);
      }
      if (vnode.shapeFlag & 128) {
        return vnode.suspense.next();
      }
      const el = hostNextSibling(vnode.anchor || vnode.el);
      const teleportEnd = el && el[TeleportEndKey];
      return teleportEnd ? hostNextSibling(teleportEnd) : el;
    };
    let isFlushing = false;
    const render35 = (vnode, container, namespace) => {
      if (vnode == null) {
        if (container._vnode) {
          unmount(container._vnode, null, null, true);
        }
      } else {
        patch(
          container._vnode || null,
          vnode,
          container,
          null,
          null,
          null,
          namespace
        );
      }
      container._vnode = vnode;
      if (!isFlushing) {
        isFlushing = true;
        flushPreFlushCbs();
        flushPostFlushCbs();
        isFlushing = false;
      }
    };
    const internals = {
      p: patch,
      um: unmount,
      m: move,
      r: remove3,
      mt: mountComponent2,
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      n: getNextHostNode,
      o: options
    };
    let hydrate;
    let hydrateNode;
    if (createHydrationFns) {
      [hydrate, hydrateNode] = createHydrationFns(
        internals
      );
    }
    return {
      render: render35,
      hydrate,
      createApp: createAppAPI(render35, hydrate)
    };
  }
  function resolveChildrenNamespace({ type, props }, currentNamespace) {
    return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
  }
  function toggleRecurse({ effect: effect2, job }, allowed) {
    if (allowed) {
      effect2.flags |= 32;
      job.flags |= 4;
    } else {
      effect2.flags &= -33;
      job.flags &= -5;
    }
  }
  function needTransition(parentSuspense, transition) {
    return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
  }
  function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if (isArray(ch1) && isArray(ch2)) {
      for (let i = 0; i < ch1.length; i++) {
        const c1 = ch1[i];
        let c2 = ch2[i];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
          if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
            c2 = ch2[i] = cloneIfMounted(ch2[i]);
            c2.el = c1.el;
          }
          if (!shallow && c2.patchFlag !== -2)
            traverseStaticChildren(c1, c2);
        }
        if (c2.type === Text) {
          c2.el = c1.el;
        }
        if (c2.type === Comment && !c2.el) {
          c2.el = c1.el;
        }
        if (true) {
          c2.el && (c2.el.__vnode = c2);
        }
      }
    }
  }
  function getSequence(arr) {
    const p2 = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len = arr.length;
    for (i = 0; i < len; i++) {
      const arrI = arr[i];
      if (arrI !== 0) {
        j = result[result.length - 1];
        if (arr[j] < arrI) {
          p2[i] = j;
          result.push(i);
          continue;
        }
        u = 0;
        v = result.length - 1;
        while (u < v) {
          c = u + v >> 1;
          if (arr[result[c]] < arrI) {
            u = c + 1;
          } else {
            v = c;
          }
        }
        if (arrI < arr[result[u]]) {
          if (u > 0) {
            p2[i] = result[u - 1];
          }
          result[u] = i;
        }
      }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
      result[u] = v;
      v = p2[v];
    }
    return result;
  }
  function locateNonHydratedAsyncRoot(instance) {
    const subComponent = instance.subTree.component;
    if (subComponent) {
      if (subComponent.asyncDep && !subComponent.asyncResolved) {
        return subComponent;
      } else {
        return locateNonHydratedAsyncRoot(subComponent);
      }
    }
  }
  function invalidateMount(hooks) {
    if (hooks) {
      for (let i = 0; i < hooks.length; i++)
        hooks[i].flags |= 8;
    }
  }
  var ssrContextKey = Symbol.for("v-scx");
  var useSSRContext = () => {
    {
      const ctx = inject(ssrContextKey);
      if (!ctx) {
        warn$1(
          `Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`
        );
      }
      return ctx;
    }
  };
  function watchEffect(effect2, options) {
    return doWatch(effect2, null, options);
  }
  function watch2(source, cb, options) {
    if (!isFunction(cb)) {
      warn$1(
        `\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`
      );
    }
    return doWatch(source, cb, options);
  }
  function doWatch(source, cb, options = EMPTY_OBJ) {
    const { immediate, deep, flush, once } = options;
    if (!cb) {
      if (immediate !== void 0) {
        warn$1(
          `watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`
        );
      }
      if (deep !== void 0) {
        warn$1(
          `watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`
        );
      }
      if (once !== void 0) {
        warn$1(
          `watch() "once" option is only respected when using the watch(source, callback, options?) signature.`
        );
      }
    }
    const baseWatchOptions = extend({}, options);
    if (true)
      baseWatchOptions.onWarn = warn$1;
    const runsImmediately = cb && immediate || !cb && flush !== "post";
    let ssrCleanup;
    if (isInSSRComponentSetup) {
      if (flush === "sync") {
        const ctx = useSSRContext();
        ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
      } else if (!runsImmediately) {
        const watchStopHandle = () => {
        };
        watchStopHandle.stop = NOOP;
        watchStopHandle.resume = NOOP;
        watchStopHandle.pause = NOOP;
        return watchStopHandle;
      }
    }
    const instance = currentInstance;
    baseWatchOptions.call = (fn2, type, args) => callWithAsyncErrorHandling(fn2, instance, type, args);
    let isPre = false;
    if (flush === "post") {
      baseWatchOptions.scheduler = (job) => {
        queuePostRenderEffect(job, instance && instance.suspense);
      };
    } else if (flush !== "sync") {
      isPre = true;
      baseWatchOptions.scheduler = (job, isFirstRun) => {
        if (isFirstRun) {
          job();
        } else {
          queueJob(job);
        }
      };
    }
    baseWatchOptions.augmentJob = (job) => {
      if (cb) {
        job.flags |= 4;
      }
      if (isPre) {
        job.flags |= 2;
        if (instance) {
          job.id = instance.uid;
          job.i = instance;
        }
      }
    };
    const watchHandle = watch(source, cb, baseWatchOptions);
    if (isInSSRComponentSetup) {
      if (ssrCleanup) {
        ssrCleanup.push(watchHandle);
      } else if (runsImmediately) {
        watchHandle();
      }
    }
    return watchHandle;
  }
  function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if (isFunction(value)) {
      cb = value;
    } else {
      cb = value.handler;
      options = value;
    }
    const reset = setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    reset();
    return res;
  }
  function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return () => {
      let cur = ctx;
      for (let i = 0; i < segments.length && cur; i++) {
        cur = cur[segments[i]];
      }
      return cur;
    };
  }
  var getModelModifiers = (props, modelName) => {
    return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
  };
  function emit(instance, event2, ...rawArgs) {
    if (instance.isUnmounted)
      return;
    const props = instance.vnode.props || EMPTY_OBJ;
    if (true) {
      const {
        emitsOptions,
        propsOptions: [propsOptions]
      } = instance;
      if (emitsOptions) {
        if (!(event2 in emitsOptions) && true) {
          if (!propsOptions || !(toHandlerKey(camelize(event2)) in propsOptions)) {
            warn$1(
              `Component emitted event "${event2}" but it is neither declared in the emits option nor as an "${toHandlerKey(camelize(event2))}" prop.`
            );
          }
        } else {
          const validator = emitsOptions[event2];
          if (isFunction(validator)) {
            const isValid3 = validator(...rawArgs);
            if (!isValid3) {
              warn$1(
                `Invalid event arguments: event validation failed for event "${event2}".`
              );
            }
          }
        }
      }
    }
    let args = rawArgs;
    const isModelListener2 = event2.startsWith("update:");
    const modifiers = isModelListener2 && getModelModifiers(props, event2.slice(7));
    if (modifiers) {
      if (modifiers.trim) {
        args = rawArgs.map((a) => isString(a) ? a.trim() : a);
      }
      if (modifiers.number) {
        args = rawArgs.map(looseToNumber);
      }
    }
    if (true) {
      devtoolsComponentEmit(instance, event2, args);
    }
    if (true) {
      const lowerCaseEvent = event2.toLowerCase();
      if (lowerCaseEvent !== event2 && props[toHandlerKey(lowerCaseEvent)]) {
        warn$1(
          `Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(
            instance,
            instance.type
          )} but the handler is registered for "${event2}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(
            event2
          )}" instead of "${event2}".`
        );
      }
    }
    let handlerName;
    let handler = props[handlerName = toHandlerKey(event2)] || props[handlerName = toHandlerKey(camelize(event2))];
    if (!handler && isModelListener2) {
      handler = props[handlerName = toHandlerKey(hyphenate(event2))];
    }
    if (handler) {
      callWithAsyncErrorHandling(
        handler,
        instance,
        6,
        args
      );
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
      if (!instance.emitted) {
        instance.emitted = {};
      } else if (instance.emitted[handlerName]) {
        return;
      }
      instance.emitted[handlerName] = true;
      callWithAsyncErrorHandling(
        onceHandler,
        instance,
        6,
        args
      );
    }
  }
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== void 0) {
      return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (!isFunction(comp)) {
      const extendEmits = (raw2) => {
        const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
        if (normalizedFromExtend) {
          hasExtends = true;
          extend(normalized, normalizedFromExtend);
        }
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendEmits);
      }
      if (comp.extends) {
        extendEmits(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendEmits);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject(comp)) {
        cache.set(comp, null);
      }
      return null;
    }
    if (isArray(raw)) {
      raw.forEach((key) => normalized[key] = null);
    } else {
      extend(normalized, raw);
    }
    if (isObject(comp)) {
      cache.set(comp, normalized);
    }
    return normalized;
  }
  function isEmitListener(options, key) {
    if (!options || !isOn(key)) {
      return false;
    }
    key = key.slice(2).replace(/Once$/, "");
    return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
  }
  var accessedAttrs = false;
  function markAttrsAccessed() {
    accessedAttrs = true;
  }
  function renderComponentRoot(instance) {
    const {
      type: Component,
      vnode,
      proxy,
      withProxy,
      propsOptions: [propsOptions],
      slots,
      attrs,
      emit: emit2,
      render: render35,
      renderCache,
      props,
      data,
      setupState,
      ctx,
      inheritAttrs
    } = instance;
    const prev = setCurrentRenderingInstance(instance);
    let result;
    let fallthroughAttrs;
    if (true) {
      accessedAttrs = false;
    }
    try {
      if (vnode.shapeFlag & 4) {
        const proxyToUse = withProxy || proxy;
        const thisProxy = setupState.__isScriptSetup ? new Proxy(proxyToUse, {
          get(target, key, receiver) {
            warn$1(
              `Property '${String(
                key
              )}' was accessed via 'this'. Avoid using 'this' in templates.`
            );
            return Reflect.get(target, key, receiver);
          }
        }) : proxyToUse;
        result = normalizeVNode(
          render35.call(
            thisProxy,
            proxyToUse,
            renderCache,
            true ? shallowReadonly(props) : props,
            setupState,
            data,
            ctx
          )
        );
        fallthroughAttrs = attrs;
      } else {
        const render210 = Component;
        if (attrs === props) {
          markAttrsAccessed();
        }
        result = normalizeVNode(
          render210.length > 1 ? render210(
            true ? shallowReadonly(props) : props,
            true ? {
              get attrs() {
                markAttrsAccessed();
                return shallowReadonly(attrs);
              },
              slots,
              emit: emit2
            } : { attrs, slots, emit: emit2 }
          ) : render210(
            true ? shallowReadonly(props) : props,
            null
          )
        );
        fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
      }
    } catch (err) {
      blockStack.length = 0;
      handleError(err, instance, 1);
      result = createVNode(Comment);
    }
    let root = result;
    let setRoot = void 0;
    if (result.patchFlag > 0 && result.patchFlag & 2048) {
      [root, setRoot] = getChildRoot(result);
    }
    if (fallthroughAttrs && inheritAttrs !== false) {
      const keys2 = Object.keys(fallthroughAttrs);
      const { shapeFlag } = root;
      if (keys2.length) {
        if (shapeFlag & (1 | 6)) {
          if (propsOptions && keys2.some(isModelListener)) {
            fallthroughAttrs = filterModelListeners(
              fallthroughAttrs,
              propsOptions
            );
          }
          root = cloneVNode(root, fallthroughAttrs, false, true);
        } else if (!accessedAttrs && root.type !== Comment) {
          const allAttrs = Object.keys(attrs);
          const eventAttrs = [];
          const extraAttrs = [];
          for (let i = 0, l = allAttrs.length; i < l; i++) {
            const key = allAttrs[i];
            if (isOn(key)) {
              if (!isModelListener(key)) {
                eventAttrs.push(key[2].toLowerCase() + key.slice(3));
              }
            } else {
              extraAttrs.push(key);
            }
          }
          if (extraAttrs.length) {
            warn$1(
              `Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`
            );
          }
          if (eventAttrs.length) {
            warn$1(
              `Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
            );
          }
        }
      }
    }
    if (vnode.dirs) {
      if (!isElementRoot(root)) {
        warn$1(
          `Runtime directive used on component with non-element root node. The directives will not function as intended.`
        );
      }
      root = cloneVNode(root, null, false, true);
      root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
      if (!isElementRoot(root)) {
        warn$1(
          `Component inside <Transition> renders non-element root node that cannot be animated.`
        );
      }
      setTransitionHooks(root, vnode.transition);
    }
    if (setRoot) {
      setRoot(root);
    } else {
      result = root;
    }
    setCurrentRenderingInstance(prev);
    return result;
  }
  var getChildRoot = (vnode) => {
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const childRoot = filterSingleRoot(rawChildren, false);
    if (!childRoot) {
      return [vnode, void 0];
    } else if (childRoot.patchFlag > 0 && childRoot.patchFlag & 2048) {
      return getChildRoot(childRoot);
    }
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    const setRoot = (updatedRoot) => {
      rawChildren[index] = updatedRoot;
      if (dynamicChildren) {
        if (dynamicIndex > -1) {
          dynamicChildren[dynamicIndex] = updatedRoot;
        } else if (updatedRoot.patchFlag > 0) {
          vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
        }
      }
    };
    return [normalizeVNode(childRoot), setRoot];
  };
  function filterSingleRoot(children, recurse = true) {
    let singleRoot;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (isVNode(child)) {
        if (child.type !== Comment || child.children === "v-if") {
          if (singleRoot) {
            return;
          } else {
            singleRoot = child;
            if (recurse && singleRoot.patchFlag > 0 && singleRoot.patchFlag & 2048) {
              return filterSingleRoot(singleRoot.children);
            }
          }
        }
      } else {
        return;
      }
    }
    return singleRoot;
  }
  var getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
      if (key === "class" || key === "style" || isOn(key)) {
        (res || (res = {}))[key] = attrs[key];
      }
    }
    return res;
  };
  var filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
      if (!isModelListener(key) || !(key.slice(9) in props)) {
        res[key] = attrs[key];
      }
    }
    return res;
  };
  var isElementRoot = (vnode) => {
    return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
  };
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    if ((prevChildren || nextChildren) && isHmrUpdating) {
      return true;
    }
    if (nextVNode.dirs || nextVNode.transition) {
      return true;
    }
    if (optimized && patchFlag >= 0) {
      if (patchFlag & 1024) {
        return true;
      }
      if (patchFlag & 16) {
        if (!prevProps) {
          return !!nextProps;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8) {
        const dynamicProps = nextVNode.dynamicProps;
        for (let i = 0; i < dynamicProps.length; i++) {
          const key = dynamicProps[i];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
            return true;
          }
        }
      }
    } else {
      if (prevChildren || nextChildren) {
        if (!nextChildren || !nextChildren.$stable) {
          return true;
        }
      }
      if (prevProps === nextProps) {
        return false;
      }
      if (!prevProps) {
        return !!nextProps;
      }
      if (!nextProps) {
        return true;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
      return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
      const key = nextKeys[i];
      if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
        return true;
      }
    }
    return false;
  }
  function updateHOCHostEl({ vnode, parent }, el) {
    while (parent) {
      const root = parent.subTree;
      if (root.suspense && root.suspense.activeBranch === vnode) {
        root.el = vnode.el;
      }
      if (root === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
      } else {
        break;
      }
    }
  }
  var isSuspense = (type) => type.__isSuspense;
  function queueEffectWithSuspense(fn2, suspense) {
    if (suspense && suspense.pendingBranch) {
      if (isArray(fn2)) {
        suspense.effects.push(...fn2);
      } else {
        suspense.effects.push(fn2);
      }
    } else {
      queuePostFlushCb(fn2);
    }
  }
  var Fragment = Symbol.for("v-fgt");
  var Text = Symbol.for("v-txt");
  var Comment = Symbol.for("v-cmt");
  var Static = Symbol.for("v-stc");
  var blockStack = [];
  var currentBlock = null;
  function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
  }
  function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
  }
  var isBlockTreeEnabled = 1;
  function setBlockTracking(value, inVOnce = false) {
    isBlockTreeEnabled += value;
    if (value < 0 && currentBlock && inVOnce) {
      currentBlock.hasOnce = true;
    }
  }
  function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(
      createBaseVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        true
      )
    );
  }
  function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(
      createVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        true
      )
    );
  }
  function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n2) {
    if (n2.shapeFlag & 6 && n1.component) {
      const dirtyInstances = hmrDirtyComponents.get(n2.type);
      if (dirtyInstances && dirtyInstances.has(n1.component)) {
        n1.shapeFlag &= -257;
        n2.shapeFlag &= -513;
        return false;
      }
    }
    return n1.type === n2.type && n1.key === n2.key;
  }
  var vnodeArgsTransformer;
  var createVNodeWithArgsTransform = (...args) => {
    return _createVNode(
      ...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args
    );
  };
  var normalizeKey = ({ key }) => key != null ? key : null;
  var normalizeRef = ({
    ref: ref2,
    ref_key,
    ref_for
  }) => {
    if (typeof ref2 === "number") {
      ref2 = "" + ref2;
    }
    return ref2 != null ? isString(ref2) || isRef2(ref2) || isFunction(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
  };
  function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
      __v_isVNode: true,
      __v_skip: true,
      type,
      props,
      key: props && normalizeKey(props),
      ref: props && normalizeRef(props),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetStart: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag,
      patchFlag,
      dynamicProps,
      dynamicChildren: null,
      appContext: null,
      ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
      normalizeChildren(vnode, children);
      if (shapeFlag & 128) {
        type.normalize(vnode);
      }
    } else if (children) {
      vnode.shapeFlag |= isString(children) ? 8 : 16;
    }
    if (vnode.key !== vnode.key) {
      warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  var createVNode = true ? createVNodeWithArgsTransform : _createVNode;
  function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
      if (!type) {
        warn$1(`Invalid vnode type when creating vnode: ${type}.`);
      }
      type = Comment;
    }
    if (isVNode(type)) {
      const cloned = cloneVNode(
        type,
        props,
        true
      );
      if (children) {
        normalizeChildren(cloned, children);
      }
      if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
        if (cloned.shapeFlag & 6) {
          currentBlock[currentBlock.indexOf(type)] = cloned;
        } else {
          currentBlock.push(cloned);
        }
      }
      cloned.patchFlag = -2;
      return cloned;
    }
    if (isClassComponent(type)) {
      type = type.__vccOpts;
    }
    if (props) {
      props = guardReactiveProps(props);
      let { class: klass, style } = props;
      if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
      }
      if (isObject(style)) {
        if (isProxy(style) && !isArray(style)) {
          style = extend({}, style);
        }
        props.style = normalizeStyle(style);
      }
    }
    const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction(type) ? 2 : 0;
    if (shapeFlag & 4 && isProxy(type)) {
      type = toRaw(type);
      warn$1(
        `Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`,
        `
Component that was made reactive: `,
        type
      );
    }
    return createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      isBlockNode,
      true
    );
  }
  function guardReactiveProps(props) {
    if (!props)
      return null;
    return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
  }
  function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
    const { props, ref: ref2, patchFlag, children, transition } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
      __v_isVNode: true,
      __v_skip: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
      scopeId: vnode.scopeId,
      slotScopeIds: vnode.slotScopeIds,
      children: patchFlag === -1 && isArray(children) ? children.map(deepCloneVNode) : children,
      target: vnode.target,
      targetStart: vnode.targetStart,
      targetAnchor: vnode.targetAnchor,
      staticCount: vnode.staticCount,
      shapeFlag: vnode.shapeFlag,
      patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
      dynamicProps: vnode.dynamicProps,
      dynamicChildren: vnode.dynamicChildren,
      appContext: vnode.appContext,
      dirs: vnode.dirs,
      transition,
      component: vnode.component,
      suspense: vnode.suspense,
      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
      el: vnode.el,
      anchor: vnode.anchor,
      ctx: vnode.ctx,
      ce: vnode.ce
    };
    if (transition && cloneTransition) {
      setTransitionHooks(
        cloned,
        transition.clone(cloned)
      );
    }
    return cloned;
  }
  function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if (isArray(vnode.children)) {
      cloned.children = vnode.children.map(deepCloneVNode);
    }
    return cloned;
  }
  function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
  }
  function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
  }
  function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") {
      return createVNode(Comment);
    } else if (isArray(child)) {
      return createVNode(
        Fragment,
        null,
        child.slice()
      );
    } else if (isVNode(child)) {
      return cloneIfMounted(child);
    } else {
      return createVNode(Text, null, String(child));
    }
  }
  function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
      children = null;
    } else if (isArray(children)) {
      type = 16;
    } else if (typeof children === "object") {
      if (shapeFlag & (1 | 64)) {
        const slot = children.default;
        if (slot) {
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }
        return;
      } else {
        type = 32;
        const slotFlag = children._;
        if (!slotFlag && !isInternalObject(children)) {
          children._ctx = currentRenderingInstance;
        } else if (slotFlag === 3 && currentRenderingInstance) {
          if (currentRenderingInstance.slots._ === 1) {
            children._ = 1;
          } else {
            children._ = 2;
            vnode.patchFlag |= 1024;
          }
        }
      }
    } else if (isFunction(children)) {
      children = { default: children, _ctx: currentRenderingInstance };
      type = 32;
    } else {
      children = String(children);
      if (shapeFlag & 64) {
        type = 16;
        children = [createTextVNode(children)];
      } else {
        type = 8;
      }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
  }
  function mergeProps(...args) {
    const ret = {};
    for (let i = 0; i < args.length; i++) {
      const toMerge = args[i];
      for (const key in toMerge) {
        if (key === "class") {
          if (ret.class !== toMerge.class) {
            ret.class = normalizeClass([ret.class, toMerge.class]);
          }
        } else if (key === "style") {
          ret.style = normalizeStyle([ret.style, toMerge.style]);
        } else if (isOn(key)) {
          const existing = ret[key];
          const incoming = toMerge[key];
          if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
            ret[key] = existing ? [].concat(existing, incoming) : incoming;
          }
        } else if (key !== "") {
          ret[key] = toMerge[key];
        }
      }
    }
    return ret;
  }
  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
      vnode,
      prevVNode
    ]);
  }
  var emptyAppContext = createAppContext();
  var uid = 0;
  function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
      uid: uid++,
      vnode,
      type,
      parent,
      appContext,
      root: null,
      next: null,
      subTree: null,
      effect: null,
      update: null,
      job: null,
      scope: new EffectScope(
        true
      ),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: parent ? parent.provides : Object.create(appContext.provides),
      ids: parent ? parent.ids : ["", 0, 0],
      accessCache: null,
      renderCache: [],
      components: null,
      directives: null,
      propsOptions: normalizePropsOptions(type, appContext),
      emitsOptions: normalizeEmitsOptions(type, appContext),
      emit: null,
      emitted: null,
      propsDefaults: EMPTY_OBJ,
      inheritAttrs: type.inheritAttrs,
      ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
      suspense,
      suspenseId: suspense ? suspense.pendingId : 0,
      asyncDep: null,
      asyncResolved: false,
      isMounted: false,
      isUnmounted: false,
      isDeactivated: false,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    if (true) {
      instance.ctx = createDevRenderContext(instance);
    } else {
      instance.ctx = { _: instance };
    }
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) {
      vnode.ce(instance);
    }
    return instance;
  }
  var currentInstance = null;
  var getCurrentInstance = () => currentInstance || currentRenderingInstance;
  var internalSetCurrentInstance;
  var setInSSRSetupState;
  {
    const g = getGlobalThis();
    const registerGlobalSetter = (key, setter) => {
      let setters;
      if (!(setters = g[key]))
        setters = g[key] = [];
      setters.push(setter);
      return (v) => {
        if (setters.length > 1)
          setters.forEach((set2) => set2(v));
        else
          setters[0](v);
      };
    };
    internalSetCurrentInstance = registerGlobalSetter(
      `__VUE_INSTANCE_SETTERS__`,
      (v) => currentInstance = v
    );
    setInSSRSetupState = registerGlobalSetter(
      `__VUE_SSR_SETTERS__`,
      (v) => isInSSRComponentSetup = v
    );
  }
  var setCurrentInstance = (instance) => {
    const prev = currentInstance;
    internalSetCurrentInstance(instance);
    instance.scope.on();
    return () => {
      instance.scope.off();
      internalSetCurrentInstance(prev);
    };
  };
  var unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
  };
  var isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
  function validateComponentName(name, { isNativeTag }) {
    if (isBuiltInTag(name) || isNativeTag(name)) {
      warn$1(
        "Do not use built-in or reserved HTML elements as component id: " + name
      );
    }
  }
  function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
  }
  var isInSSRComponentSetup = false;
  function setupComponent(instance, isSSR = false, optimized = false) {
    isSSR && setInSSRSetupState(isSSR);
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children, optimized || isSSR);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isSSR && setInSSRSetupState(false);
    return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
    var _a3;
    const Component = instance.type;
    if (true) {
      if (Component.name) {
        validateComponentName(Component.name, instance.appContext.config);
      }
      if (Component.components) {
        const names = Object.keys(Component.components);
        for (let i = 0; i < names.length; i++) {
          validateComponentName(names[i], instance.appContext.config);
        }
      }
      if (Component.directives) {
        const names = Object.keys(Component.directives);
        for (let i = 0; i < names.length; i++) {
          validateDirectiveName(names[i]);
        }
      }
      if (Component.compilerOptions && isRuntimeOnly()) {
        warn$1(
          `"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`
        );
      }
    }
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
    if (true) {
      exposePropsOnRenderContext(instance);
    }
    const { setup } = Component;
    if (setup) {
      pauseTracking();
      const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
      const reset = setCurrentInstance(instance);
      const setupResult = callWithErrorHandling(
        setup,
        instance,
        0,
        [
          true ? shallowReadonly(instance.props) : instance.props,
          setupContext
        ]
      );
      const isAsyncSetup = isPromise(setupResult);
      resetTracking();
      reset();
      if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
        markAsyncBoundary(instance);
      }
      if (isAsyncSetup) {
        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
        if (isSSR) {
          return setupResult.then((resolvedResult) => {
            handleSetupResult(instance, resolvedResult, isSSR);
          }).catch((e) => {
            handleError(e, instance, 0);
          });
        } else {
          instance.asyncDep = setupResult;
          if (!instance.suspense) {
            const name = (_a3 = Component.name) != null ? _a3 : "Anonymous";
            warn$1(
              `Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
            );
          }
        }
      } else {
        handleSetupResult(instance, setupResult, isSSR);
      }
    } else {
      finishComponentSetup(instance, isSSR);
    }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction(setupResult)) {
      if (instance.type.__ssrInlineRender) {
        instance.ssrRender = setupResult;
      } else {
        instance.render = setupResult;
      }
    } else if (isObject(setupResult)) {
      if (isVNode(setupResult)) {
        warn$1(
          `setup() should not return VNodes directly - return a render function instead.`
        );
      }
      if (true) {
        instance.devtoolsRawSetupState = setupResult;
      }
      instance.setupState = proxyRefs(setupResult);
      if (true) {
        exposeSetupStateOnRenderContext(instance);
      }
    } else if (setupResult !== void 0) {
      warn$1(
        `setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`
      );
    }
    finishComponentSetup(instance, isSSR);
  }
  var compile;
  var installWithProxy;
  var isRuntimeOnly = () => !compile;
  function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    if (!instance.render) {
      if (!isSSR && compile && !Component.render) {
        const template = Component.template || resolveMergedOptions(instance).template;
        if (template) {
          if (true) {
            startMeasure(instance, `compile`);
          }
          const { isCustomElement, compilerOptions } = instance.appContext.config;
          const { delimiters, compilerOptions: componentCompilerOptions } = Component;
          const finalCompilerOptions = extend(
            extend(
              {
                isCustomElement,
                delimiters
              },
              compilerOptions
            ),
            componentCompilerOptions
          );
          Component.render = compile(template, finalCompilerOptions);
          if (true) {
            endMeasure(instance, `compile`);
          }
        }
      }
      instance.render = Component.render || NOOP;
      if (installWithProxy) {
        installWithProxy(instance);
      }
    }
    if (true) {
      const reset = setCurrentInstance(instance);
      pauseTracking();
      try {
        applyOptions(instance);
      } finally {
        resetTracking();
        reset();
      }
    }
    if (!Component.render && instance.render === NOOP && !isSSR) {
      if (!compile && Component.template) {
        warn$1(
          `Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
        );
      } else {
        warn$1(`Component is missing template or render function: `, Component);
      }
    }
  }
  var attrsProxyHandlers = true ? {
    get(target, key) {
      markAttrsAccessed();
      track(target, "get", "");
      return target[key];
    },
    set() {
      warn$1(`setupContext.attrs is readonly.`);
      return false;
    },
    deleteProperty() {
      warn$1(`setupContext.attrs is readonly.`);
      return false;
    }
  } : {
    get(target, key) {
      track(target, "get", "");
      return target[key];
    }
  };
  function getSlotsProxy(instance) {
    return new Proxy(instance.slots, {
      get(target, key) {
        track(instance, "get", "$slots");
        return target[key];
      }
    });
  }
  function createSetupContext(instance) {
    const expose = (exposed) => {
      if (true) {
        if (instance.exposed) {
          warn$1(`expose() should be called only once per setup().`);
        }
        if (exposed != null) {
          let exposedType = typeof exposed;
          if (exposedType === "object") {
            if (isArray(exposed)) {
              exposedType = "array";
            } else if (isRef2(exposed)) {
              exposedType = "ref";
            }
          }
          if (exposedType !== "object") {
            warn$1(
              `expose() should be passed a plain object, received ${exposedType}.`
            );
          }
        }
      }
      instance.exposed = exposed || {};
    };
    if (true) {
      let attrsProxy;
      let slotsProxy;
      return Object.freeze({
        get attrs() {
          return attrsProxy || (attrsProxy = new Proxy(instance.attrs, attrsProxyHandlers));
        },
        get slots() {
          return slotsProxy || (slotsProxy = getSlotsProxy(instance));
        },
        get emit() {
          return (event2, ...args) => instance.emit(event2, ...args);
        },
        expose
      });
    } else {
      return {
        attrs: new Proxy(instance.attrs, attrsProxyHandlers),
        slots: instance.slots,
        emit: instance.emit,
        expose
      };
    }
  }
  function getComponentPublicInstance(instance) {
    if (instance.exposed) {
      return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get(target, key) {
          if (key in target) {
            return target[key];
          } else if (key in publicPropertiesMap) {
            return publicPropertiesMap[key](instance);
          }
        },
        has(target, key) {
          return key in target || key in publicPropertiesMap;
        }
      }));
    } else {
      return instance.proxy;
    }
  }
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
  function getComponentName(Component, includeInferred = true) {
    return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
  }
  function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
      const match2 = Component.__file.match(/([^/\\]+)\.\w+$/);
      if (match2) {
        name = match2[1];
      }
    }
    if (!name && instance && instance.parent) {
      const inferFromRegistry = (registry) => {
        for (const key in registry) {
          if (registry[key] === Component) {
            return key;
          }
        }
      };
      name = inferFromRegistry(
        instance.components || instance.parent.type.components
      ) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
  }
  function isClassComponent(value) {
    return isFunction(value) && "__vccOpts" in value;
  }
  var computed2 = (getterOrOptions, debugOptions) => {
    const c = computed(getterOrOptions, debugOptions, isInSSRComponentSetup);
    if (true) {
      const i = getCurrentInstance();
      if (i && i.appContext.config.warnRecursiveComputed) {
        c._warnRecursive = true;
      }
    }
    return c;
  };
  function h(type, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
      if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
        if (isVNode(propsOrChildren)) {
          return createVNode(type, null, [propsOrChildren]);
        }
        return createVNode(type, propsOrChildren);
      } else {
        return createVNode(type, null, propsOrChildren);
      }
    } else {
      if (l > 3) {
        children = Array.prototype.slice.call(arguments, 2);
      } else if (l === 3 && isVNode(children)) {
        children = [children];
      }
      return createVNode(type, propsOrChildren, children);
    }
  }
  function initCustomFormatter() {
    if (typeof window === "undefined") {
      return;
    }
    const vueStyle = { style: "color:#3ba776" };
    const numberStyle = { style: "color:#1677ff" };
    const stringStyle = { style: "color:#f5222d" };
    const keywordStyle = { style: "color:#eb2f96" };
    const formatter = {
      __vue_custom_formatter: true,
      header(obj) {
        if (!isObject(obj)) {
          return null;
        }
        if (obj.__isVue) {
          return ["div", vueStyle, `VueInstance`];
        } else if (isRef2(obj)) {
          pauseTracking();
          const value = obj.value;
          resetTracking();
          return [
            "div",
            {},
            ["span", vueStyle, genRefFlag(obj)],
            "<",
            formatValue(value),
            `>`
          ];
        } else if (isReactive(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"],
            "<",
            formatValue(obj),
            `>${isReadonly(obj) ? ` (readonly)` : ``}`
          ];
        } else if (isReadonly(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"],
            "<",
            formatValue(obj),
            ">"
          ];
        }
        return null;
      },
      hasBody(obj) {
        return obj && obj.__isVue;
      },
      body(obj) {
        if (obj && obj.__isVue) {
          return [
            "div",
            {},
            ...formatInstance(obj.$)
          ];
        }
      }
    };
    function formatInstance(instance) {
      const blocks = [];
      if (instance.type.props && instance.props) {
        blocks.push(createInstanceBlock("props", toRaw(instance.props)));
      }
      if (instance.setupState !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("setup", instance.setupState));
      }
      if (instance.data !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("data", toRaw(instance.data)));
      }
      const computed3 = extractKeys2(instance, "computed");
      if (computed3) {
        blocks.push(createInstanceBlock("computed", computed3));
      }
      const injected = extractKeys2(instance, "inject");
      if (injected) {
        blocks.push(createInstanceBlock("injected", injected));
      }
      blocks.push([
        "div",
        {},
        [
          "span",
          {
            style: keywordStyle.style + ";opacity:0.66"
          },
          "$ (internal): "
        ],
        ["object", { object: instance }]
      ]);
      return blocks;
    }
    function createInstanceBlock(type, target) {
      target = extend({}, target);
      if (!Object.keys(target).length) {
        return ["span", {}];
      }
      return [
        "div",
        { style: "line-height:1.25em;margin-bottom:0.6em" },
        [
          "div",
          {
            style: "color:#476582"
          },
          type
        ],
        [
          "div",
          {
            style: "padding-left:1.25em"
          },
          ...Object.keys(target).map((key) => {
            return [
              "div",
              {},
              ["span", keywordStyle, key + ": "],
              formatValue(target[key], false)
            ];
          })
        ]
      ];
    }
    function formatValue(v, asRaw = true) {
      if (typeof v === "number") {
        return ["span", numberStyle, v];
      } else if (typeof v === "string") {
        return ["span", stringStyle, JSON.stringify(v)];
      } else if (typeof v === "boolean") {
        return ["span", keywordStyle, v];
      } else if (isObject(v)) {
        return ["object", { object: asRaw ? toRaw(v) : v }];
      } else {
        return ["span", stringStyle, String(v)];
      }
    }
    function extractKeys2(instance, type) {
      const Comp = instance.type;
      if (isFunction(Comp)) {
        return;
      }
      const extracted = {};
      for (const key in instance.ctx) {
        if (isKeyOfType(Comp, key, type)) {
          extracted[key] = instance.ctx[key];
        }
      }
      return extracted;
    }
    function isKeyOfType(Comp, key, type) {
      const opts = Comp[type];
      if (isArray(opts) && opts.includes(key) || isObject(opts) && key in opts) {
        return true;
      }
      if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
        return true;
      }
      if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type))) {
        return true;
      }
    }
    function genRefFlag(v) {
      if (isShallow(v)) {
        return `ShallowRef`;
      }
      if (v.effect) {
        return `ComputedRef`;
      }
      return `Ref`;
    }
    if (window.devtoolsFormatters) {
      window.devtoolsFormatters.push(formatter);
    } else {
      window.devtoolsFormatters = [formatter];
    }
  }
  var version = "3.5.17";
  var warn2 = true ? warn$1 : NOOP;

  // ../posawesome/node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js
  var policy = void 0;
  var tt = typeof window !== "undefined" && window.trustedTypes;
  if (tt) {
    try {
      policy = /* @__PURE__ */ tt.createPolicy("vue", {
        createHTML: (val) => val
      });
    } catch (e) {
      warn2(`Error creating trusted types policy: ${e}`);
    }
  }
  var unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
  var svgNS = "http://www.w3.org/2000/svg";
  var mathmlNS = "http://www.w3.org/1998/Math/MathML";
  var doc = typeof document !== "undefined" ? document : null;
  var templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
  var nodeOps = {
    insert: (child, parent, anchor) => {
      parent.insertBefore(child, anchor || null);
    },
    remove: (child) => {
      const parent = child.parentNode;
      if (parent) {
        parent.removeChild(child);
      }
    },
    createElement: (tag, namespace, is, props) => {
      const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
      if (tag === "select" && props && props.multiple != null) {
        el.setAttribute("multiple", props.multiple);
      }
      return el;
    },
    createText: (text) => doc.createTextNode(text),
    createComment: (text) => doc.createComment(text),
    setText: (node, text) => {
      node.nodeValue = text;
    },
    setElementText: (el, text) => {
      el.textContent = text;
    },
    parentNode: (node) => node.parentNode,
    nextSibling: (node) => node.nextSibling,
    querySelector: (selector) => doc.querySelector(selector),
    setScopeId(el, id) {
      el.setAttribute(id, "");
    },
    insertStaticContent(content, parent, anchor, namespace, start, end) {
      const before = anchor ? anchor.previousSibling : parent.lastChild;
      if (start && (start === end || start.nextSibling)) {
        while (true) {
          parent.insertBefore(start.cloneNode(true), anchor);
          if (start === end || !(start = start.nextSibling))
            break;
        }
      } else {
        templateContainer.innerHTML = unsafeToTrustedHTML(
          namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
        );
        const template = templateContainer.content;
        if (namespace === "svg" || namespace === "mathml") {
          const wrapper = template.firstChild;
          while (wrapper.firstChild) {
            template.appendChild(wrapper.firstChild);
          }
          template.removeChild(wrapper);
        }
        parent.insertBefore(template, anchor);
      }
      return [
        before ? before.nextSibling : parent.firstChild,
        anchor ? anchor.previousSibling : parent.lastChild
      ];
    }
  };
  var TRANSITION = "transition";
  var ANIMATION = "animation";
  var vtcKey = Symbol("_vtc");
  var DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
      type: Boolean,
      default: true
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
  };
  var TransitionPropsValidators = /* @__PURE__ */ extend(
    {},
    BaseTransitionPropsValidators,
    DOMTransitionPropsValidators
  );
  var decorate$1 = (t) => {
    t.displayName = "Transition";
    t.props = TransitionPropsValidators;
    return t;
  };
  var Transition = /* @__PURE__ */ decorate$1(
    (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots)
  );
  var callHook2 = (hook, args = []) => {
    if (isArray(hook)) {
      hook.forEach((h2) => h2(...args));
    } else if (hook) {
      hook(...args);
    }
  };
  var hasExplicitCallback = (hook) => {
    return hook ? isArray(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
  };
  function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for (const key in rawProps) {
      if (!(key in DOMTransitionPropsValidators)) {
        baseProps[key] = rawProps[key];
      }
    }
    if (rawProps.css === false) {
      return baseProps;
    }
    const {
      name = "v",
      type,
      duration,
      enterFromClass = `${name}-enter-from`,
      enterActiveClass = `${name}-enter-active`,
      enterToClass = `${name}-enter-to`,
      appearFromClass = enterFromClass,
      appearActiveClass = enterActiveClass,
      appearToClass = enterToClass,
      leaveFromClass = `${name}-leave-from`,
      leaveActiveClass = `${name}-leave-active`,
      leaveToClass = `${name}-leave-to`
    } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const {
      onBeforeEnter,
      onEnter,
      onEnterCancelled,
      onLeave,
      onLeaveCancelled,
      onBeforeAppear = onBeforeEnter,
      onAppear = onEnter,
      onAppearCancelled = onEnterCancelled
    } = baseProps;
    const finishEnter = (el, isAppear, done, isCancelled) => {
      el._enterCancelled = isCancelled;
      removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
      removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
      done && done();
    };
    const finishLeave = (el, done) => {
      el._isLeaving = false;
      removeTransitionClass(el, leaveFromClass);
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
      done && done();
    };
    const makeEnterHook = (isAppear) => {
      return (el, done) => {
        const hook = isAppear ? onAppear : onEnter;
        const resolve2 = () => finishEnter(el, isAppear, done);
        callHook2(hook, [el, resolve2]);
        nextFrame(() => {
          removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
          addTransitionClass(el, isAppear ? appearToClass : enterToClass);
          if (!hasExplicitCallback(hook)) {
            whenTransitionEnds(el, type, enterDuration, resolve2);
          }
        });
      };
    };
    return extend(baseProps, {
      onBeforeEnter(el) {
        callHook2(onBeforeEnter, [el]);
        addTransitionClass(el, enterFromClass);
        addTransitionClass(el, enterActiveClass);
      },
      onBeforeAppear(el) {
        callHook2(onBeforeAppear, [el]);
        addTransitionClass(el, appearFromClass);
        addTransitionClass(el, appearActiveClass);
      },
      onEnter: makeEnterHook(false),
      onAppear: makeEnterHook(true),
      onLeave(el, done) {
        el._isLeaving = true;
        const resolve2 = () => finishLeave(el, done);
        addTransitionClass(el, leaveFromClass);
        if (!el._enterCancelled) {
          forceReflow();
          addTransitionClass(el, leaveActiveClass);
        } else {
          addTransitionClass(el, leaveActiveClass);
          forceReflow();
        }
        nextFrame(() => {
          if (!el._isLeaving) {
            return;
          }
          removeTransitionClass(el, leaveFromClass);
          addTransitionClass(el, leaveToClass);
          if (!hasExplicitCallback(onLeave)) {
            whenTransitionEnds(el, type, leaveDuration, resolve2);
          }
        });
        callHook2(onLeave, [el, resolve2]);
      },
      onEnterCancelled(el) {
        finishEnter(el, false, void 0, true);
        callHook2(onEnterCancelled, [el]);
      },
      onAppearCancelled(el) {
        finishEnter(el, true, void 0, true);
        callHook2(onAppearCancelled, [el]);
      },
      onLeaveCancelled(el) {
        finishLeave(el);
        callHook2(onLeaveCancelled, [el]);
      }
    });
  }
  function normalizeDuration(duration) {
    if (duration == null) {
      return null;
    } else if (isObject(duration)) {
      return [NumberOf(duration.enter), NumberOf(duration.leave)];
    } else {
      const n = NumberOf(duration);
      return [n, n];
    }
  }
  function NumberOf(val) {
    const res = toNumber(val);
    if (true) {
      assertNumber(res, "<transition> explicit duration");
    }
    return res;
  }
  function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
    (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
  }
  function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
    const _vtc = el[vtcKey];
    if (_vtc) {
      _vtc.delete(cls);
      if (!_vtc.size) {
        el[vtcKey] = void 0;
      }
    }
  }
  function nextFrame(cb) {
    requestAnimationFrame(() => {
      requestAnimationFrame(cb);
    });
  }
  var endId = 0;
  function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
    const id = el._endId = ++endId;
    const resolveIfNotStale = () => {
      if (id === el._endId) {
        resolve2();
      }
    };
    if (explicitTimeout != null) {
      return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type) {
      return resolve2();
    }
    const endEvent = type + "end";
    let ended = 0;
    const end = () => {
      el.removeEventListener(endEvent, onEnd);
      resolveIfNotStale();
    };
    const onEnd = (e) => {
      if (e.target === el && ++ended >= propCount) {
        end();
      }
    };
    setTimeout(() => {
      if (ended < propCount) {
        end();
      }
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
  }
  function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    const getStyleProperties = (key) => (styles[key] || "").split(", ");
    const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
    const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
    const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type = TRANSITION;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
      getStyleProperties(`${TRANSITION}Property`).toString()
    );
    return {
      type,
      timeout,
      propCount,
      hasTransform
    };
  }
  function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
  }
  function toMs(s) {
    if (s === "auto")
      return 0;
    return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
  }
  function forceReflow() {
    return document.body.offsetHeight;
  }
  function patchClass(el, value, isSVG) {
    const transitionClasses = el[vtcKey];
    if (transitionClasses) {
      value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
    }
    if (value == null) {
      el.removeAttribute("class");
    } else if (isSVG) {
      el.setAttribute("class", value);
    } else {
      el.className = value;
    }
  }
  var vShowOriginalDisplay = Symbol("_vod");
  var vShowHidden = Symbol("_vsh");
  var vShow = {
    beforeMount(el, { value }, { transition }) {
      el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
      if (transition && value) {
        transition.beforeEnter(el);
      } else {
        setDisplay(el, value);
      }
    },
    mounted(el, { value }, { transition }) {
      if (transition && value) {
        transition.enter(el);
      }
    },
    updated(el, { value, oldValue }, { transition }) {
      if (!value === !oldValue)
        return;
      if (transition) {
        if (value) {
          transition.beforeEnter(el);
          setDisplay(el, true);
          transition.enter(el);
        } else {
          transition.leave(el, () => {
            setDisplay(el, false);
          });
        }
      } else {
        setDisplay(el, value);
      }
    },
    beforeUnmount(el, { value }) {
      setDisplay(el, value);
    }
  };
  if (true) {
    vShow.name = "show";
  }
  function setDisplay(el, value) {
    el.style.display = value ? el[vShowOriginalDisplay] : "none";
    el[vShowHidden] = !value;
  }
  var CSS_VAR_TEXT = Symbol(true ? "CSS_VAR_TEXT" : "");
  var displayRE = /(^|;)\s*display\s*:/;
  function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = isString(next);
    let hasControlledDisplay = false;
    if (next && !isCssString) {
      if (prev) {
        if (!isString(prev)) {
          for (const key in prev) {
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        } else {
          for (const prevStyle of prev.split(";")) {
            const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        }
      }
      for (const key in next) {
        if (key === "display") {
          hasControlledDisplay = true;
        }
        setStyle(style, key, next[key]);
      }
    } else {
      if (isCssString) {
        if (prev !== next) {
          const cssVarText = style[CSS_VAR_TEXT];
          if (cssVarText) {
            next += ";" + cssVarText;
          }
          style.cssText = next;
          hasControlledDisplay = displayRE.test(next);
        }
      } else if (prev) {
        el.removeAttribute("style");
      }
    }
    if (vShowOriginalDisplay in el) {
      el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
      if (el[vShowHidden]) {
        style.display = "none";
      }
    }
  }
  var semicolonRE = /[^\\];\s*$/;
  var importantRE = /\s*!important$/;
  function setStyle(style, name, val) {
    if (isArray(val)) {
      val.forEach((v) => setStyle(style, name, v));
    } else {
      if (val == null)
        val = "";
      if (true) {
        if (semicolonRE.test(val)) {
          warn2(
            `Unexpected semicolon at the end of '${name}' style value: '${val}'`
          );
        }
      }
      if (name.startsWith("--")) {
        style.setProperty(name, val);
      } else {
        const prefixed = autoPrefix(style, name);
        if (importantRE.test(val)) {
          style.setProperty(
            hyphenate(prefixed),
            val.replace(importantRE, ""),
            "important"
          );
        } else {
          style[prefixed] = val;
        }
      }
    }
  }
  var prefixes = ["Webkit", "Moz", "ms"];
  var prefixCache = {};
  function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
      return cached;
    }
    let name = camelize(rawName);
    if (name !== "filter" && name in style) {
      return prefixCache[rawName] = name;
    }
    name = capitalize(name);
    for (let i = 0; i < prefixes.length; i++) {
      const prefixed = prefixes[i] + name;
      if (prefixed in style) {
        return prefixCache[rawName] = prefixed;
      }
    }
    return rawName;
  }
  var xlinkNS = "http://www.w3.org/1999/xlink";
  function patchAttr(el, key, value, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key)) {
    if (isSVG && key.startsWith("xlink:")) {
      if (value == null) {
        el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
        el.removeAttribute(key);
      } else {
        el.setAttribute(
          key,
          isBoolean2 ? "" : isSymbol(value) ? String(value) : value
        );
      }
    }
  }
  function patchDOMProp(el, key, value, parentComponent, attrName) {
    if (key === "innerHTML" || key === "textContent") {
      if (value != null) {
        el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
      }
      return;
    }
    const tag = el.tagName;
    if (key === "value" && tag !== "PROGRESS" && !tag.includes("-")) {
      const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
      const newValue = value == null ? el.type === "checkbox" ? "on" : "" : String(value);
      if (oldValue !== newValue || !("_value" in el)) {
        el.value = newValue;
      }
      if (value == null) {
        el.removeAttribute(key);
      }
      el._value = value;
      return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
      const type = typeof el[key];
      if (type === "boolean") {
        value = includeBooleanAttr(value);
      } else if (value == null && type === "string") {
        value = "";
        needRemove = true;
      } else if (type === "number") {
        value = 0;
        needRemove = true;
      }
    }
    try {
      el[key] = value;
    } catch (e) {
      if (!needRemove) {
        warn2(
          `Failed setting prop "${key}" on <${tag.toLowerCase()}>: value ${value} is invalid.`,
          e
        );
      }
    }
    needRemove && el.removeAttribute(attrName || key);
  }
  function addEventListener2(el, event2, handler, options) {
    el.addEventListener(event2, handler, options);
  }
  function removeEventListener(el, event2, handler, options) {
    el.removeEventListener(event2, handler, options);
  }
  var veiKey = Symbol("_vei");
  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el[veiKey] || (el[veiKey] = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
      existingInvoker.value = true ? sanitizeEventValue(nextValue, rawName) : nextValue;
    } else {
      const [name, options] = parseName(rawName);
      if (nextValue) {
        const invoker = invokers[rawName] = createInvoker(
          true ? sanitizeEventValue(nextValue, rawName) : nextValue,
          instance
        );
        addEventListener2(el, name, invoker, options);
      } else if (existingInvoker) {
        removeEventListener(el, name, existingInvoker, options);
        invokers[rawName] = void 0;
      }
    }
  }
  var optionsModifierRE = /(?:Once|Passive|Capture)$/;
  function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
      options = {};
      let m;
      while (m = name.match(optionsModifierRE)) {
        name = name.slice(0, name.length - m[0].length);
        options[m[0].toLowerCase()] = true;
      }
    }
    const event2 = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
    return [event2, options];
  }
  var cachedNow = 0;
  var p = /* @__PURE__ */ Promise.resolve();
  var getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
  function createInvoker(initialValue, instance) {
    const invoker = (e) => {
      if (!e._vts) {
        e._vts = Date.now();
      } else if (e._vts <= invoker.attached) {
        return;
      }
      callWithAsyncErrorHandling(
        patchStopImmediatePropagation(e, invoker.value),
        instance,
        5,
        [e]
      );
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
  }
  function sanitizeEventValue(value, propName) {
    if (isFunction(value) || isArray(value)) {
      return value;
    }
    warn2(
      `Wrong type passed as event handler to ${propName} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof value}.`
    );
    return NOOP;
  }
  function patchStopImmediatePropagation(e, value) {
    if (isArray(value)) {
      const originalStop = e.stopImmediatePropagation;
      e.stopImmediatePropagation = () => {
        originalStop.call(e);
        e._stopped = true;
      };
      return value.map(
        (fn2) => (e2) => !e2._stopped && fn2 && fn2(e2)
      );
    } else {
      return value;
    }
  }
  var isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
  var patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
    const isSVG = namespace === "svg";
    if (key === "class") {
      patchClass(el, nextValue, isSVG);
    } else if (key === "style") {
      patchStyle(el, prevValue, nextValue);
    } else if (isOn(key)) {
      if (!isModelListener(key)) {
        patchEvent(el, key, prevValue, nextValue, parentComponent);
      }
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
      patchDOMProp(el, key, nextValue);
      if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
        patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
      }
    } else if (el._isVueCE && (/[A-Z]/.test(key) || !isString(nextValue))) {
      patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
    } else {
      if (key === "true-value") {
        el._trueValue = nextValue;
      } else if (key === "false-value") {
        el._falseValue = nextValue;
      }
      patchAttr(el, key, nextValue, isSVG);
    }
  };
  function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
      if (key === "innerHTML" || key === "textContent") {
        return true;
      }
      if (key in el && isNativeOn(key) && isFunction(value)) {
        return true;
      }
      return false;
    }
    if (key === "spellcheck" || key === "draggable" || key === "translate" || key === "autocorrect") {
      return false;
    }
    if (key === "form") {
      return false;
    }
    if (key === "list" && el.tagName === "INPUT") {
      return false;
    }
    if (key === "type" && el.tagName === "TEXTAREA") {
      return false;
    }
    if (key === "width" || key === "height") {
      const tag = el.tagName;
      if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
        return false;
      }
    }
    if (isNativeOn(key) && isString(value)) {
      return false;
    }
    return key in el;
  }
  var positionMap = /* @__PURE__ */ new WeakMap();
  var newPositionMap = /* @__PURE__ */ new WeakMap();
  var moveCbKey = Symbol("_moveCb");
  var enterCbKey2 = Symbol("_enterCb");
  var decorate = (t) => {
    delete t.props.mode;
    return t;
  };
  var TransitionGroupImpl = /* @__PURE__ */ decorate({
    name: "TransitionGroup",
    props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
      tag: String,
      moveClass: String
    }),
    setup(props, { slots }) {
      const instance = getCurrentInstance();
      const state = useTransitionState();
      let prevChildren;
      let children;
      onUpdated(() => {
        if (!prevChildren.length) {
          return;
        }
        const moveClass = props.moveClass || `${props.name || "v"}-move`;
        if (!hasCSSTransform(
          prevChildren[0].el,
          instance.vnode.el,
          moveClass
        )) {
          prevChildren = [];
          return;
        }
        prevChildren.forEach(callPendingCbs);
        prevChildren.forEach(recordPosition);
        const movedChildren = prevChildren.filter(applyTranslation);
        forceReflow();
        movedChildren.forEach((c) => {
          const el = c.el;
          const style = el.style;
          addTransitionClass(el, moveClass);
          style.transform = style.webkitTransform = style.transitionDuration = "";
          const cb = el[moveCbKey] = (e) => {
            if (e && e.target !== el) {
              return;
            }
            if (!e || /transform$/.test(e.propertyName)) {
              el.removeEventListener("transitionend", cb);
              el[moveCbKey] = null;
              removeTransitionClass(el, moveClass);
            }
          };
          el.addEventListener("transitionend", cb);
        });
        prevChildren = [];
      });
      return () => {
        const rawProps = toRaw(props);
        const cssTransitionProps = resolveTransitionProps(rawProps);
        let tag = rawProps.tag || Fragment;
        prevChildren = [];
        if (children) {
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child.el && child.el instanceof Element) {
              prevChildren.push(child);
              setTransitionHooks(
                child,
                resolveTransitionHooks(
                  child,
                  cssTransitionProps,
                  state,
                  instance
                )
              );
              positionMap.set(
                child,
                child.el.getBoundingClientRect()
              );
            }
          }
        }
        children = slots.default ? getTransitionRawChildren(slots.default()) : [];
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child.key != null) {
            setTransitionHooks(
              child,
              resolveTransitionHooks(child, cssTransitionProps, state, instance)
            );
          } else if (child.type !== Text) {
            warn2(`<TransitionGroup> children must be keyed.`);
          }
        }
        return createVNode(tag, null, children);
      };
    }
  });
  var TransitionGroup = TransitionGroupImpl;
  function callPendingCbs(c) {
    const el = c.el;
    if (el[moveCbKey]) {
      el[moveCbKey]();
    }
    if (el[enterCbKey2]) {
      el[enterCbKey2]();
    }
  }
  function recordPosition(c) {
    newPositionMap.set(c, c.el.getBoundingClientRect());
  }
  function applyTranslation(c) {
    const oldPos = positionMap.get(c);
    const newPos = newPositionMap.get(c);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
      const s = c.el.style;
      s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
      s.transitionDuration = "0s";
      return c;
    }
  }
  function hasCSSTransform(el, root, moveClass) {
    const clone = el.cloneNode();
    const _vtc = el[vtcKey];
    if (_vtc) {
      _vtc.forEach((cls) => {
        cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
      });
    }
    moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
    clone.style.display = "none";
    const container = root.nodeType === 1 ? root : root.parentNode;
    container.appendChild(clone);
    const { hasTransform } = getTransitionInfo(clone);
    container.removeChild(clone);
    return hasTransform;
  }
  var getModelAssigner = (vnode) => {
    const fn2 = vnode.props["onUpdate:modelValue"] || false;
    return isArray(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
  };
  function onCompositionStart(e) {
    e.target.composing = true;
  }
  function onCompositionEnd(e) {
    const target = e.target;
    if (target.composing) {
      target.composing = false;
      target.dispatchEvent(new Event("input"));
    }
  }
  var assignKey = Symbol("_assign");
  var vModelText = {
    created(el, { modifiers: { lazy, trim, number } }, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      const castToNumber = number || vnode.props && vnode.props.type === "number";
      addEventListener2(el, lazy ? "change" : "input", (e) => {
        if (e.target.composing)
          return;
        let domValue = el.value;
        if (trim) {
          domValue = domValue.trim();
        }
        if (castToNumber) {
          domValue = looseToNumber(domValue);
        }
        el[assignKey](domValue);
      });
      if (trim) {
        addEventListener2(el, "change", () => {
          el.value = el.value.trim();
        });
      }
      if (!lazy) {
        addEventListener2(el, "compositionstart", onCompositionStart);
        addEventListener2(el, "compositionend", onCompositionEnd);
        addEventListener2(el, "change", onCompositionEnd);
      }
    },
    mounted(el, { value }) {
      el.value = value == null ? "" : value;
    },
    beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      if (el.composing)
        return;
      const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
      const newValue = value == null ? "" : value;
      if (elValue === newValue) {
        return;
      }
      if (document.activeElement === el && el.type !== "range") {
        if (lazy && value === oldValue) {
          return;
        }
        if (trim && el.value.trim() === newValue) {
          return;
        }
      }
      el.value = newValue;
    }
  };
  var systemModifiers = ["ctrl", "shift", "alt", "meta"];
  var modifierGuards = {
    stop: (e) => e.stopPropagation(),
    prevent: (e) => e.preventDefault(),
    self: (e) => e.target !== e.currentTarget,
    ctrl: (e) => !e.ctrlKey,
    shift: (e) => !e.shiftKey,
    alt: (e) => !e.altKey,
    meta: (e) => !e.metaKey,
    left: (e) => "button" in e && e.button !== 0,
    middle: (e) => "button" in e && e.button !== 1,
    right: (e) => "button" in e && e.button !== 2,
    exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
  };
  var withModifiers = (fn2, modifiers) => {
    const cache = fn2._withMods || (fn2._withMods = {});
    const cacheKey = modifiers.join(".");
    return cache[cacheKey] || (cache[cacheKey] = (event2, ...args) => {
      for (let i = 0; i < modifiers.length; i++) {
        const guard = modifierGuards[modifiers[i]];
        if (guard && guard(event2, modifiers))
          return;
      }
      return fn2(event2, ...args);
    });
  };
  var keyNames = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
  };
  var withKeys = (fn2, modifiers) => {
    const cache = fn2._withKeys || (fn2._withKeys = {});
    const cacheKey = modifiers.join(".");
    return cache[cacheKey] || (cache[cacheKey] = (event2) => {
      if (!("key" in event2)) {
        return;
      }
      const eventKey = hyphenate(event2.key);
      if (modifiers.some(
        (k) => k === eventKey || keyNames[k] === eventKey
      )) {
        return fn2(event2);
      }
    });
  };
  var rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
  var renderer;
  function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions));
  }
  var render = (...args) => {
    ensureRenderer().render(...args);
  };
  var createApp = (...args) => {
    const app = ensureRenderer().createApp(...args);
    if (true) {
      injectNativeTagCheck(app);
      injectCompilerOptionsCheck(app);
    }
    const { mount } = app;
    app.mount = (containerOrSelector) => {
      const container = normalizeContainer(containerOrSelector);
      if (!container)
        return;
      const component = app._component;
      if (!isFunction(component) && !component.render && !component.template) {
        component.template = container.innerHTML;
      }
      if (container.nodeType === 1) {
        container.textContent = "";
      }
      const proxy = mount(container, false, resolveRootNamespace(container));
      if (container instanceof Element) {
        container.removeAttribute("v-cloak");
        container.setAttribute("data-v-app", "");
      }
      return proxy;
    };
    return app;
  };
  function resolveRootNamespace(container) {
    if (container instanceof SVGElement) {
      return "svg";
    }
    if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
      return "mathml";
    }
  }
  function injectNativeTagCheck(app) {
    Object.defineProperty(app.config, "isNativeTag", {
      value: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
      writable: false
    });
  }
  function injectCompilerOptionsCheck(app) {
    if (isRuntimeOnly()) {
      const isCustomElement = app.config.isCustomElement;
      Object.defineProperty(app.config, "isCustomElement", {
        get() {
          return isCustomElement;
        },
        set() {
          warn2(
            `The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`
          );
        }
      });
      const compilerOptions = app.config.compilerOptions;
      const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
      Object.defineProperty(app.config, "compilerOptions", {
        get() {
          warn2(msg);
          return compilerOptions;
        },
        set() {
          warn2(msg);
        }
      });
    }
  }
  function normalizeContainer(container) {
    if (isString(container)) {
      const res = document.querySelector(container);
      if (!res) {
        warn2(
          `Failed to mount app: mount target selector "${container}" returned null.`
        );
      }
      return res;
    }
    if (window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
      warn2(
        `mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`
      );
    }
    return container;
  }

  // ../posawesome/node_modules/vue/dist/vue.runtime.esm-bundler.js
  function initDev() {
    {
      initCustomFormatter();
    }
  }
  if (true) {
    initDev();
  }

  // ../posawesome/node_modules/vuetify/lib/composables/toggleScope.js
  function useToggleScope(source, fn2) {
    let scope;
    function start() {
      scope = effectScope();
      scope.run(() => fn2.length ? fn2(() => {
        scope == null ? void 0 : scope.stop();
        start();
      }) : fn2());
    }
    watch2(source, (active) => {
      if (active && !scope) {
        start();
      } else if (!active) {
        scope == null ? void 0 : scope.stop();
        scope = void 0;
      }
    }, {
      immediate: true
    });
    onScopeDispose(() => {
      scope == null ? void 0 : scope.stop();
    });
  }

  // ../posawesome/node_modules/vuetify/lib/util/globals.js
  var IN_BROWSER = typeof window !== "undefined";
  var SUPPORTS_INTERSECTION = IN_BROWSER && "IntersectionObserver" in window;
  var SUPPORTS_TOUCH = IN_BROWSER && ("ontouchstart" in window || window.navigator.maxTouchPoints > 0);
  var SUPPORTS_EYE_DROPPER = IN_BROWSER && "EyeDropper" in window;

  // ../posawesome/node_modules/vuetify/lib/util/helpers.js
  function _classPrivateFieldInitSpec(e, t, a) {
    _checkPrivateRedeclaration(e, t), t.set(e, a);
  }
  function _checkPrivateRedeclaration(e, t) {
    if (t.has(e))
      throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
  function _classPrivateFieldSet(s, a, r) {
    return s.set(_assertClassBrand(s, a), r), r;
  }
  function _classPrivateFieldGet(s, a) {
    return s.get(_assertClassBrand(s, a));
  }
  function _assertClassBrand(e, t, n) {
    if ("function" == typeof e ? e === t : e.has(t))
      return arguments.length < 3 ? t : n;
    throw new TypeError("Private element is not present on this object");
  }
  function getNestedValue(obj, path, fallback) {
    const last = path.length - 1;
    if (last < 0)
      return obj === void 0 ? fallback : obj;
    for (let i = 0; i < last; i++) {
      if (obj == null) {
        return fallback;
      }
      obj = obj[path[i]];
    }
    if (obj == null)
      return fallback;
    return obj[path[last]] === void 0 ? fallback : obj[path[last]];
  }
  function deepEqual(a, b) {
    if (a === b)
      return true;
    if (a instanceof Date && b instanceof Date && a.getTime() !== b.getTime()) {
      return false;
    }
    if (a !== Object(a) || b !== Object(b)) {
      return false;
    }
    const props = Object.keys(a);
    if (props.length !== Object.keys(b).length) {
      return false;
    }
    return props.every((p2) => deepEqual(a[p2], b[p2]));
  }
  function getObjectValueByPath(obj, path, fallback) {
    if (obj == null || !path || typeof path !== "string")
      return fallback;
    if (obj[path] !== void 0)
      return obj[path];
    path = path.replace(/\[(\w+)\]/g, ".$1");
    path = path.replace(/^\./, "");
    return getNestedValue(obj, path.split("."), fallback);
  }
  function getPropertyFromItem(item, property, fallback) {
    if (property === true)
      return item === void 0 ? fallback : item;
    if (property == null || typeof property === "boolean")
      return fallback;
    if (item !== Object(item)) {
      if (typeof property !== "function")
        return fallback;
      const value2 = property(item, fallback);
      return typeof value2 === "undefined" ? fallback : value2;
    }
    if (typeof property === "string")
      return getObjectValueByPath(item, property, fallback);
    if (Array.isArray(property))
      return getNestedValue(item, property, fallback);
    if (typeof property !== "function")
      return fallback;
    const value = property(item, fallback);
    return typeof value === "undefined" ? fallback : value;
  }
  function createRange(length) {
    let start = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return Array.from({
      length
    }, (v, k) => start + k);
  }
  function convertToUnit(str) {
    let unit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "px";
    if (str == null || str === "") {
      return void 0;
    }
    const num = Number(str);
    if (isNaN(num)) {
      return String(str);
    } else if (!isFinite(num)) {
      return void 0;
    } else {
      return `${num}${unit}`;
    }
  }
  function isObject2(obj) {
    return obj !== null && typeof obj === "object" && !Array.isArray(obj);
  }
  function isPlainObject2(obj) {
    let proto;
    return obj !== null && typeof obj === "object" && ((proto = Object.getPrototypeOf(obj)) === Object.prototype || proto === null);
  }
  function refElement(obj) {
    if (obj && "$el" in obj) {
      const el = obj.$el;
      if ((el == null ? void 0 : el.nodeType) === Node.TEXT_NODE) {
        return el.nextElementSibling;
      }
      return el;
    }
    return obj;
  }
  var keyCodes = Object.freeze({
    enter: 13,
    tab: 9,
    delete: 46,
    esc: 27,
    space: 32,
    up: 38,
    down: 40,
    left: 37,
    right: 39,
    end: 35,
    home: 36,
    del: 46,
    backspace: 8,
    insert: 45,
    pageup: 33,
    pagedown: 34,
    shift: 16
  });
  var keyValues = Object.freeze({
    enter: "Enter",
    tab: "Tab",
    delete: "Delete",
    esc: "Escape",
    space: "Space",
    up: "ArrowUp",
    down: "ArrowDown",
    left: "ArrowLeft",
    right: "ArrowRight",
    end: "End",
    home: "Home",
    del: "Delete",
    backspace: "Backspace",
    insert: "Insert",
    pageup: "PageUp",
    pagedown: "PageDown",
    shift: "Shift"
  });
  function keys(o) {
    return Object.keys(o);
  }
  function has(obj, key) {
    return key.every((k) => obj.hasOwnProperty(k));
  }
  function pick(obj, paths) {
    const found = {};
    for (const key of paths) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        found[key] = obj[key];
      }
    }
    return found;
  }
  function pickWithRest(obj, paths, exclude) {
    const found = /* @__PURE__ */ Object.create(null);
    const rest = /* @__PURE__ */ Object.create(null);
    for (const key in obj) {
      if (paths.some((path) => path instanceof RegExp ? path.test(key) : path === key) && !(exclude == null ? void 0 : exclude.some((path) => path === key))) {
        found[key] = obj[key];
      } else {
        rest[key] = obj[key];
      }
    }
    return [found, rest];
  }
  function omit(obj, exclude) {
    const clone = __spreadValues({}, obj);
    exclude.forEach((prop) => delete clone[prop]);
    return clone;
  }
  var onRE = /^on[^a-z]/;
  var isOn2 = (key) => onRE.test(key);
  var bubblingEvents = ["onAfterscriptexecute", "onAnimationcancel", "onAnimationend", "onAnimationiteration", "onAnimationstart", "onAuxclick", "onBeforeinput", "onBeforescriptexecute", "onChange", "onClick", "onCompositionend", "onCompositionstart", "onCompositionupdate", "onContextmenu", "onCopy", "onCut", "onDblclick", "onFocusin", "onFocusout", "onFullscreenchange", "onFullscreenerror", "onGesturechange", "onGestureend", "onGesturestart", "onGotpointercapture", "onInput", "onKeydown", "onKeypress", "onKeyup", "onLostpointercapture", "onMousedown", "onMousemove", "onMouseout", "onMouseover", "onMouseup", "onMousewheel", "onPaste", "onPointercancel", "onPointerdown", "onPointerenter", "onPointerleave", "onPointermove", "onPointerout", "onPointerover", "onPointerup", "onReset", "onSelect", "onSubmit", "onTouchcancel", "onTouchend", "onTouchmove", "onTouchstart", "onTransitioncancel", "onTransitionend", "onTransitionrun", "onTransitionstart", "onWheel"];
  var compositionIgnoreKeys = ["ArrowUp", "ArrowDown", "ArrowRight", "ArrowLeft", "Enter", "Escape", "Tab", " "];
  function isComposingIgnoreKey(e) {
    return e.isComposing && compositionIgnoreKeys.includes(e.key);
  }
  function filterInputAttrs(attrs) {
    const [events, props] = pickWithRest(attrs, [onRE]);
    const inputEvents = omit(events, bubblingEvents);
    const [rootAttrs, inputAttrs] = pickWithRest(props, ["class", "style", "id", /^data-/]);
    Object.assign(rootAttrs, events);
    Object.assign(inputAttrs, inputEvents);
    return [rootAttrs, inputAttrs];
  }
  function wrapInArray(v) {
    return v == null ? [] : Array.isArray(v) ? v : [v];
  }
  function debounce(fn2, delay) {
    let timeoutId = 0;
    const wrap = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => fn2(...args), unref(delay));
    };
    wrap.clear = () => {
      clearTimeout(timeoutId);
    };
    wrap.immediate = fn2;
    return wrap;
  }
  function clamp(value) {
    let min = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let max = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    return Math.max(min, Math.min(max, value));
  }
  function getDecimals(value) {
    const trimmedStr = value.toString().trim();
    return trimmedStr.includes(".") ? trimmedStr.length - trimmedStr.indexOf(".") - 1 : 0;
  }
  function padEnd(str, length) {
    let char = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
    return str + char.repeat(Math.max(0, length - str.length));
  }
  function padStart(str, length) {
    let char = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
    return char.repeat(Math.max(0, length - str.length)) + str;
  }
  function chunk(str) {
    let size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    const chunked = [];
    let index = 0;
    while (index < str.length) {
      chunked.push(str.substr(index, size));
      index += size;
    }
    return chunked;
  }
  function humanReadableFileSize(bytes) {
    let base = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
    if (bytes < base) {
      return `${bytes} B`;
    }
    const prefix = base === 1024 ? ["Ki", "Mi", "Gi"] : ["k", "M", "G"];
    let unit = -1;
    while (Math.abs(bytes) >= base && unit < prefix.length - 1) {
      bytes /= base;
      ++unit;
    }
    return `${bytes.toFixed(1)} ${prefix[unit]}B`;
  }
  function mergeDeep() {
    let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let arrayFn = arguments.length > 2 ? arguments[2] : void 0;
    const out = {};
    for (const key in source) {
      out[key] = source[key];
    }
    for (const key in target) {
      const sourceProperty = source[key];
      const targetProperty = target[key];
      if (isPlainObject2(sourceProperty) && isPlainObject2(targetProperty)) {
        out[key] = mergeDeep(sourceProperty, targetProperty, arrayFn);
        continue;
      }
      if (arrayFn && Array.isArray(sourceProperty) && Array.isArray(targetProperty)) {
        out[key] = arrayFn(sourceProperty, targetProperty);
        continue;
      }
      out[key] = targetProperty;
    }
    return out;
  }
  function flattenFragments(nodes) {
    return nodes.map((node) => {
      if (node.type === Fragment) {
        return flattenFragments(node.children);
      } else {
        return node;
      }
    }).flat();
  }
  function toKebabCase() {
    let str = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    if (toKebabCase.cache.has(str))
      return toKebabCase.cache.get(str);
    const kebab = str.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase();
    toKebabCase.cache.set(str, kebab);
    return kebab;
  }
  toKebabCase.cache = /* @__PURE__ */ new Map();
  function findChildrenWithProvide(key, vnode) {
    if (!vnode || typeof vnode !== "object")
      return [];
    if (Array.isArray(vnode)) {
      return vnode.map((child) => findChildrenWithProvide(key, child)).flat(1);
    } else if (vnode.suspense) {
      return findChildrenWithProvide(key, vnode.ssContent);
    } else if (Array.isArray(vnode.children)) {
      return vnode.children.map((child) => findChildrenWithProvide(key, child)).flat(1);
    } else if (vnode.component) {
      if (Object.getOwnPropertySymbols(vnode.component.provides).includes(key)) {
        return [vnode.component];
      } else if (vnode.component.subTree) {
        return findChildrenWithProvide(key, vnode.component.subTree).flat(1);
      }
    }
    return [];
  }
  var _arr = /* @__PURE__ */ new WeakMap();
  var _pointer = /* @__PURE__ */ new WeakMap();
  var CircularBuffer = class {
    constructor(size) {
      _classPrivateFieldInitSpec(this, _arr, []);
      _classPrivateFieldInitSpec(this, _pointer, 0);
      this.size = size;
    }
    get isFull() {
      return _classPrivateFieldGet(_arr, this).length === this.size;
    }
    push(val) {
      _classPrivateFieldGet(_arr, this)[_classPrivateFieldGet(_pointer, this)] = val;
      _classPrivateFieldSet(_pointer, this, (_classPrivateFieldGet(_pointer, this) + 1) % this.size);
    }
    values() {
      return _classPrivateFieldGet(_arr, this).slice(_classPrivateFieldGet(_pointer, this)).concat(_classPrivateFieldGet(_arr, this).slice(0, _classPrivateFieldGet(_pointer, this)));
    }
    clear() {
      _classPrivateFieldGet(_arr, this).length = 0;
      _classPrivateFieldSet(_pointer, this, 0);
    }
  };
  function getEventCoordinates(e) {
    if ("touches" in e) {
      return {
        clientX: e.touches[0].clientX,
        clientY: e.touches[0].clientY
      };
    }
    return {
      clientX: e.clientX,
      clientY: e.clientY
    };
  }
  function destructComputed(getter) {
    const refs = reactive({});
    watchEffect(() => {
      const base = getter();
      for (const key in base) {
        refs[key] = base[key];
      }
    }, {
      flush: "sync"
    });
    const obj = {};
    for (const key in refs) {
      obj[key] = toRef(() => refs[key]);
    }
    return obj;
  }
  function includes(arr, val) {
    return arr.includes(val);
  }
  function eventName(propName) {
    return propName[2].toLowerCase() + propName.slice(3);
  }
  var EventProp = () => [Function, Array];
  function hasEvent(props, name) {
    name = "on" + capitalize(name);
    return !!(props[name] || props[`${name}Once`] || props[`${name}Capture`] || props[`${name}OnceCapture`] || props[`${name}CaptureOnce`]);
  }
  function callEvent(handler) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    if (Array.isArray(handler)) {
      for (const h2 of handler) {
        h2(...args);
      }
    } else if (typeof handler === "function") {
      handler(...args);
    }
  }
  function focusableChildren(el) {
    let filterByTabIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    const targets = ["button", "[href]", 'input:not([type="hidden"])', "select", "textarea", "[tabindex]"].map((s) => `${s}${filterByTabIndex ? ':not([tabindex="-1"])' : ""}:not([disabled])`).join(", ");
    return [...el.querySelectorAll(targets)];
  }
  function getNextElement(elements, location2, condition) {
    var _a3;
    let _el;
    let idx = elements.indexOf(document.activeElement);
    const inc = location2 === "next" ? 1 : -1;
    do {
      idx += inc;
      _el = elements[idx];
    } while ((!_el || _el.offsetParent == null || !((_a3 = condition == null ? void 0 : condition(_el)) != null ? _a3 : true)) && idx < elements.length && idx >= 0);
    return _el;
  }
  function focusChild(el, location2) {
    var _a3, _b, _c, _d;
    const focusable = focusableChildren(el);
    if (location2 == null) {
      if (el === document.activeElement || !el.contains(document.activeElement)) {
        (_a3 = focusable[0]) == null ? void 0 : _a3.focus();
      }
    } else if (location2 === "first") {
      (_b = focusable[0]) == null ? void 0 : _b.focus();
    } else if (location2 === "last") {
      (_c = focusable.at(-1)) == null ? void 0 : _c.focus();
    } else if (typeof location2 === "number") {
      (_d = focusable[location2]) == null ? void 0 : _d.focus();
    } else {
      const _el = getNextElement(focusable, location2);
      if (_el)
        _el.focus();
      else
        focusChild(el, location2 === "next" ? "first" : "last");
    }
  }
  function isEmpty(val) {
    return val === null || val === void 0 || typeof val === "string" && val.trim() === "";
  }
  function noop() {
  }
  function matchesSelector(el, selector) {
    const supportsSelector = IN_BROWSER && typeof CSS !== "undefined" && typeof CSS.supports !== "undefined" && CSS.supports(`selector(${selector})`);
    if (!supportsSelector)
      return null;
    try {
      return !!el && el.matches(selector);
    } catch (err) {
      return null;
    }
  }
  function ensureValidVNode2(vnodes) {
    return vnodes.some((child) => {
      if (!isVNode(child))
        return true;
      if (child.type === Comment)
        return false;
      return child.type !== Fragment || ensureValidVNode2(child.children);
    }) ? vnodes : null;
  }
  function defer(timeout, cb) {
    if (!IN_BROWSER || timeout === 0) {
      cb();
      return () => {
      };
    }
    const timeoutId = window.setTimeout(cb, timeout);
    return () => window.clearTimeout(timeoutId);
  }
  function isClickInsideElement(event2, targetDiv) {
    const mouseX = event2.clientX;
    const mouseY = event2.clientY;
    const divRect = targetDiv.getBoundingClientRect();
    const divLeft = divRect.left;
    const divTop = divRect.top;
    const divRight = divRect.right;
    const divBottom = divRect.bottom;
    return mouseX >= divLeft && mouseX <= divRight && mouseY >= divTop && mouseY <= divBottom;
  }
  function templateRef() {
    const el = shallowRef();
    const fn2 = (target) => {
      el.value = target;
    };
    Object.defineProperty(fn2, "value", {
      enumerable: true,
      get: () => el.value,
      set: (val) => el.value = val
    });
    Object.defineProperty(fn2, "el", {
      enumerable: true,
      get: () => refElement(el.value)
    });
    return fn2;
  }
  function checkPrintable(e) {
    const isPrintableChar = e.key.length === 1;
    const noModifier = !e.ctrlKey && !e.metaKey && !e.altKey;
    return isPrintableChar && noModifier;
  }
  function isPrimitive(value) {
    return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "bigint";
  }
  function extractNumber(text, decimalDigitsLimit) {
    const cleanText = text.split("").filter((x) => /[\d\-.]/.test(x)).filter((x, i, all) => i === 0 && /[-]/.test(x) || x === "." && i === all.indexOf(".") || /\d/.test(x)).join("");
    if (decimalDigitsLimit === 0) {
      return cleanText.split(".")[0];
    }
    if (decimalDigitsLimit !== null && /\.\d/.test(cleanText)) {
      const parts = cleanText.split(".");
      return [parts[0], parts[1].substring(0, decimalDigitsLimit)].join(".");
    }
    return cleanText;
  }
  function camelizeProps(props) {
    const out = {};
    for (const prop in props) {
      out[camelize(prop)] = props[prop];
    }
    return out;
  }
  function onlyDefinedProps(props) {
    const booleanAttributes = ["checked", "disabled"];
    return Object.fromEntries(Object.entries(props).filter((_ref) => {
      let [key, v] = _ref;
      return booleanAttributes.includes(key) ? !!v : v !== void 0;
    }));
  }

  // ../posawesome/node_modules/vuetify/lib/util/anchor.js
  var block = ["top", "bottom"];
  var inline = ["start", "end", "left", "right"];
  function parseAnchor(anchor, isRtl) {
    let [side, align] = anchor.split(" ");
    if (!align) {
      align = includes(block, side) ? "start" : includes(inline, side) ? "top" : "center";
    }
    return {
      side: toPhysical(side, isRtl),
      align: toPhysical(align, isRtl)
    };
  }
  function toPhysical(str, isRtl) {
    if (str === "start")
      return isRtl ? "right" : "left";
    if (str === "end")
      return isRtl ? "left" : "right";
    return str;
  }
  function flipSide(anchor) {
    return {
      side: {
        center: "center",
        top: "bottom",
        bottom: "top",
        left: "right",
        right: "left"
      }[anchor.side],
      align: anchor.align
    };
  }
  function flipAlign(anchor) {
    return {
      side: anchor.side,
      align: {
        center: "center",
        top: "bottom",
        bottom: "top",
        left: "right",
        right: "left"
      }[anchor.align]
    };
  }
  function flipCorner(anchor) {
    return {
      side: anchor.align,
      align: anchor.side
    };
  }
  function getAxis(anchor) {
    return includes(block, anchor.side) ? "y" : "x";
  }

  // ../posawesome/node_modules/vuetify/lib/util/box.js
  var Box = class {
    constructor(_ref) {
      let {
        x,
        y,
        width,
        height
      } = _ref;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
    }
    get top() {
      return this.y;
    }
    get bottom() {
      return this.y + this.height;
    }
    get left() {
      return this.x;
    }
    get right() {
      return this.x + this.width;
    }
  };
  function getOverflow(a, b) {
    return {
      x: {
        before: Math.max(0, b.left - a.left),
        after: Math.max(0, a.right - b.right)
      },
      y: {
        before: Math.max(0, b.top - a.top),
        after: Math.max(0, a.bottom - b.bottom)
      }
    };
  }
  function getTargetBox(target) {
    if (Array.isArray(target)) {
      return new Box({
        x: target[0],
        y: target[1],
        width: 0,
        height: 0
      });
    } else {
      return target.getBoundingClientRect();
    }
  }
  function getElementBox(el) {
    if (el === document.documentElement) {
      if (!visualViewport) {
        return new Box({
          x: 0,
          y: 0,
          width: document.documentElement.clientWidth,
          height: document.documentElement.clientHeight
        });
      } else {
        return new Box({
          x: visualViewport.scale > 1 ? 0 : visualViewport.offsetLeft,
          y: visualViewport.scale > 1 ? 0 : visualViewport.offsetTop,
          width: visualViewport.width * visualViewport.scale,
          height: visualViewport.height * visualViewport.scale
        });
      }
    } else {
      const rect = el.getBoundingClientRect();
      return new Box({
        x: rect.x,
        y: rect.y,
        width: el.clientWidth,
        height: el.clientHeight
      });
    }
  }

  // ../posawesome/node_modules/vuetify/lib/util/animation.js
  function nullifyTransforms(el) {
    const rect = el.getBoundingClientRect();
    const style = getComputedStyle(el);
    const tx = style.transform;
    if (tx) {
      let ta, sx, sy, dx, dy;
      if (tx.startsWith("matrix3d(")) {
        ta = tx.slice(9, -1).split(/, /);
        sx = Number(ta[0]);
        sy = Number(ta[5]);
        dx = Number(ta[12]);
        dy = Number(ta[13]);
      } else if (tx.startsWith("matrix(")) {
        ta = tx.slice(7, -1).split(/, /);
        sx = Number(ta[0]);
        sy = Number(ta[3]);
        dx = Number(ta[4]);
        dy = Number(ta[5]);
      } else {
        return new Box(rect);
      }
      const to2 = style.transformOrigin;
      const x = rect.x - dx - (1 - sx) * parseFloat(to2);
      const y = rect.y - dy - (1 - sy) * parseFloat(to2.slice(to2.indexOf(" ") + 1));
      const w = sx ? rect.width / sx : el.offsetWidth + 1;
      const h2 = sy ? rect.height / sy : el.offsetHeight + 1;
      return new Box({
        x,
        y,
        width: w,
        height: h2
      });
    } else {
      return new Box(rect);
    }
  }
  function animate(el, keyframes, options) {
    if (typeof el.animate === "undefined")
      return {
        finished: Promise.resolve()
      };
    let animation;
    try {
      animation = el.animate(keyframes, options);
    } catch (err) {
      return {
        finished: Promise.resolve()
      };
    }
    if (typeof animation.finished === "undefined") {
      animation.finished = new Promise((resolve2) => {
        animation.onfinish = () => {
          resolve2(animation);
        };
      });
    }
    return animation;
  }

  // ../posawesome/node_modules/vuetify/lib/util/bindProps.js
  var handlers = /* @__PURE__ */ new WeakMap();
  function bindProps(el, props) {
    Object.keys(props).forEach((k) => {
      var _a3;
      if (isOn2(k)) {
        const name = eventName(k);
        const handler = handlers.get(el);
        if (props[k] == null) {
          handler == null ? void 0 : handler.forEach((v) => {
            const [n, fn2] = v;
            if (n === name) {
              el.removeEventListener(name, fn2);
              handler.delete(v);
            }
          });
        } else if (!handler || !((_a3 = [...handler]) == null ? void 0 : _a3.some((v) => v[0] === name && v[1] === props[k]))) {
          el.addEventListener(name, props[k]);
          const _handler = handler || /* @__PURE__ */ new Set();
          _handler.add([name, props[k]]);
          if (!handlers.has(el))
            handlers.set(el, _handler);
        }
      } else {
        if (props[k] == null) {
          el.removeAttribute(k);
        } else {
          el.setAttribute(k, props[k]);
        }
      }
    });
  }
  function unbindProps(el, props) {
    Object.keys(props).forEach((k) => {
      if (isOn2(k)) {
        const name = eventName(k);
        const handler = handlers.get(el);
        handler == null ? void 0 : handler.forEach((v) => {
          const [n, fn2] = v;
          if (n === name) {
            el.removeEventListener(name, fn2);
            handler.delete(v);
          }
        });
      } else {
        el.removeAttribute(k);
      }
    });
  }

  // ../posawesome/node_modules/vuetify/lib/util/color/APCA.js
  var mainTRC = 2.4;
  var Rco = 0.2126729;
  var Gco = 0.7151522;
  var Bco = 0.072175;
  var normBG = 0.55;
  var normTXT = 0.58;
  var revTXT = 0.57;
  var revBG = 0.62;
  var blkThrs = 0.03;
  var blkClmp = 1.45;
  var deltaYmin = 5e-4;
  var scaleBoW = 1.25;
  var scaleWoB = 1.25;
  var loConThresh = 0.078;
  var loConFactor = 12.82051282051282;
  var loConOffset = 0.06;
  var loClip = 1e-3;
  function APCAcontrast(text, background) {
    const Rtxt = (text.r / 255) ** mainTRC;
    const Gtxt = (text.g / 255) ** mainTRC;
    const Btxt = (text.b / 255) ** mainTRC;
    const Rbg = (background.r / 255) ** mainTRC;
    const Gbg = (background.g / 255) ** mainTRC;
    const Bbg = (background.b / 255) ** mainTRC;
    let Ytxt = Rtxt * Rco + Gtxt * Gco + Btxt * Bco;
    let Ybg = Rbg * Rco + Gbg * Gco + Bbg * Bco;
    if (Ytxt <= blkThrs)
      Ytxt += (blkThrs - Ytxt) ** blkClmp;
    if (Ybg <= blkThrs)
      Ybg += (blkThrs - Ybg) ** blkClmp;
    if (Math.abs(Ybg - Ytxt) < deltaYmin)
      return 0;
    let outputContrast;
    if (Ybg > Ytxt) {
      const SAPC = (Ybg ** normBG - Ytxt ** normTXT) * scaleBoW;
      outputContrast = SAPC < loClip ? 0 : SAPC < loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC - loConOffset;
    } else {
      const SAPC = (Ybg ** revBG - Ytxt ** revTXT) * scaleWoB;
      outputContrast = SAPC > -loClip ? 0 : SAPC > -loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC + loConOffset;
    }
    return outputContrast * 100;
  }

  // ../posawesome/node_modules/vuetify/lib/util/console.js
  function consoleWarn(message2) {
    warn2(`Vuetify: ${message2}`);
  }
  function consoleError(message2) {
    warn2(`Vuetify error: ${message2}`);
  }
  function deprecate(original, replacement) {
    replacement = Array.isArray(replacement) ? replacement.slice(0, -1).map((s) => `'${s}'`).join(", ") + ` or '${replacement.at(-1)}'` : `'${replacement}'`;
    warn2(`[Vuetify UPGRADE] '${original}' is deprecated, use ${replacement} instead.`);
  }

  // ../posawesome/node_modules/vuetify/lib/util/color/transformCIELAB.js
  var delta = 0.20689655172413793;
  var cielabForwardTransform = (t) => t > delta ** 3 ? Math.cbrt(t) : t / (3 * delta ** 2) + 4 / 29;
  var cielabReverseTransform = (t) => t > delta ? t ** 3 : 3 * delta ** 2 * (t - 4 / 29);
  function fromXYZ(xyz) {
    const transform2 = cielabForwardTransform;
    const transformedY = transform2(xyz[1]);
    return [116 * transformedY - 16, 500 * (transform2(xyz[0] / 0.95047) - transformedY), 200 * (transformedY - transform2(xyz[2] / 1.08883))];
  }
  function toXYZ(lab) {
    const transform2 = cielabReverseTransform;
    const Ln2 = (lab[0] + 16) / 116;
    return [transform2(Ln2 + lab[1] / 500) * 0.95047, transform2(Ln2), transform2(Ln2 - lab[2] / 200) * 1.08883];
  }

  // ../posawesome/node_modules/vuetify/lib/util/color/transformSRGB.js
  var srgbForwardMatrix = [[3.2406, -1.5372, -0.4986], [-0.9689, 1.8758, 0.0415], [0.0557, -0.204, 1.057]];
  var srgbForwardTransform = (C) => C <= 31308e-7 ? C * 12.92 : 1.055 * C ** (1 / 2.4) - 0.055;
  var srgbReverseMatrix = [[0.4124, 0.3576, 0.1805], [0.2126, 0.7152, 0.0722], [0.0193, 0.1192, 0.9505]];
  var srgbReverseTransform = (C) => C <= 0.04045 ? C / 12.92 : ((C + 0.055) / 1.055) ** 2.4;
  function fromXYZ2(xyz) {
    const rgb2 = Array(3);
    const transform2 = srgbForwardTransform;
    const matrix = srgbForwardMatrix;
    for (let i = 0; i < 3; ++i) {
      rgb2[i] = Math.round(clamp(transform2(matrix[i][0] * xyz[0] + matrix[i][1] * xyz[1] + matrix[i][2] * xyz[2])) * 255);
    }
    return {
      r: rgb2[0],
      g: rgb2[1],
      b: rgb2[2]
    };
  }
  function toXYZ2(_ref) {
    let {
      r,
      g,
      b
    } = _ref;
    const xyz = [0, 0, 0];
    const transform2 = srgbReverseTransform;
    const matrix = srgbReverseMatrix;
    r = transform2(r / 255);
    g = transform2(g / 255);
    b = transform2(b / 255);
    for (let i = 0; i < 3; ++i) {
      xyz[i] = matrix[i][0] * r + matrix[i][1] * g + matrix[i][2] * b;
    }
    return xyz;
  }

  // ../posawesome/node_modules/vuetify/lib/util/colorUtils.js
  function isCssColor(color) {
    return !!color && /^(#|var\(--|(rgb|hsl)a?\()/.test(color);
  }
  function isParsableColor(color) {
    return isCssColor(color) && !/^((rgb|hsl)a?\()?var\(--/.test(color);
  }
  var cssColorRe = new RegExp("^(?<fn>(?:rgb|hsl)a?)\\((?<values>.+)\\)");
  var mappers = {
    rgb: (r, g, b, a) => ({
      r,
      g,
      b,
      a
    }),
    rgba: (r, g, b, a) => ({
      r,
      g,
      b,
      a
    }),
    hsl: (h2, s, l, a) => HSLtoRGB({
      h: h2,
      s,
      l,
      a
    }),
    hsla: (h2, s, l, a) => HSLtoRGB({
      h: h2,
      s,
      l,
      a
    }),
    hsv: (h2, s, v, a) => HSVtoRGB({
      h: h2,
      s,
      v,
      a
    }),
    hsva: (h2, s, v, a) => HSVtoRGB({
      h: h2,
      s,
      v,
      a
    })
  };
  function parseColor(color) {
    if (typeof color === "number") {
      if (isNaN(color) || color < 0 || color > 16777215) {
        consoleWarn(`'${color}' is not a valid hex color`);
      }
      return {
        r: (color & 16711680) >> 16,
        g: (color & 65280) >> 8,
        b: color & 255
      };
    } else if (typeof color === "string" && cssColorRe.test(color)) {
      const {
        groups
      } = color.match(cssColorRe);
      const {
        fn: fn2,
        values
      } = groups;
      const realValues = values.split(/,\s*|\s*\/\s*|\s+/).map((v, i) => {
        if (v.endsWith("%") || i > 0 && i < 3 && ["hsl", "hsla", "hsv", "hsva"].includes(fn2)) {
          return parseFloat(v) / 100;
        } else {
          return parseFloat(v);
        }
      });
      return mappers[fn2](...realValues);
    } else if (typeof color === "string") {
      let hex2 = color.startsWith("#") ? color.slice(1) : color;
      if ([3, 4].includes(hex2.length)) {
        hex2 = hex2.split("").map((char) => char + char).join("");
      } else if (![6, 8].includes(hex2.length)) {
        consoleWarn(`'${color}' is not a valid hex(a) color`);
      }
      const int2 = parseInt(hex2, 16);
      if (isNaN(int2) || int2 < 0 || int2 > 4294967295) {
        consoleWarn(`'${color}' is not a valid hex(a) color`);
      }
      return HexToRGB(hex2);
    } else if (typeof color === "object") {
      if (has(color, ["r", "g", "b"])) {
        return color;
      } else if (has(color, ["h", "s", "l"])) {
        return HSVtoRGB(HSLtoHSV(color));
      } else if (has(color, ["h", "s", "v"])) {
        return HSVtoRGB(color);
      }
    }
    throw new TypeError(`Invalid color: ${color == null ? color : String(color) || color.constructor.name}
Expected #hex, #hexa, rgb(), rgba(), hsl(), hsla(), object or number`);
  }
  function HSVtoRGB(hsva) {
    const {
      h: h2,
      s,
      v,
      a
    } = hsva;
    const f = (n) => {
      const k = (n + h2 / 60) % 6;
      return v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
    };
    const rgb2 = [f(5), f(3), f(1)].map((v2) => Math.round(v2 * 255));
    return {
      r: rgb2[0],
      g: rgb2[1],
      b: rgb2[2],
      a
    };
  }
  function HSLtoRGB(hsla2) {
    return HSVtoRGB(HSLtoHSV(hsla2));
  }
  function RGBtoHSV(rgba2) {
    if (!rgba2)
      return {
        h: 0,
        s: 1,
        v: 1,
        a: 1
      };
    const r = rgba2.r / 255;
    const g = rgba2.g / 255;
    const b = rgba2.b / 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h2 = 0;
    if (max !== min) {
      if (max === r) {
        h2 = 60 * (0 + (g - b) / (max - min));
      } else if (max === g) {
        h2 = 60 * (2 + (b - r) / (max - min));
      } else if (max === b) {
        h2 = 60 * (4 + (r - g) / (max - min));
      }
    }
    if (h2 < 0)
      h2 = h2 + 360;
    const s = max === 0 ? 0 : (max - min) / max;
    const hsv = [h2, s, max];
    return {
      h: hsv[0],
      s: hsv[1],
      v: hsv[2],
      a: rgba2.a
    };
  }
  function HSVtoHSL(hsva) {
    const {
      h: h2,
      s,
      v,
      a
    } = hsva;
    const l = v - v * s / 2;
    const sprime = l === 1 || l === 0 ? 0 : (v - l) / Math.min(l, 1 - l);
    return {
      h: h2,
      s: sprime,
      l,
      a
    };
  }
  function HSLtoHSV(hsl2) {
    const {
      h: h2,
      s,
      l,
      a
    } = hsl2;
    const v = l + s * Math.min(l, 1 - l);
    const sprime = v === 0 ? 0 : 2 - 2 * l / v;
    return {
      h: h2,
      s: sprime,
      v,
      a
    };
  }
  function RGBtoCSS(_ref) {
    let {
      r,
      g,
      b,
      a
    } = _ref;
    return a === void 0 ? `rgb(${r}, ${g}, ${b})` : `rgba(${r}, ${g}, ${b}, ${a})`;
  }
  function HSVtoCSS(hsva) {
    return RGBtoCSS(HSVtoRGB(hsva));
  }
  function toHex(v) {
    const h2 = Math.round(v).toString(16);
    return ("00".substr(0, 2 - h2.length) + h2).toUpperCase();
  }
  function RGBtoHex(_ref2) {
    let {
      r,
      g,
      b,
      a
    } = _ref2;
    return `#${[toHex(r), toHex(g), toHex(b), a !== void 0 ? toHex(Math.round(a * 255)) : ""].join("")}`;
  }
  function HexToRGB(hex2) {
    hex2 = parseHex(hex2);
    let [r, g, b, a] = chunk(hex2, 2).map((c) => parseInt(c, 16));
    a = a === void 0 ? a : a / 255;
    return {
      r,
      g,
      b,
      a
    };
  }
  function HexToHSV(hex2) {
    const rgb2 = HexToRGB(hex2);
    return RGBtoHSV(rgb2);
  }
  function HSVtoHex(hsva) {
    return RGBtoHex(HSVtoRGB(hsva));
  }
  function parseHex(hex2) {
    if (hex2.startsWith("#")) {
      hex2 = hex2.slice(1);
    }
    hex2 = hex2.replace(/([^0-9a-f])/gi, "F");
    if (hex2.length === 3 || hex2.length === 4) {
      hex2 = hex2.split("").map((x) => x + x).join("");
    }
    if (hex2.length !== 6) {
      hex2 = padEnd(padEnd(hex2, 6), 8, "F");
    }
    return hex2;
  }
  function lighten(value, amount) {
    const lab = fromXYZ(toXYZ2(value));
    lab[0] = lab[0] + amount * 10;
    return fromXYZ2(toXYZ(lab));
  }
  function darken(value, amount) {
    const lab = fromXYZ(toXYZ2(value));
    lab[0] = lab[0] - amount * 10;
    return fromXYZ2(toXYZ(lab));
  }
  function getLuma(color) {
    const rgb2 = parseColor(color);
    return toXYZ2(rgb2)[1];
  }
  function getContrast(first, second) {
    const l1 = getLuma(first);
    const l2 = getLuma(second);
    const light = Math.max(l1, l2);
    const dark = Math.min(l1, l2);
    return (light + 0.05) / (dark + 0.05);
  }
  function getForeground(color) {
    const blackContrast = Math.abs(APCAcontrast(parseColor(0), parseColor(color)));
    const whiteContrast = Math.abs(APCAcontrast(parseColor(16777215), parseColor(color)));
    return whiteContrast > Math.min(blackContrast, 50) ? "#fff" : "#000";
  }

  // ../posawesome/node_modules/vuetify/lib/util/propsFactory.js
  function propsFactory(props, source) {
    return (defaults) => {
      return Object.keys(props).reduce((obj, prop) => {
        const isObjectDefinition = typeof props[prop] === "object" && props[prop] != null && !Array.isArray(props[prop]);
        const definition = isObjectDefinition ? props[prop] : {
          type: props[prop]
        };
        if (defaults && prop in defaults) {
          obj[prop] = __spreadProps(__spreadValues({}, definition), {
            default: defaults[prop]
          });
        } else {
          obj[prop] = definition;
        }
        if (source && !obj[prop].source) {
          obj[prop].source = source;
        }
        return obj;
      }, {});
    };
  }

  // ../posawesome/node_modules/vuetify/lib/composables/component.js
  var makeComponentProps = propsFactory({
    class: [String, Array, Object],
    style: {
      type: [String, Array, Object],
      default: null
    }
  }, "component");

  // ../posawesome/node_modules/vuetify/lib/util/getCurrentInstance.js
  function getCurrentInstance2(name, message2) {
    const vm2 = getCurrentInstance();
    if (!vm2) {
      throw new Error(`[Vuetify] ${name} ${message2 || "must be called from inside a setup function"}`);
    }
    return vm2;
  }
  function getCurrentInstanceName() {
    let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "composables";
    const vm2 = getCurrentInstance2(name).type;
    return toKebabCase((vm2 == null ? void 0 : vm2.aliasName) || (vm2 == null ? void 0 : vm2.name));
  }

  // ../posawesome/node_modules/vuetify/lib/util/injectSelf.js
  function injectSelf(key) {
    let vm2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstance2("injectSelf");
    const {
      provides
    } = vm2;
    if (provides && key in provides) {
      return provides[key];
    }
    return void 0;
  }

  // ../posawesome/node_modules/vuetify/lib/composables/defaults.js
  var DefaultsSymbol = Symbol.for("vuetify:defaults");
  function createDefaults(options) {
    return ref(options);
  }
  function injectDefaults() {
    const defaults = inject(DefaultsSymbol);
    if (!defaults)
      throw new Error("[Vuetify] Could not find defaults instance");
    return defaults;
  }
  function provideDefaults(defaults, options) {
    const injectedDefaults = injectDefaults();
    const providedDefaults = ref(defaults);
    const newDefaults = computed2(() => {
      const disabled = unref(options == null ? void 0 : options.disabled);
      if (disabled)
        return injectedDefaults.value;
      const scoped = unref(options == null ? void 0 : options.scoped);
      const reset = unref(options == null ? void 0 : options.reset);
      const root = unref(options == null ? void 0 : options.root);
      if (providedDefaults.value == null && !(scoped || reset || root))
        return injectedDefaults.value;
      let properties = mergeDeep(providedDefaults.value, {
        prev: injectedDefaults.value
      });
      if (scoped)
        return properties;
      if (reset || root) {
        const len = Number(reset || Infinity);
        for (let i = 0; i <= len; i++) {
          if (!properties || !("prev" in properties)) {
            break;
          }
          properties = properties.prev;
        }
        if (properties && typeof root === "string" && root in properties) {
          properties = mergeDeep(mergeDeep(properties, {
            prev: properties
          }), properties[root]);
        }
        return properties;
      }
      return properties.prev ? mergeDeep(properties.prev, properties) : properties;
    });
    provide(DefaultsSymbol, newDefaults);
    return newDefaults;
  }
  function propIsDefined(vnode, prop) {
    return vnode.props && (typeof vnode.props[prop] !== "undefined" || typeof vnode.props[toKebabCase(prop)] !== "undefined");
  }
  function internalUseDefaults() {
    var _a3;
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let name = arguments.length > 1 ? arguments[1] : void 0;
    let defaults = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : injectDefaults();
    const vm2 = getCurrentInstance2("useDefaults");
    name = (_a3 = name != null ? name : vm2.type.name) != null ? _a3 : vm2.type.__name;
    if (!name) {
      throw new Error("[Vuetify] Could not determine component name");
    }
    const componentDefaults = computed2(() => {
      var _a4, _b;
      return (_b = defaults.value) == null ? void 0 : _b[(_a4 = props._as) != null ? _a4 : name];
    });
    const _props = new Proxy(props, {
      get(target, prop) {
        var _a4, _b, _c, _d;
        const propValue = Reflect.get(target, prop);
        if (prop === "class" || prop === "style") {
          return [(_a4 = componentDefaults.value) == null ? void 0 : _a4[prop], propValue].filter((v) => v != null);
        }
        if (propIsDefined(vm2.vnode, prop))
          return propValue;
        const _componentDefault = (_b = componentDefaults.value) == null ? void 0 : _b[prop];
        if (_componentDefault !== void 0)
          return _componentDefault;
        const _globalDefault = (_d = (_c = defaults.value) == null ? void 0 : _c.global) == null ? void 0 : _d[prop];
        if (_globalDefault !== void 0)
          return _globalDefault;
        return propValue;
      }
    });
    const _subcomponentDefaults = shallowRef();
    watchEffect(() => {
      if (componentDefaults.value) {
        const subComponents = Object.entries(componentDefaults.value).filter((_ref) => {
          let [key] = _ref;
          return key.startsWith(key[0].toUpperCase());
        });
        _subcomponentDefaults.value = subComponents.length ? Object.fromEntries(subComponents) : void 0;
      } else {
        _subcomponentDefaults.value = void 0;
      }
    });
    function provideSubDefaults() {
      const injected = injectSelf(DefaultsSymbol, vm2);
      provide(DefaultsSymbol, computed2(() => {
        var _a4;
        return _subcomponentDefaults.value ? mergeDeep((_a4 = injected == null ? void 0 : injected.value) != null ? _a4 : {}, _subcomponentDefaults.value) : injected == null ? void 0 : injected.value;
      }));
    }
    return {
      props: _props,
      provideSubDefaults
    };
  }

  // ../posawesome/node_modules/vuetify/lib/util/defineComponent.js
  function defineComponent2(options) {
    var _a3, _b;
    options._setup = (_a3 = options._setup) != null ? _a3 : options.setup;
    if (!options.name) {
      consoleWarn("The component is missing an explicit name, unable to generate default prop value");
      return options;
    }
    if (options._setup) {
      options.props = propsFactory((_b = options.props) != null ? _b : {}, options.name)();
      const propKeys = Object.keys(options.props).filter((key) => key !== "class" && key !== "style");
      options.filterProps = function filterProps(props) {
        return pick(props, propKeys);
      };
      options.props._as = String;
      options.setup = function setup(props, ctx) {
        var _a4;
        const defaults = injectDefaults();
        if (!defaults.value)
          return options._setup(props, ctx);
        const {
          props: _props,
          provideSubDefaults
        } = internalUseDefaults(props, (_a4 = props._as) != null ? _a4 : options.name, defaults);
        const setupBindings = options._setup(_props, ctx);
        provideSubDefaults();
        return setupBindings;
      };
    }
    return options;
  }
  function genericComponent() {
    let exposeDefaults = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    return (options) => (exposeDefaults ? defineComponent2 : defineComponent)(options);
  }
  function defineFunctionalComponent(props, render35) {
    render35.props = props;
    return render35;
  }

  // ../posawesome/node_modules/vuetify/lib/util/createSimpleFunctional.js
  function createSimpleFunctional(klass) {
    let tag = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "div";
    let name = arguments.length > 2 ? arguments[2] : void 0;
    return genericComponent()({
      name: name != null ? name : capitalize(camelize(klass.replace(/__/g, "-"))),
      props: __spreadValues({
        tag: {
          type: String,
          default: tag
        }
      }, makeComponentProps()),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        return () => {
          var _a3;
          return h(props.tag, {
            class: [klass, props.class],
            style: props.style
          }, (_a3 = slots.default) == null ? void 0 : _a3.call(slots));
        };
      }
    });
  }

  // ../posawesome/node_modules/vuetify/lib/util/dom.js
  function attachedRoot(node) {
    if (typeof node.getRootNode !== "function") {
      while (node.parentNode)
        node = node.parentNode;
      if (node !== document)
        return null;
      return document;
    }
    const root = node.getRootNode();
    if (root !== document && root.getRootNode({
      composed: true
    }) !== document)
      return null;
    return root;
  }

  // ../posawesome/node_modules/vuetify/lib/util/easing.js
  var standardEasing = "cubic-bezier(0.4, 0, 0.2, 1)";
  var deceleratedEasing = "cubic-bezier(0.0, 0, 0.2, 1)";
  var acceleratedEasing = "cubic-bezier(0.4, 0, 1, 1)";

  // ../posawesome/node_modules/vuetify/lib/util/events.js
  function getPrefixedEventHandlers(attrs, suffix, getData) {
    return Object.keys(attrs).filter((key) => isOn2(key) && key.endsWith(suffix)).reduce((acc, key) => {
      acc[key.slice(0, -suffix.length)] = (event2) => attrs[key](event2, getData(event2));
      return acc;
    }, {});
  }

  // ../posawesome/node_modules/vuetify/lib/util/getScrollParent.js
  function getScrollParent(el) {
    let includeHidden = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    while (el) {
      if (includeHidden ? isPotentiallyScrollable(el) : hasScrollbar(el))
        return el;
      el = el.parentElement;
    }
    return document.scrollingElement;
  }
  function getScrollParents(el, stopAt) {
    const elements = [];
    if (stopAt && el && !stopAt.contains(el))
      return elements;
    while (el) {
      if (hasScrollbar(el))
        elements.push(el);
      if (el === stopAt)
        break;
      el = el.parentElement;
    }
    return elements;
  }
  function hasScrollbar(el) {
    if (!el || el.nodeType !== Node.ELEMENT_NODE)
      return false;
    const style = window.getComputedStyle(el);
    return style.overflowY === "scroll" || style.overflowY === "auto" && el.scrollHeight > el.clientHeight;
  }
  function isPotentiallyScrollable(el) {
    if (!el || el.nodeType !== Node.ELEMENT_NODE)
      return false;
    const style = window.getComputedStyle(el);
    return ["scroll", "auto"].includes(style.overflowY);
  }

  // ../posawesome/node_modules/vuetify/lib/util/isFixedPosition.js
  function isFixedPosition(el) {
    while (el) {
      if (window.getComputedStyle(el).position === "fixed") {
        return true;
      }
      el = el.offsetParent;
    }
    return false;
  }

  // ../posawesome/node_modules/vuetify/lib/util/useRender.js
  function useRender(render35) {
    const vm2 = getCurrentInstance2("useRender");
    vm2.render = render35;
  }

  // ../posawesome/node_modules/vuetify/lib/composables/proxiedModel.js
  function useProxiedModel(props, prop, defaultValue) {
    let transformIn = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : (v) => v;
    let transformOut = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : (v) => v;
    const vm2 = getCurrentInstance2("useProxiedModel");
    const internal = ref(props[prop] !== void 0 ? props[prop] : defaultValue);
    const kebabProp = toKebabCase(prop);
    const checkKebab = kebabProp !== prop;
    const isControlled = checkKebab ? computed2(() => {
      var _a3, _b, _c, _d;
      void props[prop];
      return !!((((_a3 = vm2.vnode.props) == null ? void 0 : _a3.hasOwnProperty(prop)) || ((_b = vm2.vnode.props) == null ? void 0 : _b.hasOwnProperty(kebabProp))) && (((_c = vm2.vnode.props) == null ? void 0 : _c.hasOwnProperty(`onUpdate:${prop}`)) || ((_d = vm2.vnode.props) == null ? void 0 : _d.hasOwnProperty(`onUpdate:${kebabProp}`))));
    }) : computed2(() => {
      var _a3, _b;
      void props[prop];
      return !!(((_a3 = vm2.vnode.props) == null ? void 0 : _a3.hasOwnProperty(prop)) && ((_b = vm2.vnode.props) == null ? void 0 : _b.hasOwnProperty(`onUpdate:${prop}`)));
    });
    useToggleScope(() => !isControlled.value, () => {
      watch2(() => props[prop], (val) => {
        internal.value = val;
      });
    });
    const model = computed2({
      get() {
        const externalValue = props[prop];
        return transformIn(isControlled.value ? externalValue : internal.value);
      },
      set(internalValue) {
        const newValue = transformOut(internalValue);
        const value = toRaw(isControlled.value ? props[prop] : internal.value);
        if (value === newValue || transformIn(value) === internalValue) {
          return;
        }
        internal.value = newValue;
        vm2 == null ? void 0 : vm2.emit(`update:${prop}`, newValue);
      }
    });
    Object.defineProperty(model, "externalValue", {
      get: () => isControlled.value ? props[prop] : internal.value
    });
    return model;
  }

  // ../posawesome/node_modules/vuetify/lib/locale/en.js
  var en_default = {
    badge: "Badge",
    open: "Open",
    close: "Close",
    dismiss: "Dismiss",
    confirmEdit: {
      ok: "OK",
      cancel: "Cancel"
    },
    dataIterator: {
      noResultsText: "No matching records found",
      loadingText: "Loading items..."
    },
    dataTable: {
      itemsPerPageText: "Rows per page:",
      ariaLabel: {
        sortDescending: "Sorted descending.",
        sortAscending: "Sorted ascending.",
        sortNone: "Not sorted.",
        activateNone: "Activate to remove sorting.",
        activateDescending: "Activate to sort descending.",
        activateAscending: "Activate to sort ascending."
      },
      sortBy: "Sort by"
    },
    dataFooter: {
      itemsPerPageText: "Items per page:",
      itemsPerPageAll: "All",
      nextPage: "Next page",
      prevPage: "Previous page",
      firstPage: "First page",
      lastPage: "Last page",
      pageText: "{0}-{1} of {2}"
    },
    dateRangeInput: {
      divider: "to"
    },
    datePicker: {
      itemsSelected: "{0} selected",
      range: {
        title: "Select dates",
        header: "Enter dates"
      },
      title: "Select date",
      header: "Enter date",
      input: {
        placeholder: "Enter date"
      }
    },
    noDataText: "No data available",
    carousel: {
      prev: "Previous visual",
      next: "Next visual",
      ariaLabel: {
        delimiter: "Carousel slide {0} of {1}"
      }
    },
    calendar: {
      moreEvents: "{0} more",
      today: "Today"
    },
    input: {
      clear: "Clear {0}",
      prependAction: "{0} prepended action",
      appendAction: "{0} appended action",
      otp: "Please enter OTP character {0}"
    },
    fileInput: {
      counter: "{0} files",
      counterSize: "{0} files ({1} in total)"
    },
    fileUpload: {
      title: "Drag and drop files here",
      divider: "or",
      browse: "Browse Files"
    },
    timePicker: {
      am: "AM",
      pm: "PM",
      title: "Select Time"
    },
    pagination: {
      ariaLabel: {
        root: "Pagination Navigation",
        next: "Next page",
        previous: "Previous page",
        page: "Go to page {0}",
        currentPage: "Page {0}, Current page",
        first: "First page",
        last: "Last page"
      }
    },
    stepper: {
      next: "Next",
      prev: "Previous"
    },
    rating: {
      ariaLabel: {
        item: "Rating {0} of {1}"
      }
    },
    loading: "Loading...",
    infiniteScroll: {
      loadMore: "Load more",
      empty: "No more"
    },
    rules: {
      required: "This field is required",
      email: "Please enter a valid email",
      number: "This field can only contain numbers",
      integer: "This field can only contain integer values",
      capital: "This field can only contain uppercase letters",
      maxLength: "You must enter a maximum of {0} characters",
      minLength: "You must enter a minimum of {0} characters",
      strictLength: "The length of the entered field is invalid",
      exclude: "The {0} character is not allowed",
      notEmpty: "Please choose at least one value",
      pattern: "Invalid format"
    }
  };

  // ../posawesome/node_modules/vuetify/lib/locale/adapters/vuetify.js
  var LANG_PREFIX = "$vuetify.";
  var replace = (str, params) => {
    return str.replace(/\{(\d+)\}/g, (match2, index) => {
      return String(params[Number(index)]);
    });
  };
  var createTranslateFunction = (current, fallback, messages) => {
    return function(key) {
      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }
      if (!key.startsWith(LANG_PREFIX)) {
        return replace(key, params);
      }
      const shortKey = key.replace(LANG_PREFIX, "");
      const currentLocale = current.value && messages.value[current.value];
      const fallbackLocale = fallback.value && messages.value[fallback.value];
      let str = getObjectValueByPath(currentLocale, shortKey, null);
      if (!str) {
        consoleWarn(`Translation key "${key}" not found in "${current.value}", trying fallback locale`);
        str = getObjectValueByPath(fallbackLocale, shortKey, null);
      }
      if (!str) {
        consoleError(`Translation key "${key}" not found in fallback`);
        str = key;
      }
      if (typeof str !== "string") {
        consoleError(`Translation key "${key}" has a non-string value`);
        str = key;
      }
      return replace(str, params);
    };
  };
  function createNumberFunction(current, fallback) {
    return (value, options) => {
      const numberFormat = new Intl.NumberFormat([current.value, fallback.value], options);
      return numberFormat.format(value);
    };
  }
  function useProvided(props, prop, provided) {
    var _a3, _b;
    const internal = useProxiedModel(props, prop, (_a3 = props[prop]) != null ? _a3 : provided.value);
    internal.value = (_b = props[prop]) != null ? _b : provided.value;
    watch2(provided, (v) => {
      if (props[prop] == null) {
        internal.value = provided.value;
      }
    });
    return internal;
  }
  function createProvideFunction(state) {
    return (props) => {
      const current = useProvided(props, "locale", state.current);
      const fallback = useProvided(props, "fallback", state.fallback);
      const messages = useProvided(props, "messages", state.messages);
      return {
        name: "vuetify",
        current,
        fallback,
        messages,
        t: createTranslateFunction(current, fallback, messages),
        n: createNumberFunction(current, fallback),
        provide: createProvideFunction({
          current,
          fallback,
          messages
        })
      };
    };
  }
  function createVuetifyAdapter(options) {
    var _a3, _b;
    const current = shallowRef((_a3 = options == null ? void 0 : options.locale) != null ? _a3 : "en");
    const fallback = shallowRef((_b = options == null ? void 0 : options.fallback) != null ? _b : "en");
    const messages = ref(__spreadValues({
      en: en_default
    }, options == null ? void 0 : options.messages));
    return {
      name: "vuetify",
      current,
      fallback,
      messages,
      t: createTranslateFunction(current, fallback, messages),
      n: createNumberFunction(current, fallback),
      provide: createProvideFunction({
        current,
        fallback,
        messages
      })
    };
  }

  // ../posawesome/node_modules/vuetify/lib/composables/locale.js
  var LocaleSymbol = Symbol.for("vuetify:locale");
  function isLocaleInstance(obj) {
    return obj.name != null;
  }
  function createLocale(options) {
    const i18n = (options == null ? void 0 : options.adapter) && isLocaleInstance(options == null ? void 0 : options.adapter) ? options == null ? void 0 : options.adapter : createVuetifyAdapter(options);
    const rtl = createRtl(i18n, options);
    return __spreadValues(__spreadValues({}, i18n), rtl);
  }
  function useLocale() {
    const locale = inject(LocaleSymbol);
    if (!locale)
      throw new Error("[Vuetify] Could not find injected locale instance");
    return locale;
  }
  function provideLocale(props) {
    const locale = inject(LocaleSymbol);
    if (!locale)
      throw new Error("[Vuetify] Could not find injected locale instance");
    const i18n = locale.provide(props);
    const rtl = provideRtl(i18n, locale.rtl, props);
    const data = __spreadValues(__spreadValues({}, i18n), rtl);
    provide(LocaleSymbol, data);
    return data;
  }
  var RtlSymbol = Symbol.for("vuetify:rtl");
  function genDefaults() {
    return {
      af: false,
      ar: true,
      bg: false,
      ca: false,
      ckb: false,
      cs: false,
      de: false,
      el: false,
      en: false,
      es: false,
      et: false,
      fa: true,
      fi: false,
      fr: false,
      hr: false,
      hu: false,
      he: true,
      id: false,
      it: false,
      ja: false,
      km: false,
      ko: false,
      lv: false,
      lt: false,
      nl: false,
      no: false,
      pl: false,
      pt: false,
      ro: false,
      ru: false,
      sk: false,
      sl: false,
      srCyrl: false,
      srLatn: false,
      sv: false,
      th: false,
      tr: false,
      az: false,
      uk: false,
      vi: false,
      zhHans: false,
      zhHant: false
    };
  }
  function createRtl(i18n, options) {
    var _a3;
    const rtl = ref((_a3 = options == null ? void 0 : options.rtl) != null ? _a3 : genDefaults());
    const isRtl = computed2(() => {
      var _a4;
      return (_a4 = rtl.value[i18n.current.value]) != null ? _a4 : false;
    });
    return {
      isRtl,
      rtl,
      rtlClasses: toRef(() => `v-locale--is-${isRtl.value ? "rtl" : "ltr"}`)
    };
  }
  function provideRtl(locale, rtl, props) {
    const isRtl = computed2(() => {
      var _a3, _b;
      return (_b = (_a3 = props.rtl) != null ? _a3 : rtl.value[locale.current.value]) != null ? _b : false;
    });
    return {
      isRtl,
      rtl,
      rtlClasses: toRef(() => `v-locale--is-${isRtl.value ? "rtl" : "ltr"}`)
    };
  }
  function useRtl() {
    const locale = inject(LocaleSymbol);
    if (!locale)
      throw new Error("[Vuetify] Could not find injected rtl instance");
    return {
      isRtl: locale.isRtl,
      rtlClasses: locale.rtlClasses
    };
  }

  // ../posawesome/node_modules/vuetify/lib/composables/date/adapters/vuetify.js
  function weekInfo(locale) {
    const code = locale.slice(-2).toUpperCase();
    switch (true) {
      case locale === "GB-alt-variant": {
        return {
          firstDay: 0,
          firstWeekSize: 4
        };
      }
      case locale === "001": {
        return {
          firstDay: 1,
          firstWeekSize: 1
        };
      }
      case `AG AS BD BR BS BT BW BZ CA CO DM DO ET GT GU HK HN ID IL IN JM JP KE
    KH KR LA MH MM MO MT MX MZ NI NP PA PE PH PK PR PY SA SG SV TH TT TW UM US
    VE VI WS YE ZA ZW`.includes(code): {
        return {
          firstDay: 0,
          firstWeekSize: 1
        };
      }
      case `AI AL AM AR AU AZ BA BM BN BY CL CM CN CR CY EC GE HR KG KZ LB LK LV
    MD ME MK MN MY NZ RO RS SI TJ TM TR UA UY UZ VN XK`.includes(code): {
        return {
          firstDay: 1,
          firstWeekSize: 1
        };
      }
      case `AD AN AT AX BE BG CH CZ DE DK EE ES FI FJ FO FR GB GF GP GR HU IE IS
    IT LI LT LU MC MQ NL NO PL RE RU SE SK SM VA`.includes(code): {
        return {
          firstDay: 1,
          firstWeekSize: 4
        };
      }
      case `AE AF BH DJ DZ EG IQ IR JO KW LY OM QA SD SY`.includes(code): {
        return {
          firstDay: 6,
          firstWeekSize: 1
        };
      }
      case code === "MV": {
        return {
          firstDay: 5,
          firstWeekSize: 1
        };
      }
      case code === "PT": {
        return {
          firstDay: 0,
          firstWeekSize: 4
        };
      }
      default:
        return null;
    }
  }
  function getWeekArray(date2, locale, firstDayOfWeek) {
    var _a3, _b;
    const weeks = [];
    let currentWeek = [];
    const firstDayOfMonth = startOfMonth(date2);
    const lastDayOfMonth = endOfMonth(date2);
    const first = (_b = firstDayOfWeek != null ? firstDayOfWeek : (_a3 = weekInfo(locale)) == null ? void 0 : _a3.firstDay) != null ? _b : 0;
    const firstDayWeekIndex = (firstDayOfMonth.getDay() - first + 7) % 7;
    const lastDayWeekIndex = (lastDayOfMonth.getDay() - first + 7) % 7;
    for (let i = 0; i < firstDayWeekIndex; i++) {
      const adjacentDay = new Date(firstDayOfMonth);
      adjacentDay.setDate(adjacentDay.getDate() - (firstDayWeekIndex - i));
      currentWeek.push(adjacentDay);
    }
    for (let i = 1; i <= lastDayOfMonth.getDate(); i++) {
      const day = new Date(date2.getFullYear(), date2.getMonth(), i);
      currentWeek.push(day);
      if (currentWeek.length === 7) {
        weeks.push(currentWeek);
        currentWeek = [];
      }
    }
    for (let i = 1; i < 7 - lastDayWeekIndex; i++) {
      const adjacentDay = new Date(lastDayOfMonth);
      adjacentDay.setDate(adjacentDay.getDate() + i);
      currentWeek.push(adjacentDay);
    }
    if (currentWeek.length > 0) {
      weeks.push(currentWeek);
    }
    return weeks;
  }
  function startOfWeek(date2, locale, firstDayOfWeek) {
    var _a3, _b;
    const day = (_b = firstDayOfWeek != null ? firstDayOfWeek : (_a3 = weekInfo(locale)) == null ? void 0 : _a3.firstDay) != null ? _b : 0;
    const d = new Date(date2);
    while (d.getDay() !== day) {
      d.setDate(d.getDate() - 1);
    }
    return d;
  }
  function endOfWeek(date2, locale) {
    var _a3, _b;
    const d = new Date(date2);
    const lastDay = (((_b = (_a3 = weekInfo(locale)) == null ? void 0 : _a3.firstDay) != null ? _b : 0) + 6) % 7;
    while (d.getDay() !== lastDay) {
      d.setDate(d.getDate() + 1);
    }
    return d;
  }
  function startOfMonth(date2) {
    return new Date(date2.getFullYear(), date2.getMonth(), 1);
  }
  function endOfMonth(date2) {
    return new Date(date2.getFullYear(), date2.getMonth() + 1, 0);
  }
  function parseLocalDate(value) {
    const parts = value.split("-").map(Number);
    return new Date(parts[0], parts[1] - 1, parts[2]);
  }
  var _YYYMMDD = /^([12]\d{3}-([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[12]\d|3[01]))$/;
  function date(value) {
    if (value == null)
      return new Date();
    if (value instanceof Date)
      return value;
    if (typeof value === "string") {
      let parsed;
      if (_YYYMMDD.test(value)) {
        return parseLocalDate(value);
      } else {
        parsed = Date.parse(value);
      }
      if (!isNaN(parsed))
        return new Date(parsed);
    }
    return null;
  }
  var sundayJanuarySecond2000 = new Date(2e3, 0, 2);
  function getWeekdays(locale, firstDayOfWeek) {
    var _a3, _b;
    const daysFromSunday = (_b = firstDayOfWeek != null ? firstDayOfWeek : (_a3 = weekInfo(locale)) == null ? void 0 : _a3.firstDay) != null ? _b : 0;
    return createRange(7).map((i) => {
      const weekday = new Date(sundayJanuarySecond2000);
      weekday.setDate(sundayJanuarySecond2000.getDate() + daysFromSunday + i);
      return new Intl.DateTimeFormat(locale, {
        weekday: "narrow"
      }).format(weekday);
    });
  }
  function format(value, formatString, locale, formats) {
    var _a3;
    const newDate = (_a3 = date(value)) != null ? _a3 : new Date();
    const customFormat = formats == null ? void 0 : formats[formatString];
    if (typeof customFormat === "function") {
      return customFormat(newDate, formatString, locale);
    }
    let options = {};
    switch (formatString) {
      case "fullDate":
        options = {
          year: "numeric",
          month: "long",
          day: "numeric"
        };
        break;
      case "fullDateWithWeekday":
        options = {
          weekday: "long",
          year: "numeric",
          month: "long",
          day: "numeric"
        };
        break;
      case "normalDate":
        const day = newDate.getDate();
        const month = new Intl.DateTimeFormat(locale, {
          month: "long"
        }).format(newDate);
        return `${day} ${month}`;
      case "normalDateWithWeekday":
        options = {
          weekday: "short",
          day: "numeric",
          month: "short"
        };
        break;
      case "shortDate":
        options = {
          month: "short",
          day: "numeric"
        };
        break;
      case "year":
        options = {
          year: "numeric"
        };
        break;
      case "month":
        options = {
          month: "long"
        };
        break;
      case "monthShort":
        options = {
          month: "short"
        };
        break;
      case "monthAndYear":
        options = {
          month: "long",
          year: "numeric"
        };
        break;
      case "monthAndDate":
        options = {
          month: "long",
          day: "numeric"
        };
        break;
      case "weekday":
        options = {
          weekday: "long"
        };
        break;
      case "weekdayShort":
        options = {
          weekday: "short"
        };
        break;
      case "dayOfMonth":
        return new Intl.NumberFormat(locale).format(newDate.getDate());
      case "hours12h":
        options = {
          hour: "numeric",
          hour12: true
        };
        break;
      case "hours24h":
        options = {
          hour: "numeric",
          hour12: false
        };
        break;
      case "minutes":
        options = {
          minute: "numeric"
        };
        break;
      case "seconds":
        options = {
          second: "numeric"
        };
        break;
      case "fullTime":
        options = {
          hour: "numeric",
          minute: "numeric"
        };
        break;
      case "fullTime12h":
        options = {
          hour: "numeric",
          minute: "numeric",
          hour12: true
        };
        break;
      case "fullTime24h":
        options = {
          hour: "numeric",
          minute: "numeric",
          hour12: false
        };
        break;
      case "fullDateTime":
        options = {
          year: "numeric",
          month: "short",
          day: "numeric",
          hour: "numeric",
          minute: "numeric"
        };
        break;
      case "fullDateTime12h":
        options = {
          year: "numeric",
          month: "short",
          day: "numeric",
          hour: "numeric",
          minute: "numeric",
          hour12: true
        };
        break;
      case "fullDateTime24h":
        options = {
          year: "numeric",
          month: "short",
          day: "numeric",
          hour: "numeric",
          minute: "numeric",
          hour12: false
        };
        break;
      case "keyboardDate":
        options = {
          year: "numeric",
          month: "2-digit",
          day: "2-digit"
        };
        break;
      case "keyboardDateTime":
        options = {
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "numeric",
          minute: "numeric"
        };
        return new Intl.DateTimeFormat(locale, options).format(newDate).replace(/, /g, " ");
      case "keyboardDateTime12h":
        options = {
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "numeric",
          minute: "numeric",
          hour12: true
        };
        return new Intl.DateTimeFormat(locale, options).format(newDate).replace(/, /g, " ");
      case "keyboardDateTime24h":
        options = {
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "numeric",
          minute: "numeric",
          hour12: false
        };
        return new Intl.DateTimeFormat(locale, options).format(newDate).replace(/, /g, " ");
      default:
        options = customFormat != null ? customFormat : {
          timeZone: "UTC",
          timeZoneName: "short"
        };
    }
    return new Intl.DateTimeFormat(locale, options).format(newDate);
  }
  function toISO(adapter, value) {
    const date2 = adapter.toJsDate(value);
    const year = date2.getFullYear();
    const month = padStart(String(date2.getMonth() + 1), 2, "0");
    const day = padStart(String(date2.getDate()), 2, "0");
    return `${year}-${month}-${day}`;
  }
  function parseISO(value) {
    const [year, month, day] = value.split("-").map(Number);
    return new Date(year, month - 1, day);
  }
  function addMinutes(date2, amount) {
    const d = new Date(date2);
    d.setMinutes(d.getMinutes() + amount);
    return d;
  }
  function addHours(date2, amount) {
    const d = new Date(date2);
    d.setHours(d.getHours() + amount);
    return d;
  }
  function addDays(date2, amount) {
    const d = new Date(date2);
    d.setDate(d.getDate() + amount);
    return d;
  }
  function addWeeks(date2, amount) {
    const d = new Date(date2);
    d.setDate(d.getDate() + amount * 7);
    return d;
  }
  function addMonths(date2, amount) {
    const d = new Date(date2);
    d.setDate(1);
    d.setMonth(d.getMonth() + amount);
    return d;
  }
  function getYear(date2) {
    return date2.getFullYear();
  }
  function getMonth(date2) {
    return date2.getMonth();
  }
  function getWeek(date2, locale, firstDayOfWeek, firstWeekMinSize) {
    var _a3, _b;
    const weekInfoFromLocale = weekInfo(locale);
    const weekStart = (_a3 = firstDayOfWeek != null ? firstDayOfWeek : weekInfoFromLocale == null ? void 0 : weekInfoFromLocale.firstDay) != null ? _a3 : 0;
    const minWeekSize = (_b = firstWeekMinSize != null ? firstWeekMinSize : weekInfoFromLocale == null ? void 0 : weekInfoFromLocale.firstWeekSize) != null ? _b : 1;
    function firstWeekSize(year2) {
      const yearStart2 = new Date(year2, 0, 1);
      return 7 - getDiff(yearStart2, startOfWeek(yearStart2, locale, weekStart), "days");
    }
    let year = getYear(date2);
    const currentWeekEnd = addDays(startOfWeek(date2, locale, weekStart), 6);
    if (year < getYear(currentWeekEnd) && firstWeekSize(year + 1) >= minWeekSize) {
      year++;
    }
    const yearStart = new Date(year, 0, 1);
    const size = firstWeekSize(year);
    const d1w1 = size >= minWeekSize ? addDays(yearStart, size - 7) : addDays(yearStart, size);
    return 1 + getDiff(endOfDay(date2), startOfDay(d1w1), "weeks");
  }
  function getDate(date2) {
    return date2.getDate();
  }
  function getNextMonth(date2) {
    return new Date(date2.getFullYear(), date2.getMonth() + 1, 1);
  }
  function getPreviousMonth(date2) {
    return new Date(date2.getFullYear(), date2.getMonth() - 1, 1);
  }
  function getHours(date2) {
    return date2.getHours();
  }
  function getMinutes(date2) {
    return date2.getMinutes();
  }
  function startOfYear(date2) {
    return new Date(date2.getFullYear(), 0, 1);
  }
  function endOfYear(date2) {
    return new Date(date2.getFullYear(), 11, 31);
  }
  function isWithinRange(date2, range) {
    return isAfter(date2, range[0]) && isBefore(date2, range[1]);
  }
  function isValid(date2) {
    const d = new Date(date2);
    return d instanceof Date && !isNaN(d.getTime());
  }
  function isAfter(date2, comparing) {
    return date2.getTime() > comparing.getTime();
  }
  function isAfterDay(date2, comparing) {
    return isAfter(startOfDay(date2), startOfDay(comparing));
  }
  function isBefore(date2, comparing) {
    return date2.getTime() < comparing.getTime();
  }
  function isEqual(date2, comparing) {
    return date2.getTime() === comparing.getTime();
  }
  function isSameDay(date2, comparing) {
    return date2.getDate() === comparing.getDate() && date2.getMonth() === comparing.getMonth() && date2.getFullYear() === comparing.getFullYear();
  }
  function isSameMonth(date2, comparing) {
    return date2.getMonth() === comparing.getMonth() && date2.getFullYear() === comparing.getFullYear();
  }
  function isSameYear(date2, comparing) {
    return date2.getFullYear() === comparing.getFullYear();
  }
  function getDiff(date2, comparing, unit) {
    const d = new Date(date2);
    const c = new Date(comparing);
    switch (unit) {
      case "years":
        return d.getFullYear() - c.getFullYear();
      case "quarters":
        return Math.floor((d.getMonth() - c.getMonth() + (d.getFullYear() - c.getFullYear()) * 12) / 4);
      case "months":
        return d.getMonth() - c.getMonth() + (d.getFullYear() - c.getFullYear()) * 12;
      case "weeks":
        return Math.floor((d.getTime() - c.getTime()) / (1e3 * 60 * 60 * 24 * 7));
      case "days":
        return Math.floor((d.getTime() - c.getTime()) / (1e3 * 60 * 60 * 24));
      case "hours":
        return Math.floor((d.getTime() - c.getTime()) / (1e3 * 60 * 60));
      case "minutes":
        return Math.floor((d.getTime() - c.getTime()) / (1e3 * 60));
      case "seconds":
        return Math.floor((d.getTime() - c.getTime()) / 1e3);
      default: {
        return d.getTime() - c.getTime();
      }
    }
  }
  function setHours(date2, count) {
    const d = new Date(date2);
    d.setHours(count);
    return d;
  }
  function setMinutes(date2, count) {
    const d = new Date(date2);
    d.setMinutes(count);
    return d;
  }
  function setMonth(date2, count) {
    const d = new Date(date2);
    d.setMonth(count);
    return d;
  }
  function setDate(date2, day) {
    const d = new Date(date2);
    d.setDate(day);
    return d;
  }
  function setYear(date2, year) {
    const d = new Date(date2);
    d.setFullYear(year);
    return d;
  }
  function startOfDay(date2) {
    return new Date(date2.getFullYear(), date2.getMonth(), date2.getDate(), 0, 0, 0, 0);
  }
  function endOfDay(date2) {
    return new Date(date2.getFullYear(), date2.getMonth(), date2.getDate(), 23, 59, 59, 999);
  }
  var VuetifyDateAdapter = class {
    constructor(options) {
      this.locale = options.locale;
      this.formats = options.formats;
    }
    date(value) {
      return date(value);
    }
    toJsDate(date2) {
      return date2;
    }
    toISO(date2) {
      return toISO(this, date2);
    }
    parseISO(date2) {
      return parseISO(date2);
    }
    addMinutes(date2, amount) {
      return addMinutes(date2, amount);
    }
    addHours(date2, amount) {
      return addHours(date2, amount);
    }
    addDays(date2, amount) {
      return addDays(date2, amount);
    }
    addWeeks(date2, amount) {
      return addWeeks(date2, amount);
    }
    addMonths(date2, amount) {
      return addMonths(date2, amount);
    }
    getWeekArray(date2, firstDayOfWeek) {
      const firstDay = firstDayOfWeek !== void 0 ? Number(firstDayOfWeek) : void 0;
      return getWeekArray(date2, this.locale, firstDay);
    }
    startOfWeek(date2, firstDayOfWeek) {
      const firstDay = firstDayOfWeek !== void 0 ? Number(firstDayOfWeek) : void 0;
      return startOfWeek(date2, this.locale, firstDay);
    }
    endOfWeek(date2) {
      return endOfWeek(date2, this.locale);
    }
    startOfMonth(date2) {
      return startOfMonth(date2);
    }
    endOfMonth(date2) {
      return endOfMonth(date2);
    }
    format(date2, formatString) {
      return format(date2, formatString, this.locale, this.formats);
    }
    isEqual(date2, comparing) {
      return isEqual(date2, comparing);
    }
    isValid(date2) {
      return isValid(date2);
    }
    isWithinRange(date2, range) {
      return isWithinRange(date2, range);
    }
    isAfter(date2, comparing) {
      return isAfter(date2, comparing);
    }
    isAfterDay(date2, comparing) {
      return isAfterDay(date2, comparing);
    }
    isBefore(date2, comparing) {
      return !isAfter(date2, comparing) && !isEqual(date2, comparing);
    }
    isSameDay(date2, comparing) {
      return isSameDay(date2, comparing);
    }
    isSameMonth(date2, comparing) {
      return isSameMonth(date2, comparing);
    }
    isSameYear(date2, comparing) {
      return isSameYear(date2, comparing);
    }
    setMinutes(date2, count) {
      return setMinutes(date2, count);
    }
    setHours(date2, count) {
      return setHours(date2, count);
    }
    setMonth(date2, count) {
      return setMonth(date2, count);
    }
    setDate(date2, day) {
      return setDate(date2, day);
    }
    setYear(date2, year) {
      return setYear(date2, year);
    }
    getDiff(date2, comparing, unit) {
      return getDiff(date2, comparing, unit);
    }
    getWeekdays(firstDayOfWeek) {
      const firstDay = firstDayOfWeek !== void 0 ? Number(firstDayOfWeek) : void 0;
      return getWeekdays(this.locale, firstDay);
    }
    getYear(date2) {
      return getYear(date2);
    }
    getMonth(date2) {
      return getMonth(date2);
    }
    getWeek(date2, firstDayOfWeek, firstWeekMinSize) {
      const firstDay = firstDayOfWeek !== void 0 ? Number(firstDayOfWeek) : void 0;
      return getWeek(date2, this.locale, firstDay, firstWeekMinSize);
    }
    getDate(date2) {
      return getDate(date2);
    }
    getNextMonth(date2) {
      return getNextMonth(date2);
    }
    getPreviousMonth(date2) {
      return getPreviousMonth(date2);
    }
    getHours(date2) {
      return getHours(date2);
    }
    getMinutes(date2) {
      return getMinutes(date2);
    }
    startOfDay(date2) {
      return startOfDay(date2);
    }
    endOfDay(date2) {
      return endOfDay(date2);
    }
    startOfYear(date2) {
      return startOfYear(date2);
    }
    endOfYear(date2) {
      return endOfYear(date2);
    }
  };

  // ../posawesome/node_modules/vuetify/lib/composables/date/date.js
  var DateOptionsSymbol = Symbol.for("vuetify:date-options");
  var DateAdapterSymbol = Symbol.for("vuetify:date-adapter");
  function createDate(options, locale) {
    const _options = mergeDeep({
      adapter: VuetifyDateAdapter,
      locale: {
        af: "af-ZA",
        bg: "bg-BG",
        ca: "ca-ES",
        ckb: "",
        cs: "cs-CZ",
        de: "de-DE",
        el: "el-GR",
        en: "en-US",
        et: "et-EE",
        fa: "fa-IR",
        fi: "fi-FI",
        hr: "hr-HR",
        hu: "hu-HU",
        he: "he-IL",
        id: "id-ID",
        it: "it-IT",
        ja: "ja-JP",
        ko: "ko-KR",
        lv: "lv-LV",
        lt: "lt-LT",
        nl: "nl-NL",
        no: "no-NO",
        pl: "pl-PL",
        pt: "pt-PT",
        ro: "ro-RO",
        ru: "ru-RU",
        sk: "sk-SK",
        sl: "sl-SI",
        srCyrl: "sr-SP",
        srLatn: "sr-SP",
        sv: "sv-SE",
        th: "th-TH",
        tr: "tr-TR",
        az: "az-AZ",
        uk: "uk-UA",
        vi: "vi-VN",
        zhHans: "zh-CN",
        zhHant: "zh-TW"
      }
    }, options);
    return {
      options: _options,
      instance: createInstance(_options, locale)
    };
  }
  function createDateRange(adapter, start, stop2) {
    const diff = adapter.getDiff(adapter.endOfDay(stop2 != null ? stop2 : start), adapter.startOfDay(start), "days");
    const datesInRange = [start];
    for (let i = 1; i < diff; i++) {
      const nextDate = adapter.addDays(start, i);
      datesInRange.push(nextDate);
    }
    if (stop2) {
      datesInRange.push(adapter.endOfDay(stop2));
    }
    return datesInRange;
  }
  function createInstance(options, locale) {
    var _a3;
    const instance = reactive(typeof options.adapter === "function" ? new options.adapter({
      locale: (_a3 = options.locale[locale.current.value]) != null ? _a3 : locale.current.value,
      formats: options.formats
    }) : options.adapter);
    watch2(locale.current, (value) => {
      var _a4, _b;
      instance.locale = (_b = (_a4 = options.locale[value]) != null ? _a4 : value) != null ? _b : instance.locale;
    });
    return instance;
  }
  function useDate() {
    const options = inject(DateOptionsSymbol);
    if (!options)
      throw new Error("[Vuetify] Could not find injected date options");
    const locale = useLocale();
    return createInstance(options, locale);
  }

  // ../posawesome/node_modules/vuetify/lib/composables/display.js
  var breakpoints = ["sm", "md", "lg", "xl", "xxl"];
  var DisplaySymbol = Symbol.for("vuetify:display");
  var defaultDisplayOptions = {
    mobileBreakpoint: "lg",
    thresholds: {
      xs: 0,
      sm: 600,
      md: 960,
      lg: 1280,
      xl: 1920,
      xxl: 2560
    }
  };
  var parseDisplayOptions = function() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultDisplayOptions;
    return mergeDeep(defaultDisplayOptions, options);
  };
  function getClientWidth(ssr) {
    return IN_BROWSER && !ssr ? window.innerWidth : typeof ssr === "object" && ssr.clientWidth || 0;
  }
  function getClientHeight(ssr) {
    return IN_BROWSER && !ssr ? window.innerHeight : typeof ssr === "object" && ssr.clientHeight || 0;
  }
  function getPlatform(ssr) {
    const userAgent = IN_BROWSER && !ssr ? window.navigator.userAgent : "ssr";
    function match2(regexp) {
      return Boolean(userAgent.match(regexp));
    }
    const android = match2(/android/i);
    const ios = match2(/iphone|ipad|ipod/i);
    const cordova = match2(/cordova/i);
    const electron = match2(/electron/i);
    const chrome = match2(/chrome/i);
    const edge = match2(/edge/i);
    const firefox = match2(/firefox/i);
    const opera = match2(/opera/i);
    const win = match2(/win/i);
    const mac = match2(/mac/i);
    const linux = match2(/linux/i);
    return {
      android,
      ios,
      cordova,
      electron,
      chrome,
      edge,
      firefox,
      opera,
      win,
      mac,
      linux,
      touch: SUPPORTS_TOUCH,
      ssr: userAgent === "ssr"
    };
  }
  function createDisplay(options, ssr) {
    const {
      thresholds,
      mobileBreakpoint
    } = parseDisplayOptions(options);
    const height = shallowRef(getClientHeight(ssr));
    const platform = shallowRef(getPlatform(ssr));
    const state = reactive({});
    const width = shallowRef(getClientWidth(ssr));
    function updateSize() {
      height.value = getClientHeight();
      width.value = getClientWidth();
    }
    function update() {
      updateSize();
      platform.value = getPlatform();
    }
    watchEffect(() => {
      const xs = width.value < thresholds.sm;
      const sm = width.value < thresholds.md && !xs;
      const md = width.value < thresholds.lg && !(sm || xs);
      const lg = width.value < thresholds.xl && !(md || sm || xs);
      const xl2 = width.value < thresholds.xxl && !(lg || md || sm || xs);
      const xxl = width.value >= thresholds.xxl;
      const name = xs ? "xs" : sm ? "sm" : md ? "md" : lg ? "lg" : xl2 ? "xl" : "xxl";
      const breakpointValue = typeof mobileBreakpoint === "number" ? mobileBreakpoint : thresholds[mobileBreakpoint];
      const mobile = width.value < breakpointValue;
      state.xs = xs;
      state.sm = sm;
      state.md = md;
      state.lg = lg;
      state.xl = xl2;
      state.xxl = xxl;
      state.smAndUp = !xs;
      state.mdAndUp = !(xs || sm);
      state.lgAndUp = !(xs || sm || md);
      state.xlAndUp = !(xs || sm || md || lg);
      state.smAndDown = !(md || lg || xl2 || xxl);
      state.mdAndDown = !(lg || xl2 || xxl);
      state.lgAndDown = !(xl2 || xxl);
      state.xlAndDown = !xxl;
      state.name = name;
      state.height = height.value;
      state.width = width.value;
      state.mobile = mobile;
      state.mobileBreakpoint = mobileBreakpoint;
      state.platform = platform.value;
      state.thresholds = thresholds;
    });
    if (IN_BROWSER) {
      window.addEventListener("resize", updateSize, {
        passive: true
      });
      onScopeDispose(() => {
        window.removeEventListener("resize", updateSize);
      }, true);
    }
    return __spreadProps(__spreadValues({}, toRefs(state)), {
      update,
      ssr: !!ssr
    });
  }
  var makeDisplayProps = propsFactory({
    mobile: {
      type: Boolean,
      default: false
    },
    mobileBreakpoint: [Number, String]
  }, "display");
  function useDisplay() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      mobile: null
    };
    let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    const display = inject(DisplaySymbol);
    if (!display)
      throw new Error("Could not find Vuetify display injection");
    const mobile = computed2(() => {
      if (props.mobile) {
        return true;
      } else if (typeof props.mobileBreakpoint === "number") {
        return display.width.value < props.mobileBreakpoint;
      } else if (props.mobileBreakpoint) {
        return display.width.value < display.thresholds.value[props.mobileBreakpoint];
      } else if (props.mobile === null) {
        return display.mobile.value;
      } else {
        return false;
      }
    });
    const displayClasses = toRef(() => {
      if (!name)
        return {};
      return {
        [`${name}--mobile`]: mobile.value
      };
    });
    return __spreadProps(__spreadValues({}, display), {
      displayClasses,
      mobile
    });
  }

  // ../posawesome/node_modules/vuetify/lib/composables/goto.js
  var GoToSymbol = Symbol.for("vuetify:goto");
  function genDefaults2() {
    return {
      container: void 0,
      duration: 300,
      layout: false,
      offset: 0,
      easing: "easeInOutCubic",
      patterns: {
        linear: (t) => t,
        easeInQuad: (t) => t ** 2,
        easeOutQuad: (t) => t * (2 - t),
        easeInOutQuad: (t) => t < 0.5 ? 2 * t ** 2 : -1 + (4 - 2 * t) * t,
        easeInCubic: (t) => t ** 3,
        easeOutCubic: (t) => --t ** 3 + 1,
        easeInOutCubic: (t) => t < 0.5 ? 4 * t ** 3 : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
        easeInQuart: (t) => t ** 4,
        easeOutQuart: (t) => 1 - --t ** 4,
        easeInOutQuart: (t) => t < 0.5 ? 8 * t ** 4 : 1 - 8 * --t ** 4,
        easeInQuint: (t) => t ** 5,
        easeOutQuint: (t) => 1 + --t ** 5,
        easeInOutQuint: (t) => t < 0.5 ? 16 * t ** 5 : 1 + 16 * --t ** 5
      }
    };
  }
  function getContainer(el) {
    var _a3;
    return (_a3 = getTarget(el)) != null ? _a3 : document.scrollingElement || document.body;
  }
  function getTarget(el) {
    return typeof el === "string" ? document.querySelector(el) : refElement(el);
  }
  function getOffset(target, horizontal, rtl) {
    if (typeof target === "number")
      return horizontal && rtl ? -target : target;
    let el = getTarget(target);
    let totalOffset = 0;
    while (el) {
      totalOffset += horizontal ? el.offsetLeft : el.offsetTop;
      el = el.offsetParent;
    }
    return totalOffset;
  }
  function createGoTo(options, locale) {
    return {
      rtl: locale.isRtl,
      options: mergeDeep(genDefaults2(), options)
    };
  }
  async function scrollTo(_target, _options, horizontal, goTo) {
    var _a3, _b, _c;
    const property = horizontal ? "scrollLeft" : "scrollTop";
    const options = mergeDeep((_a3 = goTo == null ? void 0 : goTo.options) != null ? _a3 : genDefaults2(), _options);
    const rtl = goTo == null ? void 0 : goTo.rtl.value;
    const target = (_b = typeof _target === "number" ? _target : getTarget(_target)) != null ? _b : 0;
    const container = options.container === "parent" && target instanceof HTMLElement ? target.parentElement : getContainer(options.container);
    const ease = typeof options.easing === "function" ? options.easing : options.patterns[options.easing];
    if (!ease)
      throw new TypeError(`Easing function "${options.easing}" not found.`);
    let targetLocation;
    if (typeof target === "number") {
      targetLocation = getOffset(target, horizontal, rtl);
    } else {
      targetLocation = getOffset(target, horizontal, rtl) - getOffset(container, horizontal, rtl);
      if (options.layout) {
        const styles = window.getComputedStyle(target);
        const layoutOffset = styles.getPropertyValue("--v-layout-top");
        if (layoutOffset)
          targetLocation -= parseInt(layoutOffset, 10);
      }
    }
    targetLocation += options.offset;
    targetLocation = clampTarget(container, targetLocation, !!rtl, !!horizontal);
    const startLocation = (_c = container[property]) != null ? _c : 0;
    if (targetLocation === startLocation)
      return Promise.resolve(targetLocation);
    const startTime = performance.now();
    return new Promise((resolve2) => requestAnimationFrame(function step(currentTime) {
      const timeElapsed = currentTime - startTime;
      const progress = timeElapsed / options.duration;
      const location2 = Math.floor(startLocation + (targetLocation - startLocation) * ease(clamp(progress, 0, 1)));
      container[property] = location2;
      if (progress >= 1 && Math.abs(location2 - container[property]) < 10) {
        return resolve2(targetLocation);
      } else if (progress > 2) {
        consoleWarn("Scroll target is not reachable");
        return resolve2(container[property]);
      }
      requestAnimationFrame(step);
    }));
  }
  function useGoTo() {
    let _options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const goToInstance = inject(GoToSymbol);
    const {
      isRtl
    } = useRtl();
    if (!goToInstance)
      throw new Error("[Vuetify] Could not find injected goto instance");
    const goTo = __spreadProps(__spreadValues({}, goToInstance), {
      rtl: toRef(() => goToInstance.rtl.value || isRtl.value)
    });
    async function go2(target, options) {
      return scrollTo(target, mergeDeep(_options, options), false, goTo);
    }
    go2.horizontal = async (target, options) => {
      return scrollTo(target, mergeDeep(_options, options), true, goTo);
    };
    return go2;
  }
  function clampTarget(container, value, rtl, horizontal) {
    const {
      scrollWidth,
      scrollHeight
    } = container;
    const [containerWidth, containerHeight] = container === document.scrollingElement ? [window.innerWidth, window.innerHeight] : [container.offsetWidth, container.offsetHeight];
    let min;
    let max;
    if (horizontal) {
      if (rtl) {
        min = -(scrollWidth - containerWidth);
        max = 0;
      } else {
        min = 0;
        max = scrollWidth - containerWidth;
      }
    } else {
      min = 0;
      max = scrollHeight + -containerHeight;
    }
    return clamp(value, min, max);
  }

  // ../posawesome/node_modules/vuetify/lib/iconsets/mdi.js
  var aliases = {
    collapse: "mdi-chevron-up",
    complete: "mdi-check",
    cancel: "mdi-close-circle",
    close: "mdi-close",
    delete: "mdi-close-circle",
    clear: "mdi-close-circle",
    success: "mdi-check-circle",
    info: "mdi-information",
    warning: "mdi-alert-circle",
    error: "mdi-close-circle",
    prev: "mdi-chevron-left",
    next: "mdi-chevron-right",
    checkboxOn: "mdi-checkbox-marked",
    checkboxOff: "mdi-checkbox-blank-outline",
    checkboxIndeterminate: "mdi-minus-box",
    delimiter: "mdi-circle",
    sortAsc: "mdi-arrow-up",
    sortDesc: "mdi-arrow-down",
    expand: "mdi-chevron-down",
    menu: "mdi-menu",
    subgroup: "mdi-menu-down",
    dropdown: "mdi-menu-down",
    radioOn: "mdi-radiobox-marked",
    radioOff: "mdi-radiobox-blank",
    edit: "mdi-pencil",
    ratingEmpty: "mdi-star-outline",
    ratingFull: "mdi-star",
    ratingHalf: "mdi-star-half-full",
    loading: "mdi-cached",
    first: "mdi-page-first",
    last: "mdi-page-last",
    unfold: "mdi-unfold-more-horizontal",
    file: "mdi-paperclip",
    plus: "mdi-plus",
    minus: "mdi-minus",
    calendar: "mdi-calendar",
    treeviewCollapse: "mdi-menu-down",
    treeviewExpand: "mdi-menu-right",
    eyeDropper: "mdi-eyedropper",
    upload: "mdi-cloud-upload",
    color: "mdi-palette"
  };
  var mdi = {
    component: (props) => h(VClassIcon, __spreadProps(__spreadValues({}, props), {
      class: "mdi"
    }))
  };

  // ../posawesome/node_modules/vuetify/lib/composables/icons.js
  var IconValue = [String, Function, Object, Array];
  var IconSymbol = Symbol.for("vuetify:icons");
  var makeIconProps = propsFactory({
    icon: {
      type: IconValue
    },
    tag: {
      type: [String, Object, Function],
      required: true
    }
  }, "icon");
  var VComponentIcon = genericComponent()({
    name: "VComponentIcon",
    props: makeIconProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      return () => {
        const Icon = props.icon;
        return createVNode(props.tag, null, {
          default: () => {
            var _a3;
            return [props.icon ? createVNode(Icon, null, null) : (_a3 = slots.default) == null ? void 0 : _a3.call(slots)];
          }
        });
      };
    }
  });
  var VSvgIcon = defineComponent2({
    name: "VSvgIcon",
    inheritAttrs: false,
    props: makeIconProps(),
    setup(props, _ref2) {
      let {
        attrs
      } = _ref2;
      return () => {
        return createVNode(props.tag, mergeProps(attrs, {
          "style": null
        }), {
          default: () => [createBaseVNode("svg", {
            "class": "v-icon__svg",
            "xmlns": "http://www.w3.org/2000/svg",
            "viewBox": "0 0 24 24",
            "role": "img",
            "aria-hidden": "true"
          }, [Array.isArray(props.icon) ? props.icon.map((path) => Array.isArray(path) ? createBaseVNode("path", {
            "d": path[0],
            "fill-opacity": path[1]
          }, null) : createBaseVNode("path", {
            "d": path
          }, null)) : createBaseVNode("path", {
            "d": props.icon
          }, null)])]
        });
      };
    }
  });
  var VLigatureIcon = defineComponent2({
    name: "VLigatureIcon",
    props: makeIconProps(),
    setup(props) {
      return () => {
        return createVNode(props.tag, null, {
          default: () => [props.icon]
        });
      };
    }
  });
  var VClassIcon = defineComponent2({
    name: "VClassIcon",
    props: makeIconProps(),
    setup(props) {
      return () => {
        return createVNode(props.tag, {
          "class": normalizeClass(props.icon)
        }, null);
      };
    }
  });
  function genDefaults3() {
    return {
      svg: {
        component: VSvgIcon
      },
      class: {
        component: VClassIcon
      }
    };
  }
  function createIcons(options) {
    var _a3;
    const sets = genDefaults3();
    const defaultSet = (_a3 = options == null ? void 0 : options.defaultSet) != null ? _a3 : "mdi";
    if (defaultSet === "mdi" && !sets.mdi) {
      sets.mdi = mdi;
    }
    return mergeDeep({
      defaultSet,
      sets,
      aliases: __spreadProps(__spreadValues({}, aliases), {
        vuetify: ["M8.2241 14.2009L12 21L22 3H14.4459L8.2241 14.2009Z", ["M7.26303 12.4733L7.00113 12L2 3H12.5261C12.5261 3 12.5261 3 12.5261 3L7.26303 12.4733Z", 0.6]],
        "vuetify-outline": "svg:M7.26 12.47 12.53 3H2L7.26 12.47ZM14.45 3 8.22 14.2 12 21 22 3H14.45ZM18.6 5 12 16.88 10.51 14.2 15.62 5ZM7.26 8.35 5.4 5H9.13L7.26 8.35Z",
        "vuetify-play": ["m6.376 13.184-4.11-7.192C1.505 4.66 2.467 3 4.003 3h8.532l-.953 1.576-.006.01-.396.677c-.429.732-.214 1.507.194 2.015.404.503 1.092.878 1.869.806a3.72 3.72 0 0 1 1.005.022c.276.053.434.143.523.237.138.146.38.635-.25 2.09-.893 1.63-1.553 1.722-1.847 1.677-.213-.033-.468-.158-.756-.406a4.95 4.95 0 0 1-.8-.927c-.39-.564-1.04-.84-1.66-.846-.625-.006-1.316.27-1.693.921l-.478.826-.911 1.506Z", ["M9.093 11.552c.046-.079.144-.15.32-.148a.53.53 0 0 1 .43.207c.285.414.636.847 1.046 1.2.405.35.914.662 1.516.754 1.334.205 2.502-.698 3.48-2.495l.014-.028.013-.03c.687-1.574.774-2.852-.005-3.675-.37-.391-.861-.586-1.333-.676a5.243 5.243 0 0 0-1.447-.044c-.173.016-.393-.073-.54-.257-.145-.18-.127-.316-.082-.392l.393-.672L14.287 3h5.71c1.536 0 2.499 1.659 1.737 2.992l-7.997 13.996c-.768 1.344-2.706 1.344-3.473 0l-3.037-5.314 1.377-2.278.004-.006.004-.007.481-.831Z", 0.6]]
      })
    }, options);
  }
  var useIcon = (props) => {
    const icons = inject(IconSymbol);
    if (!icons)
      throw new Error("Missing Vuetify Icons provide!");
    const iconData = computed2(() => {
      var _a3;
      const iconAlias = toValue(props);
      if (!iconAlias)
        return {
          component: VComponentIcon
        };
      let icon = iconAlias;
      if (typeof icon === "string") {
        icon = icon.trim();
        if (icon.startsWith("$")) {
          icon = (_a3 = icons.aliases) == null ? void 0 : _a3[icon.slice(1)];
        }
      }
      if (!icon)
        consoleWarn(`Could not find aliased icon "${iconAlias}"`);
      if (Array.isArray(icon)) {
        return {
          component: VSvgIcon,
          icon
        };
      } else if (typeof icon !== "string") {
        return {
          component: VComponentIcon,
          icon
        };
      }
      const iconSetName = Object.keys(icons.sets).find((setName) => typeof icon === "string" && icon.startsWith(`${setName}:`));
      const iconName = iconSetName ? icon.slice(iconSetName.length + 1) : icon;
      const iconSet = icons.sets[iconSetName != null ? iconSetName : icons.defaultSet];
      return {
        component: iconSet.component,
        icon: iconName
      };
    });
    return {
      iconData
    };
  };

  // ../posawesome/node_modules/vuetify/lib/composables/theme.js
  var ThemeSymbol = Symbol.for("vuetify:theme");
  var makeThemeProps = propsFactory({
    theme: String
  }, "theme");
  function genDefaults4() {
    return {
      defaultTheme: "light",
      variations: {
        colors: [],
        lighten: 0,
        darken: 0
      },
      themes: {
        light: {
          dark: false,
          colors: {
            background: "#FFFFFF",
            surface: "#FFFFFF",
            "surface-bright": "#FFFFFF",
            "surface-light": "#EEEEEE",
            "surface-variant": "#424242",
            "on-surface-variant": "#EEEEEE",
            primary: "#1867C0",
            "primary-darken-1": "#1F5592",
            secondary: "#48A9A6",
            "secondary-darken-1": "#018786",
            error: "#B00020",
            info: "#2196F3",
            success: "#4CAF50",
            warning: "#FB8C00"
          },
          variables: {
            "border-color": "#000000",
            "border-opacity": 0.12,
            "high-emphasis-opacity": 0.87,
            "medium-emphasis-opacity": 0.6,
            "disabled-opacity": 0.38,
            "idle-opacity": 0.04,
            "hover-opacity": 0.04,
            "focus-opacity": 0.12,
            "selected-opacity": 0.08,
            "activated-opacity": 0.12,
            "pressed-opacity": 0.12,
            "dragged-opacity": 0.08,
            "theme-kbd": "#212529",
            "theme-on-kbd": "#FFFFFF",
            "theme-code": "#F5F5F5",
            "theme-on-code": "#000000"
          }
        },
        dark: {
          dark: true,
          colors: {
            background: "#121212",
            surface: "#212121",
            "surface-bright": "#ccbfd6",
            "surface-light": "#424242",
            "surface-variant": "#c8c8c8",
            "on-surface-variant": "#000000",
            primary: "#2196F3",
            "primary-darken-1": "#277CC1",
            secondary: "#54B6B2",
            "secondary-darken-1": "#48A9A6",
            error: "#CF6679",
            info: "#2196F3",
            success: "#4CAF50",
            warning: "#FB8C00"
          },
          variables: {
            "border-color": "#FFFFFF",
            "border-opacity": 0.12,
            "high-emphasis-opacity": 1,
            "medium-emphasis-opacity": 0.7,
            "disabled-opacity": 0.5,
            "idle-opacity": 0.1,
            "hover-opacity": 0.04,
            "focus-opacity": 0.12,
            "selected-opacity": 0.08,
            "activated-opacity": 0.12,
            "pressed-opacity": 0.16,
            "dragged-opacity": 0.08,
            "theme-kbd": "#212529",
            "theme-on-kbd": "#FFFFFF",
            "theme-code": "#343434",
            "theme-on-code": "#CCCCCC"
          }
        }
      },
      stylesheetId: "vuetify-theme-stylesheet"
    };
  }
  function parseThemeOptions() {
    var _a3, _b, _c;
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : genDefaults4();
    const defaults = genDefaults4();
    if (!options)
      return __spreadProps(__spreadValues({}, defaults), {
        isDisabled: true
      });
    const themes = {};
    for (const [key, theme] of Object.entries((_a3 = options.themes) != null ? _a3 : {})) {
      const defaultTheme = theme.dark || key === "dark" ? (_b = defaults.themes) == null ? void 0 : _b.dark : (_c = defaults.themes) == null ? void 0 : _c.light;
      themes[key] = mergeDeep(defaultTheme, theme);
    }
    return mergeDeep(defaults, __spreadProps(__spreadValues({}, options), {
      themes
    }));
  }
  function createCssClass(lines, selector, content, scope) {
    lines.push(`${getScopedSelector(selector, scope)} {
`, ...content.map((line) => `  ${line};
`), "}\n");
  }
  function genCssVariables(theme) {
    const lightOverlay = theme.dark ? 2 : 1;
    const darkOverlay = theme.dark ? 1 : 2;
    const variables = [];
    for (const [key, value] of Object.entries(theme.colors)) {
      const rgb2 = parseColor(value);
      variables.push(`--v-theme-${key}: ${rgb2.r},${rgb2.g},${rgb2.b}`);
      if (!key.startsWith("on-")) {
        variables.push(`--v-theme-${key}-overlay-multiplier: ${getLuma(value) > 0.18 ? lightOverlay : darkOverlay}`);
      }
    }
    for (const [key, value] of Object.entries(theme.variables)) {
      const color = typeof value === "string" && value.startsWith("#") ? parseColor(value) : void 0;
      const rgb2 = color ? `${color.r}, ${color.g}, ${color.b}` : void 0;
      variables.push(`--v-${key}: ${rgb2 != null ? rgb2 : value}`);
    }
    return variables;
  }
  function genVariation(name, color, variations) {
    const object = {};
    if (variations) {
      for (const variation of ["lighten", "darken"]) {
        const fn2 = variation === "lighten" ? lighten : darken;
        for (const amount of createRange(variations[variation], 1)) {
          object[`${name}-${variation}-${amount}`] = RGBtoHex(fn2(parseColor(color), amount));
        }
      }
    }
    return object;
  }
  function genVariations(colors, variations) {
    if (!variations)
      return {};
    let variationColors = {};
    for (const name of variations.colors) {
      const color = colors[name];
      if (!color)
        continue;
      variationColors = __spreadValues(__spreadValues({}, variationColors), genVariation(name, color, variations));
    }
    return variationColors;
  }
  function genOnColors(colors) {
    const onColors = {};
    for (const color of Object.keys(colors)) {
      if (color.startsWith("on-") || colors[`on-${color}`])
        continue;
      const onColor = `on-${color}`;
      const colorVal = parseColor(colors[color]);
      onColors[onColor] = getForeground(colorVal);
    }
    return onColors;
  }
  function getScopedSelector(selector, scope) {
    if (!scope)
      return selector;
    const scopeSelector = `:where(${scope})`;
    return selector === ":root" ? scopeSelector : `${scopeSelector} ${selector}`;
  }
  function upsertStyles(styleEl, styles) {
    if (!styleEl)
      return;
    styleEl.innerHTML = styles;
  }
  function getOrCreateStyleElement(id, cspNonce) {
    if (!IN_BROWSER)
      return null;
    let style = document.getElementById(id);
    if (!style) {
      style = document.createElement("style");
      style.id = id;
      style.type = "text/css";
      if (cspNonce)
        style.setAttribute("nonce", cspNonce);
      document.head.appendChild(style);
    }
    return style;
  }
  function createTheme(options) {
    const parsedOptions = parseThemeOptions(options);
    const name = shallowRef(parsedOptions.defaultTheme);
    const themes = ref(parsedOptions.themes);
    const computedThemes = computed2(() => {
      const acc = {};
      for (const [name2, original] of Object.entries(themes.value)) {
        const colors = __spreadValues(__spreadValues({}, original.colors), genVariations(original.colors, parsedOptions.variations));
        acc[name2] = __spreadProps(__spreadValues({}, original), {
          colors: __spreadValues(__spreadValues({}, colors), genOnColors(colors))
        });
      }
      return acc;
    });
    const current = toRef(() => computedThemes.value[name.value]);
    const styles = computed2(() => {
      var _a3;
      const lines = [];
      if ((_a3 = current.value) == null ? void 0 : _a3.dark) {
        createCssClass(lines, ":root", ["color-scheme: dark"], parsedOptions.scope);
      }
      createCssClass(lines, ":root", genCssVariables(current.value), parsedOptions.scope);
      for (const [themeName, theme] of Object.entries(computedThemes.value)) {
        createCssClass(lines, `.v-theme--${themeName}`, [`color-scheme: ${theme.dark ? "dark" : "normal"}`, ...genCssVariables(theme)], parsedOptions.scope);
      }
      const bgLines = [];
      const fgLines = [];
      const colors = new Set(Object.values(computedThemes.value).flatMap((theme) => Object.keys(theme.colors)));
      for (const key of colors) {
        if (key.startsWith("on-")) {
          createCssClass(fgLines, `.${key}`, [`color: rgb(var(--v-theme-${key})) !important`], parsedOptions.scope);
        } else {
          createCssClass(bgLines, `.bg-${key}`, [`--v-theme-overlay-multiplier: var(--v-theme-${key}-overlay-multiplier)`, `background-color: rgb(var(--v-theme-${key})) !important`, `color: rgb(var(--v-theme-on-${key})) !important`], parsedOptions.scope);
          createCssClass(fgLines, `.text-${key}`, [`color: rgb(var(--v-theme-${key})) !important`], parsedOptions.scope);
          createCssClass(fgLines, `.border-${key}`, [`--v-border-color: var(--v-theme-${key})`], parsedOptions.scope);
        }
      }
      lines.push(...bgLines, ...fgLines);
      return lines.map((str, i) => i === 0 ? str : `    ${str}`).join("");
    });
    function install(app) {
      if (parsedOptions.isDisabled)
        return;
      const head = app._context.provides.usehead;
      if (head) {
        let getHead = function() {
          return {
            style: [{
              textContent: styles.value,
              id: parsedOptions.stylesheetId,
              nonce: parsedOptions.cspNonce || false
            }]
          };
        };
        if (head.push) {
          const entry = head.push(getHead);
          if (IN_BROWSER) {
            watch2(styles, () => {
              entry.patch(getHead);
            });
          }
        } else {
          if (IN_BROWSER) {
            head.addHeadObjs(toRef(getHead));
            watchEffect(() => head.updateDOM());
          } else {
            head.addHeadObjs(getHead());
          }
        }
      } else {
        let updateStyles = function() {
          upsertStyles(getOrCreateStyleElement(parsedOptions.stylesheetId, parsedOptions.cspNonce), styles.value);
        };
        if (IN_BROWSER) {
          watch2(styles, updateStyles, {
            immediate: true
          });
        } else {
          updateStyles();
        }
      }
    }
    const themeClasses = toRef(() => parsedOptions.isDisabled ? void 0 : `v-theme--${name.value}`);
    return {
      install,
      isDisabled: parsedOptions.isDisabled,
      name,
      themes,
      current,
      computedThemes,
      themeClasses,
      styles,
      global: {
        name,
        current
      }
    };
  }
  function provideTheme(props) {
    getCurrentInstance2("provideTheme");
    const theme = inject(ThemeSymbol, null);
    if (!theme)
      throw new Error("Could not find Vuetify theme injection");
    const name = toRef(() => {
      var _a3;
      return (_a3 = props.theme) != null ? _a3 : theme.name.value;
    });
    const current = toRef(() => theme.themes.value[name.value]);
    const themeClasses = toRef(() => theme.isDisabled ? void 0 : `v-theme--${name.value}`);
    const newTheme = __spreadProps(__spreadValues({}, theme), {
      name,
      current,
      themeClasses
    });
    provide(ThemeSymbol, newTheme);
    return newTheme;
  }
  function useTheme() {
    getCurrentInstance2("useTheme");
    const theme = inject(ThemeSymbol, null);
    if (!theme)
      throw new Error("Could not find Vuetify theme injection");
    return theme;
  }

  // ../posawesome/node_modules/vuetify/lib/composables/resizeObserver.js
  function useResizeObserver(callback) {
    let box = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "content";
    const resizeRef = templateRef();
    const contentRect = ref();
    if (IN_BROWSER) {
      const observer = new ResizeObserver((entries) => {
        callback == null ? void 0 : callback(entries, observer);
        if (!entries.length)
          return;
        if (box === "content") {
          contentRect.value = entries[0].contentRect;
        } else {
          contentRect.value = entries[0].target.getBoundingClientRect();
        }
      });
      onBeforeUnmount(() => {
        observer.disconnect();
      });
      watch2(() => resizeRef.el, (newValue, oldValue) => {
        if (oldValue) {
          observer.unobserve(oldValue);
          contentRect.value = void 0;
        }
        if (newValue)
          observer.observe(newValue);
      }, {
        flush: "post"
      });
    }
    return {
      resizeRef,
      contentRect: readonly(contentRect)
    };
  }

  // ../posawesome/node_modules/vuetify/lib/composables/layout.js
  var VuetifyLayoutKey = Symbol.for("vuetify:layout");
  var VuetifyLayoutItemKey = Symbol.for("vuetify:layout-item");
  var ROOT_ZINDEX = 1e3;
  var makeLayoutProps = propsFactory({
    overlaps: {
      type: Array,
      default: () => []
    },
    fullHeight: Boolean
  }, "layout");
  var makeLayoutItemProps = propsFactory({
    name: {
      type: String
    },
    order: {
      type: [Number, String],
      default: 0
    },
    absolute: Boolean
  }, "layout-item");
  function useLayout() {
    const layout = inject(VuetifyLayoutKey);
    if (!layout)
      throw new Error("[Vuetify] Could not find injected layout");
    return {
      getLayoutItem: layout.getLayoutItem,
      mainRect: layout.mainRect,
      mainStyles: layout.mainStyles
    };
  }
  function useLayoutItem(options) {
    var _a3;
    const layout = inject(VuetifyLayoutKey);
    if (!layout)
      throw new Error("[Vuetify] Could not find injected layout");
    const id = (_a3 = options.id) != null ? _a3 : `layout-item-${useId()}`;
    const vm2 = getCurrentInstance2("useLayoutItem");
    provide(VuetifyLayoutItemKey, {
      id
    });
    const isKeptAlive = shallowRef(false);
    onDeactivated(() => isKeptAlive.value = true);
    onActivated(() => isKeptAlive.value = false);
    const {
      layoutItemStyles,
      layoutItemScrimStyles
    } = layout.register(vm2, __spreadProps(__spreadValues({}, options), {
      active: computed2(() => isKeptAlive.value ? false : options.active.value),
      id
    }));
    onBeforeUnmount(() => layout.unregister(id));
    return {
      layoutItemStyles,
      layoutRect: layout.layoutRect,
      layoutItemScrimStyles
    };
  }
  var generateLayers = (layout, positions, layoutSizes, activeItems) => {
    let previousLayer = {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    };
    const layers = [{
      id: "",
      layer: __spreadValues({}, previousLayer)
    }];
    for (const id of layout) {
      const position = positions.get(id);
      const amount = layoutSizes.get(id);
      const active = activeItems.get(id);
      if (!position || !amount || !active)
        continue;
      const layer = __spreadProps(__spreadValues({}, previousLayer), {
        [position.value]: parseInt(previousLayer[position.value], 10) + (active.value ? parseInt(amount.value, 10) : 0)
      });
      layers.push({
        id,
        layer
      });
      previousLayer = layer;
    }
    return layers;
  };
  function createLayout(props) {
    const parentLayout = inject(VuetifyLayoutKey, null);
    const rootZIndex = computed2(() => parentLayout ? parentLayout.rootZIndex.value - 100 : ROOT_ZINDEX);
    const registered = ref([]);
    const positions = reactive(/* @__PURE__ */ new Map());
    const layoutSizes = reactive(/* @__PURE__ */ new Map());
    const priorities = reactive(/* @__PURE__ */ new Map());
    const activeItems = reactive(/* @__PURE__ */ new Map());
    const disabledTransitions = reactive(/* @__PURE__ */ new Map());
    const {
      resizeRef,
      contentRect: layoutRect
    } = useResizeObserver();
    const computedOverlaps = computed2(() => {
      var _a3;
      const map2 = /* @__PURE__ */ new Map();
      const overlaps = (_a3 = props.overlaps) != null ? _a3 : [];
      for (const overlap of overlaps.filter((item) => item.includes(":"))) {
        const [top, bottom] = overlap.split(":");
        if (!registered.value.includes(top) || !registered.value.includes(bottom))
          continue;
        const topPosition = positions.get(top);
        const bottomPosition = positions.get(bottom);
        const topAmount = layoutSizes.get(top);
        const bottomAmount = layoutSizes.get(bottom);
        if (!topPosition || !bottomPosition || !topAmount || !bottomAmount)
          continue;
        map2.set(bottom, {
          position: topPosition.value,
          amount: parseInt(topAmount.value, 10)
        });
        map2.set(top, {
          position: bottomPosition.value,
          amount: -parseInt(bottomAmount.value, 10)
        });
      }
      return map2;
    });
    const layers = computed2(() => {
      const uniquePriorities = [...new Set([...priorities.values()].map((p2) => p2.value))].sort((a, b) => a - b);
      const layout = [];
      for (const p2 of uniquePriorities) {
        const items2 = registered.value.filter((id) => {
          var _a3;
          return ((_a3 = priorities.get(id)) == null ? void 0 : _a3.value) === p2;
        });
        layout.push(...items2);
      }
      return generateLayers(layout, positions, layoutSizes, activeItems);
    });
    const transitionsEnabled = computed2(() => {
      return !Array.from(disabledTransitions.values()).some((ref2) => ref2.value);
    });
    const mainRect = computed2(() => {
      return layers.value[layers.value.length - 1].layer;
    });
    const mainStyles = toRef(() => {
      return __spreadValues({
        "--v-layout-left": convertToUnit(mainRect.value.left),
        "--v-layout-right": convertToUnit(mainRect.value.right),
        "--v-layout-top": convertToUnit(mainRect.value.top),
        "--v-layout-bottom": convertToUnit(mainRect.value.bottom)
      }, transitionsEnabled.value ? void 0 : {
        transition: "none"
      });
    });
    const items = computed2(() => {
      return layers.value.slice(1).map((_ref, index) => {
        let {
          id
        } = _ref;
        const {
          layer
        } = layers.value[index];
        const size = layoutSizes.get(id);
        const position = positions.get(id);
        return __spreadProps(__spreadValues({
          id
        }, layer), {
          size: Number(size.value),
          position: position.value
        });
      });
    });
    const getLayoutItem = (id) => {
      return items.value.find((item) => item.id === id);
    };
    const rootVm = getCurrentInstance2("createLayout");
    const isMounted = shallowRef(false);
    onMounted(() => {
      isMounted.value = true;
    });
    provide(VuetifyLayoutKey, {
      register: (vm2, _ref2) => {
        let {
          id,
          order,
          position,
          layoutSize,
          elementSize,
          active,
          disableTransitions,
          absolute
        } = _ref2;
        priorities.set(id, order);
        positions.set(id, position);
        layoutSizes.set(id, layoutSize);
        activeItems.set(id, active);
        disableTransitions && disabledTransitions.set(id, disableTransitions);
        const instances = findChildrenWithProvide(VuetifyLayoutItemKey, rootVm == null ? void 0 : rootVm.vnode);
        const instanceIndex = instances.indexOf(vm2);
        if (instanceIndex > -1)
          registered.value.splice(instanceIndex, 0, id);
        else
          registered.value.push(id);
        const index = computed2(() => items.value.findIndex((i) => i.id === id));
        const zIndex = computed2(() => rootZIndex.value + layers.value.length * 2 - index.value * 2);
        const layoutItemStyles = computed2(() => {
          var _a3;
          const isHorizontal = position.value === "left" || position.value === "right";
          const isOppositeHorizontal = position.value === "right";
          const isOppositeVertical = position.value === "bottom";
          const size = (_a3 = elementSize.value) != null ? _a3 : layoutSize.value;
          const unit = size === 0 ? "%" : "px";
          const styles = __spreadValues({
            [position.value]: 0,
            zIndex: zIndex.value,
            transform: `translate${isHorizontal ? "X" : "Y"}(${(active.value ? 0 : -(size === 0 ? 100 : size)) * (isOppositeHorizontal || isOppositeVertical ? -1 : 1)}${unit})`,
            position: absolute.value || rootZIndex.value !== ROOT_ZINDEX ? "absolute" : "fixed"
          }, transitionsEnabled.value ? void 0 : {
            transition: "none"
          });
          if (!isMounted.value)
            return styles;
          const item = items.value[index.value];
          if (!item)
            throw new Error(`[Vuetify] Could not find layout item "${id}"`);
          const overlap = computedOverlaps.value.get(id);
          if (overlap) {
            item[overlap.position] += overlap.amount;
          }
          return __spreadProps(__spreadValues({}, styles), {
            height: isHorizontal ? `calc(100% - ${item.top}px - ${item.bottom}px)` : elementSize.value ? `${elementSize.value}px` : void 0,
            left: isOppositeHorizontal ? void 0 : `${item.left}px`,
            right: isOppositeHorizontal ? `${item.right}px` : void 0,
            top: position.value !== "bottom" ? `${item.top}px` : void 0,
            bottom: position.value !== "top" ? `${item.bottom}px` : void 0,
            width: !isHorizontal ? `calc(100% - ${item.left}px - ${item.right}px)` : elementSize.value ? `${elementSize.value}px` : void 0
          });
        });
        const layoutItemScrimStyles = computed2(() => ({
          zIndex: zIndex.value - 1
        }));
        return {
          layoutItemStyles,
          layoutItemScrimStyles,
          zIndex
        };
      },
      unregister: (id) => {
        priorities.delete(id);
        positions.delete(id);
        layoutSizes.delete(id);
        activeItems.delete(id);
        disabledTransitions.delete(id);
        registered.value = registered.value.filter((v) => v !== id);
      },
      mainRect,
      mainStyles,
      getLayoutItem,
      items,
      layoutRect,
      rootZIndex
    });
    const layoutClasses = toRef(() => ["v-layout", {
      "v-layout--full-height": props.fullHeight
    }]);
    const layoutStyles = toRef(() => ({
      zIndex: parentLayout ? rootZIndex.value : void 0,
      position: parentLayout ? "relative" : void 0,
      overflow: parentLayout ? "hidden" : void 0
    }));
    return {
      layoutClasses,
      layoutStyles,
      getLayoutItem,
      items,
      layoutRect,
      layoutRef: resizeRef
    };
  }

  // ../posawesome/node_modules/vuetify/lib/framework.js
  function createVuetify() {
    let vuetify = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const _a3 = vuetify, {
      blueprint
    } = _a3, rest = __objRest(_a3, [
      "blueprint"
    ]);
    const options = mergeDeep(blueprint, rest);
    const {
      aliases: aliases2 = {},
      components = {},
      directives = {}
    } = options;
    const scope = effectScope();
    return scope.run(() => {
      const defaults = createDefaults(options.defaults);
      const display = createDisplay(options.display, options.ssr);
      const theme = createTheme(options.theme);
      const icons = createIcons(options.icons);
      const locale = createLocale(options.locale);
      const date2 = createDate(options.date, locale);
      const goTo = createGoTo(options.goTo, locale);
      function install(app) {
        for (const key in directives) {
          app.directive(key, directives[key]);
        }
        for (const key in components) {
          app.component(key, components[key]);
        }
        for (const key in aliases2) {
          app.component(key, defineComponent2(__spreadProps(__spreadValues({}, aliases2[key]), {
            name: key,
            aliasName: aliases2[key].name
          })));
        }
        const appScope = effectScope();
        appScope.run(() => {
          theme.install(app);
        });
        app.onUnmount(() => appScope.stop());
        app.provide(DefaultsSymbol, defaults);
        app.provide(DisplaySymbol, display);
        app.provide(ThemeSymbol, theme);
        app.provide(IconSymbol, icons);
        app.provide(LocaleSymbol, locale);
        app.provide(DateOptionsSymbol, date2.options);
        app.provide(DateAdapterSymbol, date2.instance);
        app.provide(GoToSymbol, goTo);
        if (IN_BROWSER && options.ssr) {
          if (app.$nuxt) {
            app.$nuxt.hook("app:suspense:resolve", () => {
              display.update();
            });
          } else {
            const {
              mount
            } = app;
            app.mount = function() {
              const vm2 = mount(...arguments);
              nextTick(() => display.update());
              app.mount = mount;
              return vm2;
            };
          }
        }
        if (true) {
          app.mixin({
            computed: {
              $vuetify() {
                return reactive({
                  defaults: inject2.call(this, DefaultsSymbol),
                  display: inject2.call(this, DisplaySymbol),
                  theme: inject2.call(this, ThemeSymbol),
                  icons: inject2.call(this, IconSymbol),
                  locale: inject2.call(this, LocaleSymbol),
                  date: inject2.call(this, DateAdapterSymbol)
                });
              }
            }
          });
        }
      }
      function unmount() {
        scope.stop();
      }
      return {
        install,
        unmount,
        defaults,
        display,
        theme,
        icons,
        locale,
        date: date2,
        goTo
      };
    });
  }
  var version2 = "3.8.10";
  createVuetify.version = version2;
  function inject2(key) {
    var _a3, _b, _c;
    const vm2 = this.$;
    const provides = (_c = (_a3 = vm2.parent) == null ? void 0 : _a3.provides) != null ? _c : (_b = vm2.vnode.appContext) == null ? void 0 : _b.provides;
    if (provides && key in provides) {
      return provides[key];
    }
  }

  // ../posawesome/node_modules/date-fns/constants.js
  var daysInYear = 365.2425;
  var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
  var minTime = -maxTime;
  var millisecondsInWeek = 6048e5;
  var millisecondsInDay = 864e5;
  var millisecondsInMinute = 6e4;
  var millisecondsInHour = 36e5;
  var millisecondsInSecond = 1e3;
  var secondsInHour = 3600;
  var secondsInDay = secondsInHour * 24;
  var secondsInWeek = secondsInDay * 7;
  var secondsInYear = secondsInDay * daysInYear;
  var secondsInMonth = secondsInYear / 12;
  var secondsInQuarter = secondsInMonth * 3;
  var constructFromSymbol = Symbol.for("constructDateFrom");

  // ../posawesome/node_modules/date-fns/constructFrom.js
  function constructFrom(date2, value) {
    if (typeof date2 === "function")
      return date2(value);
    if (date2 && typeof date2 === "object" && constructFromSymbol in date2)
      return date2[constructFromSymbol](value);
    if (date2 instanceof Date)
      return new date2.constructor(value);
    return new Date(value);
  }

  // ../posawesome/node_modules/date-fns/toDate.js
  function toDate(argument, context) {
    return constructFrom(context || argument, argument);
  }

  // ../posawesome/node_modules/date-fns/addDays.js
  function addDays2(date2, amount, options) {
    const _date = toDate(date2, options == null ? void 0 : options.in);
    if (isNaN(amount))
      return constructFrom((options == null ? void 0 : options.in) || date2, NaN);
    if (!amount)
      return _date;
    _date.setDate(_date.getDate() + amount);
    return _date;
  }

  // ../posawesome/node_modules/date-fns/addMonths.js
  function addMonths2(date2, amount, options) {
    const _date = toDate(date2, options == null ? void 0 : options.in);
    if (isNaN(amount))
      return constructFrom((options == null ? void 0 : options.in) || date2, NaN);
    if (!amount) {
      return _date;
    }
    const dayOfMonth = _date.getDate();
    const endOfDesiredMonth = constructFrom((options == null ? void 0 : options.in) || date2, _date.getTime());
    endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
    const daysInMonth = endOfDesiredMonth.getDate();
    if (dayOfMonth >= daysInMonth) {
      return endOfDesiredMonth;
    } else {
      _date.setFullYear(
        endOfDesiredMonth.getFullYear(),
        endOfDesiredMonth.getMonth(),
        dayOfMonth
      );
      return _date;
    }
  }

  // ../posawesome/node_modules/date-fns/add.js
  function add(date2, duration, options) {
    const {
      years = 0,
      months = 0,
      weeks = 0,
      days = 0,
      hours = 0,
      minutes = 0,
      seconds = 0
    } = duration;
    const _date = toDate(date2, options == null ? void 0 : options.in);
    const dateWithMonths = months || years ? addMonths2(_date, months + years * 12) : _date;
    const dateWithDays = days || weeks ? addDays2(dateWithMonths, days + weeks * 7) : dateWithMonths;
    const minutesToAdd = minutes + hours * 60;
    const secondsToAdd = seconds + minutesToAdd * 60;
    const msToAdd = secondsToAdd * 1e3;
    return constructFrom((options == null ? void 0 : options.in) || date2, +dateWithDays + msToAdd);
  }

  // ../posawesome/node_modules/date-fns/addMilliseconds.js
  function addMilliseconds(date2, amount, options) {
    return constructFrom((options == null ? void 0 : options.in) || date2, +toDate(date2) + amount);
  }

  // ../posawesome/node_modules/date-fns/addHours.js
  function addHours2(date2, amount, options) {
    return addMilliseconds(date2, amount * millisecondsInHour, options);
  }

  // ../posawesome/node_modules/date-fns/_lib/defaultOptions.js
  var defaultOptions = {};
  function getDefaultOptions() {
    return defaultOptions;
  }

  // ../posawesome/node_modules/date-fns/startOfWeek.js
  function startOfWeek2(date2, options) {
    var _a3, _b, _c, _d, _e, _f, _g, _h;
    const defaultOptions2 = getDefaultOptions();
    const weekStartsOn = (_h = (_g = (_d = (_c = options == null ? void 0 : options.weekStartsOn) != null ? _c : (_b = (_a3 = options == null ? void 0 : options.locale) == null ? void 0 : _a3.options) == null ? void 0 : _b.weekStartsOn) != null ? _d : defaultOptions2.weekStartsOn) != null ? _g : (_f = (_e = defaultOptions2.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.weekStartsOn) != null ? _h : 0;
    const _date = toDate(date2, options == null ? void 0 : options.in);
    const day = _date.getDay();
    const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    _date.setDate(_date.getDate() - diff);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }

  // ../posawesome/node_modules/date-fns/startOfISOWeek.js
  function startOfISOWeek(date2, options) {
    return startOfWeek2(date2, __spreadProps(__spreadValues({}, options), { weekStartsOn: 1 }));
  }

  // ../posawesome/node_modules/date-fns/getISOWeekYear.js
  function getISOWeekYear(date2, options) {
    const _date = toDate(date2, options == null ? void 0 : options.in);
    const year = _date.getFullYear();
    const fourthOfJanuaryOfNextYear = constructFrom(_date, 0);
    fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
    const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
    const fourthOfJanuaryOfThisYear = constructFrom(_date, 0);
    fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
    const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
    if (_date.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (_date.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  }

  // ../posawesome/node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.js
  function getTimezoneOffsetInMilliseconds(date2) {
    const _date = toDate(date2);
    const utcDate = new Date(
      Date.UTC(
        _date.getFullYear(),
        _date.getMonth(),
        _date.getDate(),
        _date.getHours(),
        _date.getMinutes(),
        _date.getSeconds(),
        _date.getMilliseconds()
      )
    );
    utcDate.setUTCFullYear(_date.getFullYear());
    return +date2 - +utcDate;
  }

  // ../posawesome/node_modules/date-fns/_lib/normalizeDates.js
  function normalizeDates(context, ...dates) {
    const normalize = constructFrom.bind(
      null,
      context || dates.find((date2) => typeof date2 === "object")
    );
    return dates.map(normalize);
  }

  // ../posawesome/node_modules/date-fns/startOfDay.js
  function startOfDay2(date2, options) {
    const _date = toDate(date2, options == null ? void 0 : options.in);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }

  // ../posawesome/node_modules/date-fns/differenceInCalendarDays.js
  function differenceInCalendarDays(laterDate, earlierDate, options) {
    const [laterDate_, earlierDate_] = normalizeDates(
      options == null ? void 0 : options.in,
      laterDate,
      earlierDate
    );
    const laterStartOfDay = startOfDay2(laterDate_);
    const earlierStartOfDay = startOfDay2(earlierDate_);
    const laterTimestamp = +laterStartOfDay - getTimezoneOffsetInMilliseconds(laterStartOfDay);
    const earlierTimestamp = +earlierStartOfDay - getTimezoneOffsetInMilliseconds(earlierStartOfDay);
    return Math.round((laterTimestamp - earlierTimestamp) / millisecondsInDay);
  }

  // ../posawesome/node_modules/date-fns/startOfISOWeekYear.js
  function startOfISOWeekYear(date2, options) {
    const year = getISOWeekYear(date2, options);
    const fourthOfJanuary = constructFrom((options == null ? void 0 : options.in) || date2, 0);
    fourthOfJanuary.setFullYear(year, 0, 4);
    fourthOfJanuary.setHours(0, 0, 0, 0);
    return startOfISOWeek(fourthOfJanuary);
  }

  // ../posawesome/node_modules/date-fns/addQuarters.js
  function addQuarters(date2, amount, options) {
    return addMonths2(date2, amount * 3, options);
  }

  // ../posawesome/node_modules/date-fns/addYears.js
  function addYears(date2, amount, options) {
    return addMonths2(date2, amount * 12, options);
  }

  // ../posawesome/node_modules/date-fns/compareAsc.js
  function compareAsc(dateLeft, dateRight) {
    const diff = +toDate(dateLeft) - +toDate(dateRight);
    if (diff < 0)
      return -1;
    else if (diff > 0)
      return 1;
    return diff;
  }

  // ../posawesome/node_modules/date-fns/isDate.js
  function isDate(value) {
    return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
  }

  // ../posawesome/node_modules/date-fns/isValid.js
  function isValid2(date2) {
    return !(!isDate(date2) && typeof date2 !== "number" || isNaN(+toDate(date2)));
  }

  // ../posawesome/node_modules/date-fns/getQuarter.js
  function getQuarter(date2, options) {
    const _date = toDate(date2, options == null ? void 0 : options.in);
    const quarter = Math.trunc(_date.getMonth() / 3) + 1;
    return quarter;
  }

  // ../posawesome/node_modules/date-fns/differenceInCalendarYears.js
  function differenceInCalendarYears(laterDate, earlierDate, options) {
    const [laterDate_, earlierDate_] = normalizeDates(
      options == null ? void 0 : options.in,
      laterDate,
      earlierDate
    );
    return laterDate_.getFullYear() - earlierDate_.getFullYear();
  }

  // ../posawesome/node_modules/date-fns/differenceInYears.js
  function differenceInYears(laterDate, earlierDate, options) {
    const [laterDate_, earlierDate_] = normalizeDates(
      options == null ? void 0 : options.in,
      laterDate,
      earlierDate
    );
    const sign = compareAsc(laterDate_, earlierDate_);
    const diff = Math.abs(differenceInCalendarYears(laterDate_, earlierDate_));
    laterDate_.setFullYear(1584);
    earlierDate_.setFullYear(1584);
    const partial = compareAsc(laterDate_, earlierDate_) === -sign;
    const result = sign * (diff - +partial);
    return result === 0 ? 0 : result;
  }

  // ../posawesome/node_modules/date-fns/_lib/normalizeInterval.js
  function normalizeInterval(context, interval) {
    const [start, end] = normalizeDates(context, interval.start, interval.end);
    return { start, end };
  }

  // ../posawesome/node_modules/date-fns/eachDayOfInterval.js
  function eachDayOfInterval(interval, options) {
    var _a3;
    const { start, end } = normalizeInterval(options == null ? void 0 : options.in, interval);
    let reversed = +start > +end;
    const endTime = reversed ? +start : +end;
    const date2 = reversed ? end : start;
    date2.setHours(0, 0, 0, 0);
    let step = (_a3 = options == null ? void 0 : options.step) != null ? _a3 : 1;
    if (!step)
      return [];
    if (step < 0) {
      step = -step;
      reversed = !reversed;
    }
    const dates = [];
    while (+date2 <= endTime) {
      dates.push(constructFrom(start, date2));
      date2.setDate(date2.getDate() + step);
      date2.setHours(0, 0, 0, 0);
    }
    return reversed ? dates.reverse() : dates;
  }

  // ../posawesome/node_modules/date-fns/startOfQuarter.js
  function startOfQuarter(date2, options) {
    const _date = toDate(date2, options == null ? void 0 : options.in);
    const currentMonth = _date.getMonth();
    const month = currentMonth - currentMonth % 3;
    _date.setMonth(month, 1);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }

  // ../posawesome/node_modules/date-fns/eachQuarterOfInterval.js
  function eachQuarterOfInterval(interval, options) {
    var _a3;
    const { start, end } = normalizeInterval(options == null ? void 0 : options.in, interval);
    let reversed = +start > +end;
    const endTime = reversed ? +startOfQuarter(start) : +startOfQuarter(end);
    let date2 = reversed ? startOfQuarter(end) : startOfQuarter(start);
    let step = (_a3 = options == null ? void 0 : options.step) != null ? _a3 : 1;
    if (!step)
      return [];
    if (step < 0) {
      step = -step;
      reversed = !reversed;
    }
    const dates = [];
    while (+date2 <= endTime) {
      dates.push(constructFrom(start, date2));
      date2 = addQuarters(date2, step);
    }
    return reversed ? dates.reverse() : dates;
  }

  // ../posawesome/node_modules/date-fns/startOfMonth.js
  function startOfMonth2(date2, options) {
    const _date = toDate(date2, options == null ? void 0 : options.in);
    _date.setDate(1);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }

  // ../posawesome/node_modules/date-fns/endOfYear.js
  function endOfYear2(date2, options) {
    const _date = toDate(date2, options == null ? void 0 : options.in);
    const year = _date.getFullYear();
    _date.setFullYear(year + 1, 0, 0);
    _date.setHours(23, 59, 59, 999);
    return _date;
  }

  // ../posawesome/node_modules/date-fns/startOfYear.js
  function startOfYear2(date2, options) {
    const date_ = toDate(date2, options == null ? void 0 : options.in);
    date_.setFullYear(date_.getFullYear(), 0, 1);
    date_.setHours(0, 0, 0, 0);
    return date_;
  }

  // ../posawesome/node_modules/date-fns/endOfWeek.js
  function endOfWeek2(date2, options) {
    var _a3, _b, _c, _d, _e, _f, _g, _h;
    const defaultOptions2 = getDefaultOptions();
    const weekStartsOn = (_h = (_g = (_d = (_c = options == null ? void 0 : options.weekStartsOn) != null ? _c : (_b = (_a3 = options == null ? void 0 : options.locale) == null ? void 0 : _a3.options) == null ? void 0 : _b.weekStartsOn) != null ? _d : defaultOptions2.weekStartsOn) != null ? _g : (_f = (_e = defaultOptions2.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.weekStartsOn) != null ? _h : 0;
    const _date = toDate(date2, options == null ? void 0 : options.in);
    const day = _date.getDay();
    const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
    _date.setDate(_date.getDate() + diff);
    _date.setHours(23, 59, 59, 999);
    return _date;
  }

  // ../posawesome/node_modules/date-fns/endOfQuarter.js
  function endOfQuarter(date2, options) {
    const _date = toDate(date2, options == null ? void 0 : options.in);
    const currentMonth = _date.getMonth();
    const month = currentMonth - currentMonth % 3 + 3;
    _date.setMonth(month, 0);
    _date.setHours(23, 59, 59, 999);
    return _date;
  }

  // ../posawesome/node_modules/date-fns/locale/en-US/_lib/formatDistance.js
  var formatDistanceLocale = {
    lessThanXSeconds: {
      one: "less than a second",
      other: "less than {{count}} seconds"
    },
    xSeconds: {
      one: "1 second",
      other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
      one: "less than a minute",
      other: "less than {{count}} minutes"
    },
    xMinutes: {
      one: "1 minute",
      other: "{{count}} minutes"
    },
    aboutXHours: {
      one: "about 1 hour",
      other: "about {{count}} hours"
    },
    xHours: {
      one: "1 hour",
      other: "{{count}} hours"
    },
    xDays: {
      one: "1 day",
      other: "{{count}} days"
    },
    aboutXWeeks: {
      one: "about 1 week",
      other: "about {{count}} weeks"
    },
    xWeeks: {
      one: "1 week",
      other: "{{count}} weeks"
    },
    aboutXMonths: {
      one: "about 1 month",
      other: "about {{count}} months"
    },
    xMonths: {
      one: "1 month",
      other: "{{count}} months"
    },
    aboutXYears: {
      one: "about 1 year",
      other: "about {{count}} years"
    },
    xYears: {
      one: "1 year",
      other: "{{count}} years"
    },
    overXYears: {
      one: "over 1 year",
      other: "over {{count}} years"
    },
    almostXYears: {
      one: "almost 1 year",
      other: "almost {{count}} years"
    }
  };
  var formatDistance = (token, count, options) => {
    let result;
    const tokenValue = formatDistanceLocale[token];
    if (typeof tokenValue === "string") {
      result = tokenValue;
    } else if (count === 1) {
      result = tokenValue.one;
    } else {
      result = tokenValue.other.replace("{{count}}", count.toString());
    }
    if (options == null ? void 0 : options.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        return "in " + result;
      } else {
        return result + " ago";
      }
    }
    return result;
  };

  // ../posawesome/node_modules/date-fns/locale/_lib/buildFormatLongFn.js
  function buildFormatLongFn(args) {
    return (options = {}) => {
      const width = options.width ? String(options.width) : args.defaultWidth;
      const format3 = args.formats[width] || args.formats[args.defaultWidth];
      return format3;
    };
  }

  // ../posawesome/node_modules/date-fns/locale/en-US/_lib/formatLong.js
  var dateFormats = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
  };
  var timeFormats = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
  };
  var dateTimeFormats = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
  };
  var formatLong = {
    date: buildFormatLongFn({
      formats: dateFormats,
      defaultWidth: "full"
    }),
    time: buildFormatLongFn({
      formats: timeFormats,
      defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
      formats: dateTimeFormats,
      defaultWidth: "full"
    })
  };

  // ../posawesome/node_modules/date-fns/locale/en-US/_lib/formatRelative.js
  var formatRelativeLocale = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
  };
  var formatRelative = (token, _date, _baseDate, _options) => formatRelativeLocale[token];

  // ../posawesome/node_modules/date-fns/locale/_lib/buildLocalizeFn.js
  function buildLocalizeFn(args) {
    return (value, options) => {
      const context = (options == null ? void 0 : options.context) ? String(options.context) : "standalone";
      let valuesArray;
      if (context === "formatting" && args.formattingValues) {
        const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
        const width = (options == null ? void 0 : options.width) ? String(options.width) : defaultWidth;
        valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
      } else {
        const defaultWidth = args.defaultWidth;
        const width = (options == null ? void 0 : options.width) ? String(options.width) : args.defaultWidth;
        valuesArray = args.values[width] || args.values[defaultWidth];
      }
      const index = args.argumentCallback ? args.argumentCallback(value) : value;
      return valuesArray[index];
    };
  }

  // ../posawesome/node_modules/date-fns/locale/en-US/_lib/localize.js
  var eraValues = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
  };
  var quarterValues = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
  };
  var monthValues = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    wide: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ]
  };
  var dayValues = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ]
  };
  var dayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    }
  };
  var formattingDayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    }
  };
  var ordinalNumber = (dirtyNumber, _options) => {
    const number = Number(dirtyNumber);
    const rem100 = number % 100;
    if (rem100 > 20 || rem100 < 10) {
      switch (rem100 % 10) {
        case 1:
          return number + "st";
        case 2:
          return number + "nd";
        case 3:
          return number + "rd";
      }
    }
    return number + "th";
  };
  var localize = {
    ordinalNumber,
    era: buildLocalizeFn({
      values: eraValues,
      defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
      values: quarterValues,
      defaultWidth: "wide",
      argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
      values: monthValues,
      defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
      values: dayValues,
      defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
      values: dayPeriodValues,
      defaultWidth: "wide",
      formattingValues: formattingDayPeriodValues,
      defaultFormattingWidth: "wide"
    })
  };

  // ../posawesome/node_modules/date-fns/locale/_lib/buildMatchFn.js
  function buildMatchFn(args) {
    return (string, options = {}) => {
      const width = options.width;
      const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
      const matchResult = string.match(matchPattern);
      if (!matchResult) {
        return null;
      }
      const matchedString = matchResult[0];
      const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
      const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : findKey(parsePatterns, (pattern) => pattern.test(matchedString));
      let value;
      value = args.valueCallback ? args.valueCallback(key) : key;
      value = options.valueCallback ? options.valueCallback(value) : value;
      const rest = string.slice(matchedString.length);
      return { value, rest };
    };
  }
  function findKey(object, predicate) {
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
        return key;
      }
    }
    return void 0;
  }
  function findIndex(array, predicate) {
    for (let key = 0; key < array.length; key++) {
      if (predicate(array[key])) {
        return key;
      }
    }
    return void 0;
  }

  // ../posawesome/node_modules/date-fns/locale/_lib/buildMatchPatternFn.js
  function buildMatchPatternFn(args) {
    return (string, options = {}) => {
      const matchResult = string.match(args.matchPattern);
      if (!matchResult)
        return null;
      const matchedString = matchResult[0];
      const parseResult = string.match(args.parsePattern);
      if (!parseResult)
        return null;
      let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
      value = options.valueCallback ? options.valueCallback(value) : value;
      const rest = string.slice(matchedString.length);
      return { value, rest };
    };
  }

  // ../posawesome/node_modules/date-fns/locale/en-US/_lib/match.js
  var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
  var parseOrdinalNumberPattern = /\d+/i;
  var matchEraPatterns = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
  };
  var parseEraPatterns = {
    any: [/^b/i, /^(a|c)/i]
  };
  var matchQuarterPatterns = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
  };
  var parseQuarterPatterns = {
    any: [/1/i, /2/i, /3/i, /4/i]
  };
  var matchMonthPatterns = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  };
  var parseMonthPatterns = {
    narrow: [
      /^j/i,
      /^f/i,
      /^m/i,
      /^a/i,
      /^m/i,
      /^j/i,
      /^j/i,
      /^a/i,
      /^s/i,
      /^o/i,
      /^n/i,
      /^d/i
    ],
    any: [
      /^ja/i,
      /^f/i,
      /^mar/i,
      /^ap/i,
      /^may/i,
      /^jun/i,
      /^jul/i,
      /^au/i,
      /^s/i,
      /^o/i,
      /^n/i,
      /^d/i
    ]
  };
  var matchDayPatterns = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  };
  var parseDayPatterns = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
  };
  var matchDayPeriodPatterns = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
  };
  var parseDayPeriodPatterns = {
    any: {
      am: /^a/i,
      pm: /^p/i,
      midnight: /^mi/i,
      noon: /^no/i,
      morning: /morning/i,
      afternoon: /afternoon/i,
      evening: /evening/i,
      night: /night/i
    }
  };
  var match = {
    ordinalNumber: buildMatchPatternFn({
      matchPattern: matchOrdinalNumberPattern,
      parsePattern: parseOrdinalNumberPattern,
      valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
      matchPatterns: matchEraPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseEraPatterns,
      defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
      matchPatterns: matchQuarterPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseQuarterPatterns,
      defaultParseWidth: "any",
      valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
      matchPatterns: matchMonthPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseMonthPatterns,
      defaultParseWidth: "any"
    }),
    day: buildMatchFn({
      matchPatterns: matchDayPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseDayPatterns,
      defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
      matchPatterns: matchDayPeriodPatterns,
      defaultMatchWidth: "any",
      parsePatterns: parseDayPeriodPatterns,
      defaultParseWidth: "any"
    })
  };

  // ../posawesome/node_modules/date-fns/locale/en-US.js
  var enUS = {
    code: "en-US",
    formatDistance,
    formatLong,
    formatRelative,
    localize,
    match,
    options: {
      weekStartsOn: 0,
      firstWeekContainsDate: 1
    }
  };

  // ../posawesome/node_modules/date-fns/getDayOfYear.js
  function getDayOfYear(date2, options) {
    const _date = toDate(date2, options == null ? void 0 : options.in);
    const diff = differenceInCalendarDays(_date, startOfYear2(_date));
    const dayOfYear = diff + 1;
    return dayOfYear;
  }

  // ../posawesome/node_modules/date-fns/getISOWeek.js
  function getISOWeek(date2, options) {
    const _date = toDate(date2, options == null ? void 0 : options.in);
    const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
    return Math.round(diff / millisecondsInWeek) + 1;
  }

  // ../posawesome/node_modules/date-fns/getWeekYear.js
  function getWeekYear(date2, options) {
    var _a3, _b, _c, _d, _e, _f, _g, _h;
    const _date = toDate(date2, options == null ? void 0 : options.in);
    const year = _date.getFullYear();
    const defaultOptions2 = getDefaultOptions();
    const firstWeekContainsDate = (_h = (_g = (_d = (_c = options == null ? void 0 : options.firstWeekContainsDate) != null ? _c : (_b = (_a3 = options == null ? void 0 : options.locale) == null ? void 0 : _a3.options) == null ? void 0 : _b.firstWeekContainsDate) != null ? _d : defaultOptions2.firstWeekContainsDate) != null ? _g : (_f = (_e = defaultOptions2.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.firstWeekContainsDate) != null ? _h : 1;
    const firstWeekOfNextYear = constructFrom((options == null ? void 0 : options.in) || date2, 0);
    firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
    firstWeekOfNextYear.setHours(0, 0, 0, 0);
    const startOfNextYear = startOfWeek2(firstWeekOfNextYear, options);
    const firstWeekOfThisYear = constructFrom((options == null ? void 0 : options.in) || date2, 0);
    firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
    firstWeekOfThisYear.setHours(0, 0, 0, 0);
    const startOfThisYear = startOfWeek2(firstWeekOfThisYear, options);
    if (+_date >= +startOfNextYear) {
      return year + 1;
    } else if (+_date >= +startOfThisYear) {
      return year;
    } else {
      return year - 1;
    }
  }

  // ../posawesome/node_modules/date-fns/startOfWeekYear.js
  function startOfWeekYear(date2, options) {
    var _a3, _b, _c, _d, _e, _f, _g, _h;
    const defaultOptions2 = getDefaultOptions();
    const firstWeekContainsDate = (_h = (_g = (_d = (_c = options == null ? void 0 : options.firstWeekContainsDate) != null ? _c : (_b = (_a3 = options == null ? void 0 : options.locale) == null ? void 0 : _a3.options) == null ? void 0 : _b.firstWeekContainsDate) != null ? _d : defaultOptions2.firstWeekContainsDate) != null ? _g : (_f = (_e = defaultOptions2.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.firstWeekContainsDate) != null ? _h : 1;
    const year = getWeekYear(date2, options);
    const firstWeek = constructFrom((options == null ? void 0 : options.in) || date2, 0);
    firstWeek.setFullYear(year, 0, firstWeekContainsDate);
    firstWeek.setHours(0, 0, 0, 0);
    const _date = startOfWeek2(firstWeek, options);
    return _date;
  }

  // ../posawesome/node_modules/date-fns/getWeek.js
  function getWeek2(date2, options) {
    const _date = toDate(date2, options == null ? void 0 : options.in);
    const diff = +startOfWeek2(_date, options) - +startOfWeekYear(_date, options);
    return Math.round(diff / millisecondsInWeek) + 1;
  }

  // ../posawesome/node_modules/date-fns/_lib/addLeadingZeros.js
  function addLeadingZeros(number, targetLength) {
    const sign = number < 0 ? "-" : "";
    const output = Math.abs(number).toString().padStart(targetLength, "0");
    return sign + output;
  }

  // ../posawesome/node_modules/date-fns/_lib/format/lightFormatters.js
  var lightFormatters = {
    y(date2, token) {
      const signedYear = date2.getFullYear();
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
    },
    M(date2, token) {
      const month = date2.getMonth();
      return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
    },
    d(date2, token) {
      return addLeadingZeros(date2.getDate(), token.length);
    },
    a(date2, token) {
      const dayPeriodEnumValue = date2.getHours() / 12 >= 1 ? "pm" : "am";
      switch (token) {
        case "a":
        case "aa":
          return dayPeriodEnumValue.toUpperCase();
        case "aaa":
          return dayPeriodEnumValue;
        case "aaaaa":
          return dayPeriodEnumValue[0];
        case "aaaa":
        default:
          return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
      }
    },
    h(date2, token) {
      return addLeadingZeros(date2.getHours() % 12 || 12, token.length);
    },
    H(date2, token) {
      return addLeadingZeros(date2.getHours(), token.length);
    },
    m(date2, token) {
      return addLeadingZeros(date2.getMinutes(), token.length);
    },
    s(date2, token) {
      return addLeadingZeros(date2.getSeconds(), token.length);
    },
    S(date2, token) {
      const numberOfDigits = token.length;
      const milliseconds = date2.getMilliseconds();
      const fractionalSeconds = Math.trunc(
        milliseconds * Math.pow(10, numberOfDigits - 3)
      );
      return addLeadingZeros(fractionalSeconds, token.length);
    }
  };

  // ../posawesome/node_modules/date-fns/_lib/format/formatters.js
  var dayPeriodEnum = {
    am: "am",
    pm: "pm",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  };
  var formatters = {
    G: function(date2, token, localize2) {
      const era = date2.getFullYear() > 0 ? 1 : 0;
      switch (token) {
        case "G":
        case "GG":
        case "GGG":
          return localize2.era(era, { width: "abbreviated" });
        case "GGGGG":
          return localize2.era(era, { width: "narrow" });
        case "GGGG":
        default:
          return localize2.era(era, { width: "wide" });
      }
    },
    y: function(date2, token, localize2) {
      if (token === "yo") {
        const signedYear = date2.getFullYear();
        const year = signedYear > 0 ? signedYear : 1 - signedYear;
        return localize2.ordinalNumber(year, { unit: "year" });
      }
      return lightFormatters.y(date2, token);
    },
    Y: function(date2, token, localize2, options) {
      const signedWeekYear = getWeekYear(date2, options);
      const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
      if (token === "YY") {
        const twoDigitYear = weekYear % 100;
        return addLeadingZeros(twoDigitYear, 2);
      }
      if (token === "Yo") {
        return localize2.ordinalNumber(weekYear, { unit: "year" });
      }
      return addLeadingZeros(weekYear, token.length);
    },
    R: function(date2, token) {
      const isoWeekYear = getISOWeekYear(date2);
      return addLeadingZeros(isoWeekYear, token.length);
    },
    u: function(date2, token) {
      const year = date2.getFullYear();
      return addLeadingZeros(year, token.length);
    },
    Q: function(date2, token, localize2) {
      const quarter = Math.ceil((date2.getMonth() + 1) / 3);
      switch (token) {
        case "Q":
          return String(quarter);
        case "QQ":
          return addLeadingZeros(quarter, 2);
        case "Qo":
          return localize2.ordinalNumber(quarter, { unit: "quarter" });
        case "QQQ":
          return localize2.quarter(quarter, {
            width: "abbreviated",
            context: "formatting"
          });
        case "QQQQQ":
          return localize2.quarter(quarter, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return localize2.quarter(quarter, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    q: function(date2, token, localize2) {
      const quarter = Math.ceil((date2.getMonth() + 1) / 3);
      switch (token) {
        case "q":
          return String(quarter);
        case "qq":
          return addLeadingZeros(quarter, 2);
        case "qo":
          return localize2.ordinalNumber(quarter, { unit: "quarter" });
        case "qqq":
          return localize2.quarter(quarter, {
            width: "abbreviated",
            context: "standalone"
          });
        case "qqqqq":
          return localize2.quarter(quarter, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return localize2.quarter(quarter, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    M: function(date2, token, localize2) {
      const month = date2.getMonth();
      switch (token) {
        case "M":
        case "MM":
          return lightFormatters.M(date2, token);
        case "Mo":
          return localize2.ordinalNumber(month + 1, { unit: "month" });
        case "MMM":
          return localize2.month(month, {
            width: "abbreviated",
            context: "formatting"
          });
        case "MMMMM":
          return localize2.month(month, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return localize2.month(month, { width: "wide", context: "formatting" });
      }
    },
    L: function(date2, token, localize2) {
      const month = date2.getMonth();
      switch (token) {
        case "L":
          return String(month + 1);
        case "LL":
          return addLeadingZeros(month + 1, 2);
        case "Lo":
          return localize2.ordinalNumber(month + 1, { unit: "month" });
        case "LLL":
          return localize2.month(month, {
            width: "abbreviated",
            context: "standalone"
          });
        case "LLLLL":
          return localize2.month(month, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return localize2.month(month, { width: "wide", context: "standalone" });
      }
    },
    w: function(date2, token, localize2, options) {
      const week = getWeek2(date2, options);
      if (token === "wo") {
        return localize2.ordinalNumber(week, { unit: "week" });
      }
      return addLeadingZeros(week, token.length);
    },
    I: function(date2, token, localize2) {
      const isoWeek = getISOWeek(date2);
      if (token === "Io") {
        return localize2.ordinalNumber(isoWeek, { unit: "week" });
      }
      return addLeadingZeros(isoWeek, token.length);
    },
    d: function(date2, token, localize2) {
      if (token === "do") {
        return localize2.ordinalNumber(date2.getDate(), { unit: "date" });
      }
      return lightFormatters.d(date2, token);
    },
    D: function(date2, token, localize2) {
      const dayOfYear = getDayOfYear(date2);
      if (token === "Do") {
        return localize2.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
      }
      return addLeadingZeros(dayOfYear, token.length);
    },
    E: function(date2, token, localize2) {
      const dayOfWeek = date2.getDay();
      switch (token) {
        case "E":
        case "EE":
        case "EEE":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        case "EEEEE":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        case "EEEE":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    e: function(date2, token, localize2, options) {
      const dayOfWeek = date2.getDay();
      const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
      switch (token) {
        case "e":
          return String(localDayOfWeek);
        case "ee":
          return addLeadingZeros(localDayOfWeek, 2);
        case "eo":
          return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
        case "eee":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        case "eeeee":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        case "eeee":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    c: function(date2, token, localize2, options) {
      const dayOfWeek = date2.getDay();
      const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
      switch (token) {
        case "c":
          return String(localDayOfWeek);
        case "cc":
          return addLeadingZeros(localDayOfWeek, token.length);
        case "co":
          return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
        case "ccc":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "standalone"
          });
        case "ccccc":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "standalone"
          });
        case "cccc":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    i: function(date2, token, localize2) {
      const dayOfWeek = date2.getDay();
      const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
      switch (token) {
        case "i":
          return String(isoDayOfWeek);
        case "ii":
          return addLeadingZeros(isoDayOfWeek, token.length);
        case "io":
          return localize2.ordinalNumber(isoDayOfWeek, { unit: "day" });
        case "iii":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        case "iiiii":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        case "iiiiii":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        case "iiii":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    a: function(date2, token, localize2) {
      const hours = date2.getHours();
      const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
      switch (token) {
        case "a":
        case "aa":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "aaa":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "aaaaa":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    b: function(date2, token, localize2) {
      const hours = date2.getHours();
      let dayPeriodEnumValue;
      if (hours === 12) {
        dayPeriodEnumValue = dayPeriodEnum.noon;
      } else if (hours === 0) {
        dayPeriodEnumValue = dayPeriodEnum.midnight;
      } else {
        dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
      }
      switch (token) {
        case "b":
        case "bb":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "bbb":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "bbbbb":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    B: function(date2, token, localize2) {
      const hours = date2.getHours();
      let dayPeriodEnumValue;
      if (hours >= 17) {
        dayPeriodEnumValue = dayPeriodEnum.evening;
      } else if (hours >= 12) {
        dayPeriodEnumValue = dayPeriodEnum.afternoon;
      } else if (hours >= 4) {
        dayPeriodEnumValue = dayPeriodEnum.morning;
      } else {
        dayPeriodEnumValue = dayPeriodEnum.night;
      }
      switch (token) {
        case "B":
        case "BB":
        case "BBB":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "BBBBB":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    h: function(date2, token, localize2) {
      if (token === "ho") {
        let hours = date2.getHours() % 12;
        if (hours === 0)
          hours = 12;
        return localize2.ordinalNumber(hours, { unit: "hour" });
      }
      return lightFormatters.h(date2, token);
    },
    H: function(date2, token, localize2) {
      if (token === "Ho") {
        return localize2.ordinalNumber(date2.getHours(), { unit: "hour" });
      }
      return lightFormatters.H(date2, token);
    },
    K: function(date2, token, localize2) {
      const hours = date2.getHours() % 12;
      if (token === "Ko") {
        return localize2.ordinalNumber(hours, { unit: "hour" });
      }
      return addLeadingZeros(hours, token.length);
    },
    k: function(date2, token, localize2) {
      let hours = date2.getHours();
      if (hours === 0)
        hours = 24;
      if (token === "ko") {
        return localize2.ordinalNumber(hours, { unit: "hour" });
      }
      return addLeadingZeros(hours, token.length);
    },
    m: function(date2, token, localize2) {
      if (token === "mo") {
        return localize2.ordinalNumber(date2.getMinutes(), { unit: "minute" });
      }
      return lightFormatters.m(date2, token);
    },
    s: function(date2, token, localize2) {
      if (token === "so") {
        return localize2.ordinalNumber(date2.getSeconds(), { unit: "second" });
      }
      return lightFormatters.s(date2, token);
    },
    S: function(date2, token) {
      return lightFormatters.S(date2, token);
    },
    X: function(date2, token, _localize) {
      const timezoneOffset = date2.getTimezoneOffset();
      if (timezoneOffset === 0) {
        return "Z";
      }
      switch (token) {
        case "X":
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        case "XXXX":
        case "XX":
          return formatTimezone(timezoneOffset);
        case "XXXXX":
        case "XXX":
        default:
          return formatTimezone(timezoneOffset, ":");
      }
    },
    x: function(date2, token, _localize) {
      const timezoneOffset = date2.getTimezoneOffset();
      switch (token) {
        case "x":
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        case "xxxx":
        case "xx":
          return formatTimezone(timezoneOffset);
        case "xxxxx":
        case "xxx":
        default:
          return formatTimezone(timezoneOffset, ":");
      }
    },
    O: function(date2, token, _localize) {
      const timezoneOffset = date2.getTimezoneOffset();
      switch (token) {
        case "O":
        case "OO":
        case "OOO":
          return "GMT" + formatTimezoneShort(timezoneOffset, ":");
        case "OOOO":
        default:
          return "GMT" + formatTimezone(timezoneOffset, ":");
      }
    },
    z: function(date2, token, _localize) {
      const timezoneOffset = date2.getTimezoneOffset();
      switch (token) {
        case "z":
        case "zz":
        case "zzz":
          return "GMT" + formatTimezoneShort(timezoneOffset, ":");
        case "zzzz":
        default:
          return "GMT" + formatTimezone(timezoneOffset, ":");
      }
    },
    t: function(date2, token, _localize) {
      const timestamp2 = Math.trunc(+date2 / 1e3);
      return addLeadingZeros(timestamp2, token.length);
    },
    T: function(date2, token, _localize) {
      return addLeadingZeros(+date2, token.length);
    }
  };
  function formatTimezoneShort(offset, delimiter = "") {
    const sign = offset > 0 ? "-" : "+";
    const absOffset = Math.abs(offset);
    const hours = Math.trunc(absOffset / 60);
    const minutes = absOffset % 60;
    if (minutes === 0) {
      return sign + String(hours);
    }
    return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
  }
  function formatTimezoneWithOptionalMinutes(offset, delimiter) {
    if (offset % 60 === 0) {
      const sign = offset > 0 ? "-" : "+";
      return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
    }
    return formatTimezone(offset, delimiter);
  }
  function formatTimezone(offset, delimiter = "") {
    const sign = offset > 0 ? "-" : "+";
    const absOffset = Math.abs(offset);
    const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2);
    const minutes = addLeadingZeros(absOffset % 60, 2);
    return sign + hours + delimiter + minutes;
  }

  // ../posawesome/node_modules/date-fns/_lib/format/longFormatters.js
  var dateLongFormatter = (pattern, formatLong2) => {
    switch (pattern) {
      case "P":
        return formatLong2.date({ width: "short" });
      case "PP":
        return formatLong2.date({ width: "medium" });
      case "PPP":
        return formatLong2.date({ width: "long" });
      case "PPPP":
      default:
        return formatLong2.date({ width: "full" });
    }
  };
  var timeLongFormatter = (pattern, formatLong2) => {
    switch (pattern) {
      case "p":
        return formatLong2.time({ width: "short" });
      case "pp":
        return formatLong2.time({ width: "medium" });
      case "ppp":
        return formatLong2.time({ width: "long" });
      case "pppp":
      default:
        return formatLong2.time({ width: "full" });
    }
  };
  var dateTimeLongFormatter = (pattern, formatLong2) => {
    const matchResult = pattern.match(/(P+)(p+)?/) || [];
    const datePattern = matchResult[1];
    const timePattern = matchResult[2];
    if (!timePattern) {
      return dateLongFormatter(pattern, formatLong2);
    }
    let dateTimeFormat;
    switch (datePattern) {
      case "P":
        dateTimeFormat = formatLong2.dateTime({ width: "short" });
        break;
      case "PP":
        dateTimeFormat = formatLong2.dateTime({ width: "medium" });
        break;
      case "PPP":
        dateTimeFormat = formatLong2.dateTime({ width: "long" });
        break;
      case "PPPP":
      default:
        dateTimeFormat = formatLong2.dateTime({ width: "full" });
        break;
    }
    return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
  };
  var longFormatters = {
    p: timeLongFormatter,
    P: dateTimeLongFormatter
  };

  // ../posawesome/node_modules/date-fns/_lib/protectedTokens.js
  var dayOfYearTokenRE = /^D+$/;
  var weekYearTokenRE = /^Y+$/;
  var throwTokens = ["D", "DD", "YY", "YYYY"];
  function isProtectedDayOfYearToken(token) {
    return dayOfYearTokenRE.test(token);
  }
  function isProtectedWeekYearToken(token) {
    return weekYearTokenRE.test(token);
  }
  function warnOrThrowProtectedError(token, format3, input) {
    const _message = message(token, format3, input);
    console.warn(_message);
    if (throwTokens.includes(token))
      throw new RangeError(_message);
  }
  function message(token, format3, input) {
    const subject = token[0] === "Y" ? "years" : "days of the month";
    return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format3}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
  }

  // ../posawesome/node_modules/date-fns/format.js
  var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
  var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
  var escapedStringRegExp = /^'([^]*?)'?$/;
  var doubleQuoteRegExp = /''/g;
  var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
  function format2(date2, formatStr, options) {
    var _a3, _b, _c, _d, _e, _f, _g, _h, _i2, _j, _k, _l2, _m, _n2, _o2, _p, _q, _r3;
    const defaultOptions2 = getDefaultOptions();
    const locale = (_b = (_a3 = options == null ? void 0 : options.locale) != null ? _a3 : defaultOptions2.locale) != null ? _b : enUS;
    const firstWeekContainsDate = (_j = (_i2 = (_f = (_e = options == null ? void 0 : options.firstWeekContainsDate) != null ? _e : (_d = (_c = options == null ? void 0 : options.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) != null ? _f : defaultOptions2.firstWeekContainsDate) != null ? _i2 : (_h = (_g = defaultOptions2.locale) == null ? void 0 : _g.options) == null ? void 0 : _h.firstWeekContainsDate) != null ? _j : 1;
    const weekStartsOn = (_r3 = (_q = (_n2 = (_m = options == null ? void 0 : options.weekStartsOn) != null ? _m : (_l2 = (_k = options == null ? void 0 : options.locale) == null ? void 0 : _k.options) == null ? void 0 : _l2.weekStartsOn) != null ? _n2 : defaultOptions2.weekStartsOn) != null ? _q : (_p = (_o2 = defaultOptions2.locale) == null ? void 0 : _o2.options) == null ? void 0 : _p.weekStartsOn) != null ? _r3 : 0;
    const originalDate = toDate(date2, options == null ? void 0 : options.in);
    if (!isValid2(originalDate)) {
      throw new RangeError("Invalid time value");
    }
    let parts = formatStr.match(longFormattingTokensRegExp).map((substring) => {
      const firstCharacter = substring[0];
      if (firstCharacter === "p" || firstCharacter === "P") {
        const longFormatter = longFormatters[firstCharacter];
        return longFormatter(substring, locale.formatLong);
      }
      return substring;
    }).join("").match(formattingTokensRegExp).map((substring) => {
      if (substring === "''") {
        return { isToken: false, value: "'" };
      }
      const firstCharacter = substring[0];
      if (firstCharacter === "'") {
        return { isToken: false, value: cleanEscapedString(substring) };
      }
      if (formatters[firstCharacter]) {
        return { isToken: true, value: substring };
      }
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
        );
      }
      return { isToken: false, value: substring };
    });
    if (locale.localize.preprocessor) {
      parts = locale.localize.preprocessor(originalDate, parts);
    }
    const formatterOptions = {
      firstWeekContainsDate,
      weekStartsOn,
      locale
    };
    return parts.map((part) => {
      if (!part.isToken)
        return part.value;
      const token = part.value;
      if (!(options == null ? void 0 : options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token) || !(options == null ? void 0 : options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
        warnOrThrowProtectedError(token, formatStr, String(date2));
      }
      const formatter = formatters[token[0]];
      return formatter(originalDate, token, locale.localize, formatterOptions);
    }).join("");
  }
  function cleanEscapedString(input) {
    const matched = input.match(escapedStringRegExp);
    if (!matched) {
      return input;
    }
    return matched[1].replace(doubleQuoteRegExp, "'");
  }

  // ../posawesome/node_modules/date-fns/getDay.js
  function getDay(date2, options) {
    return toDate(date2, options == null ? void 0 : options.in).getDay();
  }

  // ../posawesome/node_modules/date-fns/getDaysInMonth.js
  function getDaysInMonth(date2, options) {
    const _date = toDate(date2, options == null ? void 0 : options.in);
    const year = _date.getFullYear();
    const monthIndex = _date.getMonth();
    const lastDayOfMonth = constructFrom(_date, 0);
    lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
    lastDayOfMonth.setHours(0, 0, 0, 0);
    return lastDayOfMonth.getDate();
  }

  // ../posawesome/node_modules/date-fns/getDefaultOptions.js
  function getDefaultOptions2() {
    return Object.assign({}, getDefaultOptions());
  }

  // ../posawesome/node_modules/date-fns/getHours.js
  function getHours2(date2, options) {
    return toDate(date2, options == null ? void 0 : options.in).getHours();
  }

  // ../posawesome/node_modules/date-fns/getISODay.js
  function getISODay(date2, options) {
    const day = toDate(date2, options == null ? void 0 : options.in).getDay();
    return day === 0 ? 7 : day;
  }

  // ../posawesome/node_modules/date-fns/getMinutes.js
  function getMinutes2(date2, options) {
    return toDate(date2, options == null ? void 0 : options.in).getMinutes();
  }

  // ../posawesome/node_modules/date-fns/getMonth.js
  function getMonth2(date2, options) {
    return toDate(date2, options == null ? void 0 : options.in).getMonth();
  }

  // ../posawesome/node_modules/date-fns/getSeconds.js
  function getSeconds(date2) {
    return toDate(date2).getSeconds();
  }

  // ../posawesome/node_modules/date-fns/getYear.js
  function getYear2(date2, options) {
    return toDate(date2, options == null ? void 0 : options.in).getFullYear();
  }

  // ../posawesome/node_modules/date-fns/isAfter.js
  function isAfter2(date2, dateToCompare) {
    return +toDate(date2) > +toDate(dateToCompare);
  }

  // ../posawesome/node_modules/date-fns/isBefore.js
  function isBefore2(date2, dateToCompare) {
    return +toDate(date2) < +toDate(dateToCompare);
  }

  // ../posawesome/node_modules/date-fns/isEqual.js
  function isEqual2(leftDate, rightDate) {
    return +toDate(leftDate) === +toDate(rightDate);
  }

  // ../posawesome/node_modules/date-fns/transpose.js
  function transpose(date2, constructor) {
    const date_ = isConstructor(constructor) ? new constructor(0) : constructFrom(constructor, 0);
    date_.setFullYear(date2.getFullYear(), date2.getMonth(), date2.getDate());
    date_.setHours(
      date2.getHours(),
      date2.getMinutes(),
      date2.getSeconds(),
      date2.getMilliseconds()
    );
    return date_;
  }
  function isConstructor(constructor) {
    var _a3;
    return typeof constructor === "function" && ((_a3 = constructor.prototype) == null ? void 0 : _a3.constructor) === constructor;
  }

  // ../posawesome/node_modules/date-fns/parse/_lib/Setter.js
  var TIMEZONE_UNIT_PRIORITY = 10;
  var Setter = class {
    constructor() {
      __publicField(this, "subPriority", 0);
    }
    validate(_utcDate, _options) {
      return true;
    }
  };
  var ValueSetter = class extends Setter {
    constructor(value, validateValue, setValue, priority, subPriority) {
      super();
      this.value = value;
      this.validateValue = validateValue;
      this.setValue = setValue;
      this.priority = priority;
      if (subPriority) {
        this.subPriority = subPriority;
      }
    }
    validate(date2, options) {
      return this.validateValue(date2, this.value, options);
    }
    set(date2, flags, options) {
      return this.setValue(date2, flags, this.value, options);
    }
  };
  var DateTimezoneSetter = class extends Setter {
    constructor(context, reference) {
      super();
      __publicField(this, "priority", TIMEZONE_UNIT_PRIORITY);
      __publicField(this, "subPriority", -1);
      this.context = context || ((date2) => constructFrom(reference, date2));
    }
    set(date2, flags) {
      if (flags.timestampIsSet)
        return date2;
      return constructFrom(date2, transpose(date2, this.context));
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/Parser.js
  var Parser = class {
    run(dateString, token, match2, options) {
      const result = this.parse(dateString, token, match2, options);
      if (!result) {
        return null;
      }
      return {
        setter: new ValueSetter(
          result.value,
          this.validate,
          this.set,
          this.priority,
          this.subPriority
        ),
        rest: result.rest
      };
    }
    validate(_utcDate, _value, _options) {
      return true;
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/EraParser.js
  var EraParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 140);
      __publicField(this, "incompatibleTokens", ["R", "u", "t", "T"]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "G":
        case "GG":
        case "GGG":
          return match2.era(dateString, { width: "abbreviated" }) || match2.era(dateString, { width: "narrow" });
        case "GGGGG":
          return match2.era(dateString, { width: "narrow" });
        case "GGGG":
        default:
          return match2.era(dateString, { width: "wide" }) || match2.era(dateString, { width: "abbreviated" }) || match2.era(dateString, { width: "narrow" });
      }
    }
    set(date2, flags, value) {
      flags.era = value;
      date2.setFullYear(value, 0, 1);
      date2.setHours(0, 0, 0, 0);
      return date2;
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/constants.js
  var numericPatterns = {
    month: /^(1[0-2]|0?\d)/,
    date: /^(3[0-1]|[0-2]?\d)/,
    dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
    week: /^(5[0-3]|[0-4]?\d)/,
    hour23h: /^(2[0-3]|[0-1]?\d)/,
    hour24h: /^(2[0-4]|[0-1]?\d)/,
    hour11h: /^(1[0-1]|0?\d)/,
    hour12h: /^(1[0-2]|0?\d)/,
    minute: /^[0-5]?\d/,
    second: /^[0-5]?\d/,
    singleDigit: /^\d/,
    twoDigits: /^\d{1,2}/,
    threeDigits: /^\d{1,3}/,
    fourDigits: /^\d{1,4}/,
    anyDigitsSigned: /^-?\d+/,
    singleDigitSigned: /^-?\d/,
    twoDigitsSigned: /^-?\d{1,2}/,
    threeDigitsSigned: /^-?\d{1,3}/,
    fourDigitsSigned: /^-?\d{1,4}/
  };
  var timezonePatterns = {
    basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
    basic: /^([+-])(\d{2})(\d{2})|Z/,
    basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
    extended: /^([+-])(\d{2}):(\d{2})|Z/,
    extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/utils.js
  function mapValue(parseFnResult, mapFn) {
    if (!parseFnResult) {
      return parseFnResult;
    }
    return {
      value: mapFn(parseFnResult.value),
      rest: parseFnResult.rest
    };
  }
  function parseNumericPattern(pattern, dateString) {
    const matchResult = dateString.match(pattern);
    if (!matchResult) {
      return null;
    }
    return {
      value: parseInt(matchResult[0], 10),
      rest: dateString.slice(matchResult[0].length)
    };
  }
  function parseTimezonePattern(pattern, dateString) {
    const matchResult = dateString.match(pattern);
    if (!matchResult) {
      return null;
    }
    if (matchResult[0] === "Z") {
      return {
        value: 0,
        rest: dateString.slice(1)
      };
    }
    const sign = matchResult[1] === "+" ? 1 : -1;
    const hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
    const minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
    const seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
    return {
      value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
      rest: dateString.slice(matchResult[0].length)
    };
  }
  function parseAnyDigitsSigned(dateString) {
    return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
  }
  function parseNDigits(n, dateString) {
    switch (n) {
      case 1:
        return parseNumericPattern(numericPatterns.singleDigit, dateString);
      case 2:
        return parseNumericPattern(numericPatterns.twoDigits, dateString);
      case 3:
        return parseNumericPattern(numericPatterns.threeDigits, dateString);
      case 4:
        return parseNumericPattern(numericPatterns.fourDigits, dateString);
      default:
        return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
    }
  }
  function parseNDigitsSigned(n, dateString) {
    switch (n) {
      case 1:
        return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
      case 2:
        return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
      case 3:
        return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
      case 4:
        return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
      default:
        return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
    }
  }
  function dayPeriodEnumToHours(dayPeriod) {
    switch (dayPeriod) {
      case "morning":
        return 4;
      case "evening":
        return 17;
      case "pm":
      case "noon":
      case "afternoon":
        return 12;
      case "am":
      case "midnight":
      case "night":
      default:
        return 0;
    }
  }
  function normalizeTwoDigitYear(twoDigitYear, currentYear) {
    const isCommonEra = currentYear > 0;
    const absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
    let result;
    if (absCurrentYear <= 50) {
      result = twoDigitYear || 100;
    } else {
      const rangeEnd = absCurrentYear + 50;
      const rangeEndCentury = Math.trunc(rangeEnd / 100) * 100;
      const isPreviousCentury = twoDigitYear >= rangeEnd % 100;
      result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
    }
    return isCommonEra ? result : 1 - result;
  }
  function isLeapYearIndex(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
  }

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/YearParser.js
  var YearParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 130);
      __publicField(this, "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
    }
    parse(dateString, token, match2) {
      const valueCallback = (year) => ({
        year,
        isTwoDigitYear: token === "yy"
      });
      switch (token) {
        case "y":
          return mapValue(parseNDigits(4, dateString), valueCallback);
        case "yo":
          return mapValue(
            match2.ordinalNumber(dateString, {
              unit: "year"
            }),
            valueCallback
          );
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
      }
    }
    validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
    set(date2, flags, value) {
      const currentYear = date2.getFullYear();
      if (value.isTwoDigitYear) {
        const normalizedTwoDigitYear = normalizeTwoDigitYear(
          value.year,
          currentYear
        );
        date2.setFullYear(normalizedTwoDigitYear, 0, 1);
        date2.setHours(0, 0, 0, 0);
        return date2;
      }
      const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date2.setFullYear(year, 0, 1);
      date2.setHours(0, 0, 0, 0);
      return date2;
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/LocalWeekYearParser.js
  var LocalWeekYearParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 130);
      __publicField(this, "incompatibleTokens", [
        "y",
        "R",
        "u",
        "Q",
        "q",
        "M",
        "L",
        "I",
        "d",
        "D",
        "i",
        "t",
        "T"
      ]);
    }
    parse(dateString, token, match2) {
      const valueCallback = (year) => ({
        year,
        isTwoDigitYear: token === "YY"
      });
      switch (token) {
        case "Y":
          return mapValue(parseNDigits(4, dateString), valueCallback);
        case "Yo":
          return mapValue(
            match2.ordinalNumber(dateString, {
              unit: "year"
            }),
            valueCallback
          );
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
      }
    }
    validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
    set(date2, flags, value, options) {
      const currentYear = getWeekYear(date2, options);
      if (value.isTwoDigitYear) {
        const normalizedTwoDigitYear = normalizeTwoDigitYear(
          value.year,
          currentYear
        );
        date2.setFullYear(
          normalizedTwoDigitYear,
          0,
          options.firstWeekContainsDate
        );
        date2.setHours(0, 0, 0, 0);
        return startOfWeek2(date2, options);
      }
      const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date2.setFullYear(year, 0, options.firstWeekContainsDate);
      date2.setHours(0, 0, 0, 0);
      return startOfWeek2(date2, options);
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/ISOWeekYearParser.js
  var ISOWeekYearParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 130);
      __publicField(this, "incompatibleTokens", [
        "G",
        "y",
        "Y",
        "u",
        "Q",
        "q",
        "M",
        "L",
        "w",
        "d",
        "D",
        "e",
        "c",
        "t",
        "T"
      ]);
    }
    parse(dateString, token) {
      if (token === "R") {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token.length, dateString);
    }
    set(date2, _flags, value) {
      const firstWeekOfYear = constructFrom(date2, 0);
      firstWeekOfYear.setFullYear(value, 0, 4);
      firstWeekOfYear.setHours(0, 0, 0, 0);
      return startOfISOWeek(firstWeekOfYear);
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/ExtendedYearParser.js
  var ExtendedYearParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 130);
      __publicField(this, "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
    }
    parse(dateString, token) {
      if (token === "u") {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token.length, dateString);
    }
    set(date2, _flags, value) {
      date2.setFullYear(value, 0, 1);
      date2.setHours(0, 0, 0, 0);
      return date2;
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/QuarterParser.js
  var QuarterParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 120);
      __publicField(this, "incompatibleTokens", [
        "Y",
        "R",
        "q",
        "M",
        "L",
        "w",
        "I",
        "d",
        "D",
        "i",
        "e",
        "c",
        "t",
        "T"
      ]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "Q":
        case "QQ":
          return parseNDigits(token.length, dateString);
        case "Qo":
          return match2.ordinalNumber(dateString, { unit: "quarter" });
        case "QQQ":
          return match2.quarter(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQQ":
          return match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return match2.quarter(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
    validate(_date, value) {
      return value >= 1 && value <= 4;
    }
    set(date2, _flags, value) {
      date2.setMonth((value - 1) * 3, 1);
      date2.setHours(0, 0, 0, 0);
      return date2;
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/StandAloneQuarterParser.js
  var StandAloneQuarterParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 120);
      __publicField(this, "incompatibleTokens", [
        "Y",
        "R",
        "Q",
        "M",
        "L",
        "w",
        "I",
        "d",
        "D",
        "i",
        "e",
        "c",
        "t",
        "T"
      ]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "q":
        case "qq":
          return parseNDigits(token.length, dateString);
        case "qo":
          return match2.ordinalNumber(dateString, { unit: "quarter" });
        case "qqq":
          return match2.quarter(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqqq":
          return match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return match2.quarter(dateString, {
            width: "wide",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
    validate(_date, value) {
      return value >= 1 && value <= 4;
    }
    set(date2, _flags, value) {
      date2.setMonth((value - 1) * 3, 1);
      date2.setHours(0, 0, 0, 0);
      return date2;
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/MonthParser.js
  var MonthParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "incompatibleTokens", [
        "Y",
        "R",
        "q",
        "Q",
        "L",
        "w",
        "I",
        "D",
        "i",
        "e",
        "c",
        "t",
        "T"
      ]);
      __publicField(this, "priority", 110);
    }
    parse(dateString, token, match2) {
      const valueCallback = (value) => value - 1;
      switch (token) {
        case "M":
          return mapValue(
            parseNumericPattern(numericPatterns.month, dateString),
            valueCallback
          );
        case "MM":
          return mapValue(parseNDigits(2, dateString), valueCallback);
        case "Mo":
          return mapValue(
            match2.ordinalNumber(dateString, {
              unit: "month"
            }),
            valueCallback
          );
        case "MMM":
          return match2.month(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.month(dateString, { width: "narrow", context: "formatting" });
        case "MMMMM":
          return match2.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return match2.month(dateString, { width: "wide", context: "formatting" }) || match2.month(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.month(dateString, { width: "narrow", context: "formatting" });
      }
    }
    validate(_date, value) {
      return value >= 0 && value <= 11;
    }
    set(date2, _flags, value) {
      date2.setMonth(value, 1);
      date2.setHours(0, 0, 0, 0);
      return date2;
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/StandAloneMonthParser.js
  var StandAloneMonthParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 110);
      __publicField(this, "incompatibleTokens", [
        "Y",
        "R",
        "q",
        "Q",
        "M",
        "w",
        "I",
        "D",
        "i",
        "e",
        "c",
        "t",
        "T"
      ]);
    }
    parse(dateString, token, match2) {
      const valueCallback = (value) => value - 1;
      switch (token) {
        case "L":
          return mapValue(
            parseNumericPattern(numericPatterns.month, dateString),
            valueCallback
          );
        case "LL":
          return mapValue(parseNDigits(2, dateString), valueCallback);
        case "Lo":
          return mapValue(
            match2.ordinalNumber(dateString, {
              unit: "month"
            }),
            valueCallback
          );
        case "LLL":
          return match2.month(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.month(dateString, { width: "narrow", context: "standalone" });
        case "LLLLL":
          return match2.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return match2.month(dateString, { width: "wide", context: "standalone" }) || match2.month(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.month(dateString, { width: "narrow", context: "standalone" });
      }
    }
    validate(_date, value) {
      return value >= 0 && value <= 11;
    }
    set(date2, _flags, value) {
      date2.setMonth(value, 1);
      date2.setHours(0, 0, 0, 0);
      return date2;
    }
  };

  // ../posawesome/node_modules/date-fns/setWeek.js
  function setWeek(date2, week, options) {
    const date_ = toDate(date2, options == null ? void 0 : options.in);
    const diff = getWeek2(date_, options) - week;
    date_.setDate(date_.getDate() - diff * 7);
    return toDate(date_, options == null ? void 0 : options.in);
  }

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/LocalWeekParser.js
  var LocalWeekParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 100);
      __publicField(this, "incompatibleTokens", [
        "y",
        "R",
        "u",
        "q",
        "Q",
        "M",
        "L",
        "I",
        "d",
        "D",
        "i",
        "t",
        "T"
      ]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "w":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "wo":
          return match2.ordinalNumber(dateString, { unit: "week" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
    validate(_date, value) {
      return value >= 1 && value <= 53;
    }
    set(date2, _flags, value, options) {
      return startOfWeek2(setWeek(date2, value, options), options);
    }
  };

  // ../posawesome/node_modules/date-fns/setISOWeek.js
  function setISOWeek(date2, week, options) {
    const _date = toDate(date2, options == null ? void 0 : options.in);
    const diff = getISOWeek(_date, options) - week;
    _date.setDate(_date.getDate() - diff * 7);
    return _date;
  }

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/ISOWeekParser.js
  var ISOWeekParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 100);
      __publicField(this, "incompatibleTokens", [
        "y",
        "Y",
        "u",
        "q",
        "Q",
        "M",
        "L",
        "w",
        "d",
        "D",
        "e",
        "c",
        "t",
        "T"
      ]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "I":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "Io":
          return match2.ordinalNumber(dateString, { unit: "week" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
    validate(_date, value) {
      return value >= 1 && value <= 53;
    }
    set(date2, _flags, value) {
      return startOfISOWeek(setISOWeek(date2, value));
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/DateParser.js
  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var DAYS_IN_MONTH_LEAP_YEAR = [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ];
  var DateParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 90);
      __publicField(this, "subPriority", 1);
      __publicField(this, "incompatibleTokens", [
        "Y",
        "R",
        "q",
        "Q",
        "w",
        "I",
        "D",
        "i",
        "e",
        "c",
        "t",
        "T"
      ]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "d":
          return parseNumericPattern(numericPatterns.date, dateString);
        case "do":
          return match2.ordinalNumber(dateString, { unit: "date" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
    validate(date2, value) {
      const year = date2.getFullYear();
      const isLeapYear = isLeapYearIndex(year);
      const month = date2.getMonth();
      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    }
    set(date2, _flags, value) {
      date2.setDate(value);
      date2.setHours(0, 0, 0, 0);
      return date2;
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/DayOfYearParser.js
  var DayOfYearParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 90);
      __publicField(this, "subpriority", 1);
      __publicField(this, "incompatibleTokens", [
        "Y",
        "R",
        "q",
        "Q",
        "M",
        "L",
        "w",
        "I",
        "d",
        "E",
        "i",
        "e",
        "c",
        "t",
        "T"
      ]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "D":
        case "DD":
          return parseNumericPattern(numericPatterns.dayOfYear, dateString);
        case "Do":
          return match2.ordinalNumber(dateString, { unit: "date" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
    validate(date2, value) {
      const year = date2.getFullYear();
      const isLeapYear = isLeapYearIndex(year);
      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    }
    set(date2, _flags, value) {
      date2.setMonth(0, value);
      date2.setHours(0, 0, 0, 0);
      return date2;
    }
  };

  // ../posawesome/node_modules/date-fns/setDay.js
  function setDay(date2, day, options) {
    var _a3, _b, _c, _d, _e, _f, _g, _h;
    const defaultOptions2 = getDefaultOptions();
    const weekStartsOn = (_h = (_g = (_d = (_c = options == null ? void 0 : options.weekStartsOn) != null ? _c : (_b = (_a3 = options == null ? void 0 : options.locale) == null ? void 0 : _a3.options) == null ? void 0 : _b.weekStartsOn) != null ? _d : defaultOptions2.weekStartsOn) != null ? _g : (_f = (_e = defaultOptions2.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.weekStartsOn) != null ? _h : 0;
    const date_ = toDate(date2, options == null ? void 0 : options.in);
    const currentDay = date_.getDay();
    const remainder = day % 7;
    const dayIndex = (remainder + 7) % 7;
    const delta2 = 7 - weekStartsOn;
    const diff = day < 0 || day > 6 ? day - (currentDay + delta2) % 7 : (dayIndex + delta2) % 7 - (currentDay + delta2) % 7;
    return addDays2(date_, diff, options);
  }

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/DayParser.js
  var DayParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 90);
      __publicField(this, "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "E":
        case "EE":
        case "EEE":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
        case "EEEEE":
          return match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
        case "EEEE":
        default:
          return match2.day(dateString, { width: "wide", context: "formatting" }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      }
    }
    validate(_date, value) {
      return value >= 0 && value <= 6;
    }
    set(date2, _flags, value, options) {
      date2 = setDay(date2, value, options);
      date2.setHours(0, 0, 0, 0);
      return date2;
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/LocalDayParser.js
  var LocalDayParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 90);
      __publicField(this, "incompatibleTokens", [
        "y",
        "R",
        "u",
        "q",
        "Q",
        "M",
        "L",
        "I",
        "d",
        "D",
        "E",
        "i",
        "c",
        "t",
        "T"
      ]);
    }
    parse(dateString, token, match2, options) {
      const valueCallback = (value) => {
        const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        case "e":
        case "ee":
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
        case "eo":
          return mapValue(
            match2.ordinalNumber(dateString, {
              unit: "day"
            }),
            valueCallback
          );
        case "eee":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
        case "eeeee":
          return match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
        case "eeee":
        default:
          return match2.day(dateString, { width: "wide", context: "formatting" }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      }
    }
    validate(_date, value) {
      return value >= 0 && value <= 6;
    }
    set(date2, _flags, value, options) {
      date2 = setDay(date2, value, options);
      date2.setHours(0, 0, 0, 0);
      return date2;
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/StandAloneLocalDayParser.js
  var StandAloneLocalDayParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 90);
      __publicField(this, "incompatibleTokens", [
        "y",
        "R",
        "u",
        "q",
        "Q",
        "M",
        "L",
        "I",
        "d",
        "D",
        "E",
        "i",
        "e",
        "t",
        "T"
      ]);
    }
    parse(dateString, token, match2, options) {
      const valueCallback = (value) => {
        const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        case "c":
        case "cc":
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
        case "co":
          return mapValue(
            match2.ordinalNumber(dateString, {
              unit: "day"
            }),
            valueCallback
          );
        case "ccc":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
        case "ccccc":
          return match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
        case "cccc":
        default:
          return match2.day(dateString, { width: "wide", context: "standalone" }) || match2.day(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
      }
    }
    validate(_date, value) {
      return value >= 0 && value <= 6;
    }
    set(date2, _flags, value, options) {
      date2 = setDay(date2, value, options);
      date2.setHours(0, 0, 0, 0);
      return date2;
    }
  };

  // ../posawesome/node_modules/date-fns/setISODay.js
  function setISODay(date2, day, options) {
    const date_ = toDate(date2, options == null ? void 0 : options.in);
    const currentDay = getISODay(date_, options);
    const diff = day - currentDay;
    return addDays2(date_, diff, options);
  }

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/ISODayParser.js
  var ISODayParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 90);
      __publicField(this, "incompatibleTokens", [
        "y",
        "Y",
        "u",
        "q",
        "Q",
        "M",
        "L",
        "w",
        "d",
        "D",
        "E",
        "e",
        "c",
        "t",
        "T"
      ]);
    }
    parse(dateString, token, match2) {
      const valueCallback = (value) => {
        if (value === 0) {
          return 7;
        }
        return value;
      };
      switch (token) {
        case "i":
        case "ii":
          return parseNDigits(token.length, dateString);
        case "io":
          return match2.ordinalNumber(dateString, { unit: "day" });
        case "iii":
          return mapValue(
            match2.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            }),
            valueCallback
          );
        case "iiiii":
          return mapValue(
            match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            }),
            valueCallback
          );
        case "iiiiii":
          return mapValue(
            match2.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            }),
            valueCallback
          );
        case "iiii":
        default:
          return mapValue(
            match2.day(dateString, {
              width: "wide",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            }),
            valueCallback
          );
      }
    }
    validate(_date, value) {
      return value >= 1 && value <= 7;
    }
    set(date2, _flags, value) {
      date2 = setISODay(date2, value);
      date2.setHours(0, 0, 0, 0);
      return date2;
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/AMPMParser.js
  var AMPMParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 80);
      __publicField(this, "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "a":
        case "aa":
        case "aaa":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaaa":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
    set(date2, _flags, value) {
      date2.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date2;
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/AMPMMidnightParser.js
  var AMPMMidnightParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 80);
      __publicField(this, "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "b":
        case "bb":
        case "bbb":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbbb":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
    set(date2, _flags, value) {
      date2.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date2;
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/DayPeriodParser.js
  var DayPeriodParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 80);
      __publicField(this, "incompatibleTokens", ["a", "b", "t", "T"]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "B":
        case "BB":
        case "BBB":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBBB":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
    set(date2, _flags, value) {
      date2.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date2;
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/Hour1to12Parser.js
  var Hour1to12Parser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 70);
      __publicField(this, "incompatibleTokens", ["H", "K", "k", "t", "T"]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "h":
          return parseNumericPattern(numericPatterns.hour12h, dateString);
        case "ho":
          return match2.ordinalNumber(dateString, { unit: "hour" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
    validate(_date, value) {
      return value >= 1 && value <= 12;
    }
    set(date2, _flags, value) {
      const isPM = date2.getHours() >= 12;
      if (isPM && value < 12) {
        date2.setHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date2.setHours(0, 0, 0, 0);
      } else {
        date2.setHours(value, 0, 0, 0);
      }
      return date2;
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/Hour0to23Parser.js
  var Hour0to23Parser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 70);
      __publicField(this, "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "H":
          return parseNumericPattern(numericPatterns.hour23h, dateString);
        case "Ho":
          return match2.ordinalNumber(dateString, { unit: "hour" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
    validate(_date, value) {
      return value >= 0 && value <= 23;
    }
    set(date2, _flags, value) {
      date2.setHours(value, 0, 0, 0);
      return date2;
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/Hour0To11Parser.js
  var Hour0To11Parser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 70);
      __publicField(this, "incompatibleTokens", ["h", "H", "k", "t", "T"]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "K":
          return parseNumericPattern(numericPatterns.hour11h, dateString);
        case "Ko":
          return match2.ordinalNumber(dateString, { unit: "hour" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
    validate(_date, value) {
      return value >= 0 && value <= 11;
    }
    set(date2, _flags, value) {
      const isPM = date2.getHours() >= 12;
      if (isPM && value < 12) {
        date2.setHours(value + 12, 0, 0, 0);
      } else {
        date2.setHours(value, 0, 0, 0);
      }
      return date2;
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/Hour1To24Parser.js
  var Hour1To24Parser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 70);
      __publicField(this, "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "k":
          return parseNumericPattern(numericPatterns.hour24h, dateString);
        case "ko":
          return match2.ordinalNumber(dateString, { unit: "hour" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
    validate(_date, value) {
      return value >= 1 && value <= 24;
    }
    set(date2, _flags, value) {
      const hours = value <= 24 ? value % 24 : value;
      date2.setHours(hours, 0, 0, 0);
      return date2;
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/MinuteParser.js
  var MinuteParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 60);
      __publicField(this, "incompatibleTokens", ["t", "T"]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "m":
          return parseNumericPattern(numericPatterns.minute, dateString);
        case "mo":
          return match2.ordinalNumber(dateString, { unit: "minute" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
    validate(_date, value) {
      return value >= 0 && value <= 59;
    }
    set(date2, _flags, value) {
      date2.setMinutes(value, 0, 0);
      return date2;
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/SecondParser.js
  var SecondParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 50);
      __publicField(this, "incompatibleTokens", ["t", "T"]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "s":
          return parseNumericPattern(numericPatterns.second, dateString);
        case "so":
          return match2.ordinalNumber(dateString, { unit: "second" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
    validate(_date, value) {
      return value >= 0 && value <= 59;
    }
    set(date2, _flags, value) {
      date2.setSeconds(value, 0);
      return date2;
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/FractionOfSecondParser.js
  var FractionOfSecondParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 30);
      __publicField(this, "incompatibleTokens", ["t", "T"]);
    }
    parse(dateString, token) {
      const valueCallback = (value) => Math.trunc(value * Math.pow(10, -token.length + 3));
      return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
    set(date2, _flags, value) {
      date2.setMilliseconds(value);
      return date2;
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/ISOTimezoneWithZParser.js
  var ISOTimezoneWithZParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 10);
      __publicField(this, "incompatibleTokens", ["t", "T", "x"]);
    }
    parse(dateString, token) {
      switch (token) {
        case "X":
          return parseTimezonePattern(
            timezonePatterns.basicOptionalMinutes,
            dateString
          );
        case "XX":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "XXXX":
          return parseTimezonePattern(
            timezonePatterns.basicOptionalSeconds,
            dateString
          );
        case "XXXXX":
          return parseTimezonePattern(
            timezonePatterns.extendedOptionalSeconds,
            dateString
          );
        case "XXX":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
    set(date2, flags, value) {
      if (flags.timestampIsSet)
        return date2;
      return constructFrom(
        date2,
        date2.getTime() - getTimezoneOffsetInMilliseconds(date2) - value
      );
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/ISOTimezoneParser.js
  var ISOTimezoneParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 10);
      __publicField(this, "incompatibleTokens", ["t", "T", "X"]);
    }
    parse(dateString, token) {
      switch (token) {
        case "x":
          return parseTimezonePattern(
            timezonePatterns.basicOptionalMinutes,
            dateString
          );
        case "xx":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "xxxx":
          return parseTimezonePattern(
            timezonePatterns.basicOptionalSeconds,
            dateString
          );
        case "xxxxx":
          return parseTimezonePattern(
            timezonePatterns.extendedOptionalSeconds,
            dateString
          );
        case "xxx":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
    set(date2, flags, value) {
      if (flags.timestampIsSet)
        return date2;
      return constructFrom(
        date2,
        date2.getTime() - getTimezoneOffsetInMilliseconds(date2) - value
      );
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/TimestampSecondsParser.js
  var TimestampSecondsParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 40);
      __publicField(this, "incompatibleTokens", "*");
    }
    parse(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
    set(date2, _flags, value) {
      return [constructFrom(date2, value * 1e3), { timestampIsSet: true }];
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers/TimestampMillisecondsParser.js
  var TimestampMillisecondsParser = class extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 20);
      __publicField(this, "incompatibleTokens", "*");
    }
    parse(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
    set(date2, _flags, value) {
      return [constructFrom(date2, value), { timestampIsSet: true }];
    }
  };

  // ../posawesome/node_modules/date-fns/parse/_lib/parsers.js
  var parsers = {
    G: new EraParser(),
    y: new YearParser(),
    Y: new LocalWeekYearParser(),
    R: new ISOWeekYearParser(),
    u: new ExtendedYearParser(),
    Q: new QuarterParser(),
    q: new StandAloneQuarterParser(),
    M: new MonthParser(),
    L: new StandAloneMonthParser(),
    w: new LocalWeekParser(),
    I: new ISOWeekParser(),
    d: new DateParser(),
    D: new DayOfYearParser(),
    E: new DayParser(),
    e: new LocalDayParser(),
    c: new StandAloneLocalDayParser(),
    i: new ISODayParser(),
    a: new AMPMParser(),
    b: new AMPMMidnightParser(),
    B: new DayPeriodParser(),
    h: new Hour1to12Parser(),
    H: new Hour0to23Parser(),
    K: new Hour0To11Parser(),
    k: new Hour1To24Parser(),
    m: new MinuteParser(),
    s: new SecondParser(),
    S: new FractionOfSecondParser(),
    X: new ISOTimezoneWithZParser(),
    x: new ISOTimezoneParser(),
    t: new TimestampSecondsParser(),
    T: new TimestampMillisecondsParser()
  };

  // ../posawesome/node_modules/date-fns/parse.js
  var formattingTokensRegExp2 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
  var longFormattingTokensRegExp2 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
  var escapedStringRegExp2 = /^'([^]*?)'?$/;
  var doubleQuoteRegExp2 = /''/g;
  var notWhitespaceRegExp = /\S/;
  var unescapedLatinCharacterRegExp2 = /[a-zA-Z]/;
  function parse(dateStr, formatStr, referenceDate, options) {
    var _a3, _b, _c, _d, _e, _f, _g, _h, _i2, _j, _k, _l2, _m, _n2, _o2, _p, _q, _r3;
    const invalidDate = () => constructFrom((options == null ? void 0 : options.in) || referenceDate, NaN);
    const defaultOptions2 = getDefaultOptions2();
    const locale = (_b = (_a3 = options == null ? void 0 : options.locale) != null ? _a3 : defaultOptions2.locale) != null ? _b : enUS;
    const firstWeekContainsDate = (_j = (_i2 = (_f = (_e = options == null ? void 0 : options.firstWeekContainsDate) != null ? _e : (_d = (_c = options == null ? void 0 : options.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) != null ? _f : defaultOptions2.firstWeekContainsDate) != null ? _i2 : (_h = (_g = defaultOptions2.locale) == null ? void 0 : _g.options) == null ? void 0 : _h.firstWeekContainsDate) != null ? _j : 1;
    const weekStartsOn = (_r3 = (_q = (_n2 = (_m = options == null ? void 0 : options.weekStartsOn) != null ? _m : (_l2 = (_k = options == null ? void 0 : options.locale) == null ? void 0 : _k.options) == null ? void 0 : _l2.weekStartsOn) != null ? _n2 : defaultOptions2.weekStartsOn) != null ? _q : (_p = (_o2 = defaultOptions2.locale) == null ? void 0 : _o2.options) == null ? void 0 : _p.weekStartsOn) != null ? _r3 : 0;
    if (!formatStr)
      return dateStr ? invalidDate() : toDate(referenceDate, options == null ? void 0 : options.in);
    const subFnOptions = {
      firstWeekContainsDate,
      weekStartsOn,
      locale
    };
    const setters = [new DateTimezoneSetter(options == null ? void 0 : options.in, referenceDate)];
    const tokens = formatStr.match(longFormattingTokensRegExp2).map((substring) => {
      const firstCharacter = substring[0];
      if (firstCharacter in longFormatters) {
        const longFormatter = longFormatters[firstCharacter];
        return longFormatter(substring, locale.formatLong);
      }
      return substring;
    }).join("").match(formattingTokensRegExp2);
    const usedTokens = [];
    for (let token of tokens) {
      if (!(options == null ? void 0 : options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token)) {
        warnOrThrowProtectedError(token, formatStr, dateStr);
      }
      if (!(options == null ? void 0 : options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
        warnOrThrowProtectedError(token, formatStr, dateStr);
      }
      const firstCharacter = token[0];
      const parser = parsers[firstCharacter];
      if (parser) {
        const { incompatibleTokens } = parser;
        if (Array.isArray(incompatibleTokens)) {
          const incompatibleToken = usedTokens.find(
            (usedToken) => incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter
          );
          if (incompatibleToken) {
            throw new RangeError(
              `The format string mustn't contain \`${incompatibleToken.fullToken}\` and \`${token}\` at the same time`
            );
          }
        } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
          throw new RangeError(
            `The format string mustn't contain \`${token}\` and any other token at the same time`
          );
        }
        usedTokens.push({ token: firstCharacter, fullToken: token });
        const parseResult = parser.run(
          dateStr,
          token,
          locale.match,
          subFnOptions
        );
        if (!parseResult) {
          return invalidDate();
        }
        setters.push(parseResult.setter);
        dateStr = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp2)) {
          throw new RangeError(
            "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
          );
        }
        if (token === "''") {
          token = "'";
        } else if (firstCharacter === "'") {
          token = cleanEscapedString2(token);
        }
        if (dateStr.indexOf(token) === 0) {
          dateStr = dateStr.slice(token.length);
        } else {
          return invalidDate();
        }
      }
    }
    if (dateStr.length > 0 && notWhitespaceRegExp.test(dateStr)) {
      return invalidDate();
    }
    const uniquePrioritySetters = setters.map((setter) => setter.priority).sort((a, b) => b - a).filter((priority, index, array) => array.indexOf(priority) === index).map(
      (priority) => setters.filter((setter) => setter.priority === priority).sort((a, b) => b.subPriority - a.subPriority)
    ).map((setterArray) => setterArray[0]);
    let date2 = toDate(referenceDate, options == null ? void 0 : options.in);
    if (isNaN(+date2))
      return invalidDate();
    const flags = {};
    for (const setter of uniquePrioritySetters) {
      if (!setter.validate(date2, subFnOptions)) {
        return invalidDate();
      }
      const result = setter.set(date2, flags, subFnOptions);
      if (Array.isArray(result)) {
        date2 = result[0];
        Object.assign(flags, result[1]);
      } else {
        date2 = result;
      }
    }
    return date2;
  }
  function cleanEscapedString2(input) {
    return input.match(escapedStringRegExp2)[1].replace(doubleQuoteRegExp2, "'");
  }

  // ../posawesome/node_modules/date-fns/isSameQuarter.js
  function isSameQuarter(laterDate, earlierDate, options) {
    const [dateLeft_, dateRight_] = normalizeDates(
      options == null ? void 0 : options.in,
      laterDate,
      earlierDate
    );
    return +startOfQuarter(dateLeft_) === +startOfQuarter(dateRight_);
  }

  // ../posawesome/node_modules/date-fns/subDays.js
  function subDays(date2, amount, options) {
    return addDays2(date2, -amount, options);
  }

  // ../posawesome/node_modules/date-fns/setMonth.js
  function setMonth2(date2, month, options) {
    const _date = toDate(date2, options == null ? void 0 : options.in);
    const year = _date.getFullYear();
    const day = _date.getDate();
    const midMonth = constructFrom((options == null ? void 0 : options.in) || date2, 0);
    midMonth.setFullYear(year, month, 15);
    midMonth.setHours(0, 0, 0, 0);
    const daysInMonth = getDaysInMonth(midMonth);
    _date.setMonth(month, Math.min(day, daysInMonth));
    return _date;
  }

  // ../posawesome/node_modules/date-fns/set.js
  function set(date2, values, options) {
    let _date = toDate(date2, options == null ? void 0 : options.in);
    if (isNaN(+_date))
      return constructFrom((options == null ? void 0 : options.in) || date2, NaN);
    if (values.year != null)
      _date.setFullYear(values.year);
    if (values.month != null)
      _date = setMonth2(_date, values.month);
    if (values.date != null)
      _date.setDate(values.date);
    if (values.hours != null)
      _date.setHours(values.hours);
    if (values.minutes != null)
      _date.setMinutes(values.minutes);
    if (values.seconds != null)
      _date.setSeconds(values.seconds);
    if (values.milliseconds != null)
      _date.setMilliseconds(values.milliseconds);
    return _date;
  }

  // ../posawesome/node_modules/date-fns/setHours.js
  function setHours2(date2, hours, options) {
    const _date = toDate(date2, options == null ? void 0 : options.in);
    _date.setHours(hours);
    return _date;
  }

  // ../posawesome/node_modules/date-fns/setMilliseconds.js
  function setMilliseconds(date2, milliseconds, options) {
    const _date = toDate(date2, options == null ? void 0 : options.in);
    _date.setMilliseconds(milliseconds);
    return _date;
  }

  // ../posawesome/node_modules/date-fns/setMinutes.js
  function setMinutes2(date2, minutes, options) {
    const date_ = toDate(date2, options == null ? void 0 : options.in);
    date_.setMinutes(minutes);
    return date_;
  }

  // ../posawesome/node_modules/date-fns/setSeconds.js
  function setSeconds(date2, seconds, options) {
    const _date = toDate(date2, options == null ? void 0 : options.in);
    _date.setSeconds(seconds);
    return _date;
  }

  // ../posawesome/node_modules/date-fns/setYear.js
  function setYear2(date2, year, options) {
    const date_ = toDate(date2, options == null ? void 0 : options.in);
    if (isNaN(+date_))
      return constructFrom((options == null ? void 0 : options.in) || date2, NaN);
    date_.setFullYear(year);
    return date_;
  }

  // ../posawesome/node_modules/date-fns/subMonths.js
  function subMonths(date2, amount, options) {
    return addMonths2(date2, -amount, options);
  }

  // ../posawesome/node_modules/date-fns/sub.js
  function sub(date2, duration, options) {
    const {
      years = 0,
      months = 0,
      weeks = 0,
      days = 0,
      hours = 0,
      minutes = 0,
      seconds = 0
    } = duration;
    const withoutMonths = subMonths(date2, months + years * 12, options);
    const withoutDays = subDays(withoutMonths, days + weeks * 7, options);
    const minutesToSub = minutes + hours * 60;
    const secondsToSub = seconds + minutesToSub * 60;
    const msToSub = secondsToSub * 1e3;
    return constructFrom((options == null ? void 0 : options.in) || date2, +withoutDays - msToSub);
  }

  // ../posawesome/node_modules/date-fns/subYears.js
  function subYears(date2, amount, options) {
    return addYears(date2, -amount, options);
  }

  // ../posawesome/node_modules/@vuepic/vue-datepicker/dist/vue-datepicker.js
  function Gt() {
    const e = useAttrs();
    return openBlock(), createElementBlock(
      "svg",
      __spreadValues({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 32 32",
        fill: "currentColor",
        "aria-hidden": "true",
        class: "dp__icon",
        role: "img"
      }, e),
      [
        createBaseVNode("path", {
          d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z"
        }),
        createBaseVNode("path", {
          d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
        }),
        createBaseVNode("path", {
          d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
        }),
        createBaseVNode("path", {
          d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z"
        })
      ]
    );
  }
  Gt.compatConfig = {
    MODE: 3
  };
  function Tn() {
    return openBlock(), createElementBlock(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 32 32",
        fill: "currentColor",
        "aria-hidden": "true",
        class: "dp__icon",
        role: "img"
      },
      [
        createBaseVNode("path", {
          d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z"
        }),
        createBaseVNode("path", {
          d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
        })
      ]
    );
  }
  Tn.compatConfig = {
    MODE: 3
  };
  function Wa() {
    return openBlock(), createElementBlock(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 32 32",
        fill: "currentColor",
        "aria-hidden": "true",
        class: "dp__icon",
        role: "img"
      },
      [
        createBaseVNode("path", {
          d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
        })
      ]
    );
  }
  Wa.compatConfig = {
    MODE: 3
  };
  function Va() {
    return openBlock(), createElementBlock(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 32 32",
        fill: "currentColor",
        "aria-hidden": "true",
        class: "dp__icon",
        role: "img"
      },
      [
        createBaseVNode("path", {
          d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z"
        })
      ]
    );
  }
  Va.compatConfig = {
    MODE: 3
  };
  function ja() {
    return openBlock(), createElementBlock(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 32 32",
        fill: "currentColor",
        "aria-hidden": "true",
        class: "dp__icon",
        role: "img"
      },
      [
        createBaseVNode("path", {
          d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z"
        }),
        createBaseVNode("path", {
          d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
        })
      ]
    );
  }
  ja.compatConfig = {
    MODE: 3
  };
  function Ka() {
    return openBlock(), createElementBlock(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 32 32",
        fill: "currentColor",
        "aria-hidden": "true",
        class: "dp__icon",
        role: "img"
      },
      [
        createBaseVNode("path", {
          d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
        })
      ]
    );
  }
  Ka.compatConfig = {
    MODE: 3
  };
  function Ga() {
    return openBlock(), createElementBlock(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 32 32",
        fill: "currentColor",
        "aria-hidden": "true",
        class: "dp__icon",
        role: "img"
      },
      [
        createBaseVNode("path", {
          d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
        })
      ]
    );
  }
  Ga.compatConfig = {
    MODE: 3
  };
  var tt2 = (e, t) => t ? new Date(e.toLocaleString("en-US", { timeZone: t })) : new Date(e);
  var Qa = (e, t, r) => {
    const a = La(e, t, r);
    return a || K();
  };
  var kl = (e, t, r) => {
    const a = t.dateInTz ? tt2(new Date(e), t.dateInTz) : K(e);
    return r ? je(a, true) : a;
  };
  var La = (e, t, r) => {
    if (!e)
      return null;
    const a = r ? je(K(e), true) : K(e);
    return t ? t.exactMatch ? kl(e, t, r) : tt2(a, t.timezone) : a;
  };
  var wl = (e) => {
    const r = new Date(e.getFullYear(), 0, 1).getTimezoneOffset();
    return e.getTimezoneOffset() < r;
  };
  var Dl = (e, t) => {
    if (!e)
      return 0;
    const r = /* @__PURE__ */ new Date(), a = new Date(r.toLocaleString("en-US", { timeZone: "UTC" })), n = new Date(r.toLocaleString("en-US", { timeZone: e })), c = (wl(t != null ? t : n) ? n : t != null ? t : n).getTimezoneOffset() / 60;
    return (+a - +n) / (1e3 * 60 * 60) - c;
  };
  var ut = /* @__PURE__ */ ((e) => (e.month = "month", e.year = "year", e))(ut || {});
  var it = /* @__PURE__ */ ((e) => (e.top = "top", e.bottom = "bottom", e))(it || {});
  var _t = /* @__PURE__ */ ((e) => (e.header = "header", e.calendar = "calendar", e.timePicker = "timePicker", e))(_t || {});
  var qe = /* @__PURE__ */ ((e) => (e.month = "month", e.year = "year", e.calendar = "calendar", e.time = "time", e.minutes = "minutes", e.hours = "hours", e.seconds = "seconds", e))(qe || {});
  var Ml = ["timestamp", "date", "iso"];
  var Ze = /* @__PURE__ */ ((e) => (e.up = "up", e.down = "down", e.left = "left", e.right = "right", e))(Ze || {});
  var Oe = /* @__PURE__ */ ((e) => (e.arrowUp = "ArrowUp", e.arrowDown = "ArrowDown", e.arrowLeft = "ArrowLeft", e.arrowRight = "ArrowRight", e.enter = "Enter", e.space = " ", e.esc = "Escape", e.tab = "Tab", e.home = "Home", e.end = "End", e.pageUp = "PageUp", e.pageDown = "PageDown", e))(Oe || {});
  var zt = /* @__PURE__ */ ((e) => (e.MONTH_AND_YEAR = "MM-yyyy", e.YEAR = "yyyy", e.DATE = "dd-MM-yyyy", e))(zt || {});
  function sn(e) {
    return (t) => {
      const r = new Intl.DateTimeFormat(e, {
        weekday: "short",
        timeZone: "UTC"
      }).format(/* @__PURE__ */ new Date(`2017-01-0${t}T00:00:00+00:00`));
      return e === "ar" ? r.slice(2, 5) : r.slice(0, 2);
    };
  }
  function $l(e) {
    return (t) => format2(tt2(/* @__PURE__ */ new Date(`2017-01-0${t}T00:00:00+00:00`), "UTC"), "EEEEEE", { locale: e });
  }
  var Al = (e, t, r) => {
    const a = [1, 2, 3, 4, 5, 6, 7];
    let n;
    if (e !== null)
      try {
        n = a.map($l(e));
      } catch (e2) {
        n = a.map(sn(t));
      }
    else
      n = a.map(sn(t));
    const u = n.slice(0, r), c = n.slice(r + 1, n.length);
    return [n[r]].concat(...c).concat(...u);
  };
  var qa = (e, t, r) => {
    const a = [];
    for (let n = +e[0]; n <= +e[1]; n++)
      a.push({ value: +n, text: Cn(n, t) });
    return r ? a.reverse() : a;
  };
  var Sn = (e, t, r) => {
    const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((u) => {
      const c = u < 10 ? `0${u}` : u;
      return /* @__PURE__ */ new Date(`2017-${c}-01T00:00:00+00:00`);
    });
    if (e !== null)
      try {
        const u = r === "long" ? "LLLL" : "LLL";
        return a.map((c, p2) => {
          const d = format2(tt2(c, "UTC"), u, { locale: e });
          return {
            text: d.charAt(0).toUpperCase() + d.substring(1),
            value: p2
          };
        });
      } catch (e2) {
      }
    const n = new Intl.DateTimeFormat(t, { month: r, timeZone: "UTC" });
    return a.map((u, c) => {
      const p2 = n.format(u);
      return {
        text: p2.charAt(0).toUpperCase() + p2.substring(1),
        value: c
      };
    });
  };
  var Tl = (e) => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][e];
  var He = (e) => {
    const t = unref(e);
    return t != null && t.$el ? t == null ? void 0 : t.$el : t;
  };
  var Sl = (e) => __spreadValues({ type: "dot" }, e != null ? e : {});
  var Pn = (e) => Array.isArray(e) ? !!e[0] && !!e[1] : false;
  var Xa = {
    prop: (e) => `"${e}" prop must be enabled!`,
    dateArr: (e) => `You need to use array as "model-value" binding in order to support "${e}"`
  };
  var ze = (e) => e;
  var un = (e) => e === 0 ? e : !e || isNaN(+e) ? null : +e;
  var dn = (e) => e === null;
  var Rn = (e) => {
    if (e)
      return [...e.querySelectorAll("input, button, select, textarea, a[href]")][0];
  };
  var Pl = (e) => {
    const t = [], r = (a) => a.filter((n) => n);
    for (let a = 0; a < e.length; a += 3) {
      const n = [e[a], e[a + 1], e[a + 2]];
      t.push(r(n));
    }
    return t;
  };
  var xt = (e, t, r) => {
    const a = r != null, n = t != null;
    if (!a && !n)
      return false;
    const u = +r, c = +t;
    return a && n ? +e > u || +e < c : a ? +e > u : n ? +e < c : false;
  };
  var Wt = (e, t) => Pl(e).map((r) => r.map((a) => {
    const { active: n, disabled: u, isBetween: c, highlighted: p2 } = t(a);
    return __spreadProps(__spreadValues({}, a), {
      active: n,
      disabled: u,
      className: {
        dp__overlay_cell_active: n,
        dp__overlay_cell: !n,
        dp__overlay_cell_disabled: u,
        dp__overlay_cell_pad: true,
        dp__overlay_cell_active_disabled: u && n,
        dp__cell_in_between: c,
        "dp--highlighted": p2
      }
    });
  }));
  var $t = (e, t, r = false) => {
    e && t.allowStopPropagation && (r && e.stopImmediatePropagation(), e.stopPropagation());
  };
  var Rl = () => [
    "a[href]",
    "area[href]",
    "input:not([disabled]):not([type='hidden'])",
    "select:not([disabled])",
    "textarea:not([disabled])",
    "button:not([disabled])",
    "[tabindex]:not([tabindex='-1'])",
    "[data-datepicker-instance]"
  ].join(", ");
  function Cl(e, t) {
    let r = [...document.querySelectorAll(Rl())];
    r = r.filter((n) => !e.contains(n) || n.hasAttribute("data-datepicker-instance"));
    const a = r.indexOf(e);
    if (a >= 0 && (t ? a - 1 >= 0 : a + 1 <= r.length))
      return r[a + (t ? -1 : 1)];
  }
  var Fa = (e, t) => e == null ? void 0 : e.querySelector(`[data-dp-element="${t}"]`);
  var Cn = (e, t) => new Intl.NumberFormat(t, { useGrouping: false, style: "decimal" }).format(e);
  var Ja = (e, t) => format2(e, t != null ? t : zt.DATE);
  var Ta = (e) => Array.isArray(e);
  var va = (e, t, r) => t.get(Ja(e, r));
  var Ol = (e, t) => e ? t ? t instanceof Map ? !!va(e, t) : t(K(e)) : false : true;
  var xe = (e, t, r = false, a) => {
    if (e.key === Oe.enter || e.key === Oe.space)
      return r && e.preventDefault(), t();
    if (a)
      return a(e);
  };
  var Bl = () => "ontouchstart" in window || navigator.maxTouchPoints > 0;
  var On = (e, t) => e ? zt.MONTH_AND_YEAR : t ? zt.YEAR : zt.DATE;
  var Bn = (e) => e < 10 ? `0${e}` : e;
  var cn = (e, t, r, a, n, u) => {
    const c = parse(e, t.slice(0, e.length), /* @__PURE__ */ new Date(), { locale: u });
    return isValid2(c) && isDate(c) ? a || n ? c : set(c, {
      hours: +r.hours,
      minutes: +(r == null ? void 0 : r.minutes),
      seconds: +(r == null ? void 0 : r.seconds),
      milliseconds: 0
    }) : null;
  };
  var _l = (e, t, r, a, n, u) => {
    const c = Array.isArray(r) ? r[0] : r;
    if (typeof t == "string")
      return cn(e, t, c, a, n, u);
    if (Array.isArray(t)) {
      let p2 = null;
      for (const d of t)
        if (p2 = cn(e, d, c, a, n, u), p2)
          break;
      return p2;
    }
    return typeof t == "function" ? t(e) : null;
  };
  var K = (e) => e ? new Date(e) : /* @__PURE__ */ new Date();
  var Yl = (e, t, r) => {
    if (t) {
      const n = (e.getMonth() + 1).toString().padStart(2, "0"), u = e.getDate().toString().padStart(2, "0"), c = e.getHours().toString().padStart(2, "0"), p2 = e.getMinutes().toString().padStart(2, "0"), d = r ? e.getSeconds().toString().padStart(2, "0") : "00";
      return `${e.getFullYear()}-${n}-${u}T${c}:${p2}:${d}.000Z`;
    }
    const a = Date.UTC(
      e.getUTCFullYear(),
      e.getUTCMonth(),
      e.getUTCDate(),
      e.getUTCHours(),
      e.getUTCMinutes(),
      e.getUTCSeconds()
    );
    return new Date(a).toISOString();
  };
  var je = (e, t) => {
    const r = K(JSON.parse(JSON.stringify(e))), a = set(r, { hours: 0, minutes: 0, seconds: 0, milliseconds: 0 });
    return t ? startOfMonth2(a) : a;
  };
  var At = (e, t, r, a) => {
    let n = e ? K(e) : K();
    return (t || t === 0) && (n = setHours2(n, +t)), (r || r === 0) && (n = setMinutes2(n, +r)), (a || a === 0) && (n = setSeconds(n, +a)), setMilliseconds(n, 0);
  };
  var Ne = (e, t) => !e || !t ? false : isBefore2(je(e), je(t));
  var Te = (e, t) => !e || !t ? false : isEqual2(je(e), je(t));
  var Fe = (e, t) => !e || !t ? false : isAfter2(je(e), je(t));
  var ea = (e, t, r) => e != null && e[0] && (e != null && e[1]) ? Fe(r, e[0]) && Ne(r, e[1]) : e != null && e[0] && t ? Fe(r, e[0]) && Ne(r, t) || Ne(r, e[0]) && Fe(r, t) : false;
  var dt = (e) => {
    const t = set(new Date(e), { date: 1 });
    return je(t);
  };
  var Sa = (e, t, r) => t && (r || r === 0) ? Object.fromEntries(
    ["hours", "minutes", "seconds"].map((a) => a === t ? [a, r] : [a, isNaN(+e[a]) ? void 0 : +e[a]])
  ) : {
    hours: isNaN(+e.hours) ? void 0 : +e.hours,
    minutes: isNaN(+e.minutes) ? void 0 : +e.minutes,
    seconds: isNaN(+e.seconds) ? void 0 : +e.seconds
  };
  var Yt = (e) => ({
    hours: getHours2(e),
    minutes: getMinutes2(e),
    seconds: getSeconds(e)
  });
  var _n = (e, t) => {
    if (t) {
      const r = getYear2(K(t));
      if (r > e)
        return 12;
      if (r === e)
        return getMonth2(K(t));
    }
  };
  var Yn = (e, t) => {
    if (t) {
      const r = getYear2(K(t));
      return r < e ? -1 : r === e ? getMonth2(K(t)) : void 0;
    }
  };
  var Vt = (e) => {
    if (e)
      return getYear2(K(e));
  };
  var In = (e, t) => {
    const r = Fe(e, t) ? t : e, a = Fe(t, e) ? t : e;
    return eachDayOfInterval({ start: r, end: a });
  };
  var Il = (e) => {
    const t = addMonths2(e, 1);
    return { month: getMonth2(t), year: getYear2(t) };
  };
  var gt = (e, t) => {
    const r = startOfWeek2(e, { weekStartsOn: +t }), a = endOfWeek2(e, { weekStartsOn: +t });
    return [r, a];
  };
  var En = (e, t) => {
    const r = {
      hours: getHours2(K()),
      minutes: getMinutes2(K()),
      seconds: t ? getSeconds(K()) : 0
    };
    return Object.assign(r, e);
  };
  var Mt = (e, t, r) => [set(K(e), { date: 1 }), set(K(), { month: t, year: r, date: 1 })];
  var ht = (e, t, r) => {
    let a = e ? K(e) : K();
    return (t || t === 0) && (a = setMonth2(a, t)), r && (a = setYear2(a, r)), a;
  };
  var Nn = (e, t, r, a, n) => {
    if (!a || n && !t || !n && !r)
      return false;
    const u = n ? addMonths2(e, 1) : subMonths(e, 1), c = [getMonth2(u), getYear2(u)];
    return n ? !Nl(...c, t) : !El(...c, r);
  };
  var El = (e, t, r) => Ne(...Mt(r, e, t)) || Te(...Mt(r, e, t));
  var Nl = (e, t, r) => Fe(...Mt(r, e, t)) || Te(...Mt(r, e, t));
  var Ln = (e, t, r, a, n, u, c) => {
    if (typeof t == "function" && !c)
      return t(e);
    const p2 = r ? { locale: r } : void 0;
    return Array.isArray(e) ? `${format2(e[0], u, p2)}${n && !e[1] ? "" : a}${e[1] ? format2(e[1], u, p2) : ""}` : format2(e, u, p2);
  };
  var Nt = (e) => {
    if (e)
      return null;
    throw new Error(Xa.prop("partial-range"));
  };
  var sa = (e, t) => {
    if (t)
      return e();
    throw new Error(Xa.prop("range"));
  };
  var za = (e) => Array.isArray(e) ? isValid2(e[0]) && (e[1] ? isValid2(e[1]) : true) : e ? isValid2(e) : false;
  var Ll = (e, t) => set(t != null ? t : K(), {
    hours: +e.hours || 0,
    minutes: +e.minutes || 0,
    seconds: +e.seconds || 0
  });
  var Pa = (e, t, r, a) => {
    if (!e)
      return true;
    if (a) {
      const n = r === "max" ? isBefore2(e, t) : isAfter2(e, t), u = { seconds: 0, milliseconds: 0 };
      return n || isEqual2(set(e, u), set(t, u));
    }
    return r === "max" ? e.getTime() <= t.getTime() : e.getTime() >= t.getTime();
  };
  var Ra = (e, t, r) => e ? Ll(e, t) : K(r != null ? r : t);
  var fn = (e, t, r, a, n) => {
    if (Array.isArray(a)) {
      const c = Ra(e, a[0], t), p2 = Ra(e, a[1], t);
      return Pa(a[0], c, r, !!t) && Pa(a[1], p2, r, !!t) && n;
    }
    const u = Ra(e, a, t);
    return Pa(a, u, r, !!t) && n;
  };
  var Ca = (e) => set(K(), Yt(e));
  var Fl = (e, t, r) => {
    if (e instanceof Map) {
      const a = `${Bn(r + 1)}-${t}`;
      return e.size ? e.has(a) : false;
    }
    return typeof e == "function" ? e(je(set(K(), { month: r, year: t }), true)) : false;
  };
  var zl = (e, t, r) => {
    if (e instanceof Map) {
      const a = `${Bn(r + 1)}-${t}`;
      return e.size ? e.has(a) : true;
    }
    return true;
  };
  var Fn = (e, t, r) => typeof e == "function" ? e({ month: t, year: r }) : !!e.months.find((a) => a.month === t && a.year === r);
  var Za = (e, t) => typeof e == "function" ? e(t) : e.years.includes(t);
  var Ha = (e) => `dp-${format2(e, "yyyy-MM-dd")}`;
  var vn = (e, t) => {
    const r = subDays(je(t), e), a = addDays2(je(t), e);
    return { before: r, after: a };
  };
  var Qt = reactive({
    menuFocused: false,
    shiftKeyInMenu: false
  });
  var zn = () => {
    const e = (a) => {
      Qt.menuFocused = a;
    }, t = (a) => {
      Qt.shiftKeyInMenu !== a && (Qt.shiftKeyInMenu = a);
    };
    return {
      control: computed2(() => ({ shiftKeyInMenu: Qt.shiftKeyInMenu, menuFocused: Qt.menuFocused })),
      setMenuFocused: e,
      setShiftKey: t
    };
  };
  var Ce = reactive({
    monthYear: [],
    calendar: [],
    time: [],
    actionRow: [],
    selectionGrid: [],
    timePicker: {
      0: [],
      1: []
    },
    monthPicker: []
  });
  var Oa = ref(null);
  var ua = ref(false);
  var Ba = ref(false);
  var _a = ref(false);
  var Ya = ref(false);
  var Qe = ref(0);
  var Le = ref(0);
  var St = () => {
    const e = computed2(() => ua.value ? [...Ce.selectionGrid, Ce.actionRow].filter((h2) => h2.length) : Ba.value ? [
      ...Ce.timePicker[0],
      ...Ce.timePicker[1],
      Ya.value ? [] : [Oa.value],
      Ce.actionRow
    ].filter((h2) => h2.length) : _a.value ? [...Ce.monthPicker, Ce.actionRow] : [Ce.monthYear, ...Ce.calendar, Ce.time, Ce.actionRow].filter((h2) => h2.length)), t = (h2) => {
      Qe.value = h2 ? Qe.value + 1 : Qe.value - 1;
      let R = null;
      e.value[Le.value] && (R = e.value[Le.value][Qe.value]), !R && e.value[Le.value + (h2 ? 1 : -1)] ? (Le.value = Le.value + (h2 ? 1 : -1), Qe.value = h2 ? 0 : e.value[Le.value].length - 1) : R || (Qe.value = h2 ? Qe.value - 1 : Qe.value + 1);
    }, r = (h2) => {
      if (Le.value === 0 && !h2 || Le.value === e.value.length && h2)
        return;
      Le.value = h2 ? Le.value + 1 : Le.value - 1, e.value[Le.value] ? e.value[Le.value] && !e.value[Le.value][Qe.value] && Qe.value !== 0 && (Qe.value = e.value[Le.value].length - 1) : Le.value = h2 ? Le.value - 1 : Le.value + 1;
    }, a = (h2) => {
      let R = null;
      e.value[Le.value] && (R = e.value[Le.value][Qe.value]), R ? R.focus({ preventScroll: !ua.value }) : Qe.value = h2 ? Qe.value - 1 : Qe.value + 1;
    }, n = () => {
      t(true), a(true);
    }, u = () => {
      t(false), a(false);
    }, c = () => {
      r(false), a(true);
    }, p2 = () => {
      r(true), a(true);
    }, d = (h2, R) => {
      Ce[R] = h2;
    }, Y = (h2, R) => {
      Ce[R] = h2;
    }, f = () => {
      Qe.value = 0, Le.value = 0;
    };
    return {
      buildMatrix: d,
      buildMultiLevelMatrix: Y,
      setTimePickerBackRef: (h2) => {
        Oa.value = h2;
      },
      setSelectionGrid: (h2) => {
        ua.value = h2, f(), h2 || (Ce.selectionGrid = []);
      },
      setTimePicker: (h2, R = false) => {
        Ba.value = h2, Ya.value = R, f(), h2 || (Ce.timePicker[0] = [], Ce.timePicker[1] = []);
      },
      setTimePickerElements: (h2, R = 0) => {
        Ce.timePicker[R] = h2;
      },
      arrowRight: n,
      arrowLeft: u,
      arrowUp: c,
      arrowDown: p2,
      clearArrowNav: () => {
        Ce.monthYear = [], Ce.calendar = [], Ce.time = [], Ce.actionRow = [], Ce.selectionGrid = [], Ce.timePicker[0] = [], Ce.timePicker[1] = [], ua.value = false, Ba.value = false, Ya.value = false, _a.value = false, f(), Oa.value = null;
      },
      setMonthPicker: (h2) => {
        _a.value = h2, f();
      },
      refSets: Ce
    };
  };
  var mn = (e) => __spreadValues({
    menuAppearTop: "dp-menu-appear-top",
    menuAppearBottom: "dp-menu-appear-bottom",
    open: "dp-slide-down",
    close: "dp-slide-up",
    next: "calendar-next",
    previous: "calendar-prev",
    vNext: "dp-slide-up",
    vPrevious: "dp-slide-down"
  }, e != null ? e : {});
  var Hl = (e) => __spreadValues({
    toggleOverlay: "Toggle overlay",
    menu: "Datepicker menu",
    input: "Datepicker input",
    openTimePicker: "Open time picker",
    closeTimePicker: "Close time Picker",
    incrementValue: (t) => `Increment ${t}`,
    decrementValue: (t) => `Decrement ${t}`,
    openTpOverlay: (t) => `Open ${t} overlay`,
    amPmButton: "Switch AM/PM mode",
    openYearsOverlay: "Open years overlay",
    openMonthsOverlay: "Open months overlay",
    nextMonth: "Next month",
    prevMonth: "Previous month",
    nextYear: "Next year",
    prevYear: "Previous year",
    day: void 0,
    weekDay: void 0,
    clearInput: "Clear value",
    calendarIcon: "Calendar icon",
    timePicker: "Time picker",
    monthPicker: (t) => `Month picker${t ? " overlay" : ""}`,
    yearPicker: (t) => `Year picker${t ? " overlay" : ""}`,
    timeOverlay: (t) => `${t} overlay`
  }, e != null ? e : {});
  var pn = (e) => e ? typeof e == "boolean" ? e ? 2 : 0 : +e >= 2 ? +e : 2 : 0;
  var Ul = (e) => {
    var _a3;
    const t = typeof e == "object" && e, r = {
      static: true,
      solo: false
    };
    if (!e)
      return __spreadProps(__spreadValues({}, r), { count: pn(false) });
    const a = t ? e : {}, n = t ? (_a3 = a.count) != null ? _a3 : true : e, u = pn(n);
    return Object.assign(r, a, { count: u });
  };
  var Wl = (e, t, r) => e || (typeof r == "string" ? r : t);
  var Vl = (e) => typeof e == "boolean" ? e ? mn({}) : false : mn(e);
  var jl = (e) => {
    const t = {
      enterSubmit: true,
      tabSubmit: true,
      openMenu: "open",
      selectOnFocus: false,
      rangeSeparator: " - ",
      escClose: true
    };
    return typeof e == "object" ? __spreadProps(__spreadValues(__spreadValues({}, t), e != null ? e : {}), { enabled: true }) : __spreadProps(__spreadValues({}, t), { enabled: e });
  };
  var Kl = (e) => __spreadValues({
    months: [],
    years: [],
    times: { hours: [], minutes: [], seconds: [] }
  }, e != null ? e : {});
  var Gl = (e) => __spreadValues({
    showSelect: true,
    showCancel: true,
    showNow: false,
    showPreview: true
  }, e != null ? e : {});
  var Ql = (e) => {
    const t = { input: false };
    return typeof e == "object" ? __spreadProps(__spreadValues(__spreadValues({}, t), e != null ? e : {}), { enabled: true }) : __spreadValues({
      enabled: e
    }, t);
  };
  var ql = (e) => __spreadValues(__spreadValues({}, {
    allowStopPropagation: true,
    closeOnScroll: false,
    modeHeight: 255,
    allowPreventDefault: false,
    closeOnClearValue: true,
    closeOnAutoApply: true,
    noSwipe: false,
    keepActionRow: false,
    onClickOutside: void 0,
    tabOutClosesMenu: true,
    arrowLeft: void 0,
    keepViewOnOffsetClick: false,
    timeArrowHoldThreshold: 0,
    shadowDom: false,
    mobileBreakpoint: 600,
    setDateOnMenuClose: false
  }), e != null ? e : {});
  var Xl = (e) => {
    const t = {
      dates: Array.isArray(e) ? e.map((r) => K(r)) : [],
      years: [],
      months: [],
      quarters: [],
      weeks: [],
      weekdays: [],
      options: { highlightDisabled: false }
    };
    return typeof e == "function" ? e : __spreadValues(__spreadValues({}, t), e != null ? e : {});
  };
  var Jl = (e) => {
    var _a3, _b;
    return typeof e == "object" ? {
      type: (_a3 = e == null ? void 0 : e.type) != null ? _a3 : "local",
      hideOnOffsetDates: (_b = e == null ? void 0 : e.hideOnOffsetDates) != null ? _b : false
    } : {
      type: e,
      hideOnOffsetDates: false
    };
  };
  var Zl = (e) => {
    const t = {
      noDisabledRange: false,
      showLastInRange: true,
      minMaxRawRange: false,
      partialRange: true,
      disableTimeRangeValidation: false,
      maxRange: void 0,
      minRange: void 0,
      autoRange: void 0,
      fixedStart: false,
      fixedEnd: false
    };
    return typeof e == "object" ? __spreadValues(__spreadValues({ enabled: true }, t), e) : __spreadValues({
      enabled: e
    }, t);
  };
  var xl = (e) => {
    var _a3, _b, _c, _d;
    return e ? typeof e == "string" ? {
      timezone: e,
      exactMatch: false,
      dateInTz: void 0,
      emitTimezone: void 0,
      convertModel: true
    } : {
      timezone: e.timezone,
      exactMatch: (_a3 = e.exactMatch) != null ? _a3 : false,
      dateInTz: (_b = e.dateInTz) != null ? _b : void 0,
      emitTimezone: (_c = e.emitTimezone) != null ? _c : void 0,
      convertModel: (_d = e.convertModel) != null ? _d : true
    } : { timezone: void 0, exactMatch: false, emitTimezone: void 0 };
  };
  var Ia = (e, t, r, a) => new Map(
    e.map((n) => {
      const u = Qa(n, t, a);
      return [Ja(u, r), u];
    })
  );
  var er = (e, t) => e.length ? new Map(
    e.map((r) => {
      const a = Qa(r.date, t);
      return [Ja(a, zt.DATE), r];
    })
  ) : null;
  var tr = (e) => {
    var r;
    const t = On(e.isMonthPicker, e.isYearPicker);
    return {
      minDate: La(e.minDate, e.timezone, e.isSpecific),
      maxDate: La(e.maxDate, e.timezone, e.isSpecific),
      disabledDates: Ta(e.disabledDates) ? Ia(e.disabledDates, e.timezone, t, e.isSpecific) : e.disabledDates,
      allowedDates: Ta(e.allowedDates) ? Ia(e.allowedDates, e.timezone, t, e.isSpecific) : null,
      highlight: typeof e.highlight == "object" && Ta((r = e.highlight) == null ? void 0 : r.dates) ? Ia(e.highlight.dates, e.timezone, t) : e.highlight,
      markers: er(e.markers, e.timezone)
    };
  };
  var ar = (e) => {
    var _a3;
    return typeof e == "boolean" ? { enabled: e, dragSelect: true, limit: null } : {
      enabled: !!e,
      limit: e.limit ? +e.limit : null,
      dragSelect: (_a3 = e.dragSelect) != null ? _a3 : true
    };
  };
  var nr = (e) => __spreadValues({}, Object.fromEntries(
    Object.keys(e).map((r) => {
      const a = r, n = e[a], u = typeof e[a] == "string" ? { [n]: true } : Object.fromEntries(n.map((c) => [c, true]));
      return [r, u];
    })
  ));
  var Ye = (e) => {
    const t = () => {
      const H = e.enableSeconds ? ":ss" : "", D = e.enableMinutes ? ":mm" : "";
      return e.is24 ? `HH${D}${H}` : `hh${D}${H} aa`;
    }, r = () => {
      var H;
      return e.format ? e.format : e.monthPicker ? "MM/yyyy" : e.timePicker ? t() : e.weekPicker ? `${((H = _2.value) == null ? void 0 : H.type) === "iso" ? "II" : "ww"}-RR` : e.yearPicker ? "yyyy" : e.quarterPicker ? "QQQ/yyyy" : e.enableTimePicker ? `MM/dd/yyyy, ${t()}` : "MM/dd/yyyy";
    }, a = (H) => En(H, e.enableSeconds), n = () => j.value.enabled ? e.startTime && Array.isArray(e.startTime) ? [a(e.startTime[0]), a(e.startTime[1])] : null : e.startTime && !Array.isArray(e.startTime) ? a(e.startTime) : null, u = computed2(() => Ul(e.multiCalendars)), c = computed2(() => n()), p2 = computed2(() => Hl(e.ariaLabels)), d = computed2(() => Kl(e.filters)), Y = computed2(() => Vl(e.transitions)), f = computed2(() => Gl(e.actionRow)), O = computed2(
      () => Wl(e.previewFormat, e.format, r())
    ), m = computed2(() => jl(e.textInput)), P = computed2(() => Ql(e.inline)), F = computed2(() => ql(e.config)), L = computed2(() => Xl(e.highlight)), _2 = computed2(() => Jl(e.weekNumbers)), h2 = computed2(() => xl(e.timezone)), R = computed2(() => ar(e.multiDates)), b = computed2(
      () => tr({
        minDate: e.minDate,
        maxDate: e.maxDate,
        disabledDates: e.disabledDates,
        allowedDates: e.allowedDates,
        highlight: L.value,
        markers: e.markers,
        timezone: h2.value,
        isSpecific: e.monthPicker || e.yearPicker || e.quarterPicker,
        isMonthPicker: e.monthPicker,
        isYearPicker: e.yearPicker
      })
    ), j = computed2(() => Zl(e.range)), z = computed2(() => nr(e.ui));
    return {
      defaultedTransitions: Y,
      defaultedMultiCalendars: u,
      defaultedStartTime: c,
      defaultedAriaLabels: p2,
      defaultedFilters: d,
      defaultedActionRow: f,
      defaultedPreviewFormat: O,
      defaultedTextInput: m,
      defaultedInline: P,
      defaultedConfig: F,
      defaultedHighlight: L,
      defaultedWeekNumbers: _2,
      defaultedRange: j,
      propDates: b,
      defaultedTz: h2,
      defaultedMultiDates: R,
      defaultedUI: z,
      getDefaultPattern: r,
      getDefaultStartTime: n,
      handleEventPropagation: (H) => {
        F.value.allowStopPropagation && H.stopPropagation(), F.value.allowPreventDefault && H.preventDefault();
      }
    };
  };
  var lr = (e, t, r) => {
    const a = ref(), { defaultedTextInput: n, defaultedRange: u, defaultedTz: c, defaultedMultiDates: p2, getDefaultPattern: d } = Ye(t), Y = ref(""), f = toRef(t, "format"), O = toRef(t, "formatLocale");
    watch2(
      a,
      () => {
        typeof t.onInternalModelChange == "function" && e("internal-model-change", a.value, T(true));
      },
      { deep: true }
    ), watch2(u, (l, w) => {
      l.enabled !== w.enabled && (a.value = null);
    }), watch2(f, () => {
      U();
    });
    const m = (l) => c.value.timezone && c.value.convertModel ? tt2(l, c.value.timezone) : l, P = (l) => {
      if (c.value.timezone && c.value.convertModel) {
        const w = Dl(c.value.timezone, l);
        return addHours2(l, w);
      }
      return l;
    }, F = (l, w, oe2 = false) => Ln(
      l,
      t.format,
      t.formatLocale,
      n.value.rangeSeparator,
      t.modelAuto,
      w != null ? w : d(),
      oe2
    ), L = (l) => l ? t.modelType ? Z(l) : {
      hours: getHours2(l),
      minutes: getMinutes2(l),
      seconds: t.enableSeconds ? getSeconds(l) : 0
    } : null, _2 = (l) => t.modelType ? Z(l) : { month: getMonth2(l), year: getYear2(l) }, h2 = (l) => Array.isArray(l) ? p2.value.enabled ? l.map((w) => R(w, setYear2(K(), w))) : sa(
      () => [
        setYear2(K(), l[0]),
        l[1] ? setYear2(K(), l[1]) : Nt(u.value.partialRange)
      ],
      u.value.enabled
    ) : setYear2(K(), +l), R = (l, w) => (typeof l == "string" || typeof l == "number") && t.modelType ? S(l) : w, b = (l) => Array.isArray(l) ? [
      R(
        l[0],
        At(null, +l[0].hours, +l[0].minutes, l[0].seconds)
      ),
      R(
        l[1],
        At(null, +l[1].hours, +l[1].minutes, l[1].seconds)
      )
    ] : R(l, At(null, l.hours, l.minutes, l.seconds)), j = (l) => {
      const w = set(K(), { date: 1 });
      return Array.isArray(l) ? p2.value.enabled ? l.map((oe2) => R(oe2, ht(w, +oe2.month, +oe2.year))) : sa(
        () => [
          R(l[0], ht(w, +l[0].month, +l[0].year)),
          R(
            l[1],
            l[1] ? ht(w, +l[1].month, +l[1].year) : Nt(u.value.partialRange)
          )
        ],
        u.value.enabled
      ) : R(l, ht(w, +l.month, +l.year));
    }, z = (l) => {
      if (Array.isArray(l))
        return l.map((w) => S(w));
      throw new Error(Xa.dateArr("multi-dates"));
    }, ae2 = (l) => {
      if (Array.isArray(l) && u.value.enabled) {
        const w = l[0], oe2 = l[1];
        return [
          K(Array.isArray(w) ? w[0] : null),
          Array.isArray(oe2) && oe2.length ? K(oe2[0]) : null
        ];
      }
      return K(l[0]);
    }, H = (l) => t.modelAuto ? Array.isArray(l) ? [S(l[0]), S(l[1])] : t.autoApply ? [S(l)] : [S(l), null] : Array.isArray(l) ? sa(
      () => l[1] ? [
        S(l[0]),
        l[1] ? S(l[1]) : Nt(u.value.partialRange)
      ] : [S(l[0])],
      u.value.enabled
    ) : S(l), D = () => {
      Array.isArray(a.value) && u.value.enabled && a.value.length === 1 && a.value.push(Nt(u.value.partialRange));
    }, Q2 = () => {
      const l = a.value;
      return [
        Z(l[0]),
        l[1] ? Z(l[1]) : Nt(u.value.partialRange)
      ];
    }, B = () => Array.isArray(a.value) ? a.value[1] ? Q2() : Z(ze(a.value[0])) : [], q = () => (a.value || []).map((l) => Z(l)), ve = (l = false) => (l || D(), t.modelAuto ? B() : p2.value.enabled ? q() : Array.isArray(a.value) ? sa(() => Q2(), u.value.enabled) : Z(ze(a.value))), pe2 = (l) => !l || Array.isArray(l) && !l.length ? null : t.timePicker ? b(ze(l)) : t.monthPicker ? j(ze(l)) : t.yearPicker ? h2(ze(l)) : p2.value.enabled ? z(ze(l)) : t.weekPicker ? ae2(ze(l)) : H(ze(l)), v = (l) => {
      const w = pe2(l);
      za(ze(w)) ? (a.value = ze(w), U()) : (a.value = null, Y.value = "");
    }, N = () => {
      const l = (w) => format2(w, n.value.format);
      return `${l(a.value[0])} ${n.value.rangeSeparator} ${a.value[1] ? l(a.value[1]) : ""}`;
    }, ee = () => r.value && a.value ? Array.isArray(a.value) ? N() : format2(a.value, n.value.format) : F(a.value), y = () => a.value ? p2.value.enabled ? a.value.map((l) => F(l)).join("; ") : n.value.enabled && typeof n.value.format == "string" ? ee() : F(a.value) : "", U = () => {
      !t.format || typeof t.format == "string" || n.value.enabled && typeof n.value.format == "string" ? Y.value = y() : Y.value = t.format(a.value);
    }, S = (l) => {
      if (t.utc) {
        const w = new Date(l);
        return t.utc === "preserve" ? new Date(w.getTime() + w.getTimezoneOffset() * 6e4) : w;
      }
      return t.modelType ? Ml.includes(t.modelType) ? m(new Date(l)) : t.modelType === "format" && (typeof t.format == "string" || !t.format) ? m(
        parse(l, d(), /* @__PURE__ */ new Date(), { locale: O.value })
      ) : m(
        parse(l, t.modelType, /* @__PURE__ */ new Date(), { locale: O.value })
      ) : m(new Date(l));
    }, Z = (l) => l ? t.utc ? Yl(l, t.utc === "preserve", t.enableSeconds) : t.modelType ? t.modelType === "timestamp" ? +P(l) : t.modelType === "iso" ? P(l).toISOString() : t.modelType === "format" && (typeof t.format == "string" || !t.format) ? F(P(l)) : F(P(l), t.modelType, true) : P(l) : "", A = (l, w = false, oe2 = false) => {
      if (oe2)
        return l;
      if (e("update:model-value", l), c.value.emitTimezone && w) {
        const M = Array.isArray(l) ? l.map((he2) => tt2(ze(he2), c.value.emitTimezone)) : tt2(ze(l), c.value.emitTimezone);
        e("update:model-timezone-value", M);
      }
    }, ie = (l) => Array.isArray(a.value) ? p2.value.enabled ? a.value.map((w) => l(w)) : [
      l(a.value[0]),
      a.value[1] ? l(a.value[1]) : Nt(u.value.partialRange)
    ] : l(ze(a.value)), i = () => {
      if (Array.isArray(a.value)) {
        const l = gt(a.value[0], t.weekStart), w = a.value[1] ? gt(a.value[1], t.weekStart) : [];
        return [l.map((oe2) => K(oe2)), w.map((oe2) => K(oe2))];
      }
      return gt(a.value, t.weekStart).map((l) => K(l));
    }, W = (l, w) => A(ze(ie(l)), false, w), se = (l) => {
      const w = i();
      return l ? w : e("update:model-value", i());
    }, T = (l = false) => (l || U(), t.monthPicker ? W(_2, l) : t.timePicker ? W(L, l) : t.yearPicker ? W(getYear2, l) : t.weekPicker ? se(l) : A(ve(l), true, l));
    return {
      inputValue: Y,
      internalModelValue: a,
      checkBeforeEmit: () => a.value ? u.value.enabled ? u.value.partialRange ? a.value.length >= 1 : a.value.length === 2 : !!a.value : false,
      parseExternalModelValue: v,
      formatInputValue: U,
      emitModelValue: T
    };
  };
  var rr = (e, t) => {
    const { defaultedFilters: r, propDates: a } = Ye(e), { validateMonthYearInRange: n } = Pt(e), u = (f, O) => {
      let m = f;
      return r.value.months.includes(getMonth2(m)) ? (m = O ? addMonths2(f, 1) : subMonths(f, 1), u(m, O)) : m;
    }, c = (f, O) => {
      let m = f;
      return r.value.years.includes(getYear2(m)) ? (m = O ? addYears(f, 1) : subYears(f, 1), c(m, O)) : m;
    }, p2 = (f, O = false) => {
      const m = set(K(), { month: e.month, year: e.year });
      let P = f ? addMonths2(m, 1) : subMonths(m, 1);
      e.disableYearSelect && (P = setYear2(P, e.year));
      let F = getMonth2(P), L = getYear2(P);
      r.value.months.includes(F) && (P = u(P, f), F = getMonth2(P), L = getYear2(P)), r.value.years.includes(L) && (P = c(P, f), L = getYear2(P)), n(F, L, f, e.preventMinMaxNavigation) && d(F, L, O);
    }, d = (f, O, m) => {
      t("update-month-year", { month: f, year: O, fromNav: m });
    }, Y = computed2(() => (f) => Nn(
      set(K(), { month: e.month, year: e.year }),
      a.value.maxDate,
      a.value.minDate,
      e.preventMinMaxNavigation,
      f
    ));
    return { handleMonthYearChange: p2, isDisabled: Y, updateMonthYear: d };
  };
  var pa = {
    multiCalendars: { type: [Boolean, Number, String, Object], default: void 0 },
    modelValue: { type: [String, Date, Array, Object, Number], default: null },
    modelType: { type: String, default: null },
    position: { type: String, default: "center" },
    dark: { type: Boolean, default: false },
    format: {
      type: [String, Function],
      default: () => null
    },
    autoPosition: { type: [Boolean, String], default: true },
    altPosition: { type: Function, default: null },
    transitions: { type: [Boolean, Object], default: true },
    formatLocale: { type: Object, default: null },
    utc: { type: [Boolean, String], default: false },
    ariaLabels: { type: Object, default: () => ({}) },
    offset: { type: [Number, String], default: 10 },
    hideNavigation: { type: Array, default: () => [] },
    timezone: { type: [String, Object], default: null },
    vertical: { type: Boolean, default: false },
    disableMonthYearSelect: { type: Boolean, default: false },
    disableYearSelect: { type: Boolean, default: false },
    dayClass: {
      type: Function,
      default: null
    },
    yearRange: { type: Array, default: () => [1900, 2100] },
    enableTimePicker: { type: Boolean, default: true },
    autoApply: { type: Boolean, default: false },
    disabledDates: { type: [Array, Function], default: () => [] },
    monthNameFormat: { type: String, default: "short" },
    startDate: { type: [Date, String], default: null },
    startTime: { type: [Object, Array], default: null },
    hideOffsetDates: { type: Boolean, default: false },
    noToday: { type: Boolean, default: false },
    disabledWeekDays: { type: Array, default: () => [] },
    allowedDates: { type: Array, default: null },
    nowButtonLabel: { type: String, default: "Now" },
    markers: { type: Array, default: () => [] },
    escClose: { type: Boolean, default: true },
    spaceConfirm: { type: Boolean, default: true },
    monthChangeOnArrows: { type: Boolean, default: true },
    presetDates: { type: Array, default: () => [] },
    flow: { type: Array, default: () => [] },
    partialFlow: { type: Boolean, default: false },
    preventMinMaxNavigation: { type: Boolean, default: false },
    reverseYears: { type: Boolean, default: false },
    weekPicker: { type: Boolean, default: false },
    filters: { type: Object, default: () => ({}) },
    arrowNavigation: { type: Boolean, default: false },
    highlight: {
      type: [Function, Object],
      default: null
    },
    teleport: { type: [Boolean, String, Object], default: null },
    teleportCenter: { type: Boolean, default: false },
    locale: { type: String, default: "en-Us" },
    weekNumName: { type: String, default: "W" },
    weekStart: { type: [Number, String], default: 1 },
    weekNumbers: {
      type: [String, Function, Object],
      default: null
    },
    monthChangeOnScroll: { type: [Boolean, String], default: true },
    dayNames: {
      type: [Function, Array],
      default: null
    },
    monthPicker: { type: Boolean, default: false },
    customProps: { type: Object, default: null },
    yearPicker: { type: Boolean, default: false },
    modelAuto: { type: Boolean, default: false },
    selectText: { type: String, default: "Select" },
    cancelText: { type: String, default: "Cancel" },
    previewFormat: {
      type: [String, Function],
      default: () => ""
    },
    multiDates: { type: [Object, Boolean], default: false },
    ignoreTimeValidation: { type: Boolean, default: false },
    minDate: { type: [Date, String], default: null },
    maxDate: { type: [Date, String], default: null },
    minTime: { type: Object, default: null },
    maxTime: { type: Object, default: null },
    name: { type: String, default: null },
    placeholder: { type: String, default: "" },
    hideInputIcon: { type: Boolean, default: false },
    clearable: { type: Boolean, default: true },
    alwaysClearable: { type: Boolean, default: false },
    state: { type: Boolean, default: null },
    required: { type: Boolean, default: false },
    autocomplete: { type: String, default: "off" },
    timePicker: { type: Boolean, default: false },
    enableSeconds: { type: Boolean, default: false },
    is24: { type: Boolean, default: true },
    noHoursOverlay: { type: Boolean, default: false },
    noMinutesOverlay: { type: Boolean, default: false },
    noSecondsOverlay: { type: Boolean, default: false },
    hoursGridIncrement: { type: [String, Number], default: 1 },
    minutesGridIncrement: { type: [String, Number], default: 5 },
    secondsGridIncrement: { type: [String, Number], default: 5 },
    hoursIncrement: { type: [Number, String], default: 1 },
    minutesIncrement: { type: [Number, String], default: 1 },
    secondsIncrement: { type: [Number, String], default: 1 },
    range: { type: [Boolean, Object], default: false },
    uid: { type: String, default: null },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    inline: { type: [Boolean, Object], default: false },
    textInput: { type: [Boolean, Object], default: false },
    sixWeeks: { type: [Boolean, String], default: false },
    actionRow: { type: Object, default: () => ({}) },
    focusStartDate: { type: Boolean, default: false },
    disabledTimes: { type: [Function, Array], default: void 0 },
    timePickerInline: { type: Boolean, default: false },
    calendar: { type: Function, default: null },
    config: { type: Object, default: void 0 },
    quarterPicker: { type: Boolean, default: false },
    yearFirst: { type: Boolean, default: false },
    loading: { type: Boolean, default: false },
    onInternalModelChange: { type: [Function, Object], default: null },
    enableMinutes: { type: Boolean, default: true },
    ui: { type: Object, default: () => ({}) }
  };
  var ct = __spreadProps(__spreadValues({}, pa), {
    shadow: { type: Boolean, default: false },
    flowStep: { type: Number, default: 0 },
    internalModelValue: { type: [Date, Array], default: null },
    noOverlayFocus: { type: Boolean, default: false },
    collapse: { type: Boolean, default: false },
    menuWrapRef: { type: Object, default: null },
    getInputRect: { type: Function, default: () => ({}) },
    isTextInputDate: { type: Boolean, default: false },
    isMobile: { type: Boolean, default: void 0 }
  });
  var or = ["title"];
  var sr = ["disabled"];
  var ur = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    __name: "ActionRow",
    props: __spreadValues({
      menuMount: { type: Boolean, default: false },
      calendarWidth: { type: Number, default: 0 }
    }, ct),
    emits: ["close-picker", "select-date", "select-now", "invalid-select"],
    setup(e, { emit: t }) {
      const r = t, a = e, {
        defaultedActionRow: n,
        defaultedPreviewFormat: u,
        defaultedMultiCalendars: c,
        defaultedTextInput: p2,
        defaultedInline: d,
        defaultedRange: Y,
        defaultedMultiDates: f
      } = Ye(a), { isTimeValid: O, isMonthValid: m } = Pt(a), { buildMatrix: P } = St(), F = ref(null), L = ref(null), _2 = ref(false), h2 = ref({}), R = ref(null), b = ref(null);
      onMounted(() => {
        a.arrowNavigation && P([He(F), He(L)], "actionRow"), j(), window.addEventListener("resize", j);
      }), onUnmounted(() => {
        window.removeEventListener("resize", j);
      });
      const j = () => {
        _2.value = false, setTimeout(() => {
          var ee, y;
          const v = (ee = R.value) == null ? void 0 : ee.getBoundingClientRect(), N = (y = b.value) == null ? void 0 : y.getBoundingClientRect();
          v && N && (h2.value.maxWidth = `${N.width - v.width - 20}px`), _2.value = true;
        }, 0);
      }, z = computed2(() => Y.value.enabled && !Y.value.partialRange && a.internalModelValue ? a.internalModelValue.length === 2 : true), ae2 = computed2(
        () => !O.value(a.internalModelValue) || !m.value(a.internalModelValue) || !z.value
      ), H = () => {
        const v = u.value;
        return a.timePicker || a.monthPicker, v(ze(a.internalModelValue));
      }, D = () => {
        const v = a.internalModelValue;
        return c.value.count > 0 ? `${Q2(v[0])} - ${Q2(v[1])}` : [Q2(v[0]), Q2(v[1])];
      }, Q2 = (v) => Ln(
        v,
        u.value,
        a.formatLocale,
        p2.value.rangeSeparator,
        a.modelAuto,
        u.value
      ), B = computed2(() => !a.internalModelValue || !a.menuMount ? "" : typeof u.value == "string" ? Array.isArray(a.internalModelValue) ? a.internalModelValue.length === 2 && a.internalModelValue[1] ? D() : f.value.enabled ? a.internalModelValue.map((v) => `${Q2(v)}`) : a.modelAuto ? `${Q2(a.internalModelValue[0])}` : `${Q2(a.internalModelValue[0])} -` : Q2(a.internalModelValue) : H()), q = () => f.value.enabled ? "; " : " - ", ve = computed2(
        () => Array.isArray(B.value) ? B.value.join(q()) : B.value
      ), pe2 = () => {
        O.value(a.internalModelValue) && m.value(a.internalModelValue) && z.value ? r("select-date") : r("invalid-select");
      };
      return (v, N) => (openBlock(), createElementBlock("div", {
        ref_key: "actionRowRef",
        ref: b,
        class: "dp__action_row"
      }, [
        v.$slots["action-row"] ? renderSlot(v.$slots, "action-row", normalizeProps(mergeProps({ key: 0 }, {
          internalModelValue: v.internalModelValue,
          disabled: ae2.value,
          selectDate: () => v.$emit("select-date"),
          closePicker: () => v.$emit("close-picker")
        }))) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          unref(n).showPreview ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "dp__selection_preview",
            title: ve.value,
            style: normalizeStyle(h2.value)
          }, [
            v.$slots["action-preview"] && _2.value ? renderSlot(v.$slots, "action-preview", {
              key: 0,
              value: v.internalModelValue
            }) : createCommentVNode("", true),
            !v.$slots["action-preview"] && _2.value ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(ve.value), 1)
            ], 64)) : createCommentVNode("", true)
          ], 12, or)) : createCommentVNode("", true),
          createBaseVNode("div", {
            ref_key: "actionBtnContainer",
            ref: R,
            class: "dp__action_buttons",
            "data-dp-element": "action-row"
          }, [
            v.$slots["action-buttons"] ? renderSlot(v.$slots, "action-buttons", {
              key: 0,
              value: v.internalModelValue
            }) : createCommentVNode("", true),
            v.$slots["action-buttons"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              !unref(d).enabled && unref(n).showCancel ? (openBlock(), createElementBlock("button", {
                key: 0,
                ref_key: "cancelButtonRef",
                ref: F,
                type: "button",
                class: "dp__action_button dp__action_cancel",
                onClick: N[0] || (N[0] = (ee) => v.$emit("close-picker")),
                onKeydown: N[1] || (N[1] = (ee) => unref(xe)(ee, () => v.$emit("close-picker")))
              }, toDisplayString(v.cancelText), 545)) : createCommentVNode("", true),
              unref(n).showNow ? (openBlock(), createElementBlock("button", {
                key: 1,
                type: "button",
                class: "dp__action_button dp__action_cancel",
                onClick: N[2] || (N[2] = (ee) => v.$emit("select-now")),
                onKeydown: N[3] || (N[3] = (ee) => unref(xe)(ee, () => v.$emit("select-now")))
              }, toDisplayString(v.nowButtonLabel), 33)) : createCommentVNode("", true),
              unref(n).showSelect ? (openBlock(), createElementBlock("button", {
                key: 2,
                ref_key: "selectButtonRef",
                ref: L,
                type: "button",
                class: "dp__action_button dp__action_select",
                disabled: ae2.value,
                "data-test-id": "select-button",
                onKeydown: N[4] || (N[4] = (ee) => unref(xe)(ee, () => pe2())),
                onClick: pe2
              }, toDisplayString(v.selectText), 41, sr)) : createCommentVNode("", true)
            ], 64))
          ], 512)
        ], 64))
      ], 512));
    }
  });
  var ir = ["role", "aria-label", "tabindex"];
  var dr = { class: "dp__selection_grid_header" };
  var cr = ["aria-selected", "aria-disabled", "data-test-id", "onClick", "onKeydown", "onMouseover"];
  var fr = ["aria-label"];
  var aa = /* @__PURE__ */ defineComponent({
    __name: "SelectionOverlay",
    props: {
      items: {},
      type: {},
      isLast: { type: Boolean },
      arrowNavigation: { type: Boolean },
      skipButtonRef: { type: Boolean },
      headerRefs: {},
      hideNavigation: {},
      escClose: { type: Boolean },
      useRelative: { type: Boolean },
      height: {},
      textInput: { type: [Boolean, Object] },
      config: {},
      noOverlayFocus: { type: Boolean },
      focusValue: {},
      menuWrapRef: {},
      ariaLabels: {},
      overlayLabel: {}
    },
    emits: ["selected", "toggle", "reset-flow", "hover-value"],
    setup(e, { expose: t, emit: r }) {
      const { setSelectionGrid: a, buildMultiLevelMatrix: n, setMonthPicker: u } = St(), c = r, p2 = e, { defaultedAriaLabels: d, defaultedTextInput: Y, defaultedConfig: f, handleEventPropagation: O } = Ye(
        p2
      ), { hideNavigationButtons: m } = ha(), P = ref(false), F = ref(null), L = ref(null), _2 = ref([]), h2 = ref(), R = ref(null), b = ref(0), j = ref(null);
      onBeforeUpdate(() => {
        F.value = null;
      }), onMounted(() => {
        nextTick().then(() => ve()), p2.noOverlayFocus || ae2(), z(true);
      }), onUnmounted(() => z(false));
      const z = (i) => {
        var W;
        p2.arrowNavigation && ((W = p2.headerRefs) != null && W.length ? u(i) : a(i));
      }, ae2 = () => {
        var W;
        const i = He(L);
        i && (Y.value.enabled || (F.value ? (W = F.value) == null || W.focus({ preventScroll: true }) : i.focus({ preventScroll: true })), P.value = i.clientHeight < i.scrollHeight);
      }, H = computed2(
        () => ({
          dp__overlay: true,
          "dp--overlay-absolute": !p2.useRelative,
          "dp--overlay-relative": p2.useRelative
        })
      ), D = computed2(
        () => p2.useRelative ? { height: `${p2.height}px`, width: "var(--dp-menu-min-width)" } : void 0
      ), Q2 = computed2(() => ({
        dp__overlay_col: true
      })), B = computed2(
        () => ({
          dp__btn: true,
          dp__button: true,
          dp__overlay_action: true,
          dp__over_action_scroll: P.value,
          dp__button_bottom: p2.isLast
        })
      ), q = computed2(() => {
        var i, W;
        return {
          dp__overlay_container: true,
          dp__container_flex: ((i = p2.items) == null ? void 0 : i.length) <= 6,
          dp__container_block: ((W = p2.items) == null ? void 0 : W.length) > 6
        };
      });
      watch2(
        () => p2.items,
        () => ve(false),
        { deep: true }
      );
      const ve = (i = true) => {
        nextTick().then(() => {
          const W = He(F), se = He(L), T = He(R), re = He(j), l = T ? T.getBoundingClientRect().height : 0;
          se && (se.getBoundingClientRect().height ? b.value = se.getBoundingClientRect().height - l : b.value = f.value.modeHeight - l), W && re && i && (re.scrollTop = W.offsetTop - re.offsetTop - (b.value / 2 - W.getBoundingClientRect().height) - l);
        });
      }, pe2 = (i) => {
        i.disabled || c("selected", i.value);
      }, v = () => {
        c("toggle"), c("reset-flow");
      }, N = (i) => {
        p2.escClose && (v(), O(i));
      }, ee = (i, W, se, T) => {
        i && ((W.active || W.value === p2.focusValue) && (F.value = i), p2.arrowNavigation && (Array.isArray(_2.value[se]) ? _2.value[se][T] = i : _2.value[se] = [i], y()));
      }, y = () => {
        var W, se;
        const i = (W = p2.headerRefs) != null && W.length ? [p2.headerRefs].concat(_2.value) : _2.value.concat([p2.skipButtonRef ? [] : [R.value]]);
        n(ze(i), (se = p2.headerRefs) != null && se.length ? "monthPicker" : "selectionGrid");
      }, U = (i) => {
        p2.arrowNavigation || $t(i, f.value, true);
      }, S = (i) => {
        h2.value = i, c("hover-value", i);
      }, Z = () => {
        var _a3;
        if (v(), !p2.isLast) {
          const i = Fa((_a3 = p2.menuWrapRef) != null ? _a3 : null, "action-row");
          if (i) {
            const W = Rn(i);
            W == null || W.focus();
          }
        }
      }, A = (i) => {
        switch (i.key) {
          case Oe.esc:
            return N(i);
          case Oe.arrowLeft:
            return U(i);
          case Oe.arrowRight:
            return U(i);
          case Oe.arrowUp:
            return U(i);
          case Oe.arrowDown:
            return U(i);
          default:
            return;
        }
      }, ie = (i) => {
        if (i.key === Oe.enter)
          return v();
        if (i.key === Oe.tab)
          return Z();
      };
      return t({ focusGrid: ae2 }), (i, W) => {
        var se;
        return openBlock(), createElementBlock("div", {
          ref_key: "gridWrapRef",
          ref: L,
          class: normalizeClass(H.value),
          style: normalizeStyle(D.value),
          role: i.useRelative ? void 0 : "dialog",
          "aria-label": i.overlayLabel,
          tabindex: i.useRelative ? void 0 : "0",
          onKeydown: A,
          onClick: W[0] || (W[0] = withModifiers(() => {
          }, ["prevent"]))
        }, [
          createBaseVNode("div", {
            ref_key: "containerRef",
            ref: j,
            class: normalizeClass(q.value),
            style: normalizeStyle({ "--dp-overlay-height": `${b.value}px` }),
            role: "grid"
          }, [
            createBaseVNode("div", dr, [
              renderSlot(i.$slots, "header")
            ]),
            i.$slots.overlay ? renderSlot(i.$slots, "overlay", { key: 0 }) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(i.items, (T, re) => (openBlock(), createElementBlock("div", {
              key: re,
              class: normalizeClass(["dp__overlay_row", { dp__flex_row: i.items.length >= 3 }]),
              role: "row"
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(T, (l, w) => (openBlock(), createElementBlock("div", {
                key: l.value,
                ref_for: true,
                ref: (oe2) => ee(oe2, l, re, w),
                role: "gridcell",
                class: normalizeClass(Q2.value),
                "aria-selected": l.active || void 0,
                "aria-disabled": l.disabled || void 0,
                tabindex: "0",
                "data-test-id": l.text,
                onClick: withModifiers((oe2) => pe2(l), ["prevent"]),
                onKeydown: (oe2) => unref(xe)(oe2, () => pe2(l), true),
                onMouseover: (oe2) => S(l.value)
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(l.className)
                }, [
                  i.$slots.item ? renderSlot(i.$slots, "item", {
                    key: 0,
                    item: l
                  }) : createCommentVNode("", true),
                  i.$slots.item ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createTextVNode(toDisplayString(l.text), 1)
                  ], 64))
                ], 2)
              ], 42, cr))), 128))
            ], 2))), 128))
          ], 6),
          i.$slots["button-icon"] ? withDirectives((openBlock(), createElementBlock("button", {
            key: 0,
            ref_key: "toggleButton",
            ref: R,
            type: "button",
            "aria-label": (se = unref(d)) == null ? void 0 : se.toggleOverlay,
            class: normalizeClass(B.value),
            tabindex: "0",
            onClick: v,
            onKeydown: ie
          }, [
            renderSlot(i.$slots, "button-icon")
          ], 42, fr)), [
            [vShow, !unref(m)(i.hideNavigation, i.type)]
          ]) : createCommentVNode("", true)
        ], 46, ir);
      };
    }
  });
  var vr = ["data-dp-mobile"];
  var ya = /* @__PURE__ */ defineComponent({
    __name: "InstanceWrap",
    props: {
      multiCalendars: {},
      stretch: { type: Boolean },
      collapse: { type: Boolean },
      isMobile: { type: Boolean }
    },
    setup(e) {
      const t = e, r = computed2(
        () => t.multiCalendars > 0 ? [...Array(t.multiCalendars).keys()] : [0]
      ), a = computed2(() => ({
        dp__instance_calendar: t.multiCalendars > 0
      }));
      return (n, u) => (openBlock(), createElementBlock("div", {
        class: normalizeClass({
          dp__menu_inner: !n.stretch,
          "dp--menu--inner-stretched": n.stretch,
          dp__flex_display: n.multiCalendars > 0,
          "dp--flex-display-collapsed": n.collapse
        }),
        "data-dp-mobile": n.isMobile
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(r.value, (c, p2) => (openBlock(), createElementBlock("div", {
          key: c,
          class: normalizeClass(a.value)
        }, [
          renderSlot(n.$slots, "default", {
            instance: c,
            index: p2
          })
        ], 2))), 128))
      ], 10, vr));
    }
  });
  var mr = ["data-dp-element", "aria-label", "aria-disabled"];
  var qt = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    __name: "ArrowBtn",
    props: {
      ariaLabel: {},
      elName: {},
      disabled: { type: Boolean }
    },
    emits: ["activate", "set-ref"],
    setup(e, { emit: t }) {
      const r = t, a = ref(null);
      return onMounted(() => r("set-ref", a)), (n, u) => (openBlock(), createElementBlock("button", {
        ref_key: "elRef",
        ref: a,
        type: "button",
        "data-dp-element": n.elName,
        class: "dp__btn dp--arrow-btn-nav",
        tabindex: "0",
        "aria-label": n.ariaLabel,
        "aria-disabled": n.disabled || void 0,
        onClick: u[0] || (u[0] = (c) => n.$emit("activate")),
        onKeydown: u[1] || (u[1] = (c) => unref(xe)(c, () => n.$emit("activate"), true))
      }, [
        createBaseVNode("span", {
          class: normalizeClass(["dp__inner_nav", { dp__inner_nav_disabled: n.disabled }])
        }, [
          renderSlot(n.$slots, "default")
        ], 2)
      ], 40, mr));
    }
  });
  var pr = ["aria-label", "data-test-id"];
  var Hn = /* @__PURE__ */ defineComponent({
    __name: "YearModePicker",
    props: __spreadProps(__spreadValues({}, ct), {
      showYearPicker: { type: Boolean, default: false },
      items: { type: Array, default: () => [] },
      instance: { type: Number, default: 0 },
      year: { type: Number, default: 0 },
      isDisabled: { type: Function, default: () => false }
    }),
    emits: ["toggle-year-picker", "year-select", "handle-year"],
    setup(e, { emit: t }) {
      const r = t, a = e, { showRightIcon: n, showLeftIcon: u } = ha(), { defaultedConfig: c, defaultedMultiCalendars: p2, defaultedAriaLabels: d, defaultedTransitions: Y, defaultedUI: f } = Ye(a), { showTransition: O, transitionName: m } = na(Y), P = ref(false), F = (h2 = false, R) => {
        P.value = !P.value, r("toggle-year-picker", { flow: h2, show: R });
      }, L = (h2) => {
        P.value = false, r("year-select", h2);
      }, _2 = (h2 = false) => {
        r("handle-year", h2);
      };
      return (h2, R) => {
        var b, j, z, ae2, H;
        return openBlock(), createElementBlock(Fragment, null, [
          createBaseVNode("div", {
            class: normalizeClass(["dp--year-mode-picker", { "dp--hidden-el": P.value }])
          }, [
            unref(u)(unref(p2), e.instance) ? (openBlock(), createBlock(qt, {
              key: 0,
              ref: "mpPrevIconRef",
              "aria-label": (b = unref(d)) == null ? void 0 : b.prevYear,
              disabled: e.isDisabled(false),
              class: normalizeClass((j = unref(f)) == null ? void 0 : j.navBtnPrev),
              onActivate: R[0] || (R[0] = (D) => _2(false))
            }, {
              default: withCtx(() => [
                h2.$slots["arrow-left"] ? renderSlot(h2.$slots, "arrow-left", { key: 0 }) : createCommentVNode("", true),
                h2.$slots["arrow-left"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Wa), { key: 1 }))
              ]),
              _: 3
            }, 8, ["aria-label", "disabled", "class"])) : createCommentVNode("", true),
            createBaseVNode("button", {
              ref: "mpYearButtonRef",
              class: "dp__btn dp--year-select",
              type: "button",
              "aria-label": `${e.year}-${(z = unref(d)) == null ? void 0 : z.openYearsOverlay}`,
              "data-test-id": `year-mode-btn-${e.instance}`,
              onClick: R[1] || (R[1] = () => F(false)),
              onKeydown: R[2] || (R[2] = withKeys(() => F(false), ["enter"]))
            }, [
              h2.$slots.year ? renderSlot(h2.$slots, "year", {
                key: 0,
                year: e.year
              }) : createCommentVNode("", true),
              h2.$slots.year ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString(e.year), 1)
              ], 64))
            ], 40, pr),
            unref(n)(unref(p2), e.instance) ? (openBlock(), createBlock(qt, {
              key: 1,
              ref: "mpNextIconRef",
              "aria-label": (ae2 = unref(d)) == null ? void 0 : ae2.nextYear,
              disabled: e.isDisabled(true),
              class: normalizeClass((H = unref(f)) == null ? void 0 : H.navBtnNext),
              onActivate: R[3] || (R[3] = (D) => _2(true))
            }, {
              default: withCtx(() => [
                h2.$slots["arrow-right"] ? renderSlot(h2.$slots, "arrow-right", { key: 0 }) : createCommentVNode("", true),
                h2.$slots["arrow-right"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Va), { key: 1 }))
              ]),
              _: 3
            }, 8, ["aria-label", "disabled", "class"])) : createCommentVNode("", true)
          ], 2),
          createVNode(Transition, {
            name: unref(m)(e.showYearPicker),
            css: unref(O)
          }, {
            default: withCtx(() => {
              var D, Q2;
              return [
                e.showYearPicker ? (openBlock(), createBlock(aa, {
                  key: 0,
                  items: e.items,
                  "text-input": h2.textInput,
                  "esc-close": h2.escClose,
                  config: h2.config,
                  "is-last": h2.autoApply && !unref(c).keepActionRow,
                  "hide-navigation": h2.hideNavigation,
                  "aria-labels": h2.ariaLabels,
                  "overlay-label": (Q2 = (D = unref(d)) == null ? void 0 : D.yearPicker) == null ? void 0 : Q2.call(D, true),
                  type: "year",
                  onToggle: F,
                  onSelected: R[4] || (R[4] = (B) => L(B))
                }, createSlots({
                  "button-icon": withCtx(() => [
                    h2.$slots["calendar-icon"] ? renderSlot(h2.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
                    h2.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Gt), { key: 1 }))
                  ]),
                  _: 2
                }, [
                  h2.$slots["year-overlay-value"] ? {
                    name: "item",
                    fn: withCtx(({ item: B }) => [
                      renderSlot(h2.$slots, "year-overlay-value", {
                        text: B.text,
                        value: B.value
                      })
                    ]),
                    key: "0"
                  } : void 0
                ]), 1032, ["items", "text-input", "esc-close", "config", "is-last", "hide-navigation", "aria-labels", "overlay-label"])) : createCommentVNode("", true)
              ];
            }),
            _: 3
          }, 8, ["name", "css"])
        ], 64);
      };
    }
  });
  var xa = (e, t, r) => {
    if (t.value && Array.isArray(t.value))
      if (t.value.some((a) => Te(e, a))) {
        const a = t.value.filter((n) => !Te(n, e));
        t.value = a.length ? a : null;
      } else
        (r && +r > t.value.length || !r) && t.value.push(e);
    else
      t.value = [e];
  };
  var en = (e, t, r) => {
    let a = e.value ? e.value.slice() : [];
    return a.length === 2 && a[1] !== null && (a = []), a.length ? (Ne(t, a[0]) ? a.unshift(t) : a[1] = t, r("range-end", t)) : (a = [t], r("range-start", t)), a;
  };
  var ga = (e, t, r, a) => {
    e && (e[0] && e[1] && r && t("auto-apply"), e[0] && !e[1] && a && r && t("auto-apply"));
  };
  var Un = (e) => {
    Array.isArray(e.value) && e.value.length <= 2 && e.range ? e.modelValue.value = e.value.map((t) => tt2(K(t), e.timezone)) : Array.isArray(e.value) || (e.modelValue.value = tt2(K(e.value), e.timezone));
  };
  var Wn = (e, t, r, a) => Array.isArray(t.value) && (t.value.length === 2 || t.value.length === 1 && a.value.partialRange) ? a.value.fixedStart && (Fe(e, t.value[0]) || Te(e, t.value[0])) ? [t.value[0], e] : a.value.fixedEnd && (Ne(e, t.value[1]) || Te(e, t.value[1])) ? [e, t.value[1]] : (r("invalid-fixed-range", e), t.value) : [];
  var Vn = ({
    multiCalendars: e,
    range: t,
    highlight: r,
    propDates: a,
    calendars: n,
    modelValue: u,
    props: c,
    filters: p2,
    year: d,
    month: Y,
    emit: f
  }) => {
    const O = computed2(() => qa(c.yearRange, c.locale, c.reverseYears)), m = ref([false]), P = computed2(() => (B, q) => {
      const ve = set(dt(/* @__PURE__ */ new Date()), {
        month: Y.value(B),
        year: d.value(B)
      }), pe2 = q ? endOfYear2(ve) : startOfYear2(ve);
      return Nn(
        pe2,
        a.value.maxDate,
        a.value.minDate,
        c.preventMinMaxNavigation,
        q
      );
    }), F = () => Array.isArray(u.value) && e.value.solo && u.value[1], L = () => {
      for (let B = 0; B < e.value.count; B++)
        if (B === 0)
          n.value[B] = n.value[0];
        else if (B === e.value.count - 1 && F())
          n.value[B] = {
            month: getMonth2(u.value[1]),
            year: getYear2(u.value[1])
          };
        else {
          const q = set(K(), n.value[B - 1]);
          n.value[B] = { month: getMonth2(q), year: getYear2(addYears(q, 1)) };
        }
    }, _2 = (B) => {
      if (!B)
        return L();
      const q = set(K(), n.value[B]);
      return n.value[0].year = getYear2(subYears(q, e.value.count - 1)), L();
    }, h2 = (B, q) => {
      const ve = differenceInYears(q, B);
      return t.value.showLastInRange && ve > 1 ? q : B;
    }, R = (B) => c.focusStartDate || e.value.solo ? B[0] : B[1] ? h2(B[0], B[1]) : B[0], b = () => {
      if (u.value) {
        const B = Array.isArray(u.value) ? R(u.value) : u.value;
        n.value[0] = { month: getMonth2(B), year: getYear2(B) };
      }
    }, j = () => {
      b(), e.value.count && L();
    };
    watch2(u, (B, q) => {
      c.isTextInputDate && JSON.stringify(B != null ? B : {}) !== JSON.stringify(q != null ? q : {}) && j();
    }), onMounted(() => {
      j();
    });
    const z = (B, q) => {
      n.value[q].year = B, f("update-month-year", { instance: q, year: B, month: n.value[q].month }), e.value.count && !e.value.solo && _2(q);
    }, ae2 = computed2(() => (B) => Wt(O.value, (q) => {
      var N;
      const ve = d.value(B) === q.value, pe2 = xt(
        q.value,
        Vt(a.value.minDate),
        Vt(a.value.maxDate)
      ) || ((N = p2.value.years) == null ? void 0 : N.includes(d.value(B))), v = Za(r.value, q.value);
      return { active: ve, disabled: pe2, highlighted: v };
    })), H = (B, q) => {
      z(B, q), Q2(q);
    }, D = (B, q = false) => {
      if (!P.value(B, q)) {
        const ve = q ? d.value(B) + 1 : d.value(B) - 1;
        z(ve, B);
      }
    }, Q2 = (B, q = false, ve) => {
      q || f("reset-flow"), ve !== void 0 ? m.value[B] = ve : m.value[B] = !m.value[B], m.value[B] ? f("overlay-toggle", { open: true, overlay: qe.year }) : (f("overlay-closed"), f("overlay-toggle", { open: false, overlay: qe.year }));
    };
    return {
      isDisabled: P,
      groupedYears: ae2,
      showYearPicker: m,
      selectYear: z,
      toggleYearPicker: Q2,
      handleYearSelect: H,
      handleYear: D
    };
  };
  var yr = (e, t) => {
    const {
      defaultedMultiCalendars: r,
      defaultedAriaLabels: a,
      defaultedTransitions: n,
      defaultedConfig: u,
      defaultedRange: c,
      defaultedHighlight: p2,
      propDates: d,
      defaultedTz: Y,
      defaultedFilters: f,
      defaultedMultiDates: O
    } = Ye(e), m = () => {
      e.isTextInputDate && j(getYear2(K(e.startDate)), 0);
    }, { modelValue: P, year: F, month: L, calendars: _2 } = la(e, t, m), h2 = computed2(() => Sn(e.formatLocale, e.locale, e.monthNameFormat)), R = ref(null), { checkMinMaxRange: b } = Pt(e), {
      selectYear: j,
      groupedYears: z,
      showYearPicker: ae2,
      toggleYearPicker: H,
      handleYearSelect: D,
      handleYear: Q2,
      isDisabled: B
    } = Vn({
      modelValue: P,
      multiCalendars: r,
      range: c,
      highlight: p2,
      calendars: _2,
      year: F,
      propDates: d,
      month: L,
      filters: f,
      props: e,
      emit: t
    });
    onMounted(() => {
      e.startDate && (P.value && e.focusStartDate || !P.value) && j(getYear2(K(e.startDate)), 0);
    });
    const q = (T) => T ? { month: getMonth2(T), year: getYear2(T) } : { month: null, year: null }, ve = () => P.value ? Array.isArray(P.value) ? P.value.map((T) => q(T)) : q(P.value) : q(), pe2 = (T, re) => {
      const l = _2.value[T], w = ve();
      return Array.isArray(w) ? w.some((oe2) => oe2.year === (l == null ? void 0 : l.year) && oe2.month === re) : (l == null ? void 0 : l.year) === w.year && re === w.month;
    }, v = (T, re, l) => {
      var oe2, M;
      const w = ve();
      return Array.isArray(w) ? F.value(re) === ((oe2 = w[l]) == null ? void 0 : oe2.year) && T === ((M = w[l]) == null ? void 0 : M.month) : false;
    }, N = (T, re) => {
      if (c.value.enabled) {
        const l = ve();
        if (Array.isArray(P.value) && Array.isArray(l)) {
          const w = v(T, re, 0) || v(T, re, 1), oe2 = ht(dt(K()), T, F.value(re));
          return ea(P.value, R.value, oe2) && !w;
        }
        return false;
      }
      return false;
    }, ee = computed2(() => (T) => Wt(h2.value, (re) => {
      var he2;
      const l = pe2(T, re.value), w = xt(
        re.value,
        _n(F.value(T), d.value.minDate),
        Yn(F.value(T), d.value.maxDate)
      ) || Fl(d.value.disabledDates, F.value(T), re.value) || ((he2 = f.value.months) == null ? void 0 : he2.includes(re.value)) || !zl(d.value.allowedDates, F.value(T), re.value), oe2 = N(re.value, T), M = Fn(p2.value, re.value, F.value(T));
      return { active: l, disabled: w, isBetween: oe2, highlighted: M };
    })), y = (T, re) => ht(dt(K()), T, F.value(re)), U = (T, re) => {
      const l = P.value ? P.value : dt(/* @__PURE__ */ new Date());
      P.value = ht(l, T, F.value(re)), t("auto-apply"), t("update-flow-step");
    }, S = (T, re) => {
      const l = y(T, re);
      c.value.fixedEnd || c.value.fixedStart ? P.value = Wn(l, P, t, c) : P.value ? b(l, P.value) && (P.value = en(P, y(T, re), t)) : P.value = [y(T, re)], nextTick().then(() => {
        ga(P.value, t, e.autoApply, e.modelAuto);
      });
    }, Z = (T, re) => {
      xa(y(T, re), P, O.value.limit), t("auto-apply", true);
    }, A = (T, re) => (_2.value[re].month = T, i(re, _2.value[re].year, T), O.value.enabled ? Z(T, re) : c.value.enabled ? S(T, re) : U(T, re)), ie = (T, re) => {
      j(T, re), i(re, T, null);
    }, i = (T, re, l) => {
      let w = l;
      if (!w && w !== 0) {
        const oe2 = ve();
        w = Array.isArray(oe2) ? oe2[T].month : oe2.month;
      }
      t("update-month-year", { instance: T, year: re, month: w });
    };
    return {
      groupedMonths: ee,
      groupedYears: z,
      year: F,
      isDisabled: B,
      defaultedMultiCalendars: r,
      defaultedAriaLabels: a,
      defaultedTransitions: n,
      defaultedConfig: u,
      showYearPicker: ae2,
      modelValue: P,
      presetDate: (T, re) => {
        Un({
          value: T,
          modelValue: P,
          range: c.value.enabled,
          timezone: re ? void 0 : Y.value.timezone
        }), t("auto-apply");
      },
      setHoverDate: (T, re) => {
        R.value = y(T, re);
      },
      selectMonth: A,
      selectYear: ie,
      toggleYearPicker: H,
      handleYearSelect: D,
      handleYear: Q2,
      getModelMonthYear: ve
    };
  };
  var gr = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    __name: "MonthPicker",
    props: __spreadValues({}, ct),
    emits: [
      "update:internal-model-value",
      "overlay-closed",
      "reset-flow",
      "range-start",
      "range-end",
      "auto-apply",
      "update-month-year",
      "update-flow-step",
      "mount",
      "invalid-fixed-range",
      "overlay-toggle"
    ],
    setup(e, { expose: t, emit: r }) {
      const a = r, n = useSlots(), u = at(n, "yearMode"), c = e;
      onMounted(() => {
        c.shadow || a("mount", null);
      });
      const {
        groupedMonths: p2,
        groupedYears: d,
        year: Y,
        isDisabled: f,
        defaultedMultiCalendars: O,
        defaultedConfig: m,
        showYearPicker: P,
        modelValue: F,
        presetDate: L,
        setHoverDate: _2,
        selectMonth: h2,
        selectYear: R,
        toggleYearPicker: b,
        handleYearSelect: j,
        handleYear: z,
        getModelMonthYear: ae2
      } = yr(c, a);
      return t({ getSidebarProps: () => ({
        modelValue: F,
        year: Y,
        getModelMonthYear: ae2,
        selectMonth: h2,
        selectYear: R,
        handleYear: z
      }), presetDate: L, toggleYearPicker: (D) => b(0, D) }), (D, Q2) => (openBlock(), createBlock(ya, {
        "multi-calendars": unref(O).count,
        collapse: D.collapse,
        stretch: "",
        "is-mobile": D.isMobile
      }, {
        default: withCtx(({ instance: B }) => [
          D.$slots["top-extra"] ? renderSlot(D.$slots, "top-extra", {
            key: 0,
            value: D.internalModelValue
          }) : createCommentVNode("", true),
          D.$slots["month-year"] ? renderSlot(D.$slots, "month-year", normalizeProps(mergeProps({ key: 1 }, {
            year: unref(Y),
            months: unref(p2)(B),
            years: unref(d)(B),
            selectMonth: unref(h2),
            selectYear: unref(R),
            instance: B
          }))) : (openBlock(), createBlock(aa, {
            key: 2,
            items: unref(p2)(B),
            "arrow-navigation": D.arrowNavigation,
            "is-last": D.autoApply && !unref(m).keepActionRow,
            "esc-close": D.escClose,
            height: unref(m).modeHeight,
            config: D.config,
            "no-overlay-focus": !!(D.noOverlayFocus || D.textInput),
            "use-relative": "",
            type: "month",
            onSelected: (q) => unref(h2)(q, B),
            onHoverValue: (q) => unref(_2)(q, B)
          }, createSlots({
            header: withCtx(() => [
              createVNode(Hn, mergeProps(D.$props, {
                items: unref(d)(B),
                instance: B,
                "show-year-picker": unref(P)[B],
                year: unref(Y)(B),
                "is-disabled": (q) => unref(f)(B, q),
                onHandleYear: (q) => unref(z)(B, q),
                onYearSelect: (q) => unref(j)(q, B),
                onToggleYearPicker: (q) => unref(b)(B, q == null ? void 0 : q.flow, q == null ? void 0 : q.show)
              }), createSlots({ _: 2 }, [
                renderList(unref(u), (q, ve) => ({
                  name: q,
                  fn: withCtx((pe2) => [
                    renderSlot(D.$slots, q, normalizeProps(guardReactiveProps(pe2)))
                  ])
                }))
              ]), 1040, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])
            ]),
            _: 2
          }, [
            D.$slots["month-overlay-value"] ? {
              name: "item",
              fn: withCtx(({ item: q }) => [
                renderSlot(D.$slots, "month-overlay-value", {
                  text: q.text,
                  value: q.value
                })
              ]),
              key: "0"
            } : void 0
          ]), 1032, ["items", "arrow-navigation", "is-last", "esc-close", "height", "config", "no-overlay-focus", "onSelected", "onHoverValue"]))
        ]),
        _: 3
      }, 8, ["multi-calendars", "collapse", "is-mobile"]));
    }
  });
  var hr = (e, t) => {
    const r = () => {
      e.isTextInputDate && (f.value = getYear2(K(e.startDate)));
    }, { modelValue: a } = la(e, t, r), n = ref(null), { defaultedHighlight: u, defaultedMultiDates: c, defaultedFilters: p2, defaultedRange: d, propDates: Y } = Ye(e), f = ref();
    onMounted(() => {
      e.startDate && (a.value && e.focusStartDate || !a.value) && (f.value = getYear2(K(e.startDate)));
    });
    const O = (b) => Array.isArray(a.value) ? a.value.some((j) => getYear2(j) === b) : a.value ? getYear2(a.value) === b : false, m = (b) => d.value.enabled && Array.isArray(a.value) ? ea(a.value, n.value, _2(b)) : false, P = (b) => Y.value.allowedDates instanceof Map ? Y.value.allowedDates.size ? Y.value.allowedDates.has(`${b}`) : false : true, F = (b) => Y.value.disabledDates instanceof Map ? Y.value.disabledDates.size ? Y.value.disabledDates.has(`${b}`) : false : true, L = computed2(() => Wt(qa(e.yearRange, e.locale, e.reverseYears), (b) => {
      const j = O(b.value), z = xt(
        b.value,
        Vt(Y.value.minDate),
        Vt(Y.value.maxDate)
      ) || p2.value.years.includes(b.value) || !P(b.value) || F(b.value), ae2 = m(b.value) && !j, H = Za(u.value, b.value);
      return { active: j, disabled: z, isBetween: ae2, highlighted: H };
    })), _2 = (b) => setYear2(dt(startOfYear2(/* @__PURE__ */ new Date())), b);
    return {
      groupedYears: L,
      modelValue: a,
      focusYear: f,
      setHoverValue: (b) => {
        n.value = setYear2(dt(/* @__PURE__ */ new Date()), b);
      },
      selectYear: (b) => {
        var j;
        if (t("update-month-year", { instance: 0, year: b }), c.value.enabled)
          return a.value ? Array.isArray(a.value) && (((j = a.value) == null ? void 0 : j.map((ae2) => getYear2(ae2))).includes(b) ? a.value = a.value.filter((ae2) => getYear2(ae2) !== b) : a.value.push(setYear2(je(K()), b))) : a.value = [setYear2(je(startOfYear2(K())), b)], t("auto-apply", true);
        d.value.enabled ? (a.value = en(a, _2(b), t), nextTick().then(() => {
          ga(a.value, t, e.autoApply, e.modelAuto);
        })) : (a.value = _2(b), t("auto-apply"));
      }
    };
  };
  var br = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    __name: "YearPicker",
    props: __spreadValues({}, ct),
    emits: [
      "update:internal-model-value",
      "reset-flow",
      "range-start",
      "range-end",
      "auto-apply",
      "update-month-year"
    ],
    setup(e, { expose: t, emit: r }) {
      const a = r, n = e, { groupedYears: u, modelValue: c, focusYear: p2, selectYear: d, setHoverValue: Y } = hr(n, a), { defaultedConfig: f } = Ye(n);
      return t({ getSidebarProps: () => ({
        modelValue: c,
        selectYear: d
      }) }), (m, P) => (openBlock(), createElementBlock("div", null, [
        m.$slots["top-extra"] ? renderSlot(m.$slots, "top-extra", {
          key: 0,
          value: m.internalModelValue
        }) : createCommentVNode("", true),
        m.$slots["month-year"] ? renderSlot(m.$slots, "month-year", normalizeProps(mergeProps({ key: 1 }, {
          years: unref(u),
          selectYear: unref(d)
        }))) : (openBlock(), createBlock(aa, {
          key: 2,
          items: unref(u),
          "is-last": m.autoApply && !unref(f).keepActionRow,
          height: unref(f).modeHeight,
          config: m.config,
          "no-overlay-focus": !!(m.noOverlayFocus || m.textInput),
          "focus-value": unref(p2),
          type: "year",
          "use-relative": "",
          onSelected: unref(d),
          onHoverValue: unref(Y)
        }, createSlots({ _: 2 }, [
          m.$slots["year-overlay-value"] ? {
            name: "item",
            fn: withCtx(({ item: F }) => [
              renderSlot(m.$slots, "year-overlay-value", {
                text: F.text,
                value: F.value
              })
            ]),
            key: "0"
          } : void 0
        ]), 1032, ["items", "is-last", "height", "config", "no-overlay-focus", "focus-value", "onSelected", "onHoverValue"]))
      ]));
    }
  });
  var kr = {
    key: 0,
    class: "dp__time_input"
  };
  var wr = ["data-compact", "data-collapsed"];
  var Dr = ["data-test-id", "aria-label", "onKeydown", "onClick", "onMousedown"];
  var Mr = ["aria-label", "disabled", "data-test-id", "onKeydown", "onClick"];
  var $r = ["data-test-id", "aria-label", "onKeydown", "onClick", "onMousedown"];
  var Ar = { key: 0 };
  var Tr = ["aria-label", "data-compact"];
  var Sr = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    __name: "TimeInput",
    props: __spreadValues({
      hours: { type: Number, default: 0 },
      minutes: { type: Number, default: 0 },
      seconds: { type: Number, default: 0 },
      closeTimePickerBtn: { type: Object, default: null },
      order: { type: Number, default: 0 },
      disabledTimesConfig: { type: Function, default: null },
      validateTime: { type: Function, default: () => false }
    }, ct),
    emits: [
      "set-hours",
      "set-minutes",
      "update:hours",
      "update:minutes",
      "update:seconds",
      "reset-flow",
      "mounted",
      "overlay-closed",
      "overlay-opened",
      "am-pm-change"
    ],
    setup(e, { expose: t, emit: r }) {
      const a = r, n = e, { setTimePickerElements: u, setTimePickerBackRef: c } = St(), {
        defaultedAriaLabels: p2,
        defaultedTransitions: d,
        defaultedFilters: Y,
        defaultedConfig: f,
        defaultedRange: O,
        defaultedMultiCalendars: m
      } = Ye(n), { transitionName: P, showTransition: F } = na(d), L = reactive({
        hours: false,
        minutes: false,
        seconds: false
      }), _2 = ref("AM"), h2 = ref(null), R = ref([]), b = ref(), j = ref(false);
      onMounted(() => {
        a("mounted");
      });
      const z = (o) => set(/* @__PURE__ */ new Date(), {
        hours: o.hours,
        minutes: o.minutes,
        seconds: n.enableSeconds ? o.seconds : 0,
        milliseconds: 0
      }), ae2 = computed2(
        () => (o) => S(o, n[o]) || D(o, n[o])
      ), H = computed2(() => ({ hours: n.hours, minutes: n.minutes, seconds: n.seconds })), D = (o, E) => O.value.enabled && !O.value.disableTimeRangeValidation ? !n.validateTime(o, E) : false, Q2 = (o, E) => {
        if (O.value.enabled && !O.value.disableTimeRangeValidation) {
          const fe = E ? +n[`${o}Increment`] : -+n[`${o}Increment`], I = n[o] + fe;
          return !n.validateTime(o, I);
        }
        return false;
      }, B = computed2(() => (o) => !W(+n[o] + +n[`${o}Increment`], o) || Q2(o, true)), q = computed2(() => (o) => !W(+n[o] - +n[`${o}Increment`], o) || Q2(o, false)), ve = (o, E) => add(set(K(), o), E), pe2 = (o, E) => sub(set(K(), o), E), v = computed2(
        () => ({
          dp__time_col: true,
          dp__time_col_block: !n.timePickerInline,
          dp__time_col_reg_block: !n.enableSeconds && n.is24 && !n.timePickerInline,
          dp__time_col_reg_inline: !n.enableSeconds && n.is24 && n.timePickerInline,
          dp__time_col_reg_with_button: !n.enableSeconds && !n.is24,
          dp__time_col_sec: n.enableSeconds && n.is24,
          dp__time_col_sec_with_button: n.enableSeconds && !n.is24
        })
      ), N = computed2(
        () => n.timePickerInline && O.value.enabled && !m.value.count
      ), ee = computed2(() => {
        const o = [{ type: "hours" }];
        return n.enableMinutes && o.push({ type: "", separator: true }, {
          type: "minutes"
        }), n.enableSeconds && o.push({ type: "", separator: true }, {
          type: "seconds"
        }), o;
      }), y = computed2(() => ee.value.filter((o) => !o.separator)), U = computed2(() => (o) => {
        if (o === "hours") {
          const E = oe2(+n.hours);
          return { text: E < 10 ? `0${E}` : `${E}`, value: E };
        }
        return { text: n[o] < 10 ? `0${n[o]}` : `${n[o]}`, value: n[o] };
      }), S = (o, E) => {
        var I;
        if (!n.disabledTimesConfig)
          return false;
        const fe = n.disabledTimesConfig(n.order, o === "hours" ? E : void 0);
        return fe[o] ? !!((I = fe[o]) != null && I.includes(E)) : true;
      }, Z = (o, E) => E !== "hours" || _2.value === "AM" ? o : o + 12, A = (o) => {
        const E = n.is24 ? 24 : 12, fe = o === "hours" ? E : 60, I = +n[`${o}GridIncrement`], $e = o === "hours" && !n.is24 ? I : 0, be = [];
        for (let Pe2 = $e; Pe2 < fe; Pe2 += I)
          be.push({ value: n.is24 ? Pe2 : Z(Pe2, o), text: Pe2 < 10 ? `0${Pe2}` : `${Pe2}` });
        return o === "hours" && !n.is24 && be.unshift({ value: _2.value === "PM" ? 12 : 0, text: "12" }), Wt(be, (Pe2) => ({ active: false, disabled: Y.value.times[o].includes(Pe2.value) || !W(Pe2.value, o) || S(o, Pe2.value) || D(o, Pe2.value) }));
      }, ie = (o) => o >= 0 ? o : 59, i = (o) => o >= 0 ? o : 23, W = (o, E) => {
        const fe = n.minTime ? z(Sa(n.minTime)) : null, I = n.maxTime ? z(Sa(n.maxTime)) : null, $e = z(
          Sa(
            H.value,
            E,
            E === "minutes" || E === "seconds" ? ie(o) : i(o)
          )
        );
        return fe && I ? (isBefore2($e, I) || isEqual2($e, I)) && (isAfter2($e, fe) || isEqual2($e, fe)) : fe ? isAfter2($e, fe) || isEqual2($e, fe) : I ? isBefore2($e, I) || isEqual2($e, I) : true;
      }, se = (o) => n[`no${o[0].toUpperCase() + o.slice(1)}Overlay`], T = (o) => {
        se(o) || (L[o] = !L[o], L[o] ? (j.value = true, a("overlay-opened", o)) : (j.value = false, a("overlay-closed", o)));
      }, re = (o) => o === "hours" ? getHours2 : o === "minutes" ? getMinutes2 : getSeconds, l = () => {
        b.value && clearTimeout(b.value);
      }, w = (o, E = true, fe) => {
        const I = E ? ve : pe2, $e = E ? +n[`${o}Increment`] : -+n[`${o}Increment`];
        W(+n[o] + $e, o) && a(
          `update:${o}`,
          re(o)(I({ [o]: +n[o] }, { [o]: +n[`${o}Increment`] }))
        ), !(fe != null && fe.keyboard) && f.value.timeArrowHoldThreshold && (b.value = setTimeout(() => {
          w(o, E);
        }, f.value.timeArrowHoldThreshold));
      }, oe2 = (o) => n.is24 ? o : (o >= 12 ? _2.value = "PM" : _2.value = "AM", Tl(o)), M = () => {
        _2.value === "PM" ? (_2.value = "AM", a("update:hours", n.hours - 12)) : (_2.value = "PM", a("update:hours", n.hours + 12)), a("am-pm-change", _2.value);
      }, he2 = (o) => {
        L[o] = true;
      }, ke = (o, E, fe) => {
        if (o && n.arrowNavigation) {
          Array.isArray(R.value[E]) ? R.value[E][fe] = o : R.value[E] = [o];
          const I = R.value.reduce(
            ($e, be) => be.map((Pe2, Ee2) => [...$e[Ee2] || [], be[Ee2]]),
            []
          );
          c(n.closeTimePickerBtn), h2.value && (I[1] = I[1].concat(h2.value)), u(I, n.order);
        }
      }, le = (o, E) => (T(o), a(`update:${o}`, E));
      return t({ openChildCmp: he2 }), (o, E) => {
        var fe;
        return o.disabled ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", kr, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(ee.value, (I, $e) => {
            var be, Pe2, Ee2;
            return openBlock(), createElementBlock("div", {
              key: $e,
              class: normalizeClass(v.value),
              "data-compact": N.value && !o.enableSeconds,
              "data-collapsed": N.value && o.enableSeconds
            }, [
              I.separator ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                j.value ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  createTextVNode(":")
                ], 64))
              ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createBaseVNode("button", {
                  ref_for: true,
                  ref: (Be) => ke(Be, $e, 0),
                  type: "button",
                  class: normalizeClass({
                    dp__btn: true,
                    dp__inc_dec_button: !o.timePickerInline,
                    dp__inc_dec_button_inline: o.timePickerInline,
                    dp__tp_inline_btn_top: o.timePickerInline,
                    dp__inc_dec_button_disabled: B.value(I.type),
                    "dp--hidden-el": j.value
                  }),
                  "data-test-id": `${I.type}-time-inc-btn-${n.order}`,
                  "aria-label": (be = unref(p2)) == null ? void 0 : be.incrementValue(I.type),
                  tabindex: "0",
                  onKeydown: (Be) => unref(xe)(Be, () => w(I.type, true, { keyboard: true }), true),
                  onClick: (Be) => unref(f).timeArrowHoldThreshold ? void 0 : w(I.type, true),
                  onMousedown: (Be) => unref(f).timeArrowHoldThreshold ? w(I.type, true) : void 0,
                  onMouseup: l
                }, [
                  n.timePickerInline ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    o.$slots["tp-inline-arrow-up"] ? renderSlot(o.$slots, "tp-inline-arrow-up", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      E[2] || (E[2] = createBaseVNode("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_l" }, null, -1)),
                      E[3] || (E[3] = createBaseVNode("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_r" }, null, -1))
                    ], 64))
                  ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    o.$slots["arrow-up"] ? renderSlot(o.$slots, "arrow-up", { key: 0 }) : createCommentVNode("", true),
                    o.$slots["arrow-up"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Ka), { key: 1 }))
                  ], 64))
                ], 42, Dr),
                createBaseVNode("button", {
                  ref_for: true,
                  ref: (Be) => ke(Be, $e, 1),
                  type: "button",
                  "aria-label": `${U.value(I.type).text}-${(Pe2 = unref(p2)) == null ? void 0 : Pe2.openTpOverlay(I.type)}`,
                  class: normalizeClass({
                    dp__time_display: true,
                    dp__time_display_block: !o.timePickerInline,
                    dp__time_display_inline: o.timePickerInline,
                    "dp--time-invalid": ae2.value(I.type),
                    "dp--time-overlay-btn": !ae2.value(I.type),
                    "dp--hidden-el": j.value
                  }),
                  disabled: se(I.type),
                  tabindex: "0",
                  "data-test-id": `${I.type}-toggle-overlay-btn-${n.order}`,
                  onKeydown: (Be) => unref(xe)(Be, () => T(I.type), true),
                  onClick: (Be) => T(I.type)
                }, [
                  o.$slots[I.type] ? renderSlot(o.$slots, I.type, {
                    key: 0,
                    text: U.value(I.type).text,
                    value: U.value(I.type).value
                  }) : createCommentVNode("", true),
                  o.$slots[I.type] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createTextVNode(toDisplayString(U.value(I.type).text), 1)
                  ], 64))
                ], 42, Mr),
                createBaseVNode("button", {
                  ref_for: true,
                  ref: (Be) => ke(Be, $e, 2),
                  type: "button",
                  class: normalizeClass({
                    dp__btn: true,
                    dp__inc_dec_button: !o.timePickerInline,
                    dp__inc_dec_button_inline: o.timePickerInline,
                    dp__tp_inline_btn_bottom: o.timePickerInline,
                    dp__inc_dec_button_disabled: q.value(I.type),
                    "dp--hidden-el": j.value
                  }),
                  "data-test-id": `${I.type}-time-dec-btn-${n.order}`,
                  "aria-label": (Ee2 = unref(p2)) == null ? void 0 : Ee2.decrementValue(I.type),
                  tabindex: "0",
                  onKeydown: (Be) => unref(xe)(Be, () => w(I.type, false, { keyboard: true }), true),
                  onClick: (Be) => unref(f).timeArrowHoldThreshold ? void 0 : w(I.type, false),
                  onMousedown: (Be) => unref(f).timeArrowHoldThreshold ? w(I.type, false) : void 0,
                  onMouseup: l
                }, [
                  n.timePickerInline ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    o.$slots["tp-inline-arrow-down"] ? renderSlot(o.$slots, "tp-inline-arrow-down", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      E[4] || (E[4] = createBaseVNode("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_l" }, null, -1)),
                      E[5] || (E[5] = createBaseVNode("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_r" }, null, -1))
                    ], 64))
                  ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    o.$slots["arrow-down"] ? renderSlot(o.$slots, "arrow-down", { key: 0 }) : createCommentVNode("", true),
                    o.$slots["arrow-down"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Ga), { key: 1 }))
                  ], 64))
                ], 42, $r)
              ], 64))
            ], 10, wr);
          }), 128)),
          o.is24 ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", Ar, [
            o.$slots["am-pm-button"] ? renderSlot(o.$slots, "am-pm-button", {
              key: 0,
              toggle: M,
              value: _2.value
            }) : createCommentVNode("", true),
            o.$slots["am-pm-button"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("button", {
              key: 1,
              ref_key: "amPmButton",
              ref: h2,
              type: "button",
              class: "dp__pm_am_button",
              role: "button",
              "aria-label": (fe = unref(p2)) == null ? void 0 : fe.amPmButton,
              tabindex: "0",
              "data-compact": N.value,
              onClick: M,
              onKeydown: E[0] || (E[0] = (I) => unref(xe)(I, () => M(), true))
            }, toDisplayString(_2.value), 41, Tr))
          ])),
          (openBlock(true), createElementBlock(Fragment, null, renderList(y.value, (I, $e) => (openBlock(), createBlock(Transition, {
            key: $e,
            name: unref(P)(L[I.type]),
            css: unref(F)
          }, {
            default: withCtx(() => {
              var be, Pe2;
              return [
                L[I.type] ? (openBlock(), createBlock(aa, {
                  key: 0,
                  items: A(I.type),
                  "is-last": o.autoApply && !unref(f).keepActionRow,
                  "esc-close": o.escClose,
                  type: I.type,
                  "text-input": o.textInput,
                  config: o.config,
                  "arrow-navigation": o.arrowNavigation,
                  "aria-labels": o.ariaLabels,
                  "overlay-label": (Pe2 = (be = unref(p2)).timeOverlay) == null ? void 0 : Pe2.call(be, I.type),
                  onSelected: (Ee2) => le(I.type, Ee2),
                  onToggle: (Ee2) => T(I.type),
                  onResetFlow: E[1] || (E[1] = (Ee2) => o.$emit("reset-flow"))
                }, createSlots({
                  "button-icon": withCtx(() => [
                    o.$slots["clock-icon"] ? renderSlot(o.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true),
                    o.$slots["clock-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(resolveDynamicComponent(o.timePickerInline ? unref(Gt) : unref(ja)), { key: 1 }))
                  ]),
                  _: 2
                }, [
                  o.$slots[`${I.type}-overlay-value`] ? {
                    name: "item",
                    fn: withCtx(({ item: Ee2 }) => [
                      renderSlot(o.$slots, `${I.type}-overlay-value`, {
                        text: Ee2.text,
                        value: Ee2.value
                      })
                    ]),
                    key: "0"
                  } : void 0,
                  o.$slots[`${I.type}-overlay-header`] ? {
                    name: "header",
                    fn: withCtx(() => [
                      renderSlot(o.$slots, `${I.type}-overlay-header`, {
                        toggle: () => T(I.type)
                      })
                    ]),
                    key: "1"
                  } : void 0
                ]), 1032, ["items", "is-last", "esc-close", "type", "text-input", "config", "arrow-navigation", "aria-labels", "overlay-label", "onSelected", "onToggle"])) : createCommentVNode("", true)
              ];
            }),
            _: 2
          }, 1032, ["name", "css"]))), 128))
        ]));
      };
    }
  });
  var Pr = ["data-dp-mobile"];
  var Rr = ["aria-label", "tabindex"];
  var Cr = ["role", "aria-label", "tabindex"];
  var Or = ["aria-label"];
  var jn = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    __name: "TimePicker",
    props: __spreadValues({
      hours: { type: [Number, Array], default: 0 },
      minutes: { type: [Number, Array], default: 0 },
      seconds: { type: [Number, Array], default: 0 },
      disabledTimesConfig: { type: Function, default: null },
      validateTime: {
        type: Function,
        default: () => false
      }
    }, ct),
    emits: [
      "update:hours",
      "update:minutes",
      "update:seconds",
      "mount",
      "reset-flow",
      "overlay-opened",
      "overlay-closed",
      "am-pm-change"
    ],
    setup(e, { expose: t, emit: r }) {
      const a = r, n = e, { buildMatrix: u, setTimePicker: c } = St(), p2 = useSlots(), { defaultedTransitions: d, defaultedAriaLabels: Y, defaultedTextInput: f, defaultedConfig: O, defaultedRange: m } = Ye(n), { transitionName: P, showTransition: F } = na(d), { hideNavigationButtons: L } = ha(), _2 = ref(null), h2 = ref(null), R = ref([]), b = ref(null), j = ref(false);
      onMounted(() => {
        a("mount"), !n.timePicker && n.arrowNavigation ? u([He(_2.value)], "time") : c(true, n.timePicker);
      });
      const z = computed2(() => m.value.enabled && n.modelAuto ? Pn(n.internalModelValue) : true), ae2 = ref(false), H = (S) => ({
        hours: Array.isArray(n.hours) ? n.hours[S] : n.hours,
        minutes: Array.isArray(n.minutes) ? n.minutes[S] : n.minutes,
        seconds: Array.isArray(n.seconds) ? n.seconds[S] : n.seconds
      }), D = computed2(() => {
        const S = [];
        if (m.value.enabled)
          for (let Z = 0; Z < 2; Z++)
            S.push(H(Z));
        else
          S.push(H(0));
        return S;
      }), Q2 = (S, Z = false, A = "") => {
        Z || a("reset-flow"), ae2.value = S, a(S ? "overlay-opened" : "overlay-closed", qe.time), n.arrowNavigation && c(S), nextTick(() => {
          A !== "" && R.value[0] && R.value[0].openChildCmp(A);
        });
      }, B = computed2(() => ({
        dp__btn: true,
        dp__button: true,
        dp__button_bottom: n.autoApply && !O.value.keepActionRow
      })), q = at(p2, "timePicker"), ve = (S, Z, A) => m.value.enabled ? Z === 0 ? [S, D.value[1][A]] : [D.value[0][A], S] : S, pe2 = (S) => {
        a("update:hours", S);
      }, v = (S) => {
        a("update:minutes", S);
      }, N = (S) => {
        a("update:seconds", S);
      }, ee = () => {
        if (b.value && !f.value.enabled && !n.noOverlayFocus) {
          const S = Rn(b.value);
          S && S.focus({ preventScroll: true });
        }
      }, y = (S) => {
        j.value = false, a("overlay-closed", S);
      }, U = (S) => {
        j.value = true, a("overlay-opened", S);
      };
      return t({ toggleTimePicker: Q2 }), (S, Z) => {
        var A;
        return openBlock(), createElementBlock("div", {
          class: "dp--tp-wrap",
          "data-dp-mobile": S.isMobile
        }, [
          !S.timePicker && !S.timePickerInline ? withDirectives((openBlock(), createElementBlock("button", {
            key: 0,
            ref_key: "openTimePickerBtn",
            ref: _2,
            type: "button",
            class: normalizeClass(__spreadProps(__spreadValues({}, B.value), { "dp--hidden-el": ae2.value })),
            "aria-label": (A = unref(Y)) == null ? void 0 : A.openTimePicker,
            tabindex: S.noOverlayFocus ? void 0 : 0,
            "data-test-id": "open-time-picker-btn",
            onKeydown: Z[0] || (Z[0] = (ie) => unref(xe)(ie, () => Q2(true))),
            onClick: Z[1] || (Z[1] = (ie) => Q2(true))
          }, [
            S.$slots["clock-icon"] ? renderSlot(S.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true),
            S.$slots["clock-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(ja), { key: 1 }))
          ], 42, Rr)), [
            [vShow, !unref(L)(S.hideNavigation, "time")]
          ]) : createCommentVNode("", true),
          createVNode(Transition, {
            name: unref(P)(ae2.value),
            css: unref(F) && !S.timePickerInline
          }, {
            default: withCtx(() => {
              var ie, i;
              return [
                ae2.value || S.timePicker || S.timePickerInline ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  ref_key: "overlayRef",
                  ref: b,
                  role: S.timePickerInline ? void 0 : "dialog",
                  class: normalizeClass({
                    dp__overlay: !S.timePickerInline,
                    "dp--overlay-absolute": !n.timePicker && !S.timePickerInline,
                    "dp--overlay-relative": n.timePicker
                  }),
                  style: normalizeStyle(S.timePicker ? { height: `${unref(O).modeHeight}px` } : void 0),
                  "aria-label": (ie = unref(Y)) == null ? void 0 : ie.timePicker,
                  tabindex: S.timePickerInline ? void 0 : 0
                }, [
                  createBaseVNode("div", {
                    class: normalizeClass(
                      S.timePickerInline ? "dp__time_picker_inline_container" : "dp__overlay_container dp__container_flex dp__time_picker_overlay_container"
                    ),
                    style: { display: "flex" }
                  }, [
                    S.$slots["time-picker-overlay"] ? renderSlot(S.$slots, "time-picker-overlay", {
                      key: 0,
                      hours: e.hours,
                      minutes: e.minutes,
                      seconds: e.seconds,
                      setHours: pe2,
                      setMinutes: v,
                      setSeconds: N
                    }) : createCommentVNode("", true),
                    S.$slots["time-picker-overlay"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", {
                      key: 1,
                      class: normalizeClass(S.timePickerInline ? "dp__flex" : "dp__overlay_row dp__flex_row")
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(D.value, (W, se) => withDirectives((openBlock(), createBlock(Sr, mergeProps({
                        key: se,
                        ref_for: true
                      }, __spreadProps(__spreadValues({}, S.$props), {
                        order: se,
                        hours: W.hours,
                        minutes: W.minutes,
                        seconds: W.seconds,
                        closeTimePickerBtn: h2.value,
                        disabledTimesConfig: e.disabledTimesConfig,
                        disabled: se === 0 ? unref(m).fixedStart : unref(m).fixedEnd
                      }), {
                        ref_for: true,
                        ref_key: "timeInputRefs",
                        ref: R,
                        "validate-time": (T, re) => e.validateTime(T, ve(re, se, T)),
                        "onUpdate:hours": (T) => pe2(ve(T, se, "hours")),
                        "onUpdate:minutes": (T) => v(ve(T, se, "minutes")),
                        "onUpdate:seconds": (T) => N(ve(T, se, "seconds")),
                        onMounted: ee,
                        onOverlayClosed: y,
                        onOverlayOpened: U,
                        onAmPmChange: Z[2] || (Z[2] = (T) => S.$emit("am-pm-change", T))
                      }), createSlots({ _: 2 }, [
                        renderList(unref(q), (T, re) => ({
                          name: T,
                          fn: withCtx((l) => [
                            renderSlot(S.$slots, T, mergeProps({ ref_for: true }, l))
                          ])
                        }))
                      ]), 1040, ["validate-time", "onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"])), [
                        [vShow, se === 0 ? true : z.value]
                      ])), 128))
                    ], 2)),
                    !S.timePicker && !S.timePickerInline ? withDirectives((openBlock(), createElementBlock("button", {
                      key: 2,
                      ref_key: "closeTimePickerBtn",
                      ref: h2,
                      type: "button",
                      class: normalizeClass(__spreadProps(__spreadValues({}, B.value), { "dp--hidden-el": j.value })),
                      "aria-label": (i = unref(Y)) == null ? void 0 : i.closeTimePicker,
                      tabindex: "0",
                      onKeydown: Z[3] || (Z[3] = (W) => unref(xe)(W, () => Q2(false))),
                      onClick: Z[4] || (Z[4] = (W) => Q2(false))
                    }, [
                      S.$slots["calendar-icon"] ? renderSlot(S.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
                      S.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Gt), { key: 1 }))
                    ], 42, Or)), [
                      [vShow, !unref(L)(S.hideNavigation, "time")]
                    ]) : createCommentVNode("", true)
                  ], 2)
                ], 14, Cr)) : createCommentVNode("", true)
              ];
            }),
            _: 3
          }, 8, ["name", "css"])
        ], 8, Pr);
      };
    }
  });
  var Kn = (e, t, r, a) => {
    const { defaultedRange: n } = Ye(e), u = (b, j) => Array.isArray(t[b]) ? t[b][j] : t[b], c = (b) => e.enableSeconds ? Array.isArray(t.seconds) ? t.seconds[b] : t.seconds : 0, p2 = (b, j) => b ? j !== void 0 ? At(b, u("hours", j), u("minutes", j), c(j)) : At(b, t.hours, t.minutes, c()) : setSeconds(K(), c(j)), d = (b, j) => {
      t[b] = j;
    }, Y = computed2(() => e.modelAuto && n.value.enabled ? Array.isArray(r.value) ? r.value.length > 1 : false : n.value.enabled), f = (b, j) => {
      const z = Object.fromEntries(
        Object.keys(t).map((ae2) => ae2 === b ? [ae2, j] : [ae2, t[ae2]].slice())
      );
      if (Y.value && !n.value.disableTimeRangeValidation) {
        const ae2 = (D) => r.value ? At(
          r.value[D],
          z.hours[D],
          z.minutes[D],
          z.seconds[D]
        ) : null, H = (D) => setMilliseconds(r.value[D], 0);
        return !(Te(ae2(0), ae2(1)) && (isAfter2(ae2(0), H(1)) || isBefore2(ae2(1), H(0))));
      }
      return true;
    }, O = (b, j) => {
      f(b, j) && (d(b, j), a && a());
    }, m = (b) => {
      O("hours", b);
    }, P = (b) => {
      O("minutes", b);
    }, F = (b) => {
      O("seconds", b);
    }, L = (b, j, z, ae2) => {
      j && m(b), !j && !z && P(b), z && F(b), r.value && ae2(r.value);
    }, _2 = (b) => {
      if (b) {
        const j = Array.isArray(b), z = j ? [+b[0].hours, +b[1].hours] : +b.hours, ae2 = j ? [+b[0].minutes, +b[1].minutes] : +b.minutes, H = j ? [+b[0].seconds, +b[1].seconds] : +b.seconds;
        d("hours", z), d("minutes", ae2), e.enableSeconds && d("seconds", H);
      }
    }, h2 = (b, j) => {
      const z = {
        hours: Array.isArray(t.hours) ? t.hours[b] : t.hours,
        disabledArr: []
      };
      return (j || j === 0) && (z.hours = j), Array.isArray(e.disabledTimes) && (z.disabledArr = n.value.enabled && Array.isArray(e.disabledTimes[b]) ? e.disabledTimes[b] : e.disabledTimes), z;
    }, R = computed2(() => (b, j) => {
      var _a3, _b;
      var z;
      if (Array.isArray(e.disabledTimes)) {
        const { disabledArr: ae2, hours: H } = h2(b, j), D = ae2.filter((Q2) => +Q2.hours === H);
        return ((z = D[0]) == null ? void 0 : z.minutes) === "*" ? { hours: [H], minutes: void 0, seconds: void 0 } : {
          hours: [],
          minutes: (_a3 = D == null ? void 0 : D.map((Q2) => +Q2.minutes)) != null ? _a3 : [],
          seconds: (_b = D == null ? void 0 : D.map((Q2) => Q2.seconds ? +Q2.seconds : void 0)) != null ? _b : []
        };
      }
      return { hours: [], minutes: [], seconds: [] };
    });
    return {
      setTime: d,
      updateHours: m,
      updateMinutes: P,
      updateSeconds: F,
      getSetDateTime: p2,
      updateTimeValues: L,
      getSecondsValue: c,
      assignStartTime: _2,
      validateTime: f,
      disabledTimesConfig: R
    };
  };
  var Br = (e, t) => {
    const r = () => {
      e.isTextInputDate && j();
    }, { modelValue: a, time: n } = la(e, t, r), { defaultedStartTime: u, defaultedRange: c, defaultedTz: p2 } = Ye(e), { updateTimeValues: d, getSetDateTime: Y, setTime: f, assignStartTime: O, disabledTimesConfig: m, validateTime: P } = Kn(e, n, a, F);
    function F() {
      t("update-flow-step");
    }
    const L = (H) => {
      const { hours: D, minutes: Q2, seconds: B } = H;
      return { hours: +D, minutes: +Q2, seconds: B ? +B : 0 };
    }, _2 = () => {
      if (e.startTime) {
        if (Array.isArray(e.startTime)) {
          const D = L(e.startTime[0]), Q2 = L(e.startTime[1]);
          return [set(K(), D), set(K(), Q2)];
        }
        const H = L(e.startTime);
        return set(K(), H);
      }
      return c.value.enabled ? [null, null] : null;
    }, h2 = () => {
      if (c.value.enabled) {
        const [H, D] = _2();
        a.value = [
          tt2(Y(H, 0), p2.value.timezone),
          tt2(Y(D, 1), p2.value.timezone)
        ];
      } else
        a.value = tt2(Y(_2()), p2.value.timezone);
    }, R = (H) => Array.isArray(H) ? [Yt(K(H[0])), Yt(K(H[1]))] : [Yt(H != null ? H : K())], b = (H, D, Q2) => {
      f("hours", H), f("minutes", D), f("seconds", e.enableSeconds ? Q2 : 0);
    }, j = () => {
      const [H, D] = R(a.value);
      return c.value.enabled ? b(
        [H.hours, D.hours],
        [H.minutes, D.minutes],
        [H.seconds, D.seconds]
      ) : b(H.hours, H.minutes, H.seconds);
    };
    onMounted(() => {
      if (!e.shadow)
        return O(u.value), a.value ? j() : h2();
    });
    const z = () => {
      Array.isArray(a.value) ? a.value = a.value.map((H, D) => H && Y(H, D)) : a.value = Y(a.value), t("time-update");
    };
    return {
      modelValue: a,
      time: n,
      disabledTimesConfig: m,
      updateTime: (H, D = true, Q2 = false) => {
        d(H, D, Q2, z);
      },
      validateTime: P
    };
  };
  var _r = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    __name: "TimePickerSolo",
    props: __spreadValues({}, ct),
    emits: [
      "update:internal-model-value",
      "time-update",
      "am-pm-change",
      "mount",
      "reset-flow",
      "update-flow-step",
      "overlay-toggle"
    ],
    setup(e, { expose: t, emit: r }) {
      const a = r, n = e, u = useSlots(), c = at(u, "timePicker"), p2 = ref(null), { time: d, modelValue: Y, disabledTimesConfig: f, updateTime: O, validateTime: m } = Br(n, a);
      return onMounted(() => {
        n.shadow || a("mount", null);
      }), t({ getSidebarProps: () => ({
        modelValue: Y,
        time: d,
        updateTime: O
      }), toggleTimePicker: (L, _2 = false, h2 = "") => {
        var R;
        (R = p2.value) == null || R.toggleTimePicker(L, _2, h2);
      } }), (L, _2) => (openBlock(), createBlock(ya, {
        "multi-calendars": 0,
        stretch: "",
        "is-mobile": L.isMobile
      }, {
        default: withCtx(() => [
          createVNode(jn, mergeProps({
            ref_key: "tpRef",
            ref: p2
          }, L.$props, {
            hours: unref(d).hours,
            minutes: unref(d).minutes,
            seconds: unref(d).seconds,
            "internal-model-value": L.internalModelValue,
            "disabled-times-config": unref(f),
            "validate-time": unref(m),
            "onUpdate:hours": _2[0] || (_2[0] = (h2) => unref(O)(h2)),
            "onUpdate:minutes": _2[1] || (_2[1] = (h2) => unref(O)(h2, false)),
            "onUpdate:seconds": _2[2] || (_2[2] = (h2) => unref(O)(h2, false, true)),
            onAmPmChange: _2[3] || (_2[3] = (h2) => L.$emit("am-pm-change", h2)),
            onResetFlow: _2[4] || (_2[4] = (h2) => L.$emit("reset-flow")),
            onOverlayClosed: _2[5] || (_2[5] = (h2) => L.$emit("overlay-toggle", { open: false, overlay: h2 })),
            onOverlayOpened: _2[6] || (_2[6] = (h2) => L.$emit("overlay-toggle", { open: true, overlay: h2 }))
          }), createSlots({ _: 2 }, [
            renderList(unref(c), (h2, R) => ({
              name: h2,
              fn: withCtx((b) => [
                renderSlot(L.$slots, h2, normalizeProps(guardReactiveProps(b)))
              ])
            }))
          ]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config", "validate-time"])
        ]),
        _: 3
      }, 8, ["is-mobile"]));
    }
  });
  var Yr = { class: "dp--header-wrap" };
  var Ir = {
    key: 0,
    class: "dp__month_year_wrap"
  };
  var Er = { key: 0 };
  var Nr = { class: "dp__month_year_wrap" };
  var Lr = ["data-dp-element", "aria-label", "data-test-id", "onClick", "onKeydown"];
  var Fr = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    __name: "DpHeader",
    props: __spreadValues({
      month: { type: Number, default: 0 },
      year: { type: Number, default: 0 },
      instance: { type: Number, default: 0 },
      years: { type: Array, default: () => [] },
      months: { type: Array, default: () => [] }
    }, ct),
    emits: ["update-month-year", "mount", "reset-flow", "overlay-closed", "overlay-opened"],
    setup(e, { expose: t, emit: r }) {
      const a = r, n = e, {
        defaultedTransitions: u,
        defaultedAriaLabels: c,
        defaultedMultiCalendars: p2,
        defaultedFilters: d,
        defaultedConfig: Y,
        defaultedHighlight: f,
        propDates: O,
        defaultedUI: m
      } = Ye(n), { transitionName: P, showTransition: F } = na(u), { buildMatrix: L } = St(), { handleMonthYearChange: _2, isDisabled: h2, updateMonthYear: R } = rr(n, a), { showLeftIcon: b, showRightIcon: j } = ha(), z = ref(false), ae2 = ref(false), H = ref(false), D = ref([null, null, null, null]);
      onMounted(() => {
        a("mount");
      });
      const Q2 = (i) => ({
        get: () => n[i],
        set: (W) => {
          const se = i === ut.month ? ut.year : ut.month;
          a("update-month-year", { [i]: W, [se]: n[se] }), i === ut.month ? y(true) : U(true);
        }
      }), B = computed2(Q2(ut.month)), q = computed2(Q2(ut.year)), ve = computed2(() => (i) => ({
        month: n.month,
        year: n.year,
        items: i === ut.month ? n.months : n.years,
        instance: n.instance,
        updateMonthYear: R,
        toggle: i === ut.month ? y : U
      })), pe2 = computed2(() => {
        const i = n.months.find((W) => W.value === n.month);
        return i || { text: "", value: 0 };
      }), v = computed2(() => Wt(n.months, (i) => {
        const W = n.month === i.value, se = xt(
          i.value,
          _n(n.year, O.value.minDate),
          Yn(n.year, O.value.maxDate)
        ) || d.value.months.includes(i.value), T = Fn(f.value, i.value, n.year);
        return { active: W, disabled: se, highlighted: T };
      })), N = computed2(() => Wt(n.years, (i) => {
        const W = n.year === i.value, se = xt(
          i.value,
          Vt(O.value.minDate),
          Vt(O.value.maxDate)
        ) || d.value.years.includes(i.value), T = Za(f.value, i.value);
        return { active: W, disabled: se, highlighted: T };
      })), ee = (i, W, se) => {
        se !== void 0 ? i.value = se : i.value = !i.value, i.value ? (H.value = true, a("overlay-opened", W)) : (H.value = false, a("overlay-closed", W));
      }, y = (i = false, W) => {
        S(i), ee(z, qe.month, W);
      }, U = (i = false, W) => {
        S(i), ee(ae2, qe.year, W);
      }, S = (i) => {
        i || a("reset-flow");
      }, Z = (i, W) => {
        n.arrowNavigation && (D.value[W] = He(i), L(D.value, "monthYear"));
      }, A = computed2(() => {
        var _a3, _b;
        var i, W, se, T, re, l;
        return [
          {
            type: ut.month,
            index: 1,
            toggle: y,
            modelValue: B.value,
            updateModelValue: (w) => B.value = w,
            text: pe2.value.text,
            showSelectionGrid: z.value,
            items: v.value,
            ariaLabel: (i = c.value) == null ? void 0 : i.openMonthsOverlay,
            overlayLabel: (_a3 = (se = (W = c.value).monthPicker) == null ? void 0 : se.call(W, true)) != null ? _a3 : void 0
          },
          {
            type: ut.year,
            index: 2,
            toggle: U,
            modelValue: q.value,
            updateModelValue: (w) => q.value = w,
            text: Cn(n.year, n.locale),
            showSelectionGrid: ae2.value,
            items: N.value,
            ariaLabel: (T = c.value) == null ? void 0 : T.openYearsOverlay,
            overlayLabel: (_b = (l = (re = c.value).yearPicker) == null ? void 0 : l.call(re, true)) != null ? _b : void 0
          }
        ];
      }), ie = computed2(() => n.disableYearSelect ? [A.value[0]] : n.yearFirst ? [...A.value].reverse() : A.value);
      return t({
        toggleMonthPicker: y,
        toggleYearPicker: U,
        handleMonthYearChange: _2
      }), (i, W) => {
        var se, T, re, l, w, oe2;
        return openBlock(), createElementBlock("div", Yr, [
          i.$slots["month-year"] ? (openBlock(), createElementBlock("div", Ir, [
            renderSlot(i.$slots, "month-year", normalizeProps(guardReactiveProps({
              month: e.month,
              year: e.year,
              months: e.months,
              years: e.years,
              updateMonthYear: unref(R),
              handleMonthYearChange: unref(_2),
              instance: e.instance,
              isDisabled: unref(h2)
            })))
          ])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            i.$slots["top-extra"] ? (openBlock(), createElementBlock("div", Er, [
              renderSlot(i.$slots, "top-extra", { value: i.internalModelValue })
            ])) : createCommentVNode("", true),
            createBaseVNode("div", Nr, [
              unref(b)(unref(p2), e.instance) && !i.vertical ? (openBlock(), createBlock(qt, {
                key: 0,
                "aria-label": (se = unref(c)) == null ? void 0 : se.prevMonth,
                disabled: unref(h2)(false),
                class: normalizeClass((T = unref(m)) == null ? void 0 : T.navBtnPrev),
                "el-name": "action-prev",
                onActivate: W[0] || (W[0] = (M) => unref(_2)(false, true)),
                onSetRef: W[1] || (W[1] = (M) => Z(M, 0))
              }, {
                default: withCtx(() => [
                  i.$slots["arrow-left"] ? renderSlot(i.$slots, "arrow-left", { key: 0 }) : createCommentVNode("", true),
                  i.$slots["arrow-left"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Wa), { key: 1 }))
                ]),
                _: 3
              }, 8, ["aria-label", "disabled", "class"])) : createCommentVNode("", true),
              createBaseVNode("div", {
                class: normalizeClass(["dp__month_year_wrap", {
                  dp__year_disable_select: i.disableYearSelect
                }])
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(ie.value, (M, he2) => (openBlock(), createElementBlock(Fragment, {
                  key: M.type
                }, [
                  createBaseVNode("button", {
                    ref_for: true,
                    ref: (ke) => Z(ke, he2 + 1),
                    type: "button",
                    "data-dp-element": `overlay-${M.type}`,
                    class: normalizeClass(["dp__btn dp__month_year_select", { "dp--hidden-el": H.value }]),
                    "aria-label": `${M.text}-${M.ariaLabel}`,
                    "data-test-id": `${M.type}-toggle-overlay-${e.instance}`,
                    onClick: M.toggle,
                    onKeydown: (ke) => unref(xe)(ke, () => M.toggle(), true)
                  }, [
                    i.$slots[M.type] ? renderSlot(i.$slots, M.type, {
                      key: 0,
                      text: M.text,
                      value: n[M.type]
                    }) : createCommentVNode("", true),
                    i.$slots[M.type] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      createTextVNode(toDisplayString(M.text), 1)
                    ], 64))
                  ], 42, Lr),
                  createVNode(Transition, {
                    name: unref(P)(M.showSelectionGrid),
                    css: unref(F)
                  }, {
                    default: withCtx(() => [
                      M.showSelectionGrid ? (openBlock(), createBlock(aa, {
                        key: 0,
                        items: M.items,
                        "arrow-navigation": i.arrowNavigation,
                        "hide-navigation": i.hideNavigation,
                        "is-last": i.autoApply && !unref(Y).keepActionRow,
                        "skip-button-ref": false,
                        config: i.config,
                        type: M.type,
                        "header-refs": [],
                        "esc-close": i.escClose,
                        "menu-wrap-ref": i.menuWrapRef,
                        "text-input": i.textInput,
                        "aria-labels": i.ariaLabels,
                        "overlay-label": M.overlayLabel,
                        onSelected: M.updateModelValue,
                        onToggle: M.toggle
                      }, createSlots({
                        "button-icon": withCtx(() => [
                          i.$slots["calendar-icon"] ? renderSlot(i.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
                          i.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Gt), { key: 1 }))
                        ]),
                        _: 2
                      }, [
                        i.$slots[`${M.type}-overlay-value`] ? {
                          name: "item",
                          fn: withCtx(({ item: ke }) => [
                            renderSlot(i.$slots, `${M.type}-overlay-value`, {
                              text: ke.text,
                              value: ke.value
                            })
                          ]),
                          key: "0"
                        } : void 0,
                        i.$slots[`${M.type}-overlay`] ? {
                          name: "overlay",
                          fn: withCtx(() => [
                            renderSlot(i.$slots, `${M.type}-overlay`, mergeProps({ ref_for: true }, ve.value(M.type)))
                          ]),
                          key: "1"
                        } : void 0,
                        i.$slots[`${M.type}-overlay-header`] ? {
                          name: "header",
                          fn: withCtx(() => [
                            renderSlot(i.$slots, `${M.type}-overlay-header`, {
                              toggle: M.toggle
                            })
                          ]),
                          key: "2"
                        } : void 0
                      ]), 1032, ["items", "arrow-navigation", "hide-navigation", "is-last", "config", "type", "esc-close", "menu-wrap-ref", "text-input", "aria-labels", "overlay-label", "onSelected", "onToggle"])) : createCommentVNode("", true)
                    ]),
                    _: 2
                  }, 1032, ["name", "css"])
                ], 64))), 128))
              ], 2),
              unref(b)(unref(p2), e.instance) && i.vertical ? (openBlock(), createBlock(qt, {
                key: 1,
                "aria-label": (re = unref(c)) == null ? void 0 : re.prevMonth,
                "el-name": "action-prev",
                disabled: unref(h2)(false),
                class: normalizeClass((l = unref(m)) == null ? void 0 : l.navBtnPrev),
                onActivate: W[2] || (W[2] = (M) => unref(_2)(false, true))
              }, {
                default: withCtx(() => [
                  i.$slots["arrow-up"] ? renderSlot(i.$slots, "arrow-up", { key: 0 }) : createCommentVNode("", true),
                  i.$slots["arrow-up"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Ka), { key: 1 }))
                ]),
                _: 3
              }, 8, ["aria-label", "disabled", "class"])) : createCommentVNode("", true),
              unref(j)(unref(p2), e.instance) ? (openBlock(), createBlock(qt, {
                key: 2,
                ref: "rightIcon",
                "el-name": "action-next",
                disabled: unref(h2)(true),
                "aria-label": (w = unref(c)) == null ? void 0 : w.nextMonth,
                class: normalizeClass((oe2 = unref(m)) == null ? void 0 : oe2.navBtnNext),
                onActivate: W[3] || (W[3] = (M) => unref(_2)(true, true)),
                onSetRef: W[4] || (W[4] = (M) => Z(M, i.disableYearSelect ? 2 : 3))
              }, {
                default: withCtx(() => [
                  i.$slots[i.vertical ? "arrow-down" : "arrow-right"] ? renderSlot(i.$slots, i.vertical ? "arrow-down" : "arrow-right", { key: 0 }) : createCommentVNode("", true),
                  i.$slots[i.vertical ? "arrow-down" : "arrow-right"] ? createCommentVNode("", true) : (openBlock(), createBlock(resolveDynamicComponent(i.vertical ? unref(Ga) : unref(Va)), { key: 1 }))
                ]),
                _: 3
              }, 8, ["disabled", "aria-label", "class"])) : createCommentVNode("", true)
            ])
          ], 64))
        ]);
      };
    }
  });
  var zr = {
    class: "dp__calendar_header",
    role: "row"
  };
  var Hr = {
    key: 0,
    class: "dp__calendar_header_item",
    role: "gridcell"
  };
  var Ur = ["aria-label"];
  var Wr = {
    key: 0,
    class: "dp__calendar_item dp__week_num",
    role: "gridcell"
  };
  var Vr = { class: "dp__cell_inner" };
  var jr = ["id", "aria-pressed", "aria-disabled", "aria-label", "tabindex", "data-test-id", "onClick", "onTouchend", "onKeydown", "onMouseenter", "onMouseleave", "onMousedown"];
  var Kr = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    __name: "DpCalendar",
    props: __spreadValues({
      mappedDates: { type: Array, default: () => [] },
      instance: { type: Number, default: 0 },
      month: { type: Number, default: 0 },
      year: { type: Number, default: 0 }
    }, ct),
    emits: [
      "select-date",
      "set-hover-date",
      "handle-scroll",
      "mount",
      "handle-swipe",
      "handle-space",
      "tooltip-open",
      "tooltip-close"
    ],
    setup(e, { expose: t, emit: r }) {
      const a = r, n = e, { buildMultiLevelMatrix: u } = St(), {
        defaultedTransitions: c,
        defaultedConfig: p2,
        defaultedAriaLabels: d,
        defaultedMultiCalendars: Y,
        defaultedWeekNumbers: f,
        defaultedMultiDates: O,
        defaultedUI: m
      } = Ye(n), P = ref(null), F = ref({
        bottom: "",
        left: "",
        transform: ""
      }), L = ref([]), _2 = ref(null), h2 = ref(true), R = ref(""), b = ref({ startX: 0, endX: 0, startY: 0, endY: 0 }), j = ref([]), z = ref({ left: "50%" }), ae2 = ref(false), H = computed2(() => n.calendar ? n.calendar(n.mappedDates) : n.mappedDates), D = computed2(() => n.dayNames ? Array.isArray(n.dayNames) ? n.dayNames : n.dayNames(n.locale, +n.weekStart) : Al(n.formatLocale, n.locale, +n.weekStart));
      onMounted(() => {
        a("mount", { cmp: "calendar", refs: L }), p2.value.noSwipe || _2.value && (_2.value.addEventListener("touchstart", Z, { passive: false }), _2.value.addEventListener("touchend", A, { passive: false }), _2.value.addEventListener("touchmove", ie, { passive: false })), n.monthChangeOnScroll && _2.value && _2.value.addEventListener("wheel", se, { passive: false });
      }), onUnmounted(() => {
        p2.value.noSwipe || _2.value && (_2.value.removeEventListener("touchstart", Z), _2.value.removeEventListener("touchend", A), _2.value.removeEventListener("touchmove", ie)), n.monthChangeOnScroll && _2.value && _2.value.removeEventListener("wheel", se);
      });
      const Q2 = (M) => M ? n.vertical ? "vNext" : "next" : n.vertical ? "vPrevious" : "previous", B = (M, he2) => {
        if (n.transitions) {
          const ke = je(ht(K(), n.month, n.year));
          R.value = Fe(je(ht(K(), M, he2)), ke) ? c.value[Q2(true)] : c.value[Q2(false)], h2.value = false, nextTick(() => {
            h2.value = true;
          });
        }
      }, q = computed2(
        () => {
          var _a3;
          return __spreadValues({}, (_a3 = m.value.calendar) != null ? _a3 : {});
        }
      ), ve = computed2(() => (M) => {
        const he2 = Sl(M);
        return {
          dp__marker_dot: he2.type === "dot",
          dp__marker_line: he2.type === "line"
        };
      }), pe2 = computed2(() => (M) => Te(M, P.value)), v = computed2(() => ({
        dp__calendar: true,
        dp__calendar_next: Y.value.count > 0 && n.instance !== 0
      })), N = computed2(() => (M) => n.hideOffsetDates ? M.current : true), ee = async (M, he2) => {
        const { width: ke, height: le } = M.getBoundingClientRect();
        P.value = he2.value;
        let o = { left: `${ke / 2}px` }, E = -50;
        if (await nextTick(), j.value[0]) {
          const { left: fe, width: I } = j.value[0].getBoundingClientRect();
          fe < 0 && (o = { left: "0" }, E = 0, z.value.left = `${ke / 2}px`), window.innerWidth < fe + I && (o = { right: "0" }, E = 0, z.value.left = `${I - ke / 2}px`);
        }
        F.value = __spreadProps(__spreadValues({
          bottom: `${le}px`
        }, o), {
          transform: `translateX(${E}%)`
        });
      }, y = async (M, he2, ke) => {
        var o, E, fe;
        const le = He(L.value[he2][ke]);
        le && ((o = M.marker) != null && o.customPosition && ((fe = (E = M.marker) == null ? void 0 : E.tooltip) != null && fe.length) ? F.value = M.marker.customPosition(le) : await ee(le, M), a("tooltip-open", M.marker));
      }, U = async (M, he2, ke) => {
        var le, o;
        if (ae2.value && O.value.enabled && O.value.dragSelect)
          return a("select-date", M);
        if (a("set-hover-date", M), (o = (le = M.marker) == null ? void 0 : le.tooltip) != null && o.length) {
          if (n.hideOffsetDates && !M.current)
            return;
          await y(M, he2, ke);
        }
      }, S = (M) => {
        P.value && (P.value = null, F.value = JSON.parse(JSON.stringify({ bottom: "", left: "", transform: "" })), a("tooltip-close", M.marker));
      }, Z = (M) => {
        b.value.startX = M.changedTouches[0].screenX, b.value.startY = M.changedTouches[0].screenY;
      }, A = (M) => {
        b.value.endX = M.changedTouches[0].screenX, b.value.endY = M.changedTouches[0].screenY, i();
      }, ie = (M) => {
        n.vertical && !n.inline && M.preventDefault();
      }, i = () => {
        const M = n.vertical ? "Y" : "X";
        Math.abs(b.value[`start${M}`] - b.value[`end${M}`]) > 10 && a("handle-swipe", b.value[`start${M}`] > b.value[`end${M}`] ? "right" : "left");
      }, W = (M, he2, ke) => {
        M && (Array.isArray(L.value[he2]) ? L.value[he2][ke] = M : L.value[he2] = [M]), n.arrowNavigation && u(L.value, "calendar");
      }, se = (M) => {
        n.monthChangeOnScroll && (M.preventDefault(), a("handle-scroll", M));
      }, T = (M) => f.value.type === "local" ? getWeek2(M.value, { weekStartsOn: +n.weekStart }) : f.value.type === "iso" ? getISOWeek(M.value) : typeof f.value.type == "function" ? f.value.type(M.value) : "", re = (M) => {
        const he2 = M[0];
        return f.value.hideOnOffsetDates ? M.some((ke) => ke.current) ? T(he2) : "" : T(he2);
      }, l = (M, he2, ke = true) => {
        !ke && Bl() || (!O.value.enabled || p2.value.allowPreventDefault) && ($t(M, p2.value), a("select-date", he2));
      }, w = (M) => {
        $t(M, p2.value);
      }, oe2 = (M) => {
        O.value.enabled && O.value.dragSelect ? (ae2.value = true, a("select-date", M)) : O.value.enabled && a("select-date", M);
      };
      return t({ triggerTransition: B }), (M, he2) => (openBlock(), createElementBlock("div", {
        class: normalizeClass(v.value)
      }, [
        createBaseVNode("div", {
          ref_key: "calendarWrapRef",
          ref: _2,
          class: normalizeClass(q.value),
          role: "grid"
        }, [
          createBaseVNode("div", zr, [
            M.weekNumbers ? (openBlock(), createElementBlock("div", Hr, toDisplayString(M.weekNumName), 1)) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(D.value, (ke, le) => {
              var o, E;
              return openBlock(), createElementBlock("div", {
                key: le,
                class: "dp__calendar_header_item",
                role: "gridcell",
                "data-test-id": "calendar-header",
                "aria-label": (E = (o = unref(d)) == null ? void 0 : o.weekDay) == null ? void 0 : E.call(o, le)
              }, [
                M.$slots["calendar-header"] ? renderSlot(M.$slots, "calendar-header", {
                  key: 0,
                  day: ke,
                  index: le
                }) : createCommentVNode("", true),
                M.$slots["calendar-header"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(toDisplayString(ke), 1)
                ], 64))
              ], 8, Ur);
            }), 128))
          ]),
          he2[2] || (he2[2] = createBaseVNode("div", { class: "dp__calendar_header_separator" }, null, -1)),
          createVNode(Transition, {
            name: R.value,
            css: !!M.transitions
          }, {
            default: withCtx(() => [
              h2.value ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "dp__calendar",
                role: "rowgroup",
                onMouseleave: he2[1] || (he2[1] = (ke) => ae2.value = false)
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(H.value, (ke, le) => (openBlock(), createElementBlock("div", {
                  key: le,
                  class: "dp__calendar_row",
                  role: "row"
                }, [
                  M.weekNumbers ? (openBlock(), createElementBlock("div", Wr, [
                    createBaseVNode("div", Vr, toDisplayString(re(ke.days)), 1)
                  ])) : createCommentVNode("", true),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(ke.days, (o, E) => {
                    var _a3;
                    var fe, I, $e;
                    return openBlock(), createElementBlock("div", {
                      id: unref(Ha)(o.value),
                      ref_for: true,
                      ref: (be) => W(be, le, E),
                      key: E + le,
                      role: "gridcell",
                      class: "dp__calendar_item",
                      "aria-pressed": (_a3 = o.classData.dp__active_date || o.classData.dp__range_start || o.classData.dp__range_start) != null ? _a3 : void 0,
                      "aria-disabled": o.classData.dp__cell_disabled || void 0,
                      "aria-label": (I = (fe = unref(d)) == null ? void 0 : fe.day) == null ? void 0 : I.call(fe, o),
                      tabindex: !o.current && M.hideOffsetDates ? void 0 : 0,
                      "data-test-id": unref(Ha)(o.value),
                      onClick: withModifiers((be) => l(be, o), ["prevent"]),
                      onTouchend: (be) => l(be, o, false),
                      onKeydown: (be) => unref(xe)(be, () => M.$emit("select-date", o)),
                      onMouseenter: (be) => U(o, le, E),
                      onMouseleave: (be) => S(o),
                      onMousedown: (be) => oe2(o),
                      onMouseup: he2[0] || (he2[0] = (be) => ae2.value = false)
                    }, [
                      createBaseVNode("div", {
                        class: normalizeClass(["dp__cell_inner", o.classData])
                      }, [
                        M.$slots.day && N.value(o) ? renderSlot(M.$slots, "day", {
                          key: 0,
                          day: +o.text,
                          date: o.value
                        }) : createCommentVNode("", true),
                        M.$slots.day ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                          createTextVNode(toDisplayString(o.text), 1)
                        ], 64)),
                        o.marker && N.value(o) ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                          M.$slots.marker ? renderSlot(M.$slots, "marker", {
                            key: 0,
                            marker: o.marker,
                            day: +o.text,
                            date: o.value
                          }) : (openBlock(), createElementBlock("div", {
                            key: 1,
                            class: normalizeClass(ve.value(o.marker)),
                            style: normalizeStyle(o.marker.color ? { backgroundColor: o.marker.color } : {})
                          }, null, 6))
                        ], 64)) : createCommentVNode("", true),
                        pe2.value(o.value) ? (openBlock(), createElementBlock("div", {
                          key: 3,
                          ref_for: true,
                          ref_key: "activeTooltip",
                          ref: j,
                          class: "dp__marker_tooltip",
                          style: normalizeStyle(F.value)
                        }, [
                          ($e = o.marker) != null && $e.tooltip ? (openBlock(), createElementBlock("div", {
                            key: 0,
                            class: "dp__tooltip_content",
                            onClick: w
                          }, [
                            (openBlock(true), createElementBlock(Fragment, null, renderList(o.marker.tooltip, (be, Pe2) => (openBlock(), createElementBlock("div", {
                              key: Pe2,
                              class: "dp__tooltip_text"
                            }, [
                              M.$slots["marker-tooltip"] ? renderSlot(M.$slots, "marker-tooltip", {
                                key: 0,
                                tooltip: be,
                                day: o.value
                              }) : createCommentVNode("", true),
                              M.$slots["marker-tooltip"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                                createBaseVNode("div", {
                                  class: "dp__tooltip_mark",
                                  style: normalizeStyle(be.color ? { backgroundColor: be.color } : {})
                                }, null, 4),
                                createBaseVNode("div", null, toDisplayString(be.text), 1)
                              ], 64))
                            ]))), 128)),
                            createBaseVNode("div", {
                              class: "dp__arrow_bottom_tp",
                              style: normalizeStyle(z.value)
                            }, null, 4)
                          ])) : createCommentVNode("", true)
                        ], 4)) : createCommentVNode("", true)
                      ], 2)
                    ], 40, jr);
                  }), 128))
                ]))), 128))
              ], 32)) : createCommentVNode("", true)
            ]),
            _: 3
          }, 8, ["name", "css"])
        ], 2)
      ], 2));
    }
  });
  var yn = (e) => Array.isArray(e);
  var Gr = (e, t, r, a) => {
    const n = ref([]), u = ref(/* @__PURE__ */ new Date()), c = ref(), p2 = () => A(e.isTextInputDate), { modelValue: d, calendars: Y, time: f, today: O } = la(e, t, p2), {
      defaultedMultiCalendars: m,
      defaultedStartTime: P,
      defaultedRange: F,
      defaultedConfig: L,
      defaultedTz: _2,
      propDates: h2,
      defaultedMultiDates: R
    } = Ye(e), { validateMonthYearInRange: b, isDisabled: j, isDateRangeAllowed: z, checkMinMaxRange: ae2 } = Pt(e), { updateTimeValues: H, getSetDateTime: D, setTime: Q2, assignStartTime: B, validateTime: q, disabledTimesConfig: ve } = Kn(e, f, d, a), pe2 = computed2(
      () => (g) => Y.value[g] ? Y.value[g].month : 0
    ), v = computed2(
      () => (g) => Y.value[g] ? Y.value[g].year : 0
    ), N = (g) => !L.value.keepViewOnOffsetClick || g ? true : !c.value, ee = (g, ne, me2, C = false) => {
      var te, ce;
      N(C) && (Y.value[g] || (Y.value[g] = { month: 0, year: 0 }), Y.value[g].month = dn(ne) ? (te = Y.value[g]) == null ? void 0 : te.month : ne, Y.value[g].year = dn(me2) ? (ce = Y.value[g]) == null ? void 0 : ce.year : me2);
    }, y = () => {
      e.autoApply && t("select-date");
    }, U = () => {
      P.value && B(P.value);
    };
    onMounted(() => {
      e.shadow || (d.value || (he2(), U()), A(true), e.focusStartDate && e.startDate && he2());
    });
    const S = computed2(() => {
      var g;
      return (g = e.flow) != null && g.length && !e.partialFlow ? e.flowStep === e.flow.length : true;
    }), Z = () => {
      e.autoApply && S.value && t("auto-apply", e.partialFlow ? e.flowStep !== e.flow.length : false);
    }, A = (g = false) => {
      if (d.value)
        return Array.isArray(d.value) ? (n.value = d.value, l(g)) : W(d.value, g);
      if (m.value.count && g && !e.startDate)
        return i(K(), g);
    }, ie = () => {
      var _a3;
      return Array.isArray(d.value) && F.value.enabled ? getMonth2(d.value[0]) === getMonth2((_a3 = d.value[1]) != null ? _a3 : d.value[0]) : false;
    }, i = (g = /* @__PURE__ */ new Date(), ne = false) => {
      if ((!m.value.count || !m.value.static || ne) && ee(0, getMonth2(g), getYear2(g)), m.value.count && (!d.value || ie() || !m.value.solo) && (!m.value.solo || ne))
        for (let me2 = 1; me2 < m.value.count; me2++) {
          const C = set(K(), { month: pe2.value(me2 - 1), year: v.value(me2 - 1) }), te = add(C, { months: 1 });
          Y.value[me2] = { month: getMonth2(te), year: getYear2(te) };
        }
    }, W = (g, ne) => {
      i(g), Q2("hours", getHours2(g)), Q2("minutes", getMinutes2(g)), Q2("seconds", getSeconds(g)), m.value.count && ne && M();
    }, se = (g) => {
      if (m.value.count) {
        if (m.value.solo)
          return 0;
        const ne = getMonth2(g[0]), me2 = getMonth2(g[1]);
        return Math.abs(me2 - ne) < m.value.count ? 0 : 1;
      }
      return 1;
    }, T = (g, ne) => {
      g[1] && F.value.showLastInRange ? i(g[se(g)], ne) : i(g[0], ne);
      const me2 = (C, te) => [
        C(g[0]),
        g[1] ? C(g[1]) : f[te][1]
      ];
      Q2("hours", me2(getHours2, "hours")), Q2("minutes", me2(getMinutes2, "minutes")), Q2("seconds", me2(getSeconds, "seconds"));
    }, re = (g, ne) => {
      if ((F.value.enabled || e.weekPicker) && !R.value.enabled)
        return T(g, ne);
      if (R.value.enabled && ne) {
        const me2 = g[g.length - 1];
        return W(me2, ne);
      }
    }, l = (g) => {
      const ne = d.value;
      re(ne, g), m.value.count && m.value.solo && M();
    }, w = (g, ne) => {
      const me2 = set(K(), { month: pe2.value(ne), year: v.value(ne) }), C = g < 0 ? addMonths2(me2, 1) : subMonths(me2, 1);
      b(getMonth2(C), getYear2(C), g < 0, e.preventMinMaxNavigation) && (ee(ne, getMonth2(C), getYear2(C)), t("update-month-year", { instance: ne, month: getMonth2(C), year: getYear2(C) }), m.value.count && !m.value.solo && oe2(ne), r());
    }, oe2 = (g) => {
      for (let ne = g - 1; ne >= 0; ne--) {
        const me2 = subMonths(set(K(), { month: pe2.value(ne + 1), year: v.value(ne + 1) }), 1);
        ee(ne, getMonth2(me2), getYear2(me2));
      }
      for (let ne = g + 1; ne <= m.value.count - 1; ne++) {
        const me2 = addMonths2(set(K(), { month: pe2.value(ne - 1), year: v.value(ne - 1) }), 1);
        ee(ne, getMonth2(me2), getYear2(me2));
      }
    }, M = () => {
      if (Array.isArray(d.value) && d.value.length === 2) {
        const g = K(
          K(d.value[1] ? d.value[1] : addMonths2(d.value[0], 1))
        ), [ne, me2] = [getMonth2(d.value[0]), getYear2(d.value[0])], [C, te] = [getMonth2(d.value[1]), getYear2(d.value[1])];
        (ne !== C || ne === C && me2 !== te) && m.value.solo && ee(1, getMonth2(g), getYear2(g));
      } else
        d.value && !Array.isArray(d.value) && (ee(0, getMonth2(d.value), getYear2(d.value)), i(K()));
    }, he2 = () => {
      e.startDate && (ee(0, getMonth2(K(e.startDate)), getYear2(K(e.startDate))), m.value.count && oe2(0));
    }, ke = (g, ne) => {
      if (e.monthChangeOnScroll) {
        const me2 = (/* @__PURE__ */ new Date()).getTime() - u.value.getTime(), C = Math.abs(g.deltaY);
        let te = 500;
        C > 1 && (te = 100), C > 100 && (te = 0), me2 > te && (u.value = /* @__PURE__ */ new Date(), w(e.monthChangeOnScroll !== "inverse" ? -g.deltaY : g.deltaY, ne));
      }
    }, le = (g, ne, me2 = false) => {
      e.monthChangeOnArrows && e.vertical === me2 && o(g, ne);
    }, o = (g, ne) => {
      w(g === "right" ? -1 : 1, ne);
    }, E = (g) => {
      if (h2.value.markers)
        return va(g.value, h2.value.markers);
    }, fe = (g, ne) => {
      switch (e.sixWeeks === true ? "append" : e.sixWeeks) {
        case "prepend":
          return [true, false];
        case "center":
          return [g == 0, true];
        case "fair":
          return [g == 0 || ne > g, true];
        case "append":
          return [false, false];
        default:
          return [false, false];
      }
    }, I = (g, ne, me2, C) => {
      if (e.sixWeeks && g.length < 6) {
        const te = 6 - g.length, ce = (ne.getDay() + 7 - C) % 7, vt = 6 - (me2.getDay() + 7 - C) % 7, [Ct, $a] = fe(ce, vt);
        for (let Ot = 1; Ot <= te; Ot++)
          if ($a ? !!(Ot % 2) == Ct : Ct) {
            const oa = g[0].days[0], Aa = $e(addDays2(oa.value, -7), getMonth2(ne));
            g.unshift({ days: Aa });
          } else {
            const oa = g[g.length - 1], Aa = oa.days[oa.days.length - 1], qn = $e(addDays2(Aa.value, 1), getMonth2(ne));
            g.push({ days: qn });
          }
      }
      return g;
    }, $e = (g, ne) => {
      const me2 = K(g), C = [];
      for (let te = 0; te < 7; te++) {
        const ce = addDays2(me2, te), yt = getMonth2(ce) !== ne;
        C.push({
          text: e.hideOffsetDates && yt ? "" : ce.getDate(),
          value: ce,
          current: !yt,
          classData: {}
        });
      }
      return C;
    }, be = (g, ne) => {
      const me2 = [], C = new Date(ne, g), te = new Date(ne, g + 1, 0), ce = e.weekStart, yt = startOfWeek2(C, { weekStartsOn: ce }), vt = (Ct) => {
        const $a = $e(Ct, g);
        if (me2.push({ days: $a }), !me2[me2.length - 1].days.some(
          (Ot) => Te(je(Ot.value), je(te))
        )) {
          const Ot = addDays2(Ct, 7);
          vt(Ot);
        }
      };
      return vt(yt), I(me2, C, te, ce);
    }, Pe2 = (g) => {
      const ne = At(K(g.value), f.hours, f.minutes, rt());
      t("date-update", ne), R.value.enabled ? xa(ne, d, R.value.limit) : d.value = ne, a(), nextTick().then(() => {
        Z();
      });
    }, Ee2 = (g) => F.value.noDisabledRange ? In(n.value[0], g).some((me2) => j(me2)) : false, Be = () => {
      n.value = d.value ? d.value.slice() : [], n.value.length === 2 && !(F.value.fixedStart || F.value.fixedEnd) && (n.value = []);
    }, k = (g, ne) => {
      const me2 = [
        K(g.value),
        addDays2(K(g.value), +F.value.autoRange)
      ];
      z(me2) ? (ne && x(g.value), n.value = me2) : t("invalid-date", g.value);
    }, x = (g) => {
      const ne = getMonth2(K(g)), me2 = getYear2(K(g));
      if (ee(0, ne, me2), m.value.count > 0)
        for (let C = 1; C < m.value.count; C++) {
          const te = Il(
            set(K(g), { year: v.value(C - 1), month: pe2.value(C - 1) })
          );
          ee(C, te.month, te.year);
        }
    }, Ie = (g) => {
      if (Ee2(g.value) || !ae2(g.value, d.value, F.value.fixedStart ? 0 : 1))
        return t("invalid-date", g.value);
      n.value = Wn(K(g.value), d, t, F);
    }, Ue = (g, ne) => {
      if (Be(), F.value.autoRange)
        return k(g, ne);
      if (F.value.fixedStart || F.value.fixedEnd)
        return Ie(g);
      n.value[0] ? ae2(K(g.value), d.value) && !Ee2(g.value) ? Ne(K(g.value), K(n.value[0])) ? (n.value.unshift(K(g.value)), t("range-end", n.value[0])) : (n.value[1] = K(g.value), t("range-end", n.value[1])) : (e.autoApply && t("auto-apply-invalid", g.value), t("invalid-date", g.value)) : (n.value[0] = K(g.value), t("range-start", n.value[0]));
    }, rt = (g = true) => e.enableSeconds ? Array.isArray(f.seconds) ? g ? f.seconds[0] : f.seconds[1] : f.seconds : 0, de = (g) => {
      n.value[g] = At(
        n.value[g],
        f.hours[g],
        f.minutes[g],
        rt(g !== 1)
      );
    }, Rt = () => {
      var g, ne;
      n.value[0] && n.value[1] && +((g = n.value) == null ? void 0 : g[0]) > +((ne = n.value) == null ? void 0 : ne[1]) && (n.value.reverse(), t("range-start", n.value[0]), t("range-end", n.value[1]));
    }, ft = () => {
      n.value.length && (n.value[0] && !n.value[1] ? de(0) : (de(0), de(1), a()), Rt(), d.value = n.value.slice(), ga(n.value, t, e.autoApply, e.modelAuto));
    }, ra = (g, ne = false) => {
      if (j(g.value) || !g.current && e.hideOffsetDates)
        return t("invalid-date", g.value);
      if (c.value = JSON.parse(JSON.stringify(g)), !F.value.enabled)
        return Pe2(g);
      yn(f.hours) && yn(f.minutes) && !R.value.enabled && (Ue(g, ne), ft());
    }, ba = (g, ne) => {
      var C;
      ee(g, ne.month, ne.year, true), m.value.count && !m.value.solo && oe2(g), t("update-month-year", { instance: g, month: ne.month, year: ne.year }), r(m.value.solo ? g : void 0);
      const me2 = (C = e.flow) != null && C.length ? e.flow[e.flowStep] : void 0;
      !ne.fromNav && (me2 === qe.month || me2 === qe.year) && a();
    }, ka = (g, ne) => {
      Un({
        value: g,
        modelValue: d,
        range: F.value.enabled,
        timezone: ne ? void 0 : _2.value.timezone
      }), y(), e.multiCalendars && nextTick().then(() => A(true));
    }, wa = () => {
      const g = Qa(K(), _2.value);
      !F.value.enabled && !R.value.enabled ? d.value = g : d.value && Array.isArray(d.value) && d.value[0] ? R.value.enabled ? d.value = [...d.value, g] : d.value = Ne(g, d.value[0]) ? [g, d.value[0]] : [d.value[0], g] : d.value = [g], y();
    }, Da = () => {
      if (Array.isArray(d.value))
        if (R.value.enabled) {
          const g = Ma();
          d.value[d.value.length - 1] = D(g);
        } else
          d.value = d.value.map((g, ne) => g && D(g, ne));
      else
        d.value = D(d.value);
      t("time-update");
    }, Ma = () => Array.isArray(d.value) && d.value.length ? d.value[d.value.length - 1] : null;
    return {
      calendars: Y,
      modelValue: d,
      month: pe2,
      year: v,
      time: f,
      disabledTimesConfig: ve,
      today: O,
      validateTime: q,
      getCalendarDays: be,
      getMarker: E,
      handleScroll: ke,
      handleSwipe: o,
      handleArrow: le,
      selectDate: ra,
      updateMonthYear: ba,
      presetDate: ka,
      selectCurrentDate: wa,
      updateTime: (g, ne = true, me2 = false) => {
        H(g, ne, me2, Da);
      },
      assignMonthAndYear: i,
      setStartTime: U
    };
  };
  var Qr = { key: 0 };
  var qr = /* @__PURE__ */ defineComponent({
    __name: "DatePicker",
    props: __spreadValues({}, ct),
    emits: [
      "tooltip-open",
      "tooltip-close",
      "mount",
      "update:internal-model-value",
      "update-flow-step",
      "reset-flow",
      "auto-apply",
      "focus-menu",
      "select-date",
      "range-start",
      "range-end",
      "invalid-fixed-range",
      "time-update",
      "am-pm-change",
      "time-picker-open",
      "time-picker-close",
      "recalculate-position",
      "update-month-year",
      "auto-apply-invalid",
      "date-update",
      "invalid-date",
      "overlay-toggle"
    ],
    setup(e, { expose: t, emit: r }) {
      const a = r, n = e, {
        calendars: u,
        month: c,
        year: p2,
        modelValue: d,
        time: Y,
        disabledTimesConfig: f,
        today: O,
        validateTime: m,
        getCalendarDays: P,
        getMarker: F,
        handleArrow: L,
        handleScroll: _2,
        handleSwipe: h2,
        selectDate: R,
        updateMonthYear: b,
        presetDate: j,
        selectCurrentDate: z,
        updateTime: ae2,
        assignMonthAndYear: H,
        setStartTime: D
      } = Gr(n, a, ie, i), Q2 = useSlots(), { setHoverDate: B, getDayClassData: q, clearHoverDate: ve } = vo(d, n), { defaultedMultiCalendars: pe2 } = Ye(n), v = ref([]), N = ref([]), ee = ref(null), y = at(Q2, "calendar"), U = at(Q2, "monthYear"), S = at(Q2, "timePicker"), Z = (le) => {
        n.shadow || a("mount", le);
      };
      watch2(
        u,
        () => {
          n.shadow || setTimeout(() => {
            a("recalculate-position");
          }, 0);
        },
        { deep: true }
      ), watch2(
        pe2,
        (le, o) => {
          le.count - o.count > 0 && H();
        },
        { deep: true }
      );
      const A = computed2(() => (le) => P(c.value(le), p2.value(le)).map((o) => __spreadProps(__spreadValues({}, o), {
        days: o.days.map((E) => (E.marker = F(E), E.classData = q(E), E))
      })));
      function ie(le) {
        var o;
        le || le === 0 ? (o = N.value[le]) == null || o.triggerTransition(c.value(le), p2.value(le)) : N.value.forEach((E, fe) => E.triggerTransition(c.value(fe), p2.value(fe)));
      }
      function i() {
        a("update-flow-step");
      }
      const W = (le, o = false) => {
        R(le, o), n.spaceConfirm && a("select-date");
      }, se = (le, o, E = 0) => {
        var fe;
        (fe = v.value[E]) == null || fe.toggleMonthPicker(le, o);
      }, T = (le, o, E = 0) => {
        var fe;
        (fe = v.value[E]) == null || fe.toggleYearPicker(le, o);
      }, re = (le, o, E) => {
        var fe;
        (fe = ee.value) == null || fe.toggleTimePicker(le, o, E);
      }, l = (le, o) => {
        var E;
        if (!n.range) {
          const fe = d.value ? d.value : O, I = o ? new Date(o) : fe, $e = le ? startOfWeek2(I, { weekStartsOn: 1 }) : endOfWeek2(I, { weekStartsOn: 1 });
          R({
            value: $e,
            current: getMonth2(I) === c.value(0),
            text: "",
            classData: {}
          }), (E = document.getElementById(Ha($e))) == null || E.focus();
        }
      }, w = (le) => {
        var o;
        (o = v.value[0]) == null || o.handleMonthYearChange(le, true);
      }, oe2 = (le) => {
        b(0, { month: c.value(0), year: p2.value(0) + (le ? 1 : -1), fromNav: true });
      }, M = (le, o) => {
        le === qe.time && a(`time-picker-${o ? "open" : "close"}`), a("overlay-toggle", { open: o, overlay: le });
      }, he2 = (le) => {
        a("overlay-toggle", { open: false, overlay: le }), a("focus-menu");
      };
      return t({
        clearHoverDate: ve,
        presetDate: j,
        selectCurrentDate: z,
        toggleMonthPicker: se,
        toggleYearPicker: T,
        toggleTimePicker: re,
        handleArrow: L,
        updateMonthYear: b,
        getSidebarProps: () => ({
          modelValue: d,
          month: c,
          year: p2,
          time: Y,
          updateTime: ae2,
          updateMonthYear: b,
          selectDate: R,
          presetDate: j
        }),
        changeMonth: w,
        changeYear: oe2,
        selectWeekDate: l,
        setStartTime: D
      }), (le, o) => (openBlock(), createElementBlock(Fragment, null, [
        createVNode(ya, {
          "multi-calendars": unref(pe2).count,
          collapse: le.collapse,
          "is-mobile": le.isMobile
        }, {
          default: withCtx(({ instance: E, index: fe }) => [
            le.disableMonthYearSelect ? createCommentVNode("", true) : (openBlock(), createBlock(Fr, mergeProps({
              key: 0,
              ref: (I) => {
                I && (v.value[fe] = I);
              },
              months: unref(Sn)(le.formatLocale, le.locale, le.monthNameFormat),
              years: unref(qa)(le.yearRange, le.locale, le.reverseYears),
              month: unref(c)(E),
              year: unref(p2)(E),
              instance: E
            }, le.$props, {
              onMount: o[0] || (o[0] = (I) => Z(unref(_t).header)),
              onResetFlow: o[1] || (o[1] = (I) => le.$emit("reset-flow")),
              onUpdateMonthYear: (I) => unref(b)(E, I),
              onOverlayClosed: he2,
              onOverlayOpened: o[2] || (o[2] = (I) => le.$emit("overlay-toggle", { open: true, overlay: I }))
            }), createSlots({ _: 2 }, [
              renderList(unref(U), (I, $e) => ({
                name: I,
                fn: withCtx((be) => [
                  renderSlot(le.$slots, I, normalizeProps(guardReactiveProps(be)))
                ])
              }))
            ]), 1040, ["months", "years", "month", "year", "instance", "onUpdateMonthYear"])),
            createVNode(Kr, mergeProps({
              ref: (I) => {
                I && (N.value[fe] = I);
              },
              "mapped-dates": A.value(E),
              month: unref(c)(E),
              year: unref(p2)(E),
              instance: E
            }, le.$props, {
              onSelectDate: (I) => unref(R)(I, E !== 1),
              onHandleSpace: (I) => W(I, E !== 1),
              onSetHoverDate: o[3] || (o[3] = (I) => unref(B)(I)),
              onHandleScroll: (I) => unref(_2)(I, E),
              onHandleSwipe: (I) => unref(h2)(I, E),
              onMount: o[4] || (o[4] = (I) => Z(unref(_t).calendar)),
              onResetFlow: o[5] || (o[5] = (I) => le.$emit("reset-flow")),
              onTooltipOpen: o[6] || (o[6] = (I) => le.$emit("tooltip-open", I)),
              onTooltipClose: o[7] || (o[7] = (I) => le.$emit("tooltip-close", I))
            }), createSlots({ _: 2 }, [
              renderList(unref(y), (I, $e) => ({
                name: I,
                fn: withCtx((be) => [
                  renderSlot(le.$slots, I, normalizeProps(guardReactiveProps(__spreadValues({}, be))))
                ])
              }))
            ]), 1040, ["mapped-dates", "month", "year", "instance", "onSelectDate", "onHandleSpace", "onHandleScroll", "onHandleSwipe"])
          ]),
          _: 3
        }, 8, ["multi-calendars", "collapse", "is-mobile"]),
        le.enableTimePicker ? (openBlock(), createElementBlock("div", Qr, [
          le.$slots["time-picker"] ? renderSlot(le.$slots, "time-picker", normalizeProps(mergeProps({ key: 0 }, { time: unref(Y), updateTime: unref(ae2) }))) : (openBlock(), createBlock(jn, mergeProps({
            key: 1,
            ref_key: "timePickerRef",
            ref: ee
          }, le.$props, {
            hours: unref(Y).hours,
            minutes: unref(Y).minutes,
            seconds: unref(Y).seconds,
            "internal-model-value": le.internalModelValue,
            "disabled-times-config": unref(f),
            "validate-time": unref(m),
            onMount: o[8] || (o[8] = (E) => Z(unref(_t).timePicker)),
            "onUpdate:hours": o[9] || (o[9] = (E) => unref(ae2)(E)),
            "onUpdate:minutes": o[10] || (o[10] = (E) => unref(ae2)(E, false)),
            "onUpdate:seconds": o[11] || (o[11] = (E) => unref(ae2)(E, false, true)),
            onResetFlow: o[12] || (o[12] = (E) => le.$emit("reset-flow")),
            onOverlayClosed: o[13] || (o[13] = (E) => M(E, false)),
            onOverlayOpened: o[14] || (o[14] = (E) => M(E, true)),
            onAmPmChange: o[15] || (o[15] = (E) => le.$emit("am-pm-change", E))
          }), createSlots({ _: 2 }, [
            renderList(unref(S), (E, fe) => ({
              name: E,
              fn: withCtx((I) => [
                renderSlot(le.$slots, E, normalizeProps(guardReactiveProps(I)))
              ])
            }))
          ]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config", "validate-time"]))
        ])) : createCommentVNode("", true)
      ], 64));
    }
  });
  var Xr = (e, t) => {
    const r = ref(), {
      defaultedMultiCalendars: a,
      defaultedConfig: n,
      defaultedHighlight: u,
      defaultedRange: c,
      propDates: p2,
      defaultedFilters: d,
      defaultedMultiDates: Y
    } = Ye(e), { modelValue: f, year: O, month: m, calendars: P } = la(e, t), { isDisabled: F } = Pt(e), { selectYear: L, groupedYears: _2, showYearPicker: h2, isDisabled: R, toggleYearPicker: b, handleYearSelect: j, handleYear: z } = Vn({
      modelValue: f,
      multiCalendars: a,
      range: c,
      highlight: u,
      calendars: P,
      propDates: p2,
      month: m,
      year: O,
      filters: d,
      props: e,
      emit: t
    }), ae2 = (y, U) => [y, U].map((S) => format2(S, "MMMM", { locale: e.formatLocale })).join("-"), H = computed2(() => (y) => f.value ? Array.isArray(f.value) ? f.value.some((U) => isSameQuarter(y, U)) : isSameQuarter(f.value, y) : false), D = (y) => {
      if (c.value.enabled) {
        if (Array.isArray(f.value)) {
          const U = Te(y, f.value[0]) || Te(y, f.value[1]);
          return ea(f.value, r.value, y) && !U;
        }
        return false;
      }
      return false;
    }, Q2 = (y, U) => y.quarter === getQuarter(U) && y.year === getYear2(U), B = (y) => typeof u.value == "function" ? u.value({ quarter: getQuarter(y), year: getYear2(y) }) : !!u.value.quarters.find((U) => Q2(U, y)), q = computed2(() => (y) => {
      const U = set(/* @__PURE__ */ new Date(), { year: O.value(y) });
      return eachQuarterOfInterval({
        start: startOfYear2(U),
        end: endOfYear2(U)
      }).map((S) => {
        const Z = startOfQuarter(S), A = endOfQuarter(S), ie = F(S), i = D(Z), W = B(Z);
        return {
          text: ae2(Z, A),
          value: Z,
          active: H.value(Z),
          highlighted: W,
          disabled: ie,
          isBetween: i
        };
      });
    }), ve = (y) => {
      xa(y, f, Y.value.limit), t("auto-apply", true);
    }, pe2 = (y) => {
      f.value = en(f, y, t), ga(f.value, t, e.autoApply, e.modelAuto);
    }, v = (y) => {
      f.value = y, t("auto-apply");
    };
    return {
      defaultedConfig: n,
      defaultedMultiCalendars: a,
      groupedYears: _2,
      year: O,
      isDisabled: R,
      quarters: q,
      showYearPicker: h2,
      modelValue: f,
      setHoverDate: (y) => {
        r.value = y;
      },
      selectYear: L,
      selectQuarter: (y, U, S) => {
        if (!S)
          return P.value[U].month = getMonth2(endOfQuarter(y)), Y.value.enabled ? ve(y) : c.value.enabled ? pe2(y) : v(y);
      },
      toggleYearPicker: b,
      handleYearSelect: j,
      handleYear: z
    };
  };
  var Jr = { class: "dp--quarter-items" };
  var Zr = ["data-test-id", "disabled", "onClick", "onMouseover"];
  var xr = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    __name: "QuarterPicker",
    props: __spreadValues({}, ct),
    emits: [
      "update:internal-model-value",
      "reset-flow",
      "overlay-closed",
      "auto-apply",
      "range-start",
      "range-end",
      "overlay-toggle",
      "update-month-year"
    ],
    setup(e, { expose: t, emit: r }) {
      const a = r, n = e, u = useSlots(), c = at(u, "yearMode"), {
        defaultedMultiCalendars: p2,
        defaultedConfig: d,
        groupedYears: Y,
        year: f,
        isDisabled: O,
        quarters: m,
        modelValue: P,
        showYearPicker: F,
        setHoverDate: L,
        selectQuarter: _2,
        toggleYearPicker: h2,
        handleYearSelect: R,
        handleYear: b
      } = Xr(n, a);
      return t({ getSidebarProps: () => ({
        modelValue: P,
        year: f,
        selectQuarter: _2,
        handleYearSelect: R,
        handleYear: b
      }) }), (z, ae2) => (openBlock(), createBlock(ya, {
        "multi-calendars": unref(p2).count,
        collapse: z.collapse,
        stretch: "",
        "is-mobile": z.isMobile
      }, {
        default: withCtx(({ instance: H }) => [
          createBaseVNode("div", {
            class: "dp-quarter-picker-wrap",
            style: normalizeStyle({ minHeight: `${unref(d).modeHeight}px` })
          }, [
            z.$slots["top-extra"] ? renderSlot(z.$slots, "top-extra", {
              key: 0,
              value: z.internalModelValue
            }) : createCommentVNode("", true),
            createBaseVNode("div", null, [
              createVNode(Hn, mergeProps(z.$props, {
                items: unref(Y)(H),
                instance: H,
                "show-year-picker": unref(F)[H],
                year: unref(f)(H),
                "is-disabled": (D) => unref(O)(H, D),
                onHandleYear: (D) => unref(b)(H, D),
                onYearSelect: (D) => unref(R)(D, H),
                onToggleYearPicker: (D) => unref(h2)(H, D == null ? void 0 : D.flow, D == null ? void 0 : D.show)
              }), createSlots({ _: 2 }, [
                renderList(unref(c), (D, Q2) => ({
                  name: D,
                  fn: withCtx((B) => [
                    renderSlot(z.$slots, D, normalizeProps(guardReactiveProps(B)))
                  ])
                }))
              ]), 1040, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])
            ]),
            createBaseVNode("div", Jr, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(m)(H), (D, Q2) => (openBlock(), createElementBlock("div", { key: Q2 }, [
                createBaseVNode("button", {
                  type: "button",
                  class: normalizeClass(["dp--qr-btn", {
                    "dp--qr-btn-active": D.active,
                    "dp--qr-btn-between": D.isBetween,
                    "dp--qr-btn-disabled": D.disabled,
                    "dp--highlighted": D.highlighted
                  }]),
                  "data-test-id": D.value,
                  disabled: D.disabled,
                  onClick: (B) => unref(_2)(D.value, H, D.disabled),
                  onMouseover: (B) => unref(L)(D.value)
                }, [
                  z.$slots.quarter ? renderSlot(z.$slots, "quarter", {
                    key: 0,
                    value: D.value,
                    text: D.text
                  }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createTextVNode(toDisplayString(D.text), 1)
                  ], 64))
                ], 42, Zr)
              ]))), 128))
            ])
          ], 4)
        ]),
        _: 3
      }, 8, ["multi-calendars", "collapse", "is-mobile"]));
    }
  });
  var Gn = (e, t) => {
    const r = ref(0);
    onMounted(() => {
      a(), window.addEventListener("resize", a, { passive: true });
    }), onUnmounted(() => {
      window.removeEventListener("resize", a);
    });
    const a = () => {
      r.value = window.document.documentElement.clientWidth;
    };
    return {
      isMobile: computed2(
        () => r.value <= e.value.mobileBreakpoint && !t ? true : void 0
      )
    };
  };
  var eo = ["id", "tabindex", "role", "aria-label"];
  var to = {
    key: 0,
    class: "dp--menu-load-container"
  };
  var ao = {
    key: 1,
    class: "dp--menu-header"
  };
  var no = ["data-dp-mobile"];
  var lo = {
    key: 0,
    class: "dp__sidebar_left"
  };
  var ro = ["data-dp-mobile"];
  var oo = ["data-test-id", "data-dp-mobile", "onClick", "onKeydown"];
  var so = {
    key: 2,
    class: "dp__sidebar_right"
  };
  var uo = {
    key: 3,
    class: "dp__action_extra"
  };
  var gn = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    __name: "DatepickerMenu",
    props: __spreadProps(__spreadValues({}, pa), {
      shadow: { type: Boolean, default: false },
      openOnTop: { type: Boolean, default: false },
      internalModelValue: { type: [Date, Array], default: null },
      noOverlayFocus: { type: Boolean, default: false },
      collapse: { type: Boolean, default: false },
      getInputRect: { type: Function, default: () => ({}) },
      isTextInputDate: { type: Boolean, default: false }
    }),
    emits: [
      "close-picker",
      "select-date",
      "auto-apply",
      "time-update",
      "flow-step",
      "update-month-year",
      "invalid-select",
      "update:internal-model-value",
      "recalculate-position",
      "invalid-fixed-range",
      "tooltip-open",
      "tooltip-close",
      "time-picker-open",
      "time-picker-close",
      "am-pm-change",
      "range-start",
      "range-end",
      "auto-apply-invalid",
      "date-update",
      "invalid-date",
      "overlay-toggle",
      "menu-blur"
    ],
    setup(e, { expose: t, emit: r }) {
      const a = r, n = e, u = ref(null), c = computed2(() => {
        const _a3 = n, { openOnTop: k } = _a3, x = __objRest(_a3, ["openOnTop"]);
        return __spreadProps(__spreadValues({}, x), {
          isMobile: _2.value,
          flowStep: pe2.value,
          menuWrapRef: u.value
        });
      }), { setMenuFocused: p2, setShiftKey: d, control: Y } = zn(), f = useSlots(), { defaultedTextInput: O, defaultedInline: m, defaultedConfig: P, defaultedUI: F, handleEventPropagation: L } = Ye(n), { isMobile: _2 } = Gn(P, n.shadow), h2 = ref(null), R = ref(0), b = ref(null), j = ref(false), z = ref(null), ae2 = ref(false), H = (k) => {
        ae2.value = true, P.value.allowPreventDefault && k.preventDefault(), $t(k, P.value, true);
      };
      onMounted(() => {
        if (!n.shadow) {
          j.value = true, D(), window.addEventListener("resize", D);
          const k = He(u);
          k && !O.value.enabled && !m.value.enabled && (p2(true), Z()), k && (k.addEventListener("pointerdown", H), k.addEventListener("mousedown", H));
        }
        document.addEventListener("mousedown", Ee2);
      }), onUnmounted(() => {
        window.removeEventListener("resize", D), document.removeEventListener("mousedown", Ee2);
        const k = He(u);
        k && (k.removeEventListener("pointerdown", H), k.removeEventListener("mousedown", H));
      });
      const D = () => {
        const k = He(b);
        k && (R.value = k.getBoundingClientRect().width);
      }, { arrowRight: Q2, arrowLeft: B, arrowDown: q, arrowUp: ve } = St(), { flowStep: pe2, updateFlowStep: v, childMount: N, resetFlow: ee, handleFlow: y } = mo(n, a, z), U = computed2(() => n.monthPicker ? gr : n.yearPicker ? br : n.timePicker ? _r : n.quarterPicker ? xr : qr), S = computed2(() => {
        var _a3, _b;
        var Ie;
        if (P.value.arrowLeft)
          return P.value.arrowLeft;
        const k = (Ie = u.value) == null ? void 0 : Ie.getBoundingClientRect(), x = n.getInputRect();
        return (x == null ? void 0 : x.width) < (R == null ? void 0 : R.value) && (x == null ? void 0 : x.left) <= ((_a3 = k == null ? void 0 : k.left) != null ? _a3 : 0) ? `${(x == null ? void 0 : x.width) / 2}px` : (x == null ? void 0 : x.right) >= ((_b = k == null ? void 0 : k.right) != null ? _b : 0) && (x == null ? void 0 : x.width) < (R == null ? void 0 : R.value) ? `${(R == null ? void 0 : R.value) - (x == null ? void 0 : x.width) / 2}px` : "50%";
      }), Z = () => {
        const k = He(u);
        k && k.focus({ preventScroll: true });
      }, A = computed2(() => {
        var k;
        return ((k = z.value) == null ? void 0 : k.getSidebarProps()) || {};
      }), ie = () => {
        n.openOnTop && a("recalculate-position");
      }, i = at(f, "action"), W = computed2(() => n.monthPicker || n.yearPicker ? at(f, "monthYear") : n.timePicker ? at(f, "timePicker") : at(f, "shared")), se = computed2(() => n.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top"), T = computed2(() => ({
        dp__menu_disabled: n.disabled,
        dp__menu_readonly: n.readonly,
        "dp-menu-loading": n.loading
      })), re = computed2(
        () => {
          var _a3;
          return __spreadValues({
            dp__menu: true,
            dp__menu_index: !m.value.enabled,
            dp__relative: m.value.enabled
          }, (_a3 = F.value.menu) != null ? _a3 : {});
        }
      ), l = (k) => {
        $t(k, P.value, true);
      }, w = (k) => {
        n.escClose && (a("close-picker"), L(k));
      }, oe2 = (k) => {
        if (n.arrowNavigation) {
          if (k === Ze.up)
            return ve();
          if (k === Ze.down)
            return q();
          if (k === Ze.left)
            return B();
          if (k === Ze.right)
            return Q2();
        } else
          k === Ze.left || k === Ze.up ? o("handleArrow", Ze.left, 0, k === Ze.up) : o("handleArrow", Ze.right, 0, k === Ze.down);
      }, M = (k) => {
        d(k.shiftKey), !n.disableMonthYearSelect && k.code === Oe.tab && k.target.classList.contains("dp__menu") && Y.value.shiftKeyInMenu && (k.preventDefault(), $t(k, P.value, true), a("close-picker"));
      }, he2 = () => {
        Z(), a("time-picker-close");
      }, ke = (k) => {
        var x, Ie, Ue;
        (x = z.value) == null || x.toggleTimePicker(false, false), (Ie = z.value) == null || Ie.toggleMonthPicker(false, false, k), (Ue = z.value) == null || Ue.toggleYearPicker(false, false, k);
      }, le = (k, x = 0) => {
        var Ie, Ue, rt;
        return k === "month" ? (Ie = z.value) == null ? void 0 : Ie.toggleMonthPicker(false, true, x) : k === "year" ? (Ue = z.value) == null ? void 0 : Ue.toggleYearPicker(false, true, x) : k === "time" ? (rt = z.value) == null ? void 0 : rt.toggleTimePicker(true, false) : ke(x);
      }, o = (k, ...x) => {
        var Ie, Ue;
        (Ie = z.value) != null && Ie[k] && ((Ue = z.value) == null || Ue[k](...x));
      }, E = () => {
        o("selectCurrentDate");
      }, fe = (k, x) => {
        o("presetDate", toValue(k), x);
      }, I = () => {
        o("clearHoverDate");
      }, $e = (k, x) => {
        o("updateMonthYear", k, x);
      }, be = (k, x) => {
        k.preventDefault(), oe2(x);
      }, Pe2 = (k) => {
        var x, Ie, Ue;
        if (M(k), k.key === Oe.home || k.key === Oe.end)
          return o(
            "selectWeekDate",
            k.key === Oe.home,
            k.target.getAttribute("id")
          );
        switch ((k.key === Oe.pageUp || k.key === Oe.pageDown) && (k.shiftKey ? (o("changeYear", k.key === Oe.pageUp), (x = Fa(u.value, "overlay-year")) == null || x.focus()) : (o("changeMonth", k.key === Oe.pageUp), (Ie = Fa(u.value, k.key === Oe.pageUp ? "action-prev" : "action-next")) == null || Ie.focus()), k.target.getAttribute("id") && ((Ue = u.value) == null || Ue.focus({ preventScroll: true }))), k.key) {
          case Oe.esc:
            return w(k);
          case Oe.arrowLeft:
            return be(k, Ze.left);
          case Oe.arrowRight:
            return be(k, Ze.right);
          case Oe.arrowUp:
            return be(k, Ze.up);
          case Oe.arrowDown:
            return be(k, Ze.down);
          default:
            return;
        }
      }, Ee2 = (k) => {
        var x;
        m.value.enabled && !m.value.input && !((x = u.value) != null && x.contains(k.target)) && ae2.value && (ae2.value = false, a("menu-blur"));
      };
      return t({
        updateMonthYear: $e,
        switchView: le,
        handleFlow: y,
        onValueCleared: () => {
          var k, x;
          (x = (k = z.value) == null ? void 0 : k.setStartTime) == null || x.call(k);
        }
      }), (k, x) => {
        var Ie, Ue, rt;
        return openBlock(), createElementBlock("div", {
          id: k.uid ? `dp-menu-${k.uid}` : void 0,
          ref_key: "dpMenuRef",
          ref: u,
          tabindex: unref(m).enabled ? void 0 : "0",
          role: unref(m).enabled ? void 0 : "dialog",
          "aria-label": (Ie = k.ariaLabels) == null ? void 0 : Ie.menu,
          class: normalizeClass(re.value),
          style: normalizeStyle({ "--dp-arrow-left": S.value }),
          onMouseleave: I,
          onClick: l,
          onKeydown: Pe2
        }, [
          (k.disabled || k.readonly) && unref(m).enabled || k.loading ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(T.value)
          }, [
            k.loading ? (openBlock(), createElementBlock("div", to, x[19] || (x[19] = [
              createBaseVNode("span", { class: "dp--menu-loader" }, null, -1)
            ]))) : createCommentVNode("", true)
          ], 2)) : createCommentVNode("", true),
          k.$slots["menu-header"] ? (openBlock(), createElementBlock("div", ao, [
            renderSlot(k.$slots, "menu-header")
          ])) : createCommentVNode("", true),
          !unref(m).enabled && !k.teleportCenter ? (openBlock(), createElementBlock("div", {
            key: 2,
            class: normalizeClass(se.value)
          }, null, 2)) : createCommentVNode("", true),
          createBaseVNode("div", {
            ref_key: "innerMenuRef",
            ref: b,
            class: normalizeClass({
              dp__menu_content_wrapper: ((Ue = k.presetDates) == null ? void 0 : Ue.length) || !!k.$slots["left-sidebar"] || !!k.$slots["right-sidebar"],
              "dp--menu-content-wrapper-collapsed": e.collapse && (((rt = k.presetDates) == null ? void 0 : rt.length) || !!k.$slots["left-sidebar"] || !!k.$slots["right-sidebar"])
            }),
            "data-dp-mobile": unref(_2),
            style: normalizeStyle({ "--dp-menu-width": `${R.value}px` })
          }, [
            k.$slots["left-sidebar"] ? (openBlock(), createElementBlock("div", lo, [
              renderSlot(k.$slots, "left-sidebar", normalizeProps(guardReactiveProps(A.value)))
            ])) : createCommentVNode("", true),
            k.presetDates.length ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass({ "dp--preset-dates-collapsed": e.collapse, "dp--preset-dates": true }),
              "data-dp-mobile": unref(_2)
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(k.presetDates, (de, Rt) => {
                var _a3;
                return openBlock(), createElementBlock(Fragment, { key: Rt }, [
                  de.slot ? renderSlot(k.$slots, de.slot, {
                    key: 0,
                    presetDate: fe,
                    label: de.label,
                    value: de.value
                  }) : (openBlock(), createElementBlock("button", {
                    key: 1,
                    type: "button",
                    style: normalizeStyle(de.style || {}),
                    class: normalizeClass(["dp__btn dp--preset-range", { "dp--preset-range-collapsed": e.collapse }]),
                    "data-test-id": (_a3 = de.testId) != null ? _a3 : void 0,
                    "data-dp-mobile": unref(_2),
                    onClick: withModifiers((ft) => fe(de.value, de.noTz), ["prevent"]),
                    onKeydown: (ft) => unref(xe)(ft, () => fe(de.value, de.noTz), true)
                  }, toDisplayString(de.label), 47, oo))
                ], 64);
              }), 128))
            ], 10, ro)) : createCommentVNode("", true),
            createBaseVNode("div", {
              ref_key: "calendarWrapperRef",
              ref: h2,
              class: "dp__instance_calendar",
              role: "document"
            }, [
              (openBlock(), createBlock(resolveDynamicComponent(U.value), mergeProps({
                ref_key: "dynCmpRef",
                ref: z
              }, c.value, {
                "flow-step": unref(pe2),
                onMount: unref(N),
                onUpdateFlowStep: unref(v),
                onResetFlow: unref(ee),
                onFocusMenu: Z,
                onSelectDate: x[0] || (x[0] = (de) => k.$emit("select-date")),
                onDateUpdate: x[1] || (x[1] = (de) => k.$emit("date-update", de)),
                onTooltipOpen: x[2] || (x[2] = (de) => k.$emit("tooltip-open", de)),
                onTooltipClose: x[3] || (x[3] = (de) => k.$emit("tooltip-close", de)),
                onAutoApply: x[4] || (x[4] = (de) => k.$emit("auto-apply", de)),
                onRangeStart: x[5] || (x[5] = (de) => k.$emit("range-start", de)),
                onRangeEnd: x[6] || (x[6] = (de) => k.$emit("range-end", de)),
                onInvalidFixedRange: x[7] || (x[7] = (de) => k.$emit("invalid-fixed-range", de)),
                onTimeUpdate: x[8] || (x[8] = (de) => k.$emit("time-update")),
                onAmPmChange: x[9] || (x[9] = (de) => k.$emit("am-pm-change", de)),
                onTimePickerOpen: x[10] || (x[10] = (de) => k.$emit("time-picker-open", de)),
                onTimePickerClose: he2,
                onRecalculatePosition: ie,
                onUpdateMonthYear: x[11] || (x[11] = (de) => k.$emit("update-month-year", de)),
                onAutoApplyInvalid: x[12] || (x[12] = (de) => k.$emit("auto-apply-invalid", de)),
                onInvalidDate: x[13] || (x[13] = (de) => k.$emit("invalid-date", de)),
                onOverlayToggle: x[14] || (x[14] = (de) => k.$emit("overlay-toggle", de)),
                "onUpdate:internalModelValue": x[15] || (x[15] = (de) => k.$emit("update:internal-model-value", de))
              }), createSlots({ _: 2 }, [
                renderList(W.value, (de, Rt) => ({
                  name: de,
                  fn: withCtx((ft) => [
                    renderSlot(k.$slots, de, normalizeProps(guardReactiveProps(__spreadValues({}, ft))))
                  ])
                }))
              ]), 1040, ["flow-step", "onMount", "onUpdateFlowStep", "onResetFlow"]))
            ], 512),
            k.$slots["right-sidebar"] ? (openBlock(), createElementBlock("div", so, [
              renderSlot(k.$slots, "right-sidebar", normalizeProps(guardReactiveProps(A.value)))
            ])) : createCommentVNode("", true),
            k.$slots["action-extra"] ? (openBlock(), createElementBlock("div", uo, [
              k.$slots["action-extra"] ? renderSlot(k.$slots, "action-extra", {
                key: 0,
                selectCurrentDate: E
              }) : createCommentVNode("", true)
            ])) : createCommentVNode("", true)
          ], 14, no),
          !k.autoApply || unref(P).keepActionRow ? (openBlock(), createBlock(ur, mergeProps({
            key: 3,
            "menu-mount": j.value
          }, c.value, {
            "calendar-width": R.value,
            onClosePicker: x[16] || (x[16] = (de) => k.$emit("close-picker")),
            onSelectDate: x[17] || (x[17] = (de) => k.$emit("select-date")),
            onInvalidSelect: x[18] || (x[18] = (de) => k.$emit("invalid-select")),
            onSelectNow: E
          }), createSlots({ _: 2 }, [
            renderList(unref(i), (de, Rt) => ({
              name: de,
              fn: withCtx((ft) => [
                renderSlot(k.$slots, de, normalizeProps(guardReactiveProps(__spreadValues({}, ft))))
              ])
            }))
          ]), 1040, ["menu-mount", "calendar-width"])) : createCommentVNode("", true)
        ], 46, eo);
      };
    }
  });
  var Lt = /* @__PURE__ */ ((e) => (e.center = "center", e.left = "left", e.right = "right", e))(Lt || {});
  var io = ({
    menuRef: e,
    menuRefInner: t,
    inputRef: r,
    pickerWrapperRef: a,
    inline: n,
    emit: u,
    props: c,
    slots: p2
  }) => {
    const { defaultedConfig: d } = Ye(c), Y = ref({}), f = ref(false), O = ref({
      top: "0",
      left: "0"
    }), m = ref(false), P = toRef(c, "teleportCenter");
    watch2(P, () => {
      O.value = JSON.parse(JSON.stringify({})), z();
    });
    const F = (y) => {
      if (c.teleport) {
        const U = y.getBoundingClientRect();
        return {
          left: U.left + window.scrollX,
          top: U.top + window.scrollY
        };
      }
      return { top: 0, left: 0 };
    }, L = (y, U) => {
      O.value.left = `${y + U - Y.value.width}px`;
    }, _2 = (y) => {
      O.value.left = `${y}px`;
    }, h2 = (y, U) => {
      c.position === Lt.left && _2(y), c.position === Lt.right && L(y, U), c.position === Lt.center && (O.value.left = `${y + U / 2 - Y.value.width / 2}px`);
    }, R = (y) => {
      const { width: U, height: S } = y.getBoundingClientRect(), { top: Z, left: A } = F(y);
      return { top: +Z, left: +A, width: U, height: S };
    }, b = () => {
      O.value.left = "50%", O.value.top = "50%", O.value.transform = "translate(-50%, -50%)", O.value.position = "fixed", delete O.value.opacity;
    }, j = () => {
      const y = He(r);
      O.value = c.altPosition(y);
    }, z = (y = true) => {
      var U;
      if (!n.value.enabled) {
        if (P.value)
          return b();
        if (c.altPosition !== null)
          return j();
        if (y) {
          const S = c.teleport ? (U = t.value) == null ? void 0 : U.$el : e.value;
          S && (Y.value = S.getBoundingClientRect()), u("recalculate-position");
        }
        return ve();
      }
    }, ae2 = ({ inputEl: y, left: U, width: S }) => {
      window.screen.width > 768 && !f.value && h2(U, S), Q2(y);
    }, H = (y) => {
      const { top: U, left: S, height: Z, width: A } = R(y);
      O.value.top = `${Z + U + +c.offset}px`, m.value = false, f.value || (O.value.left = `${S + A / 2 - Y.value.width / 2}px`), ae2({ inputEl: y, left: S, width: A });
    }, D = (y) => {
      const { top: U, left: S, width: Z } = R(y);
      O.value.top = `${U - +c.offset - Y.value.height}px`, m.value = true, ae2({ inputEl: y, left: S, width: Z });
    }, Q2 = (y) => {
      if (c.autoPosition) {
        const { left: U, width: S } = R(y), { left: Z, right: A } = Y.value;
        if (!f.value) {
          if (Math.abs(Z) !== Math.abs(A)) {
            if (Z <= 0)
              return f.value = true, _2(U);
            if (A >= document.documentElement.clientWidth)
              return f.value = true, L(U, S);
          }
          return h2(U, S);
        }
      }
    }, B = () => {
      const y = He(r);
      if (y) {
        if (c.autoPosition === it.top)
          return it.top;
        if (c.autoPosition === it.bottom)
          return it.bottom;
        const { height: U } = Y.value, { top: S, height: Z } = y.getBoundingClientRect(), ie = window.innerHeight - S - Z, i = S;
        return U <= ie ? it.bottom : U > ie && U <= i ? it.top : ie >= i ? it.bottom : it.top;
      }
      return it.bottom;
    }, q = (y) => B() === it.bottom ? H(y) : D(y), ve = () => {
      const y = He(r);
      if (y)
        return c.autoPosition ? q(y) : H(y);
    }, pe2 = function(y) {
      if (y) {
        const U = y.scrollHeight > y.clientHeight, Z = window.getComputedStyle(y).overflowY.indexOf("hidden") !== -1;
        return U && !Z;
      }
      return true;
    }, v = function(y) {
      return !y || y === document.body || y.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? window : pe2(y) ? y : v(
        y.assignedSlot && d.value.shadowDom ? y.assignedSlot.parentNode : y.parentNode
      );
    }, N = (y) => {
      if (y)
        switch (c.position) {
          case Lt.left:
            return { left: 0, transform: "translateX(0)" };
          case Lt.right:
            return { left: `${y.width}px`, transform: "translateX(-100%)" };
          default:
            return { left: `${y.width / 2}px`, transform: "translateX(-50%)" };
        }
      return {};
    };
    return {
      openOnTop: m,
      menuStyle: O,
      xCorrect: f,
      setMenuPosition: z,
      getScrollableParent: v,
      shadowRender: (y, U, S) => {
        var T, re, l;
        const Z = document.createElement("div"), A = (T = He(r)) == null ? void 0 : T.getBoundingClientRect();
        Z.setAttribute("id", "dp--temp-container");
        const ie = (re = a.value) != null && re.clientWidth ? a.value : document.body;
        ie.append(Z);
        const i = N(A), W = d.value.shadowDom ? Object.keys(p2).filter(
          (w) => ["right-sidebar", "left-sidebar", "top-extra", "action-extra"].includes(w)
        ) : Object.keys(p2), se = h(
          U,
          __spreadProps(__spreadValues({}, S), {
            shadow: true,
            style: __spreadValues({ opacity: 0, position: "absolute" }, i)
          }),
          Object.fromEntries(W.map((w) => [w, p2[w]]))
        );
        y != null && (se.appContext = y.appContext), render(se, Z), Y.value = (l = se.el) == null ? void 0 : l.getBoundingClientRect(), render(null, Z), ie.removeChild(Z);
      }
    };
  };
  var wt = [
    { name: "clock-icon", use: ["time", "calendar", "shared"] },
    { name: "arrow-left", use: ["month-year", "calendar", "shared", "year-mode"] },
    { name: "arrow-right", use: ["month-year", "calendar", "shared", "year-mode"] },
    { name: "arrow-up", use: ["time", "calendar", "month-year", "shared"] },
    { name: "arrow-down", use: ["time", "calendar", "month-year", "shared"] },
    { name: "calendar-icon", use: ["month-year", "time", "calendar", "shared", "year-mode"] },
    { name: "day", use: ["calendar", "shared"] },
    { name: "month-overlay-value", use: ["calendar", "month-year", "shared"] },
    { name: "year-overlay-value", use: ["calendar", "month-year", "shared", "year-mode"] },
    { name: "year-overlay", use: ["month-year", "shared"] },
    { name: "month-overlay", use: ["month-year", "shared"] },
    { name: "month-overlay-header", use: ["month-year", "shared"] },
    { name: "year-overlay-header", use: ["month-year", "shared"] },
    { name: "hours-overlay-value", use: ["calendar", "time", "shared"] },
    { name: "hours-overlay-header", use: ["calendar", "time", "shared"] },
    { name: "minutes-overlay-value", use: ["calendar", "time", "shared"] },
    { name: "minutes-overlay-header", use: ["calendar", "time", "shared"] },
    { name: "seconds-overlay-value", use: ["calendar", "time", "shared"] },
    { name: "seconds-overlay-header", use: ["calendar", "time", "shared"] },
    { name: "hours", use: ["calendar", "time", "shared"] },
    { name: "minutes", use: ["calendar", "time", "shared"] },
    { name: "month", use: ["calendar", "month-year", "shared"] },
    { name: "year", use: ["calendar", "month-year", "shared", "year-mode"] },
    { name: "action-buttons", use: ["action"] },
    { name: "action-preview", use: ["action"] },
    { name: "calendar-header", use: ["calendar", "shared"] },
    { name: "marker-tooltip", use: ["calendar", "shared"] },
    { name: "action-extra", use: ["menu"] },
    { name: "time-picker-overlay", use: ["calendar", "time", "shared"] },
    { name: "am-pm-button", use: ["calendar", "time", "shared"] },
    { name: "left-sidebar", use: ["menu"] },
    { name: "right-sidebar", use: ["menu"] },
    { name: "month-year", use: ["month-year", "shared"] },
    { name: "time-picker", use: ["menu", "shared"] },
    { name: "action-row", use: ["action"] },
    { name: "marker", use: ["calendar", "shared"] },
    { name: "quarter", use: ["shared"] },
    { name: "top-extra", use: ["shared", "month-year"] },
    { name: "tp-inline-arrow-up", use: ["shared", "time"] },
    { name: "tp-inline-arrow-down", use: ["shared", "time"] },
    { name: "menu-header", use: ["menu"] }
  ];
  var co = [{ name: "trigger" }, { name: "input-icon" }, { name: "clear-icon" }, { name: "dp-input" }];
  var fo = {
    all: () => wt,
    monthYear: () => wt.filter((e) => e.use.includes("month-year")),
    input: () => co,
    timePicker: () => wt.filter((e) => e.use.includes("time")),
    action: () => wt.filter((e) => e.use.includes("action")),
    calendar: () => wt.filter((e) => e.use.includes("calendar")),
    menu: () => wt.filter((e) => e.use.includes("menu")),
    shared: () => wt.filter((e) => e.use.includes("shared")),
    yearMode: () => wt.filter((e) => e.use.includes("year-mode"))
  };
  var at = (e, t, r) => {
    const a = [];
    return fo[t]().forEach((n) => {
      e[n.name] && a.push(n.name);
    }), r != null && r.length && r.forEach((n) => {
      n.slot && a.push(n.slot);
    }), a;
  };
  var na = (e) => {
    const t = computed2(() => (a) => e.value ? a ? e.value.open : e.value.close : ""), r = computed2(() => (a) => e.value ? a ? e.value.menuAppearTop : e.value.menuAppearBottom : "");
    return { transitionName: t, showTransition: !!e.value, menuTransition: r };
  };
  var la = (e, t, r) => {
    const { defaultedRange: a, defaultedTz: n } = Ye(e), u = K(tt2(K(), n.value.timezone)), c = ref([{ month: getMonth2(u), year: getYear2(u) }]), p2 = (m) => {
      const P = {
        hours: getHours2(u),
        minutes: getMinutes2(u),
        seconds: 0
      };
      return a.value.enabled ? [P[m], P[m]] : P[m];
    }, d = reactive({
      hours: p2("hours"),
      minutes: p2("minutes"),
      seconds: p2("seconds")
    });
    watch2(
      a,
      (m, P) => {
        m.enabled !== P.enabled && (d.hours = p2("hours"), d.minutes = p2("minutes"), d.seconds = p2("seconds"));
      },
      { deep: true }
    );
    const Y = computed2({
      get: () => e.internalModelValue,
      set: (m) => {
        !e.readonly && !e.disabled && t("update:internal-model-value", m);
      }
    }), f = computed2(
      () => (m) => c.value[m] ? c.value[m].month : 0
    ), O = computed2(
      () => (m) => c.value[m] ? c.value[m].year : 0
    );
    return watch2(
      Y,
      (m, P) => {
        r && JSON.stringify(m != null ? m : {}) !== JSON.stringify(P != null ? P : {}) && r();
      },
      { deep: true }
    ), {
      calendars: c,
      time: d,
      modelValue: Y,
      month: f,
      year: O,
      today: u
    };
  };
  var vo = (e, t) => {
    const {
      defaultedMultiCalendars: r,
      defaultedMultiDates: a,
      defaultedUI: n,
      defaultedHighlight: u,
      defaultedTz: c,
      propDates: p2,
      defaultedRange: d
    } = Ye(t), { isDisabled: Y } = Pt(t), f = ref(null), O = ref(tt2(/* @__PURE__ */ new Date(), c.value.timezone)), m = (l) => {
      !l.current && t.hideOffsetDates || (f.value = l.value);
    }, P = () => {
      f.value = null;
    }, F = (l) => Array.isArray(e.value) && d.value.enabled && e.value[0] && f.value ? l ? Fe(f.value, e.value[0]) : Ne(f.value, e.value[0]) : true, L = (l, w) => {
      const oe2 = () => e.value ? w ? e.value[0] || null : e.value[1] : null, M = e.value && Array.isArray(e.value) ? oe2() : null;
      return Te(K(l.value), M);
    }, _2 = (l) => {
      var _a3;
      const w = Array.isArray(e.value) ? e.value[0] : null;
      return l ? !Ne((_a3 = f.value) != null ? _a3 : null, w) : true;
    }, h2 = (l, w = true) => (d.value.enabled || t.weekPicker) && Array.isArray(e.value) && e.value.length === 2 ? t.hideOffsetDates && !l.current ? false : Te(K(l.value), e.value[w ? 0 : 1]) : d.value.enabled ? L(l, w) && _2(w) || Te(l.value, Array.isArray(e.value) ? e.value[0] : null) && F(w) : false, R = (l, w) => {
      if (Array.isArray(e.value) && e.value[0] && e.value.length === 1) {
        const oe2 = Te(l.value, f.value);
        return w ? Fe(e.value[0], l.value) && oe2 : Ne(e.value[0], l.value) && oe2;
      }
      return false;
    }, b = (l) => !e.value || t.hideOffsetDates && !l.current ? false : d.value.enabled ? t.modelAuto && Array.isArray(e.value) ? Te(l.value, e.value[0] ? e.value[0] : O.value) : false : a.value.enabled && Array.isArray(e.value) ? e.value.some((w) => Te(w, l.value)) : Te(l.value, e.value ? e.value : O.value), j = (l) => {
      if (d.value.autoRange || t.weekPicker) {
        if (f.value) {
          if (t.hideOffsetDates && !l.current)
            return false;
          const w = addDays2(f.value, +d.value.autoRange), oe2 = gt(K(f.value), t.weekStart);
          return t.weekPicker ? Te(oe2[1], K(l.value)) : Te(w, K(l.value));
        }
        return false;
      }
      return false;
    }, z = (l) => {
      if (d.value.autoRange || t.weekPicker) {
        if (f.value) {
          const w = addDays2(f.value, +d.value.autoRange);
          if (t.hideOffsetDates && !l.current)
            return false;
          const oe2 = gt(K(f.value), t.weekStart);
          return t.weekPicker ? Fe(l.value, oe2[0]) && Ne(l.value, oe2[1]) : Fe(l.value, f.value) && Ne(l.value, w);
        }
        return false;
      }
      return false;
    }, ae2 = (l) => {
      if (d.value.autoRange || t.weekPicker) {
        if (f.value) {
          if (t.hideOffsetDates && !l.current)
            return false;
          const w = gt(K(f.value), t.weekStart);
          return t.weekPicker ? Te(w[0], l.value) : Te(f.value, l.value);
        }
        return false;
      }
      return false;
    }, H = (l) => ea(e.value, f.value, l.value), D = () => t.modelAuto && Array.isArray(t.internalModelValue) ? !!t.internalModelValue[0] : false, Q2 = () => t.modelAuto ? Pn(t.internalModelValue) : true, B = (l) => {
      if (t.weekPicker)
        return false;
      const w = d.value.enabled ? !h2(l) && !h2(l, false) : true;
      return !Y(l.value) && !b(l) && !(!l.current && t.hideOffsetDates) && w;
    }, q = (l) => d.value.enabled ? t.modelAuto ? D() && b(l) : false : b(l), ve = (l) => u.value ? Ol(l.value, p2.value.highlight) : false, pe2 = (l) => {
      const w = Y(l.value);
      return w && (typeof u.value == "function" ? !u.value(l.value, w) : !u.value.options.highlightDisabled);
    }, v = (l) => {
      var w;
      return typeof u.value == "function" ? u.value(l.value) : (w = u.value.weekdays) == null ? void 0 : w.includes(l.value.getDay());
    }, N = (l) => (d.value.enabled || t.weekPicker) && (!(r.value.count > 0) || l.current) && Q2() && !(!l.current && t.hideOffsetDates) && !b(l) ? H(l) : false, ee = (l) => {
      if (Array.isArray(e.value) && e.value.length === 1) {
        const { before: w, after: oe2 } = vn(+d.value.maxRange, e.value[0]);
        return isBefore2(l.value, w) || isAfter2(l.value, oe2);
      }
      return false;
    }, y = (l) => {
      if (Array.isArray(e.value) && e.value.length === 1) {
        const { before: w, after: oe2 } = vn(+d.value.minRange, e.value[0]);
        return ea([w, oe2], e.value[0], l.value);
      }
      return false;
    }, U = (l) => d.value.enabled && (d.value.maxRange || d.value.minRange) ? d.value.maxRange && d.value.minRange ? ee(l) || y(l) : d.value.maxRange ? ee(l) : y(l) : false, S = (l) => {
      const { isRangeStart: w, isRangeEnd: oe2 } = i(l), M = d.value.enabled ? w || oe2 : false;
      return {
        dp__cell_offset: !l.current,
        dp__pointer: !t.disabled && !(!l.current && t.hideOffsetDates) && !Y(l.value) && !U(l),
        dp__cell_disabled: Y(l.value) || U(l),
        dp__cell_highlight: !pe2(l) && (ve(l) || v(l)) && !q(l) && !M && !ae2(l) && !(N(l) && t.weekPicker) && !oe2,
        dp__cell_highlight_active: !pe2(l) && (ve(l) || v(l)) && q(l),
        dp__today: !t.noToday && Te(l.value, O.value) && l.current,
        "dp--past": Ne(l.value, O.value),
        "dp--future": Fe(l.value, O.value)
      };
    }, Z = (l) => ({
      dp__active_date: q(l),
      dp__date_hover: B(l)
    }), A = (l) => {
      if (e.value && !Array.isArray(e.value)) {
        const w = gt(e.value, t.weekStart);
        return __spreadProps(__spreadValues({}, se(l)), {
          dp__range_start: Te(w[0], l.value),
          dp__range_end: Te(w[1], l.value),
          dp__range_between_week: Fe(l.value, w[0]) && Ne(l.value, w[1])
        });
      }
      return __spreadValues({}, se(l));
    }, ie = (l) => {
      if (e.value && Array.isArray(e.value)) {
        const w = gt(e.value[0], t.weekStart), oe2 = e.value[1] ? gt(e.value[1], t.weekStart) : [];
        return __spreadProps(__spreadValues({}, se(l)), {
          dp__range_start: Te(w[0], l.value) || Te(oe2[0], l.value),
          dp__range_end: Te(w[1], l.value) || Te(oe2[1], l.value),
          dp__range_between_week: Fe(l.value, w[0]) && Ne(l.value, w[1]) || Fe(l.value, oe2[0]) && Ne(l.value, oe2[1]),
          dp__range_between: Fe(l.value, w[1]) && Ne(l.value, oe2[0])
        });
      }
      return __spreadValues({}, se(l));
    }, i = (l) => {
      const w = r.value.count > 0 ? l.current && h2(l) && Q2() : h2(l) && Q2(), oe2 = r.value.count > 0 ? l.current && h2(l, false) && Q2() : h2(l, false) && Q2();
      return { isRangeStart: w, isRangeEnd: oe2 };
    }, W = (l) => {
      const { isRangeStart: w, isRangeEnd: oe2 } = i(l);
      return {
        dp__range_start: w,
        dp__range_end: oe2,
        dp__range_between: N(l),
        dp__date_hover: Te(l.value, f.value) && !w && !oe2 && !t.weekPicker,
        dp__date_hover_start: R(l, true),
        dp__date_hover_end: R(l, false)
      };
    }, se = (l) => __spreadProps(__spreadValues({}, W(l)), {
      dp__cell_auto_range: z(l),
      dp__cell_auto_range_start: ae2(l),
      dp__cell_auto_range_end: j(l)
    }), T = (l) => d.value.enabled ? d.value.autoRange ? se(l) : t.modelAuto ? __spreadValues(__spreadValues({}, Z(l)), W(l)) : t.weekPicker ? ie(l) : W(l) : t.weekPicker ? A(l) : Z(l);
    return {
      setHoverDate: m,
      clearHoverDate: P,
      getDayClassData: (l) => {
        var _a3;
        return t.hideOffsetDates && !l.current ? {} : __spreadValues(__spreadProps(__spreadValues(__spreadValues({}, S(l)), T(l)), {
          [t.dayClass ? t.dayClass(l.value, t.internalModelValue) : ""]: true
        }), (_a3 = n.value.calendarCell) != null ? _a3 : {});
      }
    };
  };
  var Pt = (e) => {
    const { defaultedFilters: t, defaultedRange: r, propDates: a, defaultedMultiDates: n } = Ye(e), u = (v) => a.value.disabledDates ? typeof a.value.disabledDates == "function" ? a.value.disabledDates(K(v)) : !!va(v, a.value.disabledDates) : false, c = (v) => a.value.maxDate ? e.yearPicker ? getYear2(v) > getYear2(a.value.maxDate) : Fe(v, a.value.maxDate) : false, p2 = (v) => a.value.minDate ? e.yearPicker ? getYear2(v) < getYear2(a.value.minDate) : Ne(v, a.value.minDate) : false, d = (v) => {
      const N = c(v), ee = p2(v), y = u(v), S = t.value.months.map((W) => +W).includes(getMonth2(v)), Z = e.disabledWeekDays.length ? e.disabledWeekDays.some((W) => +W === getDay(v)) : false, A = P(v), ie = getYear2(v), i = ie < +e.yearRange[0] || ie > +e.yearRange[1];
      return !(N || ee || y || S || i || Z || A);
    }, Y = (v, N) => Ne(...Mt(a.value.minDate, v, N)) || Te(...Mt(a.value.minDate, v, N)), f = (v, N) => Fe(...Mt(a.value.maxDate, v, N)) || Te(...Mt(a.value.maxDate, v, N)), O = (v, N, ee) => {
      let y = false;
      return a.value.maxDate && ee && f(v, N) && (y = true), a.value.minDate && !ee && Y(v, N) && (y = true), y;
    }, m = (v, N, ee, y) => {
      let U = false;
      return y && (a.value.minDate || a.value.maxDate) ? a.value.minDate && a.value.maxDate ? U = O(v, N, ee) : (a.value.minDate && Y(v, N) || a.value.maxDate && f(v, N)) && (U = true) : U = true, U;
    }, P = (v) => Array.isArray(a.value.allowedDates) && !a.value.allowedDates.length ? true : a.value.allowedDates ? !va(v, a.value.allowedDates, On(e.monthPicker, e.yearPicker)) : false, F = (v) => !d(v), L = (v) => r.value.noDisabledRange ? !eachDayOfInterval({ start: v[0], end: v[1] }).some((ee) => F(ee)) : true, _2 = (v) => {
      if (v) {
        const N = getYear2(v);
        return N >= +e.yearRange[0] && N <= e.yearRange[1];
      }
      return true;
    }, h2 = (v, N) => !!(Array.isArray(v) && v[N] && (r.value.maxRange || r.value.minRange) && _2(v[N])), R = (v, N, ee = 0) => {
      if (h2(N, ee) && _2(v)) {
        const y = differenceInCalendarDays(v, N[ee]), U = In(N[ee], v), S = U.length === 1 ? 0 : U.filter((A) => F(A)).length, Z = Math.abs(y) - (r.value.minMaxRawRange ? 0 : S);
        if (r.value.minRange && r.value.maxRange)
          return Z >= +r.value.minRange && Z <= +r.value.maxRange;
        if (r.value.minRange)
          return Z >= +r.value.minRange;
        if (r.value.maxRange)
          return Z <= +r.value.maxRange;
      }
      return true;
    }, b = () => !e.enableTimePicker || e.monthPicker || e.yearPicker || e.ignoreTimeValidation, j = (v) => Array.isArray(v) ? [v[0] ? Ca(v[0]) : null, v[1] ? Ca(v[1]) : null] : Ca(v), z = (v, N, ee) => v.find(
      (y) => +y.hours === getHours2(N) && y.minutes === "*" ? true : +y.minutes === getMinutes2(N) && +y.hours === getHours2(N)
    ) && ee, ae2 = (v, N, ee) => {
      const [y, U] = v, [S, Z] = N;
      return !z(y, S, ee) && !z(U, Z, ee) && ee;
    }, H = (v, N) => {
      const ee = Array.isArray(N) ? N : [N];
      return Array.isArray(e.disabledTimes) ? Array.isArray(e.disabledTimes[0]) ? ae2(e.disabledTimes, ee, v) : !ee.some((y) => z(e.disabledTimes, y, v)) : v;
    }, D = (v, N) => {
      const ee = Array.isArray(N) ? [Yt(N[0]), N[1] ? Yt(N[1]) : void 0] : Yt(N), y = !e.disabledTimes(ee);
      return v && y;
    }, Q2 = (v, N) => e.disabledTimes ? Array.isArray(e.disabledTimes) ? H(N, v) : D(N, v) : N, B = (v) => {
      let N = true;
      if (!v || b())
        return true;
      const ee = !a.value.minDate && !a.value.maxDate ? j(v) : v;
      return (e.maxTime || a.value.maxDate) && (N = fn(
        e.maxTime,
        a.value.maxDate,
        "max",
        ze(ee),
        N
      )), (e.minTime || a.value.minDate) && (N = fn(
        e.minTime,
        a.value.minDate,
        "min",
        ze(ee),
        N
      )), Q2(v, N);
    }, q = (v) => {
      if (!e.monthPicker)
        return true;
      let N = true;
      const ee = K(dt(v));
      if (a.value.minDate && a.value.maxDate) {
        const y = K(dt(a.value.minDate)), U = K(dt(a.value.maxDate));
        return Fe(ee, y) && Ne(ee, U) || Te(ee, y) || Te(ee, U);
      }
      if (a.value.minDate) {
        const y = K(dt(a.value.minDate));
        N = Fe(ee, y) || Te(ee, y);
      }
      if (a.value.maxDate) {
        const y = K(dt(a.value.maxDate));
        N = Ne(ee, y) || Te(ee, y);
      }
      return N;
    }, ve = computed2(() => (v) => !e.enableTimePicker || e.ignoreTimeValidation ? true : B(v)), pe2 = computed2(() => (v) => e.monthPicker ? Array.isArray(v) && (r.value.enabled || n.value.enabled) ? !v.filter((ee) => !q(ee)).length : q(v) : true);
    return {
      isDisabled: F,
      validateDate: d,
      validateMonthYearInRange: m,
      isDateRangeAllowed: L,
      checkMinMaxRange: R,
      isValidTime: B,
      isTimeValid: ve,
      isMonthValid: pe2
    };
  };
  var ha = () => {
    const e = computed2(() => (a, n) => a == null ? void 0 : a.includes(n)), t = computed2(() => (a, n) => a.count ? a.solo ? true : n === 0 : true), r = computed2(() => (a, n) => a.count ? a.solo ? true : n === a.count - 1 : true);
    return { hideNavigationButtons: e, showLeftIcon: t, showRightIcon: r };
  };
  var mo = (e, t, r) => {
    const a = ref(0), n = reactive({
      [_t.timePicker]: !e.enableTimePicker || e.timePicker || e.monthPicker,
      [_t.calendar]: false,
      [_t.header]: false
    }), u = computed2(() => e.monthPicker || e.timePicker), c = (O) => {
      var m;
      if ((m = e.flow) != null && m.length) {
        if (!O && u.value)
          return f();
        n[O] = true, Object.keys(n).filter((P) => !n[P]).length || f();
      }
    }, p2 = () => {
      var O, m;
      (O = e.flow) != null && O.length && a.value !== -1 && (a.value += 1, t("flow-step", a.value), f()), ((m = e.flow) == null ? void 0 : m.length) === a.value && nextTick().then(() => d());
    }, d = () => {
      a.value = -1;
    }, Y = (O, m, ...P) => {
      var F, L;
      e.flow[a.value] === O && r.value && ((L = (F = r.value)[m]) == null || L.call(F, ...P));
    }, f = (O = 0) => {
      O && (a.value += O), Y(qe.month, "toggleMonthPicker", true), Y(qe.year, "toggleYearPicker", true), Y(qe.calendar, "toggleTimePicker", false, true), Y(qe.time, "toggleTimePicker", true, true);
      const m = e.flow[a.value];
      (m === qe.hours || m === qe.minutes || m === qe.seconds) && Y(m, "toggleTimePicker", true, true, m);
    };
    return { childMount: c, updateFlowStep: p2, resetFlow: d, handleFlow: f, flowStep: a };
  };
  var po = {
    key: 1,
    class: "dp__input_wrap"
  };
  var yo = ["id", "name", "inputmode", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "aria-label", "aria-disabled", "aria-invalid"];
  var go = {
    key: 2,
    class: "dp--clear-btn"
  };
  var ho = ["aria-label"];
  var bo = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    __name: "DatepickerInput",
    props: __spreadValues({
      isMenuOpen: { type: Boolean, default: false },
      inputValue: { type: String, default: "" }
    }, pa),
    emits: [
      "clear",
      "open",
      "update:input-value",
      "set-input-date",
      "close",
      "select-date",
      "set-empty-date",
      "toggle",
      "focus-prev",
      "focus",
      "blur",
      "real-blur",
      "text-input"
    ],
    setup(e, { expose: t, emit: r }) {
      const a = r, n = e, {
        defaultedTextInput: u,
        defaultedAriaLabels: c,
        defaultedInline: p2,
        defaultedConfig: d,
        defaultedRange: Y,
        defaultedMultiDates: f,
        defaultedUI: O,
        getDefaultPattern: m,
        getDefaultStartTime: P
      } = Ye(n), { checkMinMaxRange: F } = Pt(n), L = ref(), _2 = ref(null), h2 = ref(false), R = ref(false), b = computed2(
        () => {
          var _a3;
          return __spreadValues({
            dp__pointer: !n.disabled && !n.readonly && !u.value.enabled,
            dp__disabled: n.disabled,
            dp__input_readonly: !u.value.enabled,
            dp__input: true,
            dp__input_icon_pad: !n.hideInputIcon,
            dp__input_valid: typeof n.state == "boolean" ? n.state : false,
            dp__input_invalid: typeof n.state == "boolean" ? !n.state : false,
            dp__input_focus: h2.value || n.isMenuOpen,
            dp__input_reg: !u.value.enabled
          }, (_a3 = O.value.input) != null ? _a3 : {});
        }
      ), j = () => {
        a("set-input-date", null), n.clearable && n.autoApply && (a("set-empty-date"), L.value = null);
      }, z = (A) => {
        var _a3;
        const ie = P();
        return _l(
          A,
          (_a3 = u.value.format) != null ? _a3 : m(),
          ie != null ? ie : En({}, n.enableSeconds),
          n.inputValue,
          R.value,
          n.formatLocale
        );
      }, ae2 = (A) => {
        const { rangeSeparator: ie } = u.value, [i, W] = A.split(`${ie}`);
        if (i) {
          const se = z(i.trim()), T = W ? z(W.trim()) : void 0;
          if (isAfter2(se, T))
            return;
          const re = se && T ? [se, T] : [se];
          F(T, re, 0) && (L.value = se ? re : null);
        }
      }, H = () => {
        R.value = true;
      }, D = (A) => {
        if (Y.value.enabled)
          ae2(A);
        else if (f.value.enabled) {
          const ie = A.split(";");
          L.value = ie.map((i) => z(i.trim())).filter((i) => i);
        } else
          L.value = z(A);
      }, Q2 = (A) => {
        var i;
        const ie = typeof A == "string" ? A : (i = A.target) == null ? void 0 : i.value;
        ie !== "" ? (u.value.openMenu && !n.isMenuOpen && a("open"), D(ie), a("set-input-date", L.value)) : j(), R.value = false, a("update:input-value", ie), a("text-input", A, L.value);
      }, B = (A) => {
        u.value.enabled ? (D(A.target.value), u.value.enterSubmit && za(L.value) && n.inputValue !== "" ? (a("set-input-date", L.value, true), L.value = null) : u.value.enterSubmit && n.inputValue === "" && (L.value = null, a("clear"))) : pe2(A);
      }, q = (A, ie) => {
        u.value.enabled && u.value.tabSubmit && !ie && D(A.target.value), u.value.tabSubmit && za(L.value) && n.inputValue !== "" ? (a("set-input-date", L.value, true, true), L.value = null) : u.value.tabSubmit && n.inputValue === "" && (L.value = null, a("clear", true));
      }, ve = () => {
        h2.value = true, a("focus"), nextTick().then(() => {
          var A;
          u.value.enabled && u.value.selectOnFocus && ((A = _2.value) == null || A.select());
        });
      }, pe2 = (A) => {
        if ($t(A, d.value, true), u.value.enabled && u.value.openMenu && !p2.value.input) {
          if (u.value.openMenu === "open" && !n.isMenuOpen)
            return a("open");
          if (u.value.openMenu === "toggle")
            return a("toggle");
        } else
          u.value.enabled || a("toggle");
      }, v = () => {
        a("real-blur"), h2.value = false, (!n.isMenuOpen || p2.value.enabled && p2.value.input) && a("blur"), n.autoApply && u.value.enabled && L.value && !n.isMenuOpen && (a("set-input-date", L.value), a("select-date"), L.value = null);
      }, N = (A) => {
        $t(A, d.value, true), a("clear");
      }, ee = () => {
        a("close");
      }, y = (A) => {
        if (A.key === "Tab" && q(A), A.key === "Enter" && B(A), A.key === "Escape" && u.value.escClose && ee(), !u.value.enabled) {
          if (A.code === "Tab")
            return;
          A.preventDefault();
        }
      }, U = () => {
        var A;
        (A = _2.value) == null || A.focus({ preventScroll: true });
      }, S = (A) => {
        L.value = A;
      }, Z = (A) => {
        A.key === Oe.tab && q(A, true);
      };
      return t({
        focusInput: U,
        setParsedDate: S
      }), (A, ie) => {
        var i, W, se;
        return openBlock(), createElementBlock("div", { onClick: pe2 }, [
          A.$slots.trigger && !A.$slots["dp-input"] && !unref(p2).enabled ? renderSlot(A.$slots, "trigger", { key: 0 }) : createCommentVNode("", true),
          !A.$slots.trigger && (!unref(p2).enabled || unref(p2).input) ? (openBlock(), createElementBlock("div", po, [
            A.$slots["dp-input"] && !A.$slots.trigger && (!unref(p2).enabled || unref(p2).enabled && unref(p2).input) ? renderSlot(A.$slots, "dp-input", {
              key: 0,
              value: e.inputValue,
              isMenuOpen: e.isMenuOpen,
              onInput: Q2,
              onEnter: B,
              onTab: q,
              onClear: N,
              onBlur: v,
              onKeypress: y,
              onPaste: H,
              onFocus: ve,
              openMenu: () => A.$emit("open"),
              closeMenu: () => A.$emit("close"),
              toggleMenu: () => A.$emit("toggle")
            }) : createCommentVNode("", true),
            A.$slots["dp-input"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("input", {
              key: 1,
              id: A.uid ? `dp-input-${A.uid}` : void 0,
              ref_key: "inputRef",
              ref: _2,
              "data-test-id": "dp-input",
              name: A.name,
              class: normalizeClass(b.value),
              inputmode: unref(u).enabled ? "text" : "none",
              placeholder: A.placeholder,
              disabled: A.disabled,
              readonly: A.readonly,
              required: A.required,
              value: e.inputValue,
              autocomplete: A.autocomplete,
              "aria-label": (i = unref(c)) == null ? void 0 : i.input,
              "aria-disabled": A.disabled || void 0,
              "aria-invalid": A.state === false ? true : void 0,
              onInput: Q2,
              onBlur: v,
              onFocus: ve,
              onKeypress: y,
              onKeydown: ie[0] || (ie[0] = (T) => y(T)),
              onPaste: H
            }, null, 42, yo)),
            createBaseVNode("div", {
              onClick: ie[3] || (ie[3] = (T) => a("toggle"))
            }, [
              A.$slots["input-icon"] && !A.hideInputIcon ? (openBlock(), createElementBlock("span", {
                key: 0,
                class: "dp__input_icon",
                onClick: ie[1] || (ie[1] = (T) => a("toggle"))
              }, [
                renderSlot(A.$slots, "input-icon")
              ])) : createCommentVNode("", true),
              !A.$slots["input-icon"] && !A.hideInputIcon && !A.$slots["dp-input"] ? (openBlock(), createBlock(unref(Gt), {
                key: 1,
                "aria-label": (W = unref(c)) == null ? void 0 : W.calendarIcon,
                class: "dp__input_icon dp__input_icons",
                onClick: ie[2] || (ie[2] = (T) => a("toggle"))
              }, null, 8, ["aria-label"])) : createCommentVNode("", true)
            ]),
            A.$slots["clear-icon"] && (A.alwaysClearable || e.inputValue && A.clearable && !A.disabled && !A.readonly) ? (openBlock(), createElementBlock("span", go, [
              renderSlot(A.$slots, "clear-icon", { clear: N })
            ])) : createCommentVNode("", true),
            !A.$slots["clear-icon"] && (A.alwaysClearable || A.clearable && e.inputValue && !A.disabled && !A.readonly) ? (openBlock(), createElementBlock("button", {
              key: 3,
              "aria-label": (se = unref(c)) == null ? void 0 : se.clearInput,
              class: "dp--clear-btn",
              type: "button",
              onKeydown: ie[4] || (ie[4] = (T) => unref(xe)(T, () => N(T), true, Z)),
              onClick: ie[5] || (ie[5] = withModifiers((T) => N(T), ["prevent"]))
            }, [
              createVNode(unref(Tn), {
                class: "dp__input_icons",
                "data-test-id": "clear-icon"
              })
            ], 40, ho)) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]);
      };
    }
  });
  var ko = typeof window < "u" ? window : void 0;
  var Ea = () => {
  };
  var wo = (e) => getCurrentScope() ? (onScopeDispose(e), true) : false;
  var Do = (e, t, r, a) => {
    if (!e)
      return Ea;
    let n = Ea;
    const u = watch2(
      () => unref(e),
      (p2) => {
        n(), p2 && (p2.removeEventListener(t, r), p2.addEventListener(t, r, a), n = () => {
          p2.removeEventListener(t, r, a), n = Ea;
        });
      },
      { immediate: true, flush: "post" }
    ), c = () => {
      u(), n();
    };
    return wo(c), c;
  };
  var Mo = (e, t, r, a = {}) => {
    const { window: n = ko, event: u = "pointerdown" } = a;
    return n ? Do(n, u, (p2) => {
      const d = He(e), Y = He(t);
      !d || !Y || d === p2.target || p2.composedPath().includes(d) || p2.composedPath().includes(Y) || r(p2);
    }, { passive: true }) : void 0;
  };
  var $o = ["data-dp-mobile"];
  var Ao = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    __name: "VueDatePicker",
    props: __spreadValues({}, pa),
    emits: [
      "update:model-value",
      "update:model-timezone-value",
      "text-submit",
      "closed",
      "cleared",
      "open",
      "focus",
      "blur",
      "internal-model-change",
      "recalculate-position",
      "flow-step",
      "update-month-year",
      "invalid-select",
      "invalid-fixed-range",
      "tooltip-open",
      "tooltip-close",
      "time-picker-open",
      "time-picker-close",
      "am-pm-change",
      "range-start",
      "range-end",
      "date-update",
      "invalid-date",
      "overlay-toggle",
      "text-input"
    ],
    setup(e, { expose: t, emit: r }) {
      const a = r, n = e, u = useSlots(), c = ref(false), p2 = toRef(n, "modelValue"), d = toRef(n, "timezone"), Y = ref(null), f = ref(null), O = ref(null), m = ref(false), P = ref(null), F = ref(false), L = ref(false), _2 = ref(false), h2 = ref(false), { setMenuFocused: R, setShiftKey: b } = zn(), { clearArrowNav: j } = St(), { validateDate: z, isValidTime: ae2 } = Pt(n), {
        defaultedTransitions: H,
        defaultedTextInput: D,
        defaultedInline: Q2,
        defaultedConfig: B,
        defaultedRange: q,
        defaultedMultiDates: ve
      } = Ye(n), { menuTransition: pe2, showTransition: v } = na(H), { isMobile: N } = Gn(B), ee = getCurrentInstance();
      onMounted(() => {
        re(n.modelValue), nextTick().then(() => {
          if (!Q2.value.enabled) {
            const C = i(P.value);
            C == null || C.addEventListener("scroll", fe), window == null || window.addEventListener("resize", I);
          }
        }), Q2.value.enabled && (c.value = true), window == null || window.addEventListener("keyup", $e), window == null || window.addEventListener("keydown", be);
      }), onUnmounted(() => {
        if (!Q2.value.enabled) {
          const C = i(P.value);
          C == null || C.removeEventListener("scroll", fe), window == null || window.removeEventListener("resize", I);
        }
        window == null || window.removeEventListener("keyup", $e), window == null || window.removeEventListener("keydown", be);
      });
      const y = at(u, "all", n.presetDates), U = at(u, "input");
      watch2(
        [p2, d],
        () => {
          re(p2.value);
        },
        { deep: true }
      );
      const { openOnTop: S, menuStyle: Z, xCorrect: A, setMenuPosition: ie, getScrollableParent: i, shadowRender: W } = io({
        menuRef: Y,
        menuRefInner: f,
        inputRef: O,
        pickerWrapperRef: P,
        inline: Q2,
        emit: a,
        props: n,
        slots: u
      }), {
        inputValue: se,
        internalModelValue: T,
        parseExternalModelValue: re,
        emitModelValue: l,
        formatInputValue: w,
        checkBeforeEmit: oe2
      } = lr(a, n, m), M = computed2(
        () => ({
          dp__main: true,
          dp__theme_dark: n.dark,
          dp__theme_light: !n.dark,
          dp__flex_display: Q2.value.enabled,
          "dp--flex-display-collapsed": _2.value,
          dp__flex_display_with_input: Q2.value.input
        })
      ), he2 = computed2(() => n.dark ? "dp__theme_dark" : "dp__theme_light"), ke = computed2(() => n.teleport ? {
        to: typeof n.teleport == "boolean" ? "body" : n.teleport,
        disabled: !n.teleport || Q2.value.enabled
      } : {}), le = computed2(() => ({ class: "dp__outer_menu_wrap" })), o = computed2(() => Q2.value.enabled && (n.timePicker || n.monthPicker || n.yearPicker || n.quarterPicker)), E = () => {
        var _a3;
        var C, te;
        return (_a3 = (te = (C = O.value) == null ? void 0 : C.$el) == null ? void 0 : te.getBoundingClientRect()) != null ? _a3 : { width: 0, left: 0, right: 0 };
      }, fe = () => {
        c.value && (B.value.closeOnScroll ? de() : ie());
      }, I = () => {
        var _a3;
        var te;
        c.value && ie();
        const C = (_a3 = (te = f.value) == null ? void 0 : te.$el.getBoundingClientRect().width) != null ? _a3 : 0;
        _2.value = document.body.offsetWidth <= C;
      }, $e = (C) => {
        C.key === "Tab" && !Q2.value.enabled && !n.teleport && B.value.tabOutClosesMenu && (P.value.contains(document.activeElement) || de()), L.value = C.shiftKey;
      }, be = (C) => {
        L.value = C.shiftKey;
      }, Pe2 = () => {
        !n.disabled && !n.readonly && (W(ee, gn, n), ie(false), c.value = true, c.value && a("open"), c.value || rt(), re(n.modelValue));
      }, Ee2 = () => {
        var C, te;
        se.value = "", rt(), (C = f.value) == null || C.onValueCleared(), (te = O.value) == null || te.setParsedDate(null), a("update:model-value", null), a("update:model-timezone-value", null), a("cleared"), B.value.closeOnClearValue && de();
      }, Be = () => {
        const C = T.value;
        return !C || !Array.isArray(C) && z(C) ? true : Array.isArray(C) ? ve.value.enabled || C.length === 2 && z(C[0]) && z(C[1]) ? true : q.value.partialRange && !n.timePicker ? z(C[0]) : false : false;
      }, k = () => {
        oe2() && Be() ? (l(), de()) : a("invalid-select", T.value);
      }, x = (C) => {
        Ie(), l(), B.value.closeOnAutoApply && !C && de();
      }, Ie = () => {
        O.value && D.value.enabled && O.value.setParsedDate(T.value);
      }, Ue = (C = false) => {
        n.autoApply && ae2(T.value) && Be() && (q.value.enabled && Array.isArray(T.value) ? (q.value.partialRange || T.value.length === 2) && x(C) : x(C));
      }, rt = () => {
        D.value.enabled || (T.value = null);
      }, de = (C = false) => {
        var te, ce;
        C && T.value && B.value.setDateOnMenuClose && k(), Q2.value.enabled || (c.value && (c.value = false, A.value = false, R(false), b(false), j(), a("closed"), se.value && re(p2.value)), rt(), a("blur"), (ce = (te = f.value) == null ? void 0 : te.$el) == null || ce.remove());
      }, Rt = (C, te, ce = false) => {
        if (!C) {
          T.value = null;
          return;
        }
        const yt = Array.isArray(C) ? !C.some((Ct) => !z(Ct)) : z(C), vt = ae2(C);
        yt && vt ? (h2.value = true, T.value = C, te ? (F.value = ce, k(), a("text-submit")) : n.autoApply && Ue(), nextTick().then(() => {
          h2.value = false;
        })) : a("invalid-date", C);
      }, ft = () => {
        n.autoApply && ae2(T.value) && l(), Ie();
      }, ra = () => c.value ? de() : Pe2(), ba = (C) => {
        T.value = C;
      }, ka = () => {
        D.value.enabled && (m.value = true, w()), a("focus");
      }, wa = () => {
        if (D.value.enabled && (m.value = false, re(n.modelValue), F.value)) {
          const C = Cl(P.value, L.value);
          C == null || C.focus();
        }
        a("blur");
      }, Da = (C) => {
        f.value && f.value.updateMonthYear(0, {
          month: un(C.month),
          year: un(C.year)
        });
      }, Ma = (C) => {
        re(C != null ? C : n.modelValue);
      }, tn2 = (C, te) => {
        var ce;
        (ce = f.value) == null || ce.switchView(C, te);
      }, g = (C, te) => B.value.onClickOutside ? B.value.onClickOutside(C, te) : de(true), ne = (C = 0) => {
        var te;
        (te = f.value) == null || te.handleFlow(C);
      }, me2 = () => Y;
      return Mo(
        Y,
        O,
        (C) => g(Be, C)
      ), t({
        closeMenu: de,
        selectDate: k,
        clearValue: Ee2,
        openMenu: Pe2,
        onScroll: fe,
        formatInputValue: w,
        updateInternalModelValue: ba,
        setMonthYear: Da,
        parseModel: Ma,
        switchView: tn2,
        toggleMenu: ra,
        handleFlow: ne,
        getDpWrapMenuRef: me2
      }), (C, te) => (openBlock(), createElementBlock("div", {
        ref_key: "pickerWrapperRef",
        ref: P,
        class: normalizeClass(M.value),
        "data-datepicker-instance": "",
        "data-dp-mobile": unref(N)
      }, [
        createVNode(bo, mergeProps({
          ref_key: "inputRef",
          ref: O,
          "input-value": unref(se),
          "onUpdate:inputValue": te[0] || (te[0] = (ce) => isRef2(se) ? se.value = ce : null),
          "is-menu-open": c.value
        }, C.$props, {
          onClear: Ee2,
          onOpen: Pe2,
          onSetInputDate: Rt,
          onSetEmptyDate: unref(l),
          onSelectDate: k,
          onToggle: ra,
          onClose: de,
          onFocus: ka,
          onBlur: wa,
          onRealBlur: te[1] || (te[1] = (ce) => m.value = false),
          onTextInput: te[2] || (te[2] = (ce) => C.$emit("text-input", ce))
        }), createSlots({ _: 2 }, [
          renderList(unref(U), (ce, yt) => ({
            name: ce,
            fn: withCtx((vt) => [
              renderSlot(C.$slots, ce, normalizeProps(guardReactiveProps(vt)))
            ])
          }))
        ]), 1040, ["input-value", "is-menu-open", "onSetEmptyDate"]),
        (openBlock(), createBlock(resolveDynamicComponent(C.teleport ? Teleport : "div"), normalizeProps(guardReactiveProps(ke.value)), {
          default: withCtx(() => [
            createVNode(Transition, {
              name: unref(pe2)(unref(S)),
              css: unref(v) && !unref(Q2).enabled
            }, {
              default: withCtx(() => [
                c.value ? (openBlock(), createElementBlock("div", mergeProps({
                  key: 0,
                  ref_key: "dpWrapMenuRef",
                  ref: Y
                }, le.value, {
                  class: { "dp--menu-wrapper": !unref(Q2).enabled },
                  style: unref(Q2).enabled ? void 0 : unref(Z)
                }), [
                  createVNode(gn, mergeProps({
                    ref_key: "dpMenuRef",
                    ref: f
                  }, C.$props, {
                    "internal-model-value": unref(T),
                    "onUpdate:internalModelValue": te[3] || (te[3] = (ce) => isRef2(T) ? T.value = ce : null),
                    class: { [he2.value]: true, "dp--menu-wrapper": C.teleport },
                    "open-on-top": unref(S),
                    "no-overlay-focus": o.value,
                    collapse: _2.value,
                    "get-input-rect": E,
                    "is-text-input-date": h2.value,
                    onClosePicker: de,
                    onSelectDate: k,
                    onAutoApply: Ue,
                    onTimeUpdate: ft,
                    onFlowStep: te[4] || (te[4] = (ce) => C.$emit("flow-step", ce)),
                    onUpdateMonthYear: te[5] || (te[5] = (ce) => C.$emit("update-month-year", ce)),
                    onInvalidSelect: te[6] || (te[6] = (ce) => C.$emit("invalid-select", unref(T))),
                    onAutoApplyInvalid: te[7] || (te[7] = (ce) => C.$emit("invalid-select", ce)),
                    onInvalidFixedRange: te[8] || (te[8] = (ce) => C.$emit("invalid-fixed-range", ce)),
                    onRecalculatePosition: unref(ie),
                    onTooltipOpen: te[9] || (te[9] = (ce) => C.$emit("tooltip-open", ce)),
                    onTooltipClose: te[10] || (te[10] = (ce) => C.$emit("tooltip-close", ce)),
                    onTimePickerOpen: te[11] || (te[11] = (ce) => C.$emit("time-picker-open", ce)),
                    onTimePickerClose: te[12] || (te[12] = (ce) => C.$emit("time-picker-close", ce)),
                    onAmPmChange: te[13] || (te[13] = (ce) => C.$emit("am-pm-change", ce)),
                    onRangeStart: te[14] || (te[14] = (ce) => C.$emit("range-start", ce)),
                    onRangeEnd: te[15] || (te[15] = (ce) => C.$emit("range-end", ce)),
                    onDateUpdate: te[16] || (te[16] = (ce) => C.$emit("date-update", ce)),
                    onInvalidDate: te[17] || (te[17] = (ce) => C.$emit("invalid-date", ce)),
                    onOverlayToggle: te[18] || (te[18] = (ce) => C.$emit("overlay-toggle", ce)),
                    onMenuBlur: te[19] || (te[19] = (ce) => C.$emit("blur"))
                  }), createSlots({ _: 2 }, [
                    renderList(unref(y), (ce, yt) => ({
                      name: ce,
                      fn: withCtx((vt) => [
                        renderSlot(C.$slots, ce, normalizeProps(guardReactiveProps(__spreadValues({}, vt))))
                      ])
                    }))
                  ]), 1040, ["internal-model-value", "class", "open-on-top", "no-overlay-focus", "collapse", "is-text-input-date", "onRecalculatePosition"])
                ], 16)) : createCommentVNode("", true)
              ]),
              _: 3
            }, 8, ["name", "css"])
          ]),
          _: 3
        }, 16))
      ], 10, $o));
    }
  });
  var Qn = /* @__PURE__ */ (() => {
    const e = Ao;
    return e.install = (t) => {
      t.component("Vue3DatePicker", e);
    }, e;
  })();
  var To = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: Qn
  }, Symbol.toStringTag, { value: "Module" }));
  Object.entries(To).forEach(([e, t]) => {
    e !== "default" && (Qn[e] = t);
  });

  // ../posawesome/node_modules/mitt/dist/mitt.mjs
  function mitt_default(n) {
    return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
      var i = n.get(t);
      i ? i.push(e) : n.set(t, [e]);
    }, off: function(t, e) {
      var i = n.get(t);
      i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
    }, emit: function(t, e) {
      var i = n.get(t);
      i && i.slice().map(function(n2) {
        n2(e);
      }), (i = n.get("*")) && i.slice().map(function(n2) {
        n2(t, e);
      });
    } };
  }

  // ../posawesome/posawesome/public/js/posapp/bus.js
  var bus_default = {
    install: (app, options) => {
      app.config.globalProperties.__ = window.__;
      app.config.globalProperties.frappe = window.frappe;
      app.config.globalProperties.eventBus = mitt_default();
    }
  };

  // ../posawesome/node_modules/@vueuse/shared/index.mjs
  function tryOnScopeDispose(fn2) {
    if (getCurrentScope()) {
      onScopeDispose(fn2);
      return true;
    }
    return false;
  }
  var localProvidedStateMap = /* @__PURE__ */ new WeakMap();
  var injectLocal = (...args) => {
    var _a3;
    const key = args[0];
    const instance = (_a3 = getCurrentInstance()) == null ? void 0 : _a3.proxy;
    if (instance == null && !hasInjectionContext())
      throw new Error("injectLocal must be called in setup");
    if (instance && localProvidedStateMap.has(instance) && key in localProvidedStateMap.get(instance))
      return localProvidedStateMap.get(instance)[key];
    return inject(...args);
  };
  var isClient = typeof window !== "undefined" && typeof document !== "undefined";
  var isWorker = typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
  var toString = Object.prototype.toString;
  var isObject3 = (val) => toString.call(val) === "[object Object]";
  var noop2 = () => {
  };
  function toRef2(...args) {
    if (args.length !== 1)
      return toRef(...args);
    const r = args[0];
    return typeof r === "function" ? readonly(customRef(() => ({ get: r, set: noop2 }))) : ref(r);
  }
  function createFilterWrapper(filter, fn2) {
    function wrapper(...args) {
      return new Promise((resolve2, reject) => {
        Promise.resolve(filter(() => fn2.apply(this, args), { fn: fn2, thisArg: this, args })).then(resolve2).catch(reject);
      });
    }
    return wrapper;
  }
  var bypassFilter = (invoke) => {
    return invoke();
  };
  function pausableFilter(extendFilter = bypassFilter, options = {}) {
    const {
      initialState = "active"
    } = options;
    const isActive = toRef2(initialState === "active");
    function pause() {
      isActive.value = false;
    }
    function resume() {
      isActive.value = true;
    }
    const eventFilter = (...args) => {
      if (isActive.value)
        extendFilter(...args);
    };
    return { isActive: readonly(isActive), pause, resume, eventFilter };
  }
  function pxValue(px) {
    return px.endsWith("rem") ? Number.parseFloat(px) * 16 : Number.parseFloat(px);
  }
  function toArray(value) {
    return Array.isArray(value) ? value : [value];
  }
  function cacheStringFunction2(fn2) {
    const cache = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn2(str));
    };
  }
  var hyphenateRE2 = /\B([A-Z])/g;
  var hyphenate2 = cacheStringFunction2((str) => str.replace(hyphenateRE2, "-$1").toLowerCase());
  var camelizeRE2 = /-(\w)/g;
  var camelize2 = cacheStringFunction2((str) => {
    return str.replace(camelizeRE2, (_2, c) => c ? c.toUpperCase() : "");
  });
  function getLifeCycleTarget(target) {
    return target || getCurrentInstance();
  }
  function watchWithFilter(source, cb, options = {}) {
    const _a3 = options, {
      eventFilter = bypassFilter
    } = _a3, watchOptions = __objRest(_a3, [
      "eventFilter"
    ]);
    return watch2(
      source,
      createFilterWrapper(
        eventFilter,
        cb
      ),
      watchOptions
    );
  }
  function watchPausable(source, cb, options = {}) {
    const _a3 = options, {
      eventFilter: filter,
      initialState = "active"
    } = _a3, watchOptions = __objRest(_a3, [
      "eventFilter",
      "initialState"
    ]);
    const { eventFilter, pause, resume, isActive } = pausableFilter(filter, { initialState });
    const stop2 = watchWithFilter(
      source,
      cb,
      __spreadProps(__spreadValues({}, watchOptions), {
        eventFilter
      })
    );
    return { stop: stop2, pause, resume, isActive };
  }
  function tryOnMounted(fn2, sync = true, target) {
    const instance = getLifeCycleTarget(target);
    if (instance)
      onMounted(fn2, target);
    else if (sync)
      fn2();
    else
      nextTick(fn2);
  }
  function useToggle(initialValue = false, options = {}) {
    const {
      truthyValue = true,
      falsyValue = false
    } = options;
    const valueIsRef = isRef2(initialValue);
    const _value = shallowRef(initialValue);
    function toggle(value) {
      if (arguments.length) {
        _value.value = value;
        return _value.value;
      } else {
        const truthy = toValue(truthyValue);
        _value.value = _value.value === truthy ? toValue(falsyValue) : truthy;
        return _value.value;
      }
    }
    if (valueIsRef)
      return toggle;
    else
      return [_value, toggle];
  }
  function watchImmediate(source, cb, options) {
    return watch2(
      source,
      cb,
      __spreadProps(__spreadValues({}, options), {
        immediate: true
      })
    );
  }

  // ../posawesome/node_modules/@vueuse/core/index.mjs
  var defaultWindow = isClient ? window : void 0;
  var defaultDocument = isClient ? window.document : void 0;
  var defaultNavigator = isClient ? window.navigator : void 0;
  var defaultLocation = isClient ? window.location : void 0;
  function unrefElement(elRef) {
    var _a3;
    const plain = toValue(elRef);
    return (_a3 = plain == null ? void 0 : plain.$el) != null ? _a3 : plain;
  }
  function useEventListener(...args) {
    const cleanups = [];
    const cleanup = () => {
      cleanups.forEach((fn2) => fn2());
      cleanups.length = 0;
    };
    const register = (el, event2, listener, options) => {
      el.addEventListener(event2, listener, options);
      return () => el.removeEventListener(event2, listener, options);
    };
    const firstParamTargets = computed2(() => {
      const test = toArray(toValue(args[0])).filter((e) => e != null);
      return test.every((e) => typeof e !== "string") ? test : void 0;
    });
    const stopWatch = watchImmediate(
      () => {
        var _a3, _b;
        return [
          (_b = (_a3 = firstParamTargets.value) == null ? void 0 : _a3.map((e) => unrefElement(e))) != null ? _b : [defaultWindow].filter((e) => e != null),
          toArray(toValue(firstParamTargets.value ? args[1] : args[0])),
          toArray(unref(firstParamTargets.value ? args[2] : args[1])),
          toValue(firstParamTargets.value ? args[3] : args[2])
        ];
      },
      ([raw_targets, raw_events, raw_listeners, raw_options]) => {
        cleanup();
        if (!(raw_targets == null ? void 0 : raw_targets.length) || !(raw_events == null ? void 0 : raw_events.length) || !(raw_listeners == null ? void 0 : raw_listeners.length))
          return;
        const optionsClone = isObject3(raw_options) ? __spreadValues({}, raw_options) : raw_options;
        cleanups.push(
          ...raw_targets.flatMap(
            (el) => raw_events.flatMap(
              (event2) => raw_listeners.map((listener) => register(el, event2, listener, optionsClone))
            )
          )
        );
      },
      { flush: "post" }
    );
    const stop2 = () => {
      stopWatch();
      cleanup();
    };
    tryOnScopeDispose(cleanup);
    return stop2;
  }
  function useMounted() {
    const isMounted = shallowRef(false);
    const instance = getCurrentInstance();
    if (instance) {
      onMounted(() => {
        isMounted.value = true;
      }, instance);
    }
    return isMounted;
  }
  function useSupported(callback) {
    const isMounted = useMounted();
    return computed2(() => {
      isMounted.value;
      return Boolean(callback());
    });
  }
  var ssrWidthSymbol = Symbol("vueuse-ssr-width");
  function useSSRWidth() {
    const ssrWidth = hasInjectionContext() ? injectLocal(ssrWidthSymbol, null) : null;
    return typeof ssrWidth === "number" ? ssrWidth : void 0;
  }
  function useMediaQuery(query, options = {}) {
    const { window: window2 = defaultWindow, ssrWidth = useSSRWidth() } = options;
    const isSupported2 = useSupported(() => window2 && "matchMedia" in window2 && typeof window2.matchMedia === "function");
    const ssrSupport = shallowRef(typeof ssrWidth === "number");
    const mediaQuery = shallowRef();
    const matches = shallowRef(false);
    const handler = (event2) => {
      matches.value = event2.matches;
    };
    watchEffect(() => {
      if (ssrSupport.value) {
        ssrSupport.value = !isSupported2.value;
        const queryStrings = toValue(query).split(",");
        matches.value = queryStrings.some((queryString) => {
          const not = queryString.includes("not all");
          const minWidth = queryString.match(/\(\s*min-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/);
          const maxWidth = queryString.match(/\(\s*max-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/);
          let res = Boolean(minWidth || maxWidth);
          if (minWidth && res) {
            res = ssrWidth >= pxValue(minWidth[1]);
          }
          if (maxWidth && res) {
            res = ssrWidth <= pxValue(maxWidth[1]);
          }
          return not ? !res : res;
        });
        return;
      }
      if (!isSupported2.value)
        return;
      mediaQuery.value = window2.matchMedia(toValue(query));
      matches.value = mediaQuery.value.matches;
    });
    useEventListener(mediaQuery, "change", handler, { passive: true });
    return computed2(() => matches.value);
  }
  var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  var globalKey = "__vueuse_ssr_handlers__";
  var handlers2 = /* @__PURE__ */ getHandlers();
  function getHandlers() {
    if (!(globalKey in _global))
      _global[globalKey] = _global[globalKey] || {};
    return _global[globalKey];
  }
  function getSSRHandler(key, fallback) {
    return handlers2[key] || fallback;
  }
  function usePreferredDark(options) {
    return useMediaQuery("(prefers-color-scheme: dark)", options);
  }
  function guessSerializerType(rawInit) {
    return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
  }
  var StorageSerializers = {
    boolean: {
      read: (v) => v === "true",
      write: (v) => String(v)
    },
    object: {
      read: (v) => JSON.parse(v),
      write: (v) => JSON.stringify(v)
    },
    number: {
      read: (v) => Number.parseFloat(v),
      write: (v) => String(v)
    },
    any: {
      read: (v) => v,
      write: (v) => String(v)
    },
    string: {
      read: (v) => v,
      write: (v) => String(v)
    },
    map: {
      read: (v) => new Map(JSON.parse(v)),
      write: (v) => JSON.stringify(Array.from(v.entries()))
    },
    set: {
      read: (v) => new Set(JSON.parse(v)),
      write: (v) => JSON.stringify(Array.from(v))
    },
    date: {
      read: (v) => new Date(v),
      write: (v) => v.toISOString()
    }
  };
  var customStorageEventName = "vueuse-storage";
  function useStorage(key, defaults, storage, options = {}) {
    var _a3;
    const {
      flush = "pre",
      deep = true,
      listenToStorageChanges = true,
      writeDefaults = true,
      mergeDefaults = false,
      shallow,
      window: window2 = defaultWindow,
      eventFilter,
      onError = (e) => {
        console.error(e);
      },
      initOnMounted
    } = options;
    const data = (shallow ? shallowRef : ref)(typeof defaults === "function" ? defaults() : defaults);
    const keyComputed = computed2(() => toValue(key));
    if (!storage) {
      try {
        storage = getSSRHandler("getDefaultStorage", () => {
          var _a22;
          return (_a22 = defaultWindow) == null ? void 0 : _a22.localStorage;
        })();
      } catch (e) {
        onError(e);
      }
    }
    if (!storage)
      return data;
    const rawInit = toValue(defaults);
    const type = guessSerializerType(rawInit);
    const serializer = (_a3 = options.serializer) != null ? _a3 : StorageSerializers[type];
    const { pause: pauseWatch, resume: resumeWatch } = watchPausable(
      data,
      () => write(data.value),
      { flush, deep, eventFilter }
    );
    watch2(keyComputed, () => update(), { flush });
    let firstMounted = false;
    const onStorageEvent = (ev) => {
      if (initOnMounted && !firstMounted) {
        return;
      }
      update(ev);
    };
    const onStorageCustomEvent = (ev) => {
      if (initOnMounted && !firstMounted) {
        return;
      }
      updateFromCustomEvent(ev);
    };
    if (window2 && listenToStorageChanges) {
      if (storage instanceof Storage)
        useEventListener(window2, "storage", onStorageEvent, { passive: true });
      else
        useEventListener(window2, customStorageEventName, onStorageCustomEvent);
    }
    if (initOnMounted) {
      tryOnMounted(() => {
        firstMounted = true;
        update();
      });
    } else {
      update();
    }
    function dispatchWriteEvent(oldValue, newValue) {
      if (window2) {
        const payload = {
          key: keyComputed.value,
          oldValue,
          newValue,
          storageArea: storage
        };
        window2.dispatchEvent(storage instanceof Storage ? new StorageEvent("storage", payload) : new CustomEvent(customStorageEventName, {
          detail: payload
        }));
      }
    }
    function write(v) {
      try {
        const oldValue = storage.getItem(keyComputed.value);
        if (v == null) {
          dispatchWriteEvent(oldValue, null);
          storage.removeItem(keyComputed.value);
        } else {
          const serialized = serializer.write(v);
          if (oldValue !== serialized) {
            storage.setItem(keyComputed.value, serialized);
            dispatchWriteEvent(oldValue, serialized);
          }
        }
      } catch (e) {
        onError(e);
      }
    }
    function read(event2) {
      const rawValue = event2 ? event2.newValue : storage.getItem(keyComputed.value);
      if (rawValue == null) {
        if (writeDefaults && rawInit != null)
          storage.setItem(keyComputed.value, serializer.write(rawInit));
        return rawInit;
      } else if (!event2 && mergeDefaults) {
        const value = serializer.read(rawValue);
        if (typeof mergeDefaults === "function")
          return mergeDefaults(value, rawInit);
        else if (type === "object" && !Array.isArray(value))
          return __spreadValues(__spreadValues({}, rawInit), value);
        return value;
      } else if (typeof rawValue !== "string") {
        return rawValue;
      } else {
        return serializer.read(rawValue);
      }
    }
    function update(event2) {
      if (event2 && event2.storageArea !== storage)
        return;
      if (event2 && event2.key == null) {
        data.value = rawInit;
        return;
      }
      if (event2 && event2.key !== keyComputed.value)
        return;
      pauseWatch();
      try {
        if ((event2 == null ? void 0 : event2.newValue) !== serializer.write(data.value))
          data.value = read(event2);
      } catch (e) {
        onError(e);
      } finally {
        if (event2)
          nextTick(resumeWatch);
        else
          resumeWatch();
      }
    }
    function updateFromCustomEvent(event2) {
      update(event2.detail);
    }
    return data;
  }
  var CSS_DISABLE_TRANS = "*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
  function useColorMode(options = {}) {
    const {
      selector = "html",
      attribute = "class",
      initialValue = "auto",
      window: window2 = defaultWindow,
      storage,
      storageKey = "vueuse-color-scheme",
      listenToStorageChanges = true,
      storageRef,
      emitAuto,
      disableTransition = true
    } = options;
    const modes2 = __spreadValues({
      auto: "",
      light: "light",
      dark: "dark"
    }, options.modes || {});
    const preferredDark = usePreferredDark({ window: window2 });
    const system = computed2(() => preferredDark.value ? "dark" : "light");
    const store = storageRef || (storageKey == null ? toRef2(initialValue) : useStorage(storageKey, initialValue, storage, { window: window2, listenToStorageChanges }));
    const state = computed2(() => store.value === "auto" ? system.value : store.value);
    const updateHTMLAttrs = getSSRHandler(
      "updateHTMLAttrs",
      (selector2, attribute2, value) => {
        const el = typeof selector2 === "string" ? window2 == null ? void 0 : window2.document.querySelector(selector2) : unrefElement(selector2);
        if (!el)
          return;
        const classesToAdd = /* @__PURE__ */ new Set();
        const classesToRemove = /* @__PURE__ */ new Set();
        let attributeToChange = null;
        if (attribute2 === "class") {
          const current = value.split(/\s/g);
          Object.values(modes2).flatMap((i) => (i || "").split(/\s/g)).filter(Boolean).forEach((v) => {
            if (current.includes(v))
              classesToAdd.add(v);
            else
              classesToRemove.add(v);
          });
        } else {
          attributeToChange = { key: attribute2, value };
        }
        if (classesToAdd.size === 0 && classesToRemove.size === 0 && attributeToChange === null)
          return;
        let style;
        if (disableTransition) {
          style = window2.document.createElement("style");
          style.appendChild(document.createTextNode(CSS_DISABLE_TRANS));
          window2.document.head.appendChild(style);
        }
        for (const c of classesToAdd) {
          el.classList.add(c);
        }
        for (const c of classesToRemove) {
          el.classList.remove(c);
        }
        if (attributeToChange) {
          el.setAttribute(attributeToChange.key, attributeToChange.value);
        }
        if (disableTransition) {
          window2.getComputedStyle(style).opacity;
          document.head.removeChild(style);
        }
      }
    );
    function defaultOnChanged(mode) {
      var _a3;
      updateHTMLAttrs(selector, attribute, (_a3 = modes2[mode]) != null ? _a3 : mode);
    }
    function onChanged(mode) {
      if (options.onChanged)
        options.onChanged(mode, defaultOnChanged);
      else
        defaultOnChanged(mode);
    }
    watch2(state, onChanged, { flush: "post", immediate: true });
    tryOnMounted(() => onChanged(state.value));
    const auto = computed2({
      get() {
        return emitAuto ? store.value : state.value;
      },
      set(v) {
        store.value = v;
      }
    });
    return Object.assign(auto, { store, system, state });
  }
  function useDark(options = {}) {
    const {
      valueDark = "dark",
      valueLight = ""
    } = options;
    const mode = useColorMode(__spreadProps(__spreadValues({}, options), {
      onChanged: (mode2, defaultHandler) => {
        var _a3;
        if (options.onChanged)
          (_a3 = options.onChanged) == null ? void 0 : _a3.call(options, mode2 === "dark", defaultHandler, mode2);
        else
          defaultHandler(mode2);
      },
      modes: {
        dark: valueDark,
        light: valueLight
      }
    }));
    const system = computed2(() => mode.system.value);
    const isDark = computed2({
      get() {
        return mode.value === "dark";
      },
      set(v) {
        const modeVal = v ? "dark" : "light";
        if (system.value === modeVal)
          mode.value = "auto";
        else
          mode.value = modeVal;
      }
    });
    return isDark;
  }
  var DEFAULT_UNITS = [
    { max: 6e4, value: 1e3, name: "second" },
    { max: 276e4, value: 6e4, name: "minute" },
    { max: 72e6, value: 36e5, name: "hour" },
    { max: 5184e5, value: 864e5, name: "day" },
    { max: 24192e5, value: 6048e5, name: "week" },
    { max: 28512e6, value: 2592e6, name: "month" },
    { max: Number.POSITIVE_INFINITY, value: 31536e6, name: "year" }
  ];

  // ../posawesome/posawesome/public/js/posapp/plugins/theme.js
  var theme_default = {
    install(app, { vuetify }) {
      const isDark = useDark({
        selector: "html",
        attribute: "class",
        valueDark: "dark-theme",
        valueLight: "",
        storageKey: "posawesome-theme",
        onChanged: (dark) => {
          vuetify.theme.global.name.value = dark ? "dark" : "light";
        }
      });
      const toggleDark = useToggle(isDark);
      const current = isDark.value ? "dark" : "light";
      vuetify.theme.global.name.value = current;
      app.config.globalProperties.$theme = {
        get current() {
          return vuetify.theme.global.name.value;
        },
        toggle: () => toggleDark(),
        isDark
      };
    }
  };

  // ../posawesome/node_modules/vuetify/lib/components/index.js
  var components_exports = {};
  __export(components_exports, {
    VAlert: () => VAlert,
    VAlertTitle: () => VAlertTitle,
    VApp: () => VApp,
    VAppBar: () => VAppBar,
    VAppBarNavIcon: () => VAppBarNavIcon,
    VAppBarTitle: () => VAppBarTitle,
    VAutocomplete: () => VAutocomplete,
    VAvatar: () => VAvatar,
    VBadge: () => VBadge,
    VBanner: () => VBanner,
    VBannerActions: () => VBannerActions,
    VBannerText: () => VBannerText,
    VBottomNavigation: () => VBottomNavigation,
    VBottomSheet: () => VBottomSheet,
    VBreadcrumbs: () => VBreadcrumbs,
    VBreadcrumbsDivider: () => VBreadcrumbsDivider,
    VBreadcrumbsItem: () => VBreadcrumbsItem,
    VBtn: () => VBtn,
    VBtnGroup: () => VBtnGroup,
    VBtnToggle: () => VBtnToggle,
    VCard: () => VCard,
    VCardActions: () => VCardActions,
    VCardItem: () => VCardItem,
    VCardSubtitle: () => VCardSubtitle,
    VCardText: () => VCardText,
    VCardTitle: () => VCardTitle,
    VCarousel: () => VCarousel,
    VCarouselItem: () => VCarouselItem,
    VCheckbox: () => VCheckbox,
    VCheckboxBtn: () => VCheckboxBtn,
    VChip: () => VChip,
    VChipGroup: () => VChipGroup,
    VClassIcon: () => VClassIcon,
    VCode: () => VCode,
    VCol: () => VCol,
    VColorPicker: () => VColorPicker,
    VCombobox: () => VCombobox,
    VComponentIcon: () => VComponentIcon,
    VConfirmEdit: () => VConfirmEdit,
    VContainer: () => VContainer,
    VCounter: () => VCounter,
    VDataIterator: () => VDataIterator,
    VDataTable: () => VDataTable,
    VDataTableFooter: () => VDataTableFooter,
    VDataTableHeaders: () => VDataTableHeaders,
    VDataTableRow: () => VDataTableRow,
    VDataTableRows: () => VDataTableRows,
    VDataTableServer: () => VDataTableServer,
    VDataTableVirtual: () => VDataTableVirtual,
    VDatePicker: () => VDatePicker,
    VDatePickerControls: () => VDatePickerControls,
    VDatePickerHeader: () => VDatePickerHeader,
    VDatePickerMonth: () => VDatePickerMonth,
    VDatePickerMonths: () => VDatePickerMonths,
    VDatePickerYears: () => VDatePickerYears,
    VDefaultsProvider: () => VDefaultsProvider,
    VDialog: () => VDialog,
    VDialogBottomTransition: () => VDialogBottomTransition,
    VDialogTopTransition: () => VDialogTopTransition,
    VDialogTransition: () => VDialogTransition,
    VDivider: () => VDivider,
    VEmptyState: () => VEmptyState,
    VExpandTransition: () => VExpandTransition,
    VExpandXTransition: () => VExpandXTransition,
    VExpansionPanel: () => VExpansionPanel,
    VExpansionPanelText: () => VExpansionPanelText,
    VExpansionPanelTitle: () => VExpansionPanelTitle,
    VExpansionPanels: () => VExpansionPanels,
    VFab: () => VFab,
    VFabTransition: () => VFabTransition,
    VFadeTransition: () => VFadeTransition,
    VField: () => VField,
    VFieldLabel: () => VFieldLabel,
    VFileInput: () => VFileInput,
    VFooter: () => VFooter,
    VForm: () => VForm,
    VHover: () => VHover,
    VIcon: () => VIcon,
    VImg: () => VImg,
    VInfiniteScroll: () => VInfiniteScroll,
    VInput: () => VInput,
    VItem: () => VItem,
    VItemGroup: () => VItemGroup,
    VKbd: () => VKbd,
    VLabel: () => VLabel,
    VLayout: () => VLayout,
    VLayoutItem: () => VLayoutItem,
    VLazy: () => VLazy,
    VLigatureIcon: () => VLigatureIcon,
    VList: () => VList,
    VListGroup: () => VListGroup,
    VListImg: () => VListImg,
    VListItem: () => VListItem,
    VListItemAction: () => VListItemAction,
    VListItemMedia: () => VListItemMedia,
    VListItemSubtitle: () => VListItemSubtitle,
    VListItemTitle: () => VListItemTitle,
    VListSubheader: () => VListSubheader,
    VLocaleProvider: () => VLocaleProvider,
    VMain: () => VMain,
    VMenu: () => VMenu,
    VMessages: () => VMessages,
    VNavigationDrawer: () => VNavigationDrawer,
    VNoSsr: () => VNoSsr,
    VNumberInput: () => VNumberInput,
    VOtpInput: () => VOtpInput,
    VOverlay: () => VOverlay,
    VPagination: () => VPagination,
    VParallax: () => VParallax,
    VProgressCircular: () => VProgressCircular,
    VProgressLinear: () => VProgressLinear,
    VRadio: () => VRadio,
    VRadioGroup: () => VRadioGroup,
    VRangeSlider: () => VRangeSlider,
    VRating: () => VRating,
    VResponsive: () => VResponsive,
    VRow: () => VRow,
    VScaleTransition: () => VScaleTransition,
    VScrollXReverseTransition: () => VScrollXReverseTransition,
    VScrollXTransition: () => VScrollXTransition,
    VScrollYReverseTransition: () => VScrollYReverseTransition,
    VScrollYTransition: () => VScrollYTransition,
    VSelect: () => VSelect,
    VSelectionControl: () => VSelectionControl,
    VSelectionControlGroup: () => VSelectionControlGroup,
    VSheet: () => VSheet,
    VSkeletonLoader: () => VSkeletonLoader,
    VSlideGroup: () => VSlideGroup,
    VSlideGroupItem: () => VSlideGroupItem,
    VSlideXReverseTransition: () => VSlideXReverseTransition,
    VSlideXTransition: () => VSlideXTransition,
    VSlideYReverseTransition: () => VSlideYReverseTransition,
    VSlideYTransition: () => VSlideYTransition,
    VSlider: () => VSlider,
    VSnackbar: () => VSnackbar,
    VSnackbarQueue: () => VSnackbarQueue,
    VSpacer: () => VSpacer,
    VSparkline: () => VSparkline,
    VSpeedDial: () => VSpeedDial,
    VStepper: () => VStepper,
    VStepperActions: () => VStepperActions,
    VStepperHeader: () => VStepperHeader,
    VStepperItem: () => VStepperItem,
    VStepperWindow: () => VStepperWindow,
    VStepperWindowItem: () => VStepperWindowItem,
    VSvgIcon: () => VSvgIcon,
    VSwitch: () => VSwitch,
    VSystemBar: () => VSystemBar,
    VTab: () => VTab,
    VTable: () => VTable,
    VTabs: () => VTabs,
    VTabsWindow: () => VTabsWindow,
    VTabsWindowItem: () => VTabsWindowItem,
    VTextField: () => VTextField,
    VTextarea: () => VTextarea,
    VThemeProvider: () => VThemeProvider,
    VTimeline: () => VTimeline,
    VTimelineItem: () => VTimelineItem,
    VToolbar: () => VToolbar,
    VToolbarItems: () => VToolbarItems,
    VToolbarTitle: () => VToolbarTitle,
    VTooltip: () => VTooltip,
    VValidation: () => VValidation,
    VVirtualScroll: () => VVirtualScroll,
    VWindow: () => VWindow,
    VWindowItem: () => VWindowItem
  });

  // ../posawesome/node_modules/vuetify/lib/components/VApp/VApp.js
  var makeVAppProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({}, makeComponentProps()), makeLayoutProps({
    fullHeight: true
  })), makeThemeProps()), "VApp");
  var VApp = genericComponent()({
    name: "VApp",
    props: makeVAppProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const theme = provideTheme(props);
      const {
        layoutClasses,
        getLayoutItem,
        items,
        layoutRef
      } = createLayout(props);
      const {
        rtlClasses
      } = useRtl();
      useRender(() => {
        var _a3;
        return createBaseVNode("div", {
          "ref": layoutRef,
          "class": normalizeClass(["v-application", theme.themeClasses.value, layoutClasses.value, rtlClasses.value, props.class]),
          "style": normalizeStyle([props.style])
        }, [createBaseVNode("div", {
          "class": "v-application__wrap"
        }, [(_a3 = slots.default) == null ? void 0 : _a3.call(slots)])]);
      });
      return {
        getLayoutItem,
        items,
        theme
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/composables/tag.js
  var makeTagProps = propsFactory({
    tag: {
      type: [String, Object, Function],
      default: "div"
    }
  }, "tag");

  // ../posawesome/node_modules/vuetify/lib/components/VToolbar/VToolbarTitle.js
  var makeVToolbarTitleProps = propsFactory(__spreadValues(__spreadValues({
    text: String
  }, makeComponentProps()), makeTagProps()), "VToolbarTitle");
  var VToolbarTitle = genericComponent()({
    name: "VToolbarTitle",
    props: makeVToolbarTitleProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => {
        const hasText = !!(slots.default || slots.text || props.text);
        return createVNode(props.tag, {
          "class": normalizeClass(["v-toolbar-title", props.class]),
          "style": normalizeStyle(props.style)
        }, {
          default: () => {
            var _a3;
            return [hasText && createBaseVNode("div", {
              "class": "v-toolbar-title__placeholder"
            }, [slots.text ? slots.text() : props.text, (_a3 = slots.default) == null ? void 0 : _a3.call(slots)])];
          }
        });
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/transitions/createTransition.js
  var makeTransitionProps = propsFactory({
    disabled: Boolean,
    group: Boolean,
    hideOnLeave: Boolean,
    leaveAbsolute: Boolean,
    mode: String,
    origin: String
  }, "transition");
  function createCssTransition(name, origin, mode) {
    return genericComponent()({
      name,
      props: makeTransitionProps({
        mode,
        origin
      }),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const functions = {
          onBeforeEnter(el) {
            if (props.origin) {
              el.style.transformOrigin = props.origin;
            }
          },
          onLeave(el) {
            if (props.leaveAbsolute) {
              const {
                offsetTop,
                offsetLeft,
                offsetWidth,
                offsetHeight
              } = el;
              el._transitionInitialStyles = {
                position: el.style.position,
                top: el.style.top,
                left: el.style.left,
                width: el.style.width,
                height: el.style.height
              };
              el.style.position = "absolute";
              el.style.top = `${offsetTop}px`;
              el.style.left = `${offsetLeft}px`;
              el.style.width = `${offsetWidth}px`;
              el.style.height = `${offsetHeight}px`;
            }
            if (props.hideOnLeave) {
              el.style.setProperty("display", "none", "important");
            }
          },
          onAfterLeave(el) {
            if (props.leaveAbsolute && (el == null ? void 0 : el._transitionInitialStyles)) {
              const {
                position,
                top,
                left,
                width,
                height
              } = el._transitionInitialStyles;
              delete el._transitionInitialStyles;
              el.style.position = position || "";
              el.style.top = top || "";
              el.style.left = left || "";
              el.style.width = width || "";
              el.style.height = height || "";
            }
          }
        };
        return () => {
          const tag = props.group ? TransitionGroup : Transition;
          return h(tag, __spreadValues(__spreadValues({
            name: props.disabled ? "" : name,
            css: !props.disabled
          }, props.group ? void 0 : {
            mode: props.mode
          }), props.disabled ? {} : functions), slots.default);
        };
      }
    });
  }
  function createJavascriptTransition(name, functions) {
    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "in-out";
    return genericComponent()({
      name,
      props: {
        mode: {
          type: String,
          default: mode
        },
        disabled: Boolean,
        group: Boolean
      },
      setup(props, _ref2) {
        let {
          slots
        } = _ref2;
        const tag = props.group ? TransitionGroup : Transition;
        return () => {
          return h(tag, __spreadValues({
            name: props.disabled ? "" : name,
            css: !props.disabled
          }, props.disabled ? {} : functions), slots.default);
        };
      }
    });
  }

  // ../posawesome/node_modules/vuetify/lib/components/transitions/expand-transition.js
  function expand_transition_default() {
    let expandedParentClass = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    let x = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const sizeProperty = x ? "width" : "height";
    const offsetProperty = camelize(`offset-${sizeProperty}`);
    return {
      onBeforeEnter(el) {
        el._parent = el.parentNode;
        el._initialStyle = {
          transition: el.style.transition,
          overflow: el.style.overflow,
          [sizeProperty]: el.style[sizeProperty]
        };
      },
      onEnter(el) {
        const initialStyle = el._initialStyle;
        if (!initialStyle)
          return;
        el.style.setProperty("transition", "none", "important");
        el.style.overflow = "hidden";
        const offset = `${el[offsetProperty]}px`;
        el.style[sizeProperty] = "0";
        void el.offsetHeight;
        el.style.transition = initialStyle.transition;
        if (expandedParentClass && el._parent) {
          el._parent.classList.add(expandedParentClass);
        }
        requestAnimationFrame(() => {
          el.style[sizeProperty] = offset;
        });
      },
      onAfterEnter: resetStyles,
      onEnterCancelled: resetStyles,
      onLeave(el) {
        el._initialStyle = {
          transition: "",
          overflow: el.style.overflow,
          [sizeProperty]: el.style[sizeProperty]
        };
        el.style.overflow = "hidden";
        el.style[sizeProperty] = `${el[offsetProperty]}px`;
        void el.offsetHeight;
        requestAnimationFrame(() => el.style[sizeProperty] = "0");
      },
      onAfterLeave,
      onLeaveCancelled: onAfterLeave
    };
    function onAfterLeave(el) {
      if (expandedParentClass && el._parent) {
        el._parent.classList.remove(expandedParentClass);
      }
      resetStyles(el);
    }
    function resetStyles(el) {
      if (!el._initialStyle)
        return;
      const size = el._initialStyle[sizeProperty];
      el.style.overflow = el._initialStyle.overflow;
      if (size != null)
        el.style[sizeProperty] = size;
      delete el._initialStyle;
    }
  }

  // ../posawesome/node_modules/vuetify/lib/components/transitions/dialog-transition.js
  var makeVDialogTransitionProps = propsFactory({
    target: [Object, Array]
  }, "v-dialog-transition");
  var saved = /* @__PURE__ */ new WeakMap();
  var VDialogTransition = genericComponent()({
    name: "VDialogTransition",
    props: makeVDialogTransitionProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const functions = {
        onBeforeEnter(el) {
          el.style.pointerEvents = "none";
          el.style.visibility = "hidden";
        },
        async onEnter(el, done) {
          var _a3;
          await new Promise((resolve2) => requestAnimationFrame(resolve2));
          await new Promise((resolve2) => requestAnimationFrame(resolve2));
          el.style.visibility = "";
          const dimensions = getDimensions(props.target, el);
          const {
            x,
            y,
            sx,
            sy,
            speed
          } = dimensions;
          saved.set(el, dimensions);
          const animation = animate(el, [{
            transform: `translate(${x}px, ${y}px) scale(${sx}, ${sy})`,
            opacity: 0
          }, {}], {
            duration: 225 * speed,
            easing: deceleratedEasing
          });
          (_a3 = getChildren(el)) == null ? void 0 : _a3.forEach((el2) => {
            animate(el2, [{
              opacity: 0
            }, {
              opacity: 0,
              offset: 0.33
            }, {}], {
              duration: 225 * 2 * speed,
              easing: standardEasing
            });
          });
          animation.finished.then(() => done());
        },
        onAfterEnter(el) {
          el.style.removeProperty("pointer-events");
        },
        onBeforeLeave(el) {
          el.style.pointerEvents = "none";
        },
        async onLeave(el, done) {
          var _a3;
          await new Promise((resolve2) => requestAnimationFrame(resolve2));
          let dimensions;
          if (!saved.has(el) || Array.isArray(props.target) || props.target.offsetParent || props.target.getClientRects().length) {
            dimensions = getDimensions(props.target, el);
          } else {
            dimensions = saved.get(el);
          }
          const {
            x,
            y,
            sx,
            sy,
            speed
          } = dimensions;
          const animation = animate(el, [{}, {
            transform: `translate(${x}px, ${y}px) scale(${sx}, ${sy})`,
            opacity: 0
          }], {
            duration: 125 * speed,
            easing: acceleratedEasing
          });
          animation.finished.then(() => done());
          (_a3 = getChildren(el)) == null ? void 0 : _a3.forEach((el2) => {
            animate(el2, [{}, {
              opacity: 0,
              offset: 0.2
            }, {
              opacity: 0
            }], {
              duration: 125 * 2 * speed,
              easing: standardEasing
            });
          });
        },
        onAfterLeave(el) {
          el.style.removeProperty("pointer-events");
        }
      };
      return () => {
        return props.target ? createVNode(Transition, mergeProps({
          "name": "dialog-transition"
        }, functions, {
          "css": false
        }), slots) : createVNode(Transition, {
          "name": "dialog-transition"
        }, slots);
      };
    }
  });
  function getChildren(el) {
    var _a3;
    const els = (_a3 = el.querySelector(":scope > .v-card, :scope > .v-sheet, :scope > .v-list")) == null ? void 0 : _a3.children;
    return els && [...els];
  }
  function getDimensions(target, el) {
    const targetBox = getTargetBox(target);
    const elBox = nullifyTransforms(el);
    const [originX, originY] = getComputedStyle(el).transformOrigin.split(" ").map((v) => parseFloat(v));
    const [anchorSide, anchorOffset] = getComputedStyle(el).getPropertyValue("--v-overlay-anchor-origin").split(" ");
    let offsetX = targetBox.left + targetBox.width / 2;
    if (anchorSide === "left" || anchorOffset === "left") {
      offsetX -= targetBox.width / 2;
    } else if (anchorSide === "right" || anchorOffset === "right") {
      offsetX += targetBox.width / 2;
    }
    let offsetY = targetBox.top + targetBox.height / 2;
    if (anchorSide === "top" || anchorOffset === "top") {
      offsetY -= targetBox.height / 2;
    } else if (anchorSide === "bottom" || anchorOffset === "bottom") {
      offsetY += targetBox.height / 2;
    }
    const tsx = targetBox.width / elBox.width;
    const tsy = targetBox.height / elBox.height;
    const maxs = Math.max(1, tsx, tsy);
    const sx = tsx / maxs || 0;
    const sy = tsy / maxs || 0;
    const asa = elBox.width * elBox.height / (window.innerWidth * window.innerHeight);
    const speed = asa > 0.12 ? Math.min(1.5, (asa - 0.12) * 10 + 1) : 1;
    return {
      x: offsetX - (originX + elBox.left),
      y: offsetY - (originY + elBox.top),
      sx,
      sy,
      speed
    };
  }

  // ../posawesome/node_modules/vuetify/lib/components/transitions/index.js
  var VFabTransition = createCssTransition("fab-transition", "center center", "out-in");
  var VDialogBottomTransition = createCssTransition("dialog-bottom-transition");
  var VDialogTopTransition = createCssTransition("dialog-top-transition");
  var VFadeTransition = createCssTransition("fade-transition");
  var VScaleTransition = createCssTransition("scale-transition");
  var VScrollXTransition = createCssTransition("scroll-x-transition");
  var VScrollXReverseTransition = createCssTransition("scroll-x-reverse-transition");
  var VScrollYTransition = createCssTransition("scroll-y-transition");
  var VScrollYReverseTransition = createCssTransition("scroll-y-reverse-transition");
  var VSlideXTransition = createCssTransition("slide-x-transition");
  var VSlideXReverseTransition = createCssTransition("slide-x-reverse-transition");
  var VSlideYTransition = createCssTransition("slide-y-transition");
  var VSlideYReverseTransition = createCssTransition("slide-y-reverse-transition");
  var VExpandTransition = createJavascriptTransition("expand-transition", expand_transition_default());
  var VExpandXTransition = createJavascriptTransition("expand-x-transition", expand_transition_default("", true));

  // ../posawesome/node_modules/vuetify/lib/components/VDefaultsProvider/VDefaultsProvider.js
  var makeVDefaultsProviderProps = propsFactory({
    defaults: Object,
    disabled: Boolean,
    reset: [Number, String],
    root: [Boolean, String],
    scoped: Boolean
  }, "VDefaultsProvider");
  var VDefaultsProvider = genericComponent(false)({
    name: "VDefaultsProvider",
    props: makeVDefaultsProviderProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        defaults,
        disabled,
        reset,
        root,
        scoped
      } = toRefs(props);
      provideDefaults(defaults, {
        reset,
        root,
        scoped,
        disabled
      });
      return () => {
        var _a3;
        return (_a3 = slots.default) == null ? void 0 : _a3.call(slots);
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/composables/dimensions.js
  var makeDimensionProps = propsFactory({
    height: [Number, String],
    maxHeight: [Number, String],
    maxWidth: [Number, String],
    minHeight: [Number, String],
    minWidth: [Number, String],
    width: [Number, String]
  }, "dimension");
  function useDimension(props) {
    const dimensionStyles = computed2(() => {
      const styles = {};
      const height = convertToUnit(props.height);
      const maxHeight = convertToUnit(props.maxHeight);
      const maxWidth = convertToUnit(props.maxWidth);
      const minHeight = convertToUnit(props.minHeight);
      const minWidth = convertToUnit(props.minWidth);
      const width = convertToUnit(props.width);
      if (height != null)
        styles.height = height;
      if (maxHeight != null)
        styles.maxHeight = maxHeight;
      if (maxWidth != null)
        styles.maxWidth = maxWidth;
      if (minHeight != null)
        styles.minHeight = minHeight;
      if (minWidth != null)
        styles.minWidth = minWidth;
      if (width != null)
        styles.width = width;
      return styles;
    });
    return {
      dimensionStyles
    };
  }

  // ../posawesome/node_modules/vuetify/lib/components/VResponsive/VResponsive.js
  function useAspectStyles(props) {
    return {
      aspectStyles: computed2(() => {
        const ratio = Number(props.aspectRatio);
        return ratio ? {
          paddingBottom: String(1 / ratio * 100) + "%"
        } : void 0;
      })
    };
  }
  var makeVResponsiveProps = propsFactory(__spreadValues(__spreadValues({
    aspectRatio: [String, Number],
    contentClass: null,
    inline: Boolean
  }, makeComponentProps()), makeDimensionProps()), "VResponsive");
  var VResponsive = genericComponent()({
    name: "VResponsive",
    props: makeVResponsiveProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        aspectStyles
      } = useAspectStyles(props);
      const {
        dimensionStyles
      } = useDimension(props);
      useRender(() => {
        var _a3;
        return createBaseVNode("div", {
          "class": normalizeClass(["v-responsive", {
            "v-responsive--inline": props.inline
          }, props.class]),
          "style": normalizeStyle([dimensionStyles.value, props.style])
        }, [createBaseVNode("div", {
          "class": "v-responsive__sizer",
          "style": normalizeStyle(aspectStyles.value)
        }, null), (_a3 = slots.additional) == null ? void 0 : _a3.call(slots), slots.default && createBaseVNode("div", {
          "class": normalizeClass(["v-responsive__content", props.contentClass])
        }, [slots.default()])]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/composables/color.js
  function useColor(colors) {
    return destructComputed(() => {
      const _colors = toValue(colors);
      const classes = [];
      const styles = {};
      if (_colors.background) {
        if (isCssColor(_colors.background)) {
          styles.backgroundColor = _colors.background;
          if (!_colors.text && isParsableColor(_colors.background)) {
            const backgroundColor = parseColor(_colors.background);
            if (backgroundColor.a == null || backgroundColor.a === 1) {
              const textColor = getForeground(backgroundColor);
              styles.color = textColor;
              styles.caretColor = textColor;
            }
          }
        } else {
          classes.push(`bg-${_colors.background}`);
        }
      }
      if (_colors.text) {
        if (isCssColor(_colors.text)) {
          styles.color = _colors.text;
          styles.caretColor = _colors.text;
        } else {
          classes.push(`text-${_colors.text}`);
        }
      }
      return {
        colorClasses: classes,
        colorStyles: styles
      };
    });
  }
  function useTextColor(color) {
    const {
      colorClasses: textColorClasses,
      colorStyles: textColorStyles
    } = useColor(() => ({
      text: toValue(color)
    }));
    return {
      textColorClasses,
      textColorStyles
    };
  }
  function useBackgroundColor(color) {
    const {
      colorClasses: backgroundColorClasses,
      colorStyles: backgroundColorStyles
    } = useColor(() => ({
      background: toValue(color)
    }));
    return {
      backgroundColorClasses,
      backgroundColorStyles
    };
  }

  // ../posawesome/node_modules/vuetify/lib/composables/rounded.js
  var makeRoundedProps = propsFactory({
    rounded: {
      type: [Boolean, Number, String],
      default: void 0
    },
    tile: Boolean
  }, "rounded");
  function useRounded(props) {
    let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    const roundedClasses = computed2(() => {
      const rounded = isRef2(props) ? props.value : props.rounded;
      const tile = isRef2(props) ? props.value : props.tile;
      const classes = [];
      if (rounded === true || rounded === "") {
        classes.push(`${name}--rounded`);
      } else if (typeof rounded === "string" || rounded === 0) {
        for (const value of String(rounded).split(" ")) {
          classes.push(`rounded-${value}`);
        }
      } else if (tile || rounded === false) {
        classes.push("rounded-0");
      }
      return classes;
    });
    return {
      roundedClasses
    };
  }

  // ../posawesome/node_modules/vuetify/lib/composables/transition.js
  var makeTransitionProps2 = propsFactory({
    transition: {
      type: null,
      default: "fade-transition",
      validator: (val) => val !== true
    }
  }, "transition");
  var MaybeTransition = (props, _ref) => {
    let {
      slots
    } = _ref;
    const _a3 = props, {
      transition,
      disabled,
      group
    } = _a3, rest = __objRest(_a3, [
      "transition",
      "disabled",
      "group"
    ]);
    const _b = isObject2(transition) ? transition : {}, {
      component = group ? TransitionGroup : Transition
    } = _b, customProps = __objRest(_b, [
      "component"
    ]);
    let transitionProps;
    if (isObject2(transition)) {
      transitionProps = mergeProps(customProps, onlyDefinedProps({
        disabled,
        group
      }), rest);
    } else {
      transitionProps = mergeProps({
        name: disabled || !transition ? "" : transition
      }, rest);
    }
    return h(component, transitionProps, slots);
  };

  // ../posawesome/node_modules/vuetify/lib/directives/intersect/index.js
  function mounted(el, binding) {
    if (!SUPPORTS_INTERSECTION)
      return;
    const modifiers = binding.modifiers || {};
    const value = binding.value;
    const {
      handler,
      options
    } = typeof value === "object" ? value : {
      handler: value,
      options: {}
    };
    const observer = new IntersectionObserver(function() {
      var _a3;
      let entries = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      let observer2 = arguments.length > 1 ? arguments[1] : void 0;
      const _observe = (_a3 = el._observe) == null ? void 0 : _a3[binding.instance.$.uid];
      if (!_observe)
        return;
      const isIntersecting = entries.some((entry) => entry.isIntersecting);
      if (handler && (!modifiers.quiet || _observe.init) && (!modifiers.once || isIntersecting || _observe.init)) {
        handler(isIntersecting, entries, observer2);
      }
      if (isIntersecting && modifiers.once)
        unmounted(el, binding);
      else
        _observe.init = true;
    }, options);
    el._observe = Object(el._observe);
    el._observe[binding.instance.$.uid] = {
      init: false,
      observer
    };
    observer.observe(el);
  }
  function unmounted(el, binding) {
    var _a3;
    const observe = (_a3 = el._observe) == null ? void 0 : _a3[binding.instance.$.uid];
    if (!observe)
      return;
    observe.observer.unobserve(el);
    delete el._observe[binding.instance.$.uid];
  }
  var Intersect = {
    mounted,
    unmounted
  };
  var intersect_default = Intersect;

  // ../posawesome/node_modules/vuetify/lib/components/VImg/VImg.js
  var makeVImgProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    absolute: Boolean,
    alt: String,
    cover: Boolean,
    color: String,
    draggable: {
      type: [Boolean, String],
      default: void 0
    },
    eager: Boolean,
    gradient: String,
    lazySrc: String,
    options: {
      type: Object,
      default: () => ({
        root: void 0,
        rootMargin: void 0,
        threshold: void 0
      })
    },
    sizes: String,
    src: {
      type: [String, Object],
      default: ""
    },
    crossorigin: String,
    referrerpolicy: String,
    srcset: String,
    position: String
  }, makeVResponsiveProps()), makeComponentProps()), makeRoundedProps()), makeTransitionProps2()), "VImg");
  var VImg = genericComponent()({
    name: "VImg",
    directives: {
      vIntersect: intersect_default
    },
    props: makeVImgProps(),
    emits: {
      loadstart: (value) => true,
      load: (value) => true,
      error: (value) => true
    },
    setup(props, _ref) {
      let {
        emit: emit2,
        slots
      } = _ref;
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(() => props.color);
      const {
        roundedClasses
      } = useRounded(props);
      const vm2 = getCurrentInstance2("VImg");
      const currentSrc = shallowRef("");
      const image = ref();
      const state = shallowRef(props.eager ? "loading" : "idle");
      const naturalWidth = shallowRef();
      const naturalHeight = shallowRef();
      const normalisedSrc = computed2(() => {
        return props.src && typeof props.src === "object" ? {
          src: props.src.src,
          srcset: props.srcset || props.src.srcset,
          lazySrc: props.lazySrc || props.src.lazySrc,
          aspect: Number(props.aspectRatio || props.src.aspect || 0)
        } : {
          src: props.src,
          srcset: props.srcset,
          lazySrc: props.lazySrc,
          aspect: Number(props.aspectRatio || 0)
        };
      });
      const aspectRatio = computed2(() => {
        return normalisedSrc.value.aspect || naturalWidth.value / naturalHeight.value || 0;
      });
      watch2(() => props.src, () => {
        init(state.value !== "idle");
      });
      watch2(aspectRatio, (val, oldVal) => {
        if (!val && oldVal && image.value) {
          pollForSize(image.value);
        }
      });
      onBeforeMount(() => init());
      function init(isIntersecting) {
        if (props.eager && isIntersecting)
          return;
        if (SUPPORTS_INTERSECTION && !isIntersecting && !props.eager)
          return;
        state.value = "loading";
        if (normalisedSrc.value.lazySrc) {
          const lazyImg = new Image();
          lazyImg.src = normalisedSrc.value.lazySrc;
          pollForSize(lazyImg, null);
        }
        if (!normalisedSrc.value.src)
          return;
        nextTick(() => {
          var _a3;
          emit2("loadstart", ((_a3 = image.value) == null ? void 0 : _a3.currentSrc) || normalisedSrc.value.src);
          setTimeout(() => {
            var _a4;
            if (vm2.isUnmounted)
              return;
            if ((_a4 = image.value) == null ? void 0 : _a4.complete) {
              if (!image.value.naturalWidth) {
                onError();
              }
              if (state.value === "error")
                return;
              if (!aspectRatio.value)
                pollForSize(image.value, null);
              if (state.value === "loading")
                onLoad();
            } else {
              if (!aspectRatio.value)
                pollForSize(image.value);
              getSrc();
            }
          });
        });
      }
      function onLoad() {
        var _a3;
        if (vm2.isUnmounted)
          return;
        getSrc();
        pollForSize(image.value);
        state.value = "loaded";
        emit2("load", ((_a3 = image.value) == null ? void 0 : _a3.currentSrc) || normalisedSrc.value.src);
      }
      function onError() {
        var _a3;
        if (vm2.isUnmounted)
          return;
        state.value = "error";
        emit2("error", ((_a3 = image.value) == null ? void 0 : _a3.currentSrc) || normalisedSrc.value.src);
      }
      function getSrc() {
        const img = image.value;
        if (img)
          currentSrc.value = img.currentSrc || img.src;
      }
      let timer = -1;
      onBeforeUnmount(() => {
        clearTimeout(timer);
      });
      function pollForSize(img) {
        let timeout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;
        const poll = () => {
          clearTimeout(timer);
          if (vm2.isUnmounted)
            return;
          const {
            naturalHeight: imgHeight,
            naturalWidth: imgWidth
          } = img;
          if (imgHeight || imgWidth) {
            naturalWidth.value = imgWidth;
            naturalHeight.value = imgHeight;
          } else if (!img.complete && state.value === "loading" && timeout != null) {
            timer = window.setTimeout(poll, timeout);
          } else if (img.currentSrc.endsWith(".svg") || img.currentSrc.startsWith("data:image/svg+xml")) {
            naturalWidth.value = 1;
            naturalHeight.value = 1;
          }
        };
        poll();
      }
      const containClasses = toRef(() => ({
        "v-img__img--cover": props.cover,
        "v-img__img--contain": !props.cover
      }));
      const __image = () => {
        var _a3;
        if (!normalisedSrc.value.src || state.value === "idle")
          return null;
        const img = createBaseVNode("img", {
          "class": normalizeClass(["v-img__img", containClasses.value]),
          "style": {
            objectPosition: props.position
          },
          "crossorigin": props.crossorigin,
          "src": normalisedSrc.value.src,
          "srcset": normalisedSrc.value.srcset,
          "alt": props.alt,
          "referrerpolicy": props.referrerpolicy,
          "draggable": props.draggable,
          "sizes": props.sizes,
          "ref": image,
          "onLoad": onLoad,
          "onError": onError
        }, null);
        const sources = (_a3 = slots.sources) == null ? void 0 : _a3.call(slots);
        return createVNode(MaybeTransition, {
          "transition": props.transition,
          "appear": true
        }, {
          default: () => [withDirectives(sources ? createBaseVNode("picture", {
            "class": "v-img__picture"
          }, [sources, img]) : img, [[vShow, state.value === "loaded"]])]
        });
      };
      const __preloadImage = () => createVNode(MaybeTransition, {
        "transition": props.transition
      }, {
        default: () => [normalisedSrc.value.lazySrc && state.value !== "loaded" && createBaseVNode("img", {
          "class": normalizeClass(["v-img__img", "v-img__img--preload", containClasses.value]),
          "style": {
            objectPosition: props.position
          },
          "crossorigin": props.crossorigin,
          "src": normalisedSrc.value.lazySrc,
          "alt": props.alt,
          "referrerpolicy": props.referrerpolicy,
          "draggable": props.draggable
        }, null)]
      });
      const __placeholder = () => {
        if (!slots.placeholder)
          return null;
        return createVNode(MaybeTransition, {
          "transition": props.transition,
          "appear": true
        }, {
          default: () => [(state.value === "loading" || state.value === "error" && !slots.error) && createBaseVNode("div", {
            "class": "v-img__placeholder"
          }, [slots.placeholder()])]
        });
      };
      const __error = () => {
        if (!slots.error)
          return null;
        return createVNode(MaybeTransition, {
          "transition": props.transition,
          "appear": true
        }, {
          default: () => [state.value === "error" && createBaseVNode("div", {
            "class": "v-img__error"
          }, [slots.error()])]
        });
      };
      const __gradient = () => {
        if (!props.gradient)
          return null;
        return createBaseVNode("div", {
          "class": "v-img__gradient",
          "style": {
            backgroundImage: `linear-gradient(${props.gradient})`
          }
        }, null);
      };
      const isBooted = shallowRef(false);
      {
        const stop2 = watch2(aspectRatio, (val) => {
          if (val) {
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                isBooted.value = true;
              });
            });
            stop2();
          }
        });
      }
      useRender(() => {
        const responsiveProps = VResponsive.filterProps(props);
        return withDirectives(createVNode(VResponsive, mergeProps({
          "class": ["v-img", {
            "v-img--absolute": props.absolute,
            "v-img--booting": !isBooted.value
          }, backgroundColorClasses.value, roundedClasses.value, props.class],
          "style": [{
            width: convertToUnit(props.width === "auto" ? naturalWidth.value : props.width)
          }, backgroundColorStyles.value, props.style]
        }, responsiveProps, {
          "aspectRatio": aspectRatio.value,
          "aria-label": props.alt,
          "role": props.alt ? "img" : void 0
        }), {
          additional: () => createBaseVNode(Fragment, null, [createVNode(__image, null, null), createVNode(__preloadImage, null, null), createVNode(__gradient, null, null), createVNode(__placeholder, null, null), createVNode(__error, null, null)]),
          default: slots.default
        }), [[intersect_default, {
          handler: init,
          options: props.options
        }, null, {
          once: true
        }]]);
      });
      return {
        currentSrc,
        image,
        state,
        naturalWidth,
        naturalHeight
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/composables/border.js
  var makeBorderProps = propsFactory({
    border: [Boolean, Number, String]
  }, "border");
  function useBorder(props) {
    let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    const borderClasses = computed2(() => {
      const border = props.border;
      if (border === true || border === "") {
        return `${name}--border`;
      } else if (typeof border === "string" || border === 0) {
        return String(border).split(" ").map((v) => `border-${v}`);
      }
      return [];
    });
    return {
      borderClasses
    };
  }

  // ../posawesome/node_modules/vuetify/lib/composables/elevation.js
  var makeElevationProps = propsFactory({
    elevation: {
      type: [Number, String],
      validator(v) {
        const value = parseInt(v);
        return !isNaN(value) && value >= 0 && value <= 24;
      }
    }
  }, "elevation");
  function useElevation(props) {
    const elevationClasses = toRef(() => {
      const elevation = isRef2(props) ? props.value : props.elevation;
      if (elevation == null)
        return [];
      return [`elevation-${elevation}`];
    });
    return {
      elevationClasses
    };
  }

  // ../posawesome/node_modules/vuetify/lib/components/VToolbar/VToolbar.js
  var allowedDensities = [null, "prominent", "default", "comfortable", "compact"];
  var makeVToolbarProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    absolute: Boolean,
    collapse: Boolean,
    color: String,
    density: {
      type: String,
      default: "default",
      validator: (v) => allowedDensities.includes(v)
    },
    extended: Boolean,
    extensionHeight: {
      type: [Number, String],
      default: 48
    },
    flat: Boolean,
    floating: Boolean,
    height: {
      type: [Number, String],
      default: 64
    },
    image: String,
    title: String
  }, makeBorderProps()), makeComponentProps()), makeElevationProps()), makeRoundedProps()), makeTagProps({
    tag: "header"
  })), makeThemeProps()), "VToolbar");
  var VToolbar = genericComponent()({
    name: "VToolbar",
    props: makeVToolbarProps(),
    setup(props, _ref) {
      var _a3;
      let {
        slots
      } = _ref;
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(() => props.color);
      const {
        borderClasses
      } = useBorder(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        roundedClasses
      } = useRounded(props);
      const {
        themeClasses
      } = provideTheme(props);
      const {
        rtlClasses
      } = useRtl();
      const isExtended = shallowRef(!!(props.extended || ((_a3 = slots.extension) == null ? void 0 : _a3.call(slots))));
      const contentHeight = computed2(() => parseInt(Number(props.height) + (props.density === "prominent" ? Number(props.height) : 0) - (props.density === "comfortable" ? 8 : 0) - (props.density === "compact" ? 16 : 0), 10));
      const extensionHeight = computed2(() => isExtended.value ? parseInt(Number(props.extensionHeight) + (props.density === "prominent" ? Number(props.extensionHeight) : 0) - (props.density === "comfortable" ? 4 : 0) - (props.density === "compact" ? 8 : 0), 10) : 0);
      provideDefaults({
        VBtn: {
          variant: "text"
        }
      });
      useRender(() => {
        var _a4;
        const hasTitle = !!(props.title || slots.title);
        const hasImage = !!(slots.image || props.image);
        const extension = (_a4 = slots.extension) == null ? void 0 : _a4.call(slots);
        isExtended.value = !!(props.extended || extension);
        return createVNode(props.tag, {
          "class": normalizeClass(["v-toolbar", {
            "v-toolbar--absolute": props.absolute,
            "v-toolbar--collapse": props.collapse,
            "v-toolbar--flat": props.flat,
            "v-toolbar--floating": props.floating,
            [`v-toolbar--density-${props.density}`]: true
          }, backgroundColorClasses.value, borderClasses.value, elevationClasses.value, roundedClasses.value, themeClasses.value, rtlClasses.value, props.class]),
          "style": normalizeStyle([backgroundColorStyles.value, props.style])
        }, {
          default: () => [hasImage && createBaseVNode("div", {
            "key": "image",
            "class": "v-toolbar__image"
          }, [!slots.image ? createVNode(VImg, {
            "key": "image-img",
            "cover": true,
            "src": props.image
          }, null) : createVNode(VDefaultsProvider, {
            "key": "image-defaults",
            "disabled": !props.image,
            "defaults": {
              VImg: {
                cover: true,
                src: props.image
              }
            }
          }, slots.image)]), createVNode(VDefaultsProvider, {
            "defaults": {
              VTabs: {
                height: convertToUnit(contentHeight.value)
              }
            }
          }, {
            default: () => {
              var _a5, _b, _c;
              return [createBaseVNode("div", {
                "class": "v-toolbar__content",
                "style": {
                  height: convertToUnit(contentHeight.value)
                }
              }, [slots.prepend && createBaseVNode("div", {
                "class": "v-toolbar__prepend"
              }, [(_a5 = slots.prepend) == null ? void 0 : _a5.call(slots)]), hasTitle && createVNode(VToolbarTitle, {
                "key": "title",
                "text": props.title
              }, {
                text: slots.title
              }), (_b = slots.default) == null ? void 0 : _b.call(slots), slots.append && createBaseVNode("div", {
                "class": "v-toolbar__append"
              }, [(_c = slots.append) == null ? void 0 : _c.call(slots)])])];
            }
          }), createVNode(VDefaultsProvider, {
            "defaults": {
              VTabs: {
                height: convertToUnit(extensionHeight.value)
              }
            }
          }, {
            default: () => [createVNode(VExpandTransition, null, {
              default: () => [isExtended.value && createBaseVNode("div", {
                "class": "v-toolbar__extension",
                "style": {
                  height: convertToUnit(extensionHeight.value)
                }
              }, [extension])]
            })]
          })]
        });
      });
      return {
        contentHeight,
        extensionHeight
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/composables/scroll.js
  var makeScrollProps = propsFactory({
    scrollTarget: {
      type: String
    },
    scrollThreshold: {
      type: [String, Number],
      default: 300
    }
  }, "scroll");
  function useScroll(props) {
    let args = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      canScroll
    } = args;
    let previousScroll = 0;
    let previousScrollHeight = 0;
    const target = ref(null);
    const currentScroll = shallowRef(0);
    const savedScroll = shallowRef(0);
    const currentThreshold = shallowRef(0);
    const isScrollActive = shallowRef(false);
    const isScrollingUp = shallowRef(false);
    const scrollThreshold = computed2(() => {
      return Number(props.scrollThreshold);
    });
    const scrollRatio = computed2(() => {
      return clamp((scrollThreshold.value - currentScroll.value) / scrollThreshold.value || 0);
    });
    const onScroll = () => {
      const targetEl = target.value;
      if (!targetEl || canScroll && !canScroll.value)
        return;
      previousScroll = currentScroll.value;
      currentScroll.value = "window" in targetEl ? targetEl.pageYOffset : targetEl.scrollTop;
      const currentScrollHeight = targetEl instanceof Window ? document.documentElement.scrollHeight : targetEl.scrollHeight;
      if (previousScrollHeight !== currentScrollHeight) {
        previousScrollHeight = currentScrollHeight;
        return;
      }
      isScrollingUp.value = currentScroll.value < previousScroll;
      currentThreshold.value = Math.abs(currentScroll.value - scrollThreshold.value);
    };
    watch2(isScrollingUp, () => {
      savedScroll.value = savedScroll.value || currentScroll.value;
    });
    watch2(isScrollActive, () => {
      savedScroll.value = 0;
    });
    onMounted(() => {
      watch2(() => props.scrollTarget, (scrollTarget) => {
        var _a3;
        const newTarget = scrollTarget ? document.querySelector(scrollTarget) : window;
        if (!newTarget) {
          consoleWarn(`Unable to locate element with identifier ${scrollTarget}`);
          return;
        }
        if (newTarget === target.value)
          return;
        (_a3 = target.value) == null ? void 0 : _a3.removeEventListener("scroll", onScroll);
        target.value = newTarget;
        target.value.addEventListener("scroll", onScroll, {
          passive: true
        });
      }, {
        immediate: true
      });
    });
    onBeforeUnmount(() => {
      var _a3;
      (_a3 = target.value) == null ? void 0 : _a3.removeEventListener("scroll", onScroll);
    });
    canScroll && watch2(canScroll, onScroll, {
      immediate: true
    });
    return {
      scrollThreshold,
      currentScroll,
      currentThreshold,
      isScrollActive,
      scrollRatio,
      isScrollingUp,
      savedScroll
    };
  }

  // ../posawesome/node_modules/vuetify/lib/composables/ssrBoot.js
  function useSsrBoot() {
    const isBooted = shallowRef(false);
    onMounted(() => {
      window.requestAnimationFrame(() => {
        isBooted.value = true;
      });
    });
    const ssrBootStyles = toRef(() => !isBooted.value ? {
      transition: "none !important"
    } : void 0);
    return {
      ssrBootStyles,
      isBooted: readonly(isBooted)
    };
  }

  // ../posawesome/node_modules/vuetify/lib/components/VAppBar/VAppBar.js
  var makeVAppBarProps = propsFactory(__spreadProps(__spreadValues(__spreadValues(__spreadValues({
    scrollBehavior: String,
    modelValue: {
      type: Boolean,
      default: true
    },
    location: {
      type: String,
      default: "top",
      validator: (value) => ["top", "bottom"].includes(value)
    }
  }, makeVToolbarProps()), makeLayoutItemProps()), makeScrollProps()), {
    height: {
      type: [Number, String],
      default: 64
    }
  }), "VAppBar");
  var VAppBar = genericComponent()({
    name: "VAppBar",
    props: makeVAppBarProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const vToolbarRef = ref();
      const isActive = useProxiedModel(props, "modelValue");
      const scrollBehavior = computed2(() => {
        var _a3, _b;
        const behavior = new Set((_b = (_a3 = props.scrollBehavior) == null ? void 0 : _a3.split(" ")) != null ? _b : []);
        return {
          hide: behavior.has("hide"),
          fullyHide: behavior.has("fully-hide"),
          inverted: behavior.has("inverted"),
          collapse: behavior.has("collapse"),
          elevate: behavior.has("elevate"),
          fadeImage: behavior.has("fade-image")
        };
      });
      const canScroll = computed2(() => {
        const behavior = scrollBehavior.value;
        return behavior.hide || behavior.fullyHide || behavior.inverted || behavior.collapse || behavior.elevate || behavior.fadeImage || !isActive.value;
      });
      const {
        currentScroll,
        scrollThreshold,
        isScrollingUp,
        scrollRatio
      } = useScroll(props, {
        canScroll
      });
      const canHide = toRef(() => scrollBehavior.value.hide || scrollBehavior.value.fullyHide);
      const isCollapsed = computed2(() => props.collapse || scrollBehavior.value.collapse && (scrollBehavior.value.inverted ? scrollRatio.value > 0 : scrollRatio.value === 0));
      const isFlat = computed2(() => props.flat || scrollBehavior.value.fullyHide && !isActive.value || scrollBehavior.value.elevate && (scrollBehavior.value.inverted ? currentScroll.value > 0 : currentScroll.value === 0));
      const opacity = computed2(() => scrollBehavior.value.fadeImage ? scrollBehavior.value.inverted ? 1 - scrollRatio.value : scrollRatio.value : void 0);
      const height = computed2(() => {
        var _a3, _b, _c, _d;
        if (scrollBehavior.value.hide && scrollBehavior.value.inverted)
          return 0;
        const height2 = (_b = (_a3 = vToolbarRef.value) == null ? void 0 : _a3.contentHeight) != null ? _b : 0;
        const extensionHeight = (_d = (_c = vToolbarRef.value) == null ? void 0 : _c.extensionHeight) != null ? _d : 0;
        if (!canHide.value)
          return height2 + extensionHeight;
        return currentScroll.value < scrollThreshold.value || scrollBehavior.value.fullyHide ? height2 + extensionHeight : height2;
      });
      useToggleScope(() => !!props.scrollBehavior, () => {
        watchEffect(() => {
          if (canHide.value) {
            if (scrollBehavior.value.inverted) {
              isActive.value = currentScroll.value > scrollThreshold.value;
            } else {
              isActive.value = isScrollingUp.value || currentScroll.value < scrollThreshold.value;
            }
          } else {
            isActive.value = true;
          }
        });
      });
      const {
        ssrBootStyles
      } = useSsrBoot();
      const {
        layoutItemStyles
      } = useLayoutItem({
        id: props.name,
        order: computed2(() => parseInt(props.order, 10)),
        position: toRef(() => props.location),
        layoutSize: height,
        elementSize: shallowRef(void 0),
        active: isActive,
        absolute: toRef(() => props.absolute)
      });
      useRender(() => {
        const toolbarProps = VToolbar.filterProps(props);
        return createVNode(VToolbar, mergeProps({
          "ref": vToolbarRef,
          "class": ["v-app-bar", {
            "v-app-bar--bottom": props.location === "bottom"
          }, props.class],
          "style": [__spreadValues(__spreadProps(__spreadValues({}, layoutItemStyles.value), {
            "--v-toolbar-image-opacity": opacity.value,
            height: void 0
          }), ssrBootStyles.value), props.style]
        }, toolbarProps, {
          "collapse": isCollapsed.value,
          "flat": isFlat.value
        }), slots);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/composables/density.js
  var allowedDensities2 = [null, "default", "comfortable", "compact"];
  var makeDensityProps = propsFactory({
    density: {
      type: String,
      default: "default",
      validator: (v) => allowedDensities2.includes(v)
    }
  }, "density");
  function useDensity(props) {
    let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    const densityClasses = toRef(() => {
      return `${name}--density-${props.density}`;
    });
    return {
      densityClasses
    };
  }

  // ../posawesome/node_modules/vuetify/lib/composables/variant.js
  var allowedVariants = ["elevated", "flat", "tonal", "outlined", "text", "plain"];
  function genOverlays(isClickable, name) {
    return createBaseVNode(Fragment, null, [isClickable && createBaseVNode("span", {
      "key": "overlay",
      "class": normalizeClass(`${name}__overlay`)
    }, null), createBaseVNode("span", {
      "key": "underlay",
      "class": normalizeClass(`${name}__underlay`)
    }, null)]);
  }
  var makeVariantProps = propsFactory({
    color: String,
    variant: {
      type: String,
      default: "elevated",
      validator: (v) => allowedVariants.includes(v)
    }
  }, "variant");
  function useVariant(props) {
    let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    const variantClasses = toRef(() => {
      const {
        variant
      } = toValue(props);
      return `${name}--variant-${variant}`;
    });
    const {
      colorClasses,
      colorStyles
    } = useColor(() => {
      const {
        variant,
        color
      } = toValue(props);
      return {
        [["elevated", "flat"].includes(variant) ? "background" : "text"]: color
      };
    });
    return {
      colorClasses,
      colorStyles,
      variantClasses
    };
  }

  // ../posawesome/node_modules/vuetify/lib/components/VBtnGroup/VBtnGroup.js
  var makeVBtnGroupProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    baseColor: String,
    divided: Boolean
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeElevationProps()), makeRoundedProps()), makeTagProps()), makeThemeProps()), makeVariantProps()), "VBtnGroup");
  var VBtnGroup = genericComponent()({
    name: "VBtnGroup",
    props: makeVBtnGroupProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        densityClasses
      } = useDensity(props);
      const {
        borderClasses
      } = useBorder(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        roundedClasses
      } = useRounded(props);
      provideDefaults({
        VBtn: {
          height: "auto",
          baseColor: toRef(() => props.baseColor),
          color: toRef(() => props.color),
          density: toRef(() => props.density),
          flat: true,
          variant: toRef(() => props.variant)
        }
      });
      useRender(() => {
        return createVNode(props.tag, {
          "class": normalizeClass(["v-btn-group", {
            "v-btn-group--divided": props.divided
          }, themeClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value, props.class]),
          "style": normalizeStyle(props.style)
        }, slots);
      });
    }
  });

  // ../posawesome/node_modules/vuetify/lib/composables/group.js
  var makeGroupProps = propsFactory({
    modelValue: {
      type: null,
      default: void 0
    },
    multiple: Boolean,
    mandatory: [Boolean, String],
    max: Number,
    selectedClass: String,
    disabled: Boolean
  }, "group");
  var makeGroupItemProps = propsFactory({
    value: null,
    disabled: Boolean,
    selectedClass: String
  }, "group-item");
  function useGroupItem(props, injectKey) {
    let required = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    const vm2 = getCurrentInstance2("useGroupItem");
    if (!vm2) {
      throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");
    }
    const id = useId();
    provide(Symbol.for(`${injectKey.description}:id`), id);
    const group = inject(injectKey, null);
    if (!group) {
      if (!required)
        return group;
      throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${injectKey.description}`);
    }
    const value = toRef(() => props.value);
    const disabled = computed2(() => !!(group.disabled.value || props.disabled));
    group.register({
      id,
      value,
      disabled
    }, vm2);
    onBeforeUnmount(() => {
      group.unregister(id);
    });
    const isSelected = computed2(() => {
      return group.isSelected(id);
    });
    const isFirst = computed2(() => {
      return group.items.value[0].id === id;
    });
    const isLast = computed2(() => {
      return group.items.value[group.items.value.length - 1].id === id;
    });
    const selectedClass = computed2(() => isSelected.value && [group.selectedClass.value, props.selectedClass]);
    watch2(isSelected, (value2) => {
      vm2.emit("group:selected", {
        value: value2
      });
    }, {
      flush: "sync"
    });
    return {
      id,
      isSelected,
      isFirst,
      isLast,
      toggle: () => group.select(id, !isSelected.value),
      select: (value2) => group.select(id, value2),
      selectedClass,
      value,
      disabled,
      group
    };
  }
  function useGroup(props, injectKey) {
    let isUnmounted = false;
    const items = reactive([]);
    const selected = useProxiedModel(props, "modelValue", [], (v) => {
      if (v == null)
        return [];
      return getIds(items, wrapInArray(v));
    }, (v) => {
      const arr = getValues(items, v);
      return props.multiple ? arr : arr[0];
    });
    const groupVm = getCurrentInstance2("useGroup");
    function register(item, vm2) {
      const unwrapped = item;
      const key = Symbol.for(`${injectKey.description}:id`);
      const children = findChildrenWithProvide(key, groupVm == null ? void 0 : groupVm.vnode);
      const index = children.indexOf(vm2);
      if (unref(unwrapped.value) == null) {
        unwrapped.value = index;
        unwrapped.useIndexAsValue = true;
      }
      if (index > -1) {
        items.splice(index, 0, unwrapped);
      } else {
        items.push(unwrapped);
      }
    }
    function unregister(id) {
      if (isUnmounted)
        return;
      forceMandatoryValue();
      const index = items.findIndex((item) => item.id === id);
      items.splice(index, 1);
    }
    function forceMandatoryValue() {
      const item = items.find((item2) => !item2.disabled);
      if (item && props.mandatory === "force" && !selected.value.length) {
        selected.value = [item.id];
      }
    }
    onMounted(() => {
      forceMandatoryValue();
    });
    onBeforeUnmount(() => {
      isUnmounted = true;
    });
    onUpdated(() => {
      for (let i = 0; i < items.length; i++) {
        if (items[i].useIndexAsValue) {
          items[i].value = i;
        }
      }
    });
    function select(id, value) {
      const item = items.find((item2) => item2.id === id);
      if (value && (item == null ? void 0 : item.disabled))
        return;
      if (props.multiple) {
        const internalValue = selected.value.slice();
        const index = internalValue.findIndex((v) => v === id);
        const isSelected = ~index;
        value = value != null ? value : !isSelected;
        if (isSelected && props.mandatory && internalValue.length <= 1)
          return;
        if (!isSelected && props.max != null && internalValue.length + 1 > props.max)
          return;
        if (index < 0 && value)
          internalValue.push(id);
        else if (index >= 0 && !value)
          internalValue.splice(index, 1);
        selected.value = internalValue;
      } else {
        const isSelected = selected.value.includes(id);
        if (props.mandatory && isSelected)
          return;
        if (!isSelected && !value)
          return;
        selected.value = (value != null ? value : !isSelected) ? [id] : [];
      }
    }
    function step(offset) {
      if (props.multiple)
        consoleWarn('This method is not supported when using "multiple" prop');
      if (!selected.value.length) {
        const item = items.find((item2) => !item2.disabled);
        item && (selected.value = [item.id]);
      } else {
        const currentId = selected.value[0];
        const currentIndex = items.findIndex((i) => i.id === currentId);
        let newIndex = (currentIndex + offset) % items.length;
        let newItem = items[newIndex];
        while (newItem.disabled && newIndex !== currentIndex) {
          newIndex = (newIndex + offset) % items.length;
          newItem = items[newIndex];
        }
        if (newItem.disabled)
          return;
        selected.value = [items[newIndex].id];
      }
    }
    const state = {
      register,
      unregister,
      selected,
      select,
      disabled: toRef(() => props.disabled),
      prev: () => step(items.length - 1),
      next: () => step(1),
      isSelected: (id) => selected.value.includes(id),
      selectedClass: toRef(() => props.selectedClass),
      items: toRef(() => items),
      getItemIndex: (value) => getItemIndex(items, value)
    };
    provide(injectKey, state);
    return state;
  }
  function getItemIndex(items, value) {
    const ids = getIds(items, [value]);
    if (!ids.length)
      return -1;
    return items.findIndex((item) => item.id === ids[0]);
  }
  function getIds(items, modelValue) {
    const ids = [];
    modelValue.forEach((value) => {
      const item = items.find((item2) => deepEqual(value, item2.value));
      const itemByIndex = items[value];
      if ((item == null ? void 0 : item.value) != null) {
        ids.push(item.id);
      } else if (itemByIndex != null) {
        ids.push(itemByIndex.id);
      }
    });
    return ids;
  }
  function getValues(items, ids) {
    const values = [];
    ids.forEach((id) => {
      const itemIndex = items.findIndex((item) => item.id === id);
      if (~itemIndex) {
        const item = items[itemIndex];
        values.push(item.value != null ? item.value : itemIndex);
      }
    });
    return values;
  }

  // ../posawesome/node_modules/vuetify/lib/components/VBtnToggle/VBtnToggle.js
  var VBtnToggleSymbol = Symbol.for("vuetify:v-btn-toggle");
  var makeVBtnToggleProps = propsFactory(__spreadValues(__spreadValues({}, makeVBtnGroupProps()), makeGroupProps()), "VBtnToggle");
  var VBtnToggle = genericComponent()({
    name: "VBtnToggle",
    props: makeVBtnToggleProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        isSelected,
        next,
        prev,
        select,
        selected
      } = useGroup(props, VBtnToggleSymbol);
      useRender(() => {
        const btnGroupProps = VBtnGroup.filterProps(props);
        return createVNode(VBtnGroup, mergeProps({
          "class": ["v-btn-toggle", props.class]
        }, btnGroupProps, {
          "style": props.style
        }), {
          default: () => {
            var _a3;
            return [(_a3 = slots.default) == null ? void 0 : _a3.call(slots, {
              isSelected,
              next,
              prev,
              select,
              selected
            })];
          }
        });
      });
      return {
        next,
        prev,
        select
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/composables/size.js
  var predefinedSizes = ["x-small", "small", "default", "large", "x-large"];
  var makeSizeProps = propsFactory({
    size: {
      type: [String, Number],
      default: "default"
    }
  }, "size");
  function useSize(props) {
    let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    return destructComputed(() => {
      const size = props.size;
      let sizeClasses;
      let sizeStyles;
      if (includes(predefinedSizes, size)) {
        sizeClasses = `${name}--size-${size}`;
      } else if (size) {
        sizeStyles = {
          width: convertToUnit(size),
          height: convertToUnit(size)
        };
      }
      return {
        sizeClasses,
        sizeStyles
      };
    });
  }

  // ../posawesome/node_modules/vuetify/lib/components/VIcon/VIcon.js
  var makeVIconProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    color: String,
    disabled: Boolean,
    start: Boolean,
    end: Boolean,
    icon: IconValue,
    opacity: [String, Number]
  }, makeComponentProps()), makeSizeProps()), makeTagProps({
    tag: "i"
  })), makeThemeProps()), "VIcon");
  var VIcon = genericComponent()({
    name: "VIcon",
    props: makeVIconProps(),
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const slotIcon = shallowRef();
      const {
        themeClasses
      } = useTheme();
      const {
        iconData
      } = useIcon(() => slotIcon.value || props.icon);
      const {
        sizeClasses
      } = useSize(props);
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(() => props.color);
      useRender(() => {
        var _a3, _b;
        const slotValue = (_a3 = slots.default) == null ? void 0 : _a3.call(slots);
        if (slotValue) {
          slotIcon.value = (_b = flattenFragments(slotValue).filter((node) => node.type === Text && node.children && typeof node.children === "string")[0]) == null ? void 0 : _b.children;
        }
        const hasClick = !!(attrs.onClick || attrs.onClickOnce);
        return createVNode(iconData.value.component, {
          "tag": props.tag,
          "icon": iconData.value.icon,
          "class": normalizeClass(["v-icon", "notranslate", themeClasses.value, sizeClasses.value, textColorClasses.value, {
            "v-icon--clickable": hasClick,
            "v-icon--disabled": props.disabled,
            "v-icon--start": props.start,
            "v-icon--end": props.end
          }, props.class]),
          "style": normalizeStyle([{
            "--v-icon-opacity": props.opacity
          }, !sizeClasses.value ? {
            fontSize: convertToUnit(props.size),
            height: convertToUnit(props.size),
            width: convertToUnit(props.size)
          } : void 0, textColorStyles.value, props.style]),
          "role": hasClick ? "button" : void 0,
          "aria-hidden": !hasClick,
          "tabindex": hasClick ? props.disabled ? -1 : 0 : void 0
        }, {
          default: () => [slotValue]
        });
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/composables/intersectionObserver.js
  function useIntersectionObserver(callback, options) {
    const intersectionRef = ref();
    const isIntersecting = shallowRef(false);
    if (SUPPORTS_INTERSECTION) {
      const observer = new IntersectionObserver((entries) => {
        callback == null ? void 0 : callback(entries, observer);
        isIntersecting.value = !!entries.find((entry) => entry.isIntersecting);
      }, options);
      onScopeDispose(() => {
        observer.disconnect();
      });
      watch2(intersectionRef, (newValue, oldValue) => {
        if (oldValue) {
          observer.unobserve(oldValue);
          isIntersecting.value = false;
        }
        if (newValue)
          observer.observe(newValue);
      }, {
        flush: "post"
      });
    }
    return {
      intersectionRef,
      isIntersecting
    };
  }

  // ../posawesome/node_modules/vuetify/lib/components/VProgressCircular/VProgressCircular.js
  var makeVProgressCircularProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    bgColor: String,
    color: String,
    indeterminate: [Boolean, String],
    modelValue: {
      type: [Number, String],
      default: 0
    },
    rotate: {
      type: [Number, String],
      default: 0
    },
    width: {
      type: [Number, String],
      default: 4
    }
  }, makeComponentProps()), makeSizeProps()), makeTagProps({
    tag: "div"
  })), makeThemeProps()), "VProgressCircular");
  var VProgressCircular = genericComponent()({
    name: "VProgressCircular",
    props: makeVProgressCircularProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const MAGIC_RADIUS_CONSTANT = 20;
      const CIRCUMFERENCE = 2 * Math.PI * MAGIC_RADIUS_CONSTANT;
      const root = ref();
      const {
        themeClasses
      } = provideTheme(props);
      const {
        sizeClasses,
        sizeStyles
      } = useSize(props);
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(() => props.color);
      const {
        textColorClasses: underlayColorClasses,
        textColorStyles: underlayColorStyles
      } = useTextColor(() => props.bgColor);
      const {
        intersectionRef,
        isIntersecting
      } = useIntersectionObserver();
      const {
        resizeRef,
        contentRect
      } = useResizeObserver();
      const normalizedValue = toRef(() => clamp(parseFloat(props.modelValue), 0, 100));
      const width = toRef(() => Number(props.width));
      const size = toRef(() => {
        return sizeStyles.value ? Number(props.size) : contentRect.value ? contentRect.value.width : Math.max(width.value, 32);
      });
      const diameter = toRef(() => MAGIC_RADIUS_CONSTANT / (1 - width.value / size.value) * 2);
      const strokeWidth = toRef(() => width.value / size.value * diameter.value);
      const strokeDashOffset = toRef(() => convertToUnit((100 - normalizedValue.value) / 100 * CIRCUMFERENCE));
      watchEffect(() => {
        intersectionRef.value = root.value;
        resizeRef.value = root.value;
      });
      useRender(() => createVNode(props.tag, {
        "ref": root,
        "class": normalizeClass(["v-progress-circular", {
          "v-progress-circular--indeterminate": !!props.indeterminate,
          "v-progress-circular--visible": isIntersecting.value,
          "v-progress-circular--disable-shrink": props.indeterminate === "disable-shrink"
        }, themeClasses.value, sizeClasses.value, textColorClasses.value, props.class]),
        "style": normalizeStyle([sizeStyles.value, textColorStyles.value, props.style]),
        "role": "progressbar",
        "aria-valuemin": "0",
        "aria-valuemax": "100",
        "aria-valuenow": props.indeterminate ? void 0 : normalizedValue.value
      }, {
        default: () => [createBaseVNode("svg", {
          "style": {
            transform: `rotate(calc(-90deg + ${Number(props.rotate)}deg))`
          },
          "xmlns": "http://www.w3.org/2000/svg",
          "viewBox": `0 0 ${diameter.value} ${diameter.value}`
        }, [createBaseVNode("circle", {
          "class": normalizeClass(["v-progress-circular__underlay", underlayColorClasses.value]),
          "style": normalizeStyle(underlayColorStyles.value),
          "fill": "transparent",
          "cx": "50%",
          "cy": "50%",
          "r": MAGIC_RADIUS_CONSTANT,
          "stroke-width": strokeWidth.value,
          "stroke-dasharray": CIRCUMFERENCE,
          "stroke-dashoffset": 0
        }, null), createBaseVNode("circle", {
          "class": "v-progress-circular__overlay",
          "fill": "transparent",
          "cx": "50%",
          "cy": "50%",
          "r": MAGIC_RADIUS_CONSTANT,
          "stroke-width": strokeWidth.value,
          "stroke-dasharray": CIRCUMFERENCE,
          "stroke-dashoffset": strokeDashOffset.value
        }, null)]), slots.default && createBaseVNode("div", {
          "class": "v-progress-circular__content"
        }, [slots.default({
          value: normalizedValue.value
        })])]
      }));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/composables/location.js
  var oppositeMap = {
    center: "center",
    top: "bottom",
    bottom: "top",
    left: "right",
    right: "left"
  };
  var makeLocationProps = propsFactory({
    location: String
  }, "location");
  function useLocation(props) {
    let opposite = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    let offset = arguments.length > 2 ? arguments[2] : void 0;
    const {
      isRtl
    } = useRtl();
    const locationStyles = computed2(() => {
      if (!props.location)
        return {};
      const {
        side,
        align
      } = parseAnchor(props.location.split(" ").length > 1 ? props.location : `${props.location} center`, isRtl.value);
      function getOffset4(side2) {
        return offset ? offset(side2) : 0;
      }
      const styles = {};
      if (side !== "center") {
        if (opposite)
          styles[oppositeMap[side]] = `calc(100% - ${getOffset4(side)}px)`;
        else
          styles[side] = 0;
      }
      if (align !== "center") {
        if (opposite)
          styles[oppositeMap[align]] = `calc(100% - ${getOffset4(align)}px)`;
        else
          styles[align] = 0;
      } else {
        if (side === "center")
          styles.top = styles.left = "50%";
        else {
          styles[{
            top: "left",
            bottom: "left",
            left: "top",
            right: "top"
          }[side]] = "50%";
        }
        styles.transform = {
          top: "translateX(-50%)",
          bottom: "translateX(-50%)",
          left: "translateY(-50%)",
          right: "translateY(-50%)",
          center: "translate(-50%, -50%)"
        }[side];
      }
      return styles;
    });
    return {
      locationStyles
    };
  }

  // ../posawesome/node_modules/vuetify/lib/components/VProgressLinear/VProgressLinear.js
  var makeVProgressLinearProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    absolute: Boolean,
    active: {
      type: Boolean,
      default: true
    },
    bgColor: String,
    bgOpacity: [Number, String],
    bufferValue: {
      type: [Number, String],
      default: 0
    },
    bufferColor: String,
    bufferOpacity: [Number, String],
    clickable: Boolean,
    color: String,
    height: {
      type: [Number, String],
      default: 4
    },
    indeterminate: Boolean,
    max: {
      type: [Number, String],
      default: 100
    },
    modelValue: {
      type: [Number, String],
      default: 0
    },
    opacity: [Number, String],
    reverse: Boolean,
    stream: Boolean,
    striped: Boolean,
    roundedBar: Boolean
  }, makeComponentProps()), makeLocationProps({
    location: "top"
  })), makeRoundedProps()), makeTagProps()), makeThemeProps()), "VProgressLinear");
  var VProgressLinear = genericComponent()({
    name: "VProgressLinear",
    props: makeVProgressLinearProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      var _a3;
      let {
        slots
      } = _ref;
      const progress = useProxiedModel(props, "modelValue");
      const {
        isRtl,
        rtlClasses
      } = useRtl();
      const {
        themeClasses
      } = provideTheme(props);
      const {
        locationStyles
      } = useLocation(props);
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(() => props.color);
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(() => props.bgColor || props.color);
      const {
        backgroundColorClasses: bufferColorClasses,
        backgroundColorStyles: bufferColorStyles
      } = useBackgroundColor(() => props.bufferColor || props.bgColor || props.color);
      const {
        backgroundColorClasses: barColorClasses,
        backgroundColorStyles: barColorStyles
      } = useBackgroundColor(() => props.color);
      const {
        roundedClasses
      } = useRounded(props);
      const {
        intersectionRef,
        isIntersecting
      } = useIntersectionObserver();
      const max = computed2(() => parseFloat(props.max));
      const height = computed2(() => parseFloat(props.height));
      const normalizedBuffer = computed2(() => clamp(parseFloat(props.bufferValue) / max.value * 100, 0, 100));
      const normalizedValue = computed2(() => clamp(parseFloat(progress.value) / max.value * 100, 0, 100));
      const isReversed = computed2(() => isRtl.value !== props.reverse);
      const transition = computed2(() => props.indeterminate ? "fade-transition" : "slide-x-transition");
      const isForcedColorsModeActive = IN_BROWSER && ((_a3 = window.matchMedia) == null ? void 0 : _a3.call(window, "(forced-colors: active)").matches);
      function handleClick(e) {
        if (!intersectionRef.value)
          return;
        const {
          left,
          right,
          width
        } = intersectionRef.value.getBoundingClientRect();
        const value = isReversed.value ? width - e.clientX + (right - width) : e.clientX - left;
        progress.value = Math.round(value / width * max.value);
      }
      useRender(() => createVNode(props.tag, {
        "ref": intersectionRef,
        "class": normalizeClass(["v-progress-linear", {
          "v-progress-linear--absolute": props.absolute,
          "v-progress-linear--active": props.active && isIntersecting.value,
          "v-progress-linear--reverse": isReversed.value,
          "v-progress-linear--rounded": props.rounded,
          "v-progress-linear--rounded-bar": props.roundedBar,
          "v-progress-linear--striped": props.striped
        }, roundedClasses.value, themeClasses.value, rtlClasses.value, props.class]),
        "style": normalizeStyle([__spreadValues({
          bottom: props.location === "bottom" ? 0 : void 0,
          top: props.location === "top" ? 0 : void 0,
          height: props.active ? convertToUnit(height.value) : 0,
          "--v-progress-linear-height": convertToUnit(height.value)
        }, props.absolute ? locationStyles.value : {}), props.style]),
        "role": "progressbar",
        "aria-hidden": props.active ? "false" : "true",
        "aria-valuemin": "0",
        "aria-valuemax": props.max,
        "aria-valuenow": props.indeterminate ? void 0 : Math.min(parseFloat(progress.value), max.value),
        "onClick": props.clickable && handleClick
      }, {
        default: () => [props.stream && createBaseVNode("div", {
          "key": "stream",
          "class": normalizeClass(["v-progress-linear__stream", textColorClasses.value]),
          "style": __spreadProps(__spreadValues({}, textColorStyles.value), {
            [isReversed.value ? "left" : "right"]: convertToUnit(-height.value),
            borderTop: `${convertToUnit(height.value / 2)} dotted`,
            opacity: parseFloat(props.bufferOpacity),
            top: `calc(50% - ${convertToUnit(height.value / 4)})`,
            width: convertToUnit(100 - normalizedBuffer.value, "%"),
            "--v-progress-linear-stream-to": convertToUnit(height.value * (isReversed.value ? 1 : -1))
          })
        }, null), createBaseVNode("div", {
          "class": normalizeClass(["v-progress-linear__background", !isForcedColorsModeActive ? backgroundColorClasses.value : void 0]),
          "style": normalizeStyle([backgroundColorStyles.value, {
            opacity: parseFloat(props.bgOpacity),
            width: props.stream ? 0 : void 0
          }])
        }, null), createBaseVNode("div", {
          "class": normalizeClass(["v-progress-linear__buffer", !isForcedColorsModeActive ? bufferColorClasses.value : void 0]),
          "style": normalizeStyle([bufferColorStyles.value, {
            opacity: parseFloat(props.bufferOpacity),
            width: convertToUnit(normalizedBuffer.value, "%")
          }])
        }, null), createVNode(Transition, {
          "name": transition.value
        }, {
          default: () => [!props.indeterminate ? createBaseVNode("div", {
            "class": normalizeClass(["v-progress-linear__determinate", !isForcedColorsModeActive ? barColorClasses.value : void 0]),
            "style": normalizeStyle([barColorStyles.value, {
              width: convertToUnit(normalizedValue.value, "%")
            }])
          }, null) : createBaseVNode("div", {
            "class": "v-progress-linear__indeterminate"
          }, [["long", "short"].map((bar) => createBaseVNode("div", {
            "key": bar,
            "class": normalizeClass(["v-progress-linear__indeterminate", bar, !isForcedColorsModeActive ? barColorClasses.value : void 0]),
            "style": normalizeStyle(barColorStyles.value)
          }, null))])]
        }), slots.default && createBaseVNode("div", {
          "class": "v-progress-linear__content"
        }, [slots.default({
          value: normalizedValue.value,
          buffer: normalizedBuffer.value
        })])]
      }));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/composables/loader.js
  var makeLoaderProps = propsFactory({
    loading: [Boolean, String]
  }, "loader");
  function useLoader(props) {
    let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    const loaderClasses = toRef(() => ({
      [`${name}--loading`]: props.loading
    }));
    return {
      loaderClasses
    };
  }
  function LoaderSlot(props, _ref) {
    var _a3;
    let {
      slots
    } = _ref;
    return createBaseVNode("div", {
      "class": normalizeClass(`${props.name}__loader`)
    }, [((_a3 = slots.default) == null ? void 0 : _a3.call(slots, {
      color: props.color,
      isActive: props.active
    })) || createVNode(VProgressLinear, {
      "absolute": props.absolute,
      "active": props.active,
      "color": props.color,
      "height": "2",
      "indeterminate": true
    }, null)]);
  }

  // ../posawesome/node_modules/vuetify/lib/composables/position.js
  var positionValues = ["static", "relative", "fixed", "absolute", "sticky"];
  var makePositionProps = propsFactory({
    position: {
      type: String,
      validator: (v) => positionValues.includes(v)
    }
  }, "position");
  function usePosition(props) {
    let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    const positionClasses = toRef(() => {
      return props.position ? `${name}--${props.position}` : void 0;
    });
    return {
      positionClasses
    };
  }

  // ../posawesome/node_modules/vuetify/lib/composables/router.js
  function useRoute() {
    const vm2 = getCurrentInstance2("useRoute");
    return computed2(() => {
      var _a3;
      return (_a3 = vm2 == null ? void 0 : vm2.proxy) == null ? void 0 : _a3.$route;
    });
  }
  function useRouter() {
    var _a3, _b;
    return (_b = (_a3 = getCurrentInstance2("useRouter")) == null ? void 0 : _a3.proxy) == null ? void 0 : _b.$router;
  }
  function useLink(props, attrs) {
    var _a3, _b;
    const RouterLink = resolveDynamicComponent("RouterLink");
    const isLink = toRef(() => !!(props.href || props.to));
    const isClickable = computed2(() => {
      return (isLink == null ? void 0 : isLink.value) || hasEvent(attrs, "click") || hasEvent(props, "click");
    });
    if (typeof RouterLink === "string" || !("useLink" in RouterLink)) {
      const href2 = toRef(() => props.href);
      return {
        isLink,
        isClickable,
        href: href2,
        linkProps: reactive({
          href: href2
        })
      };
    }
    const routerLink = RouterLink.useLink({
      to: toRef(() => props.to || ""),
      replace: toRef(() => props.replace)
    });
    const link = computed2(() => props.to ? routerLink : void 0);
    const route = useRoute();
    const isActive = computed2(() => {
      var _a4, _b2, _c, _d, _e;
      if (!link.value)
        return false;
      if (!props.exact)
        return (_b2 = (_a4 = link.value.isActive) == null ? void 0 : _a4.value) != null ? _b2 : false;
      if (!route.value)
        return (_d = (_c = link.value.isExactActive) == null ? void 0 : _c.value) != null ? _d : false;
      return ((_e = link.value.isExactActive) == null ? void 0 : _e.value) && deepEqual(link.value.route.value.query, route.value.query);
    });
    const href = computed2(() => {
      var _a4;
      return props.to ? (_a4 = link.value) == null ? void 0 : _a4.route.value.href : props.href;
    });
    return {
      isLink,
      isClickable,
      isActive,
      route: (_a3 = link.value) == null ? void 0 : _a3.route,
      navigate: (_b = link.value) == null ? void 0 : _b.navigate,
      href,
      linkProps: reactive({
        href,
        "aria-current": toRef(() => isActive.value ? "page" : void 0)
      })
    };
  }
  var makeRouterProps = propsFactory({
    href: String,
    replace: Boolean,
    to: [String, Object],
    exact: Boolean
  }, "router");
  var inTransition = false;
  function useBackButton(router, cb) {
    let popped = false;
    let removeBefore;
    let removeAfter;
    if (IN_BROWSER && (router == null ? void 0 : router.beforeEach)) {
      nextTick(() => {
        window.addEventListener("popstate", onPopstate);
        removeBefore = router.beforeEach((to2, from, next) => {
          if (!inTransition) {
            setTimeout(() => popped ? cb(next) : next());
          } else {
            popped ? cb(next) : next();
          }
          inTransition = true;
        });
        removeAfter = router == null ? void 0 : router.afterEach(() => {
          inTransition = false;
        });
      });
      onScopeDispose(() => {
        window.removeEventListener("popstate", onPopstate);
        removeBefore == null ? void 0 : removeBefore();
        removeAfter == null ? void 0 : removeAfter();
      });
    }
    function onPopstate(e) {
      var _a3;
      if ((_a3 = e.state) == null ? void 0 : _a3.replaced)
        return;
      popped = true;
      setTimeout(() => popped = false);
    }
  }

  // ../posawesome/node_modules/vuetify/lib/composables/selectLink.js
  function useSelectLink(link, select) {
    watch2(() => {
      var _a3;
      return (_a3 = link.isActive) == null ? void 0 : _a3.value;
    }, (isActive) => {
      if (link.isLink.value && isActive != null && select) {
        nextTick(() => {
          select(isActive);
        });
      }
    }, {
      immediate: true
    });
  }

  // ../posawesome/node_modules/vuetify/lib/directives/ripple/index.js
  var stopSymbol = Symbol("rippleStop");
  var DELAY_RIPPLE = 80;
  function transform(el, value) {
    el.style.transform = value;
    el.style.webkitTransform = value;
  }
  function isTouchEvent(e) {
    return e.constructor.name === "TouchEvent";
  }
  function isKeyboardEvent(e) {
    return e.constructor.name === "KeyboardEvent";
  }
  var calculate = function(e, el) {
    var _a3;
    let value = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let localX = 0;
    let localY = 0;
    if (!isKeyboardEvent(e)) {
      const offset = el.getBoundingClientRect();
      const target = isTouchEvent(e) ? e.touches[e.touches.length - 1] : e;
      localX = target.clientX - offset.left;
      localY = target.clientY - offset.top;
    }
    let radius = 0;
    let scale = 0.3;
    if ((_a3 = el._ripple) == null ? void 0 : _a3.circle) {
      scale = 0.15;
      radius = el.clientWidth / 2;
      radius = value.center ? radius : radius + Math.sqrt((localX - radius) ** 2 + (localY - radius) ** 2) / 4;
    } else {
      radius = Math.sqrt(el.clientWidth ** 2 + el.clientHeight ** 2) / 2;
    }
    const centerX = `${(el.clientWidth - radius * 2) / 2}px`;
    const centerY = `${(el.clientHeight - radius * 2) / 2}px`;
    const x = value.center ? centerX : `${localX - radius}px`;
    const y = value.center ? centerY : `${localY - radius}px`;
    return {
      radius,
      scale,
      x,
      y,
      centerX,
      centerY
    };
  };
  var ripples = {
    show(e, el) {
      var _a3;
      let value = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (!((_a3 = el == null ? void 0 : el._ripple) == null ? void 0 : _a3.enabled)) {
        return;
      }
      const container = document.createElement("span");
      const animation = document.createElement("span");
      container.appendChild(animation);
      container.className = "v-ripple__container";
      if (value.class) {
        container.className += ` ${value.class}`;
      }
      const {
        radius,
        scale,
        x,
        y,
        centerX,
        centerY
      } = calculate(e, el, value);
      const size = `${radius * 2}px`;
      animation.className = "v-ripple__animation";
      animation.style.width = size;
      animation.style.height = size;
      el.appendChild(container);
      const computed3 = window.getComputedStyle(el);
      if (computed3 && computed3.position === "static") {
        el.style.position = "relative";
        el.dataset.previousPosition = "static";
      }
      animation.classList.add("v-ripple__animation--enter");
      animation.classList.add("v-ripple__animation--visible");
      transform(animation, `translate(${x}, ${y}) scale3d(${scale},${scale},${scale})`);
      animation.dataset.activated = String(performance.now());
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          animation.classList.remove("v-ripple__animation--enter");
          animation.classList.add("v-ripple__animation--in");
          transform(animation, `translate(${centerX}, ${centerY}) scale3d(1,1,1)`);
        });
      });
    },
    hide(el) {
      var _a3;
      if (!((_a3 = el == null ? void 0 : el._ripple) == null ? void 0 : _a3.enabled))
        return;
      const ripples2 = el.getElementsByClassName("v-ripple__animation");
      if (ripples2.length === 0)
        return;
      const animation = ripples2[ripples2.length - 1];
      if (animation.dataset.isHiding)
        return;
      else
        animation.dataset.isHiding = "true";
      const diff = performance.now() - Number(animation.dataset.activated);
      const delay = Math.max(250 - diff, 0);
      setTimeout(() => {
        animation.classList.remove("v-ripple__animation--in");
        animation.classList.add("v-ripple__animation--out");
        setTimeout(() => {
          var _a4;
          const ripples3 = el.getElementsByClassName("v-ripple__animation");
          if (ripples3.length === 1 && el.dataset.previousPosition) {
            el.style.position = el.dataset.previousPosition;
            delete el.dataset.previousPosition;
          }
          if (((_a4 = animation.parentNode) == null ? void 0 : _a4.parentNode) === el)
            el.removeChild(animation.parentNode);
        }, 300);
      }, delay);
    }
  };
  function isRippleEnabled(value) {
    return typeof value === "undefined" || !!value;
  }
  function rippleShow(e) {
    const value = {};
    const element = e.currentTarget;
    if (!(element == null ? void 0 : element._ripple) || element._ripple.touched || e[stopSymbol])
      return;
    e[stopSymbol] = true;
    if (isTouchEvent(e)) {
      element._ripple.touched = true;
      element._ripple.isTouch = true;
    } else {
      if (element._ripple.isTouch)
        return;
    }
    value.center = element._ripple.centered || isKeyboardEvent(e);
    if (element._ripple.class) {
      value.class = element._ripple.class;
    }
    if (isTouchEvent(e)) {
      if (element._ripple.showTimerCommit)
        return;
      element._ripple.showTimerCommit = () => {
        ripples.show(e, element, value);
      };
      element._ripple.showTimer = window.setTimeout(() => {
        var _a3;
        if ((_a3 = element == null ? void 0 : element._ripple) == null ? void 0 : _a3.showTimerCommit) {
          element._ripple.showTimerCommit();
          element._ripple.showTimerCommit = null;
        }
      }, DELAY_RIPPLE);
    } else {
      ripples.show(e, element, value);
    }
  }
  function rippleStop(e) {
    e[stopSymbol] = true;
  }
  function rippleHide(e) {
    const element = e.currentTarget;
    if (!(element == null ? void 0 : element._ripple))
      return;
    window.clearTimeout(element._ripple.showTimer);
    if (e.type === "touchend" && element._ripple.showTimerCommit) {
      element._ripple.showTimerCommit();
      element._ripple.showTimerCommit = null;
      element._ripple.showTimer = window.setTimeout(() => {
        rippleHide(e);
      });
      return;
    }
    window.setTimeout(() => {
      if (element._ripple) {
        element._ripple.touched = false;
      }
    });
    ripples.hide(element);
  }
  function rippleCancelShow(e) {
    const element = e.currentTarget;
    if (!(element == null ? void 0 : element._ripple))
      return;
    if (element._ripple.showTimerCommit) {
      element._ripple.showTimerCommit = null;
    }
    window.clearTimeout(element._ripple.showTimer);
  }
  var keyboardRipple = false;
  function keyboardRippleShow(e) {
    if (!keyboardRipple && (e.keyCode === keyCodes.enter || e.keyCode === keyCodes.space)) {
      keyboardRipple = true;
      rippleShow(e);
    }
  }
  function keyboardRippleHide(e) {
    keyboardRipple = false;
    rippleHide(e);
  }
  function focusRippleHide(e) {
    if (keyboardRipple) {
      keyboardRipple = false;
      rippleHide(e);
    }
  }
  function updateRipple(el, binding, wasEnabled) {
    var _a3;
    const {
      value,
      modifiers
    } = binding;
    const enabled = isRippleEnabled(value);
    if (!enabled) {
      ripples.hide(el);
    }
    el._ripple = (_a3 = el._ripple) != null ? _a3 : {};
    el._ripple.enabled = enabled;
    el._ripple.centered = modifiers.center;
    el._ripple.circle = modifiers.circle;
    if (isObject2(value) && value.class) {
      el._ripple.class = value.class;
    }
    if (enabled && !wasEnabled) {
      if (modifiers.stop) {
        el.addEventListener("touchstart", rippleStop, {
          passive: true
        });
        el.addEventListener("mousedown", rippleStop);
        return;
      }
      el.addEventListener("touchstart", rippleShow, {
        passive: true
      });
      el.addEventListener("touchend", rippleHide, {
        passive: true
      });
      el.addEventListener("touchmove", rippleCancelShow, {
        passive: true
      });
      el.addEventListener("touchcancel", rippleHide);
      el.addEventListener("mousedown", rippleShow);
      el.addEventListener("mouseup", rippleHide);
      el.addEventListener("mouseleave", rippleHide);
      el.addEventListener("keydown", keyboardRippleShow);
      el.addEventListener("keyup", keyboardRippleHide);
      el.addEventListener("blur", focusRippleHide);
      el.addEventListener("dragstart", rippleHide, {
        passive: true
      });
    } else if (!enabled && wasEnabled) {
      removeListeners(el);
    }
  }
  function removeListeners(el) {
    el.removeEventListener("mousedown", rippleShow);
    el.removeEventListener("touchstart", rippleShow);
    el.removeEventListener("touchend", rippleHide);
    el.removeEventListener("touchmove", rippleCancelShow);
    el.removeEventListener("touchcancel", rippleHide);
    el.removeEventListener("mouseup", rippleHide);
    el.removeEventListener("mouseleave", rippleHide);
    el.removeEventListener("keydown", keyboardRippleShow);
    el.removeEventListener("keyup", keyboardRippleHide);
    el.removeEventListener("dragstart", rippleHide);
    el.removeEventListener("blur", focusRippleHide);
  }
  function mounted2(el, binding) {
    updateRipple(el, binding, false);
  }
  function unmounted2(el) {
    delete el._ripple;
    removeListeners(el);
  }
  function updated(el, binding) {
    if (binding.value === binding.oldValue) {
      return;
    }
    const wasEnabled = isRippleEnabled(binding.oldValue);
    updateRipple(el, binding, wasEnabled);
  }
  var Ripple = {
    mounted: mounted2,
    unmounted: unmounted2,
    updated
  };
  var ripple_default = Ripple;

  // ../posawesome/node_modules/vuetify/lib/components/VBtn/VBtn.js
  var makeVBtnProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    active: {
      type: Boolean,
      default: void 0
    },
    activeColor: String,
    baseColor: String,
    symbol: {
      type: null,
      default: VBtnToggleSymbol
    },
    flat: Boolean,
    icon: [Boolean, String, Function, Object],
    prependIcon: IconValue,
    appendIcon: IconValue,
    block: Boolean,
    readonly: Boolean,
    slim: Boolean,
    stacked: Boolean,
    ripple: {
      type: [Boolean, Object],
      default: true
    },
    text: {
      type: [String, Number, Boolean],
      default: void 0
    }
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeDimensionProps()), makeElevationProps()), makeGroupItemProps()), makeLoaderProps()), makeLocationProps()), makePositionProps()), makeRoundedProps()), makeRouterProps()), makeSizeProps()), makeTagProps({
    tag: "button"
  })), makeThemeProps()), makeVariantProps({
    variant: "elevated"
  })), "VBtn");
  var VBtn = genericComponent()({
    name: "VBtn",
    props: makeVBtnProps(),
    emits: {
      "group:selected": (val) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        borderClasses
      } = useBorder(props);
      const {
        densityClasses
      } = useDensity(props);
      const {
        dimensionStyles
      } = useDimension(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        loaderClasses
      } = useLoader(props);
      const {
        locationStyles
      } = useLocation(props);
      const {
        positionClasses
      } = usePosition(props);
      const {
        roundedClasses
      } = useRounded(props);
      const {
        sizeClasses,
        sizeStyles
      } = useSize(props);
      const group = useGroupItem(props, props.symbol, false);
      const link = useLink(props, attrs);
      const isActive = computed2(() => {
        var _a3;
        if (props.active !== void 0) {
          return props.active;
        }
        if (link.isLink.value) {
          return (_a3 = link.isActive) == null ? void 0 : _a3.value;
        }
        return group == null ? void 0 : group.isSelected.value;
      });
      const color = toRef(() => {
        var _a3;
        return isActive.value ? (_a3 = props.activeColor) != null ? _a3 : props.color : props.color;
      });
      const variantProps = computed2(() => {
        var _a3, _b, _c;
        const showColor = (group == null ? void 0 : group.isSelected.value) && (!link.isLink.value || ((_a3 = link.isActive) == null ? void 0 : _a3.value)) || !group || ((_b = link.isActive) == null ? void 0 : _b.value);
        return {
          color: showColor ? (_c = color.value) != null ? _c : props.baseColor : props.baseColor,
          variant: props.variant
        };
      });
      const {
        colorClasses,
        colorStyles,
        variantClasses
      } = useVariant(variantProps);
      const isDisabled = computed2(() => (group == null ? void 0 : group.disabled.value) || props.disabled);
      const isElevated = toRef(() => {
        return props.variant === "elevated" && !(props.disabled || props.flat || props.border);
      });
      const valueAttr = computed2(() => {
        if (props.value === void 0 || typeof props.value === "symbol")
          return void 0;
        return Object(props.value) === props.value ? JSON.stringify(props.value, null, 0) : props.value;
      });
      function onClick(e) {
        var _a3;
        if (isDisabled.value || link.isLink.value && (e.metaKey || e.ctrlKey || e.shiftKey || e.button !== 0 || attrs.target === "_blank"))
          return;
        (_a3 = link.navigate) == null ? void 0 : _a3.call(link, e);
        group == null ? void 0 : group.toggle();
      }
      useSelectLink(link, group == null ? void 0 : group.select);
      useRender(() => {
        const Tag = link.isLink.value ? "a" : props.tag;
        const hasPrepend = !!(props.prependIcon || slots.prepend);
        const hasAppend = !!(props.appendIcon || slots.append);
        const hasIcon = !!(props.icon && props.icon !== true);
        return withDirectives(createVNode(Tag, mergeProps({
          "type": Tag === "a" ? void 0 : "button",
          "class": ["v-btn", group == null ? void 0 : group.selectedClass.value, {
            "v-btn--active": isActive.value,
            "v-btn--block": props.block,
            "v-btn--disabled": isDisabled.value,
            "v-btn--elevated": isElevated.value,
            "v-btn--flat": props.flat,
            "v-btn--icon": !!props.icon,
            "v-btn--loading": props.loading,
            "v-btn--readonly": props.readonly,
            "v-btn--slim": props.slim,
            "v-btn--stacked": props.stacked
          }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, loaderClasses.value, positionClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, props.class],
          "style": [colorStyles.value, dimensionStyles.value, locationStyles.value, sizeStyles.value, props.style],
          "aria-busy": props.loading ? true : void 0,
          "disabled": isDisabled.value || void 0,
          "tabindex": props.loading || props.readonly ? -1 : void 0,
          "onClick": onClick,
          "value": valueAttr.value
        }, link.linkProps), {
          default: () => {
            var _a3, _b;
            return [genOverlays(true, "v-btn"), !props.icon && hasPrepend && createBaseVNode("span", {
              "key": "prepend",
              "class": "v-btn__prepend"
            }, [!slots.prepend ? createVNode(VIcon, {
              "key": "prepend-icon",
              "icon": props.prependIcon
            }, null) : createVNode(VDefaultsProvider, {
              "key": "prepend-defaults",
              "disabled": !props.prependIcon,
              "defaults": {
                VIcon: {
                  icon: props.prependIcon
                }
              }
            }, slots.prepend)]), createBaseVNode("span", {
              "class": "v-btn__content",
              "data-no-activator": ""
            }, [!slots.default && hasIcon ? createVNode(VIcon, {
              "key": "content-icon",
              "icon": props.icon
            }, null) : createVNode(VDefaultsProvider, {
              "key": "content-defaults",
              "disabled": !hasIcon,
              "defaults": {
                VIcon: {
                  icon: props.icon
                }
              }
            }, {
              default: () => {
                var _a4, _b2;
                return [(_b2 = (_a4 = slots.default) == null ? void 0 : _a4.call(slots)) != null ? _b2 : toDisplayString(props.text)];
              }
            })]), !props.icon && hasAppend && createBaseVNode("span", {
              "key": "append",
              "class": "v-btn__append"
            }, [!slots.append ? createVNode(VIcon, {
              "key": "append-icon",
              "icon": props.appendIcon
            }, null) : createVNode(VDefaultsProvider, {
              "key": "append-defaults",
              "disabled": !props.appendIcon,
              "defaults": {
                VIcon: {
                  icon: props.appendIcon
                }
              }
            }, slots.append)]), !!props.loading && createBaseVNode("span", {
              "key": "loader",
              "class": "v-btn__loader"
            }, [(_b = (_a3 = slots.loader) == null ? void 0 : _a3.call(slots)) != null ? _b : createVNode(VProgressCircular, {
              "color": typeof props.loading === "boolean" ? void 0 : props.loading,
              "indeterminate": true,
              "width": "2"
            }, null)])];
          }
        }), [[ripple_default, !isDisabled.value && props.ripple, "", {
          center: !!props.icon
        }]]);
      });
      return {
        group
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VAppBar/VAppBarNavIcon.js
  var makeVAppBarNavIconProps = propsFactory(__spreadValues({}, makeVBtnProps({
    icon: "$menu",
    variant: "text"
  })), "VAppBarNavIcon");
  var VAppBarNavIcon = genericComponent()({
    name: "VAppBarNavIcon",
    props: makeVAppBarNavIconProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => createVNode(VBtn, mergeProps(props, {
        "class": ["v-app-bar-nav-icon"]
      }), slots));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VAppBar/VAppBarTitle.js
  var VAppBarTitle = genericComponent()({
    name: "VAppBarTitle",
    props: makeVToolbarTitleProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => createVNode(VToolbarTitle, mergeProps(props, {
        "class": "v-app-bar-title"
      }), slots));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VAlert/VAlertTitle.js
  var VAlertTitle = createSimpleFunctional("v-alert-title");

  // ../posawesome/node_modules/vuetify/lib/components/VAlert/VAlert.js
  var allowedTypes = ["success", "info", "warning", "error"];
  var makeVAlertProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    border: {
      type: [Boolean, String],
      validator: (val) => {
        return typeof val === "boolean" || ["top", "end", "bottom", "start"].includes(val);
      }
    },
    borderColor: String,
    closable: Boolean,
    closeIcon: {
      type: IconValue,
      default: "$close"
    },
    closeLabel: {
      type: String,
      default: "$vuetify.close"
    },
    icon: {
      type: [Boolean, String, Function, Object],
      default: null
    },
    modelValue: {
      type: Boolean,
      default: true
    },
    prominent: Boolean,
    title: String,
    text: String,
    type: {
      type: String,
      validator: (val) => allowedTypes.includes(val)
    }
  }, makeComponentProps()), makeDensityProps()), makeDimensionProps()), makeElevationProps()), makeLocationProps()), makePositionProps()), makeRoundedProps()), makeTagProps()), makeThemeProps()), makeVariantProps({
    variant: "flat"
  })), "VAlert");
  var VAlert = genericComponent()({
    name: "VAlert",
    props: makeVAlertProps(),
    emits: {
      "click:close": (e) => true,
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        emit: emit2,
        slots
      } = _ref;
      const isActive = useProxiedModel(props, "modelValue");
      const icon = toRef(() => {
        var _a3;
        if (props.icon === false)
          return void 0;
        if (!props.type)
          return props.icon;
        return (_a3 = props.icon) != null ? _a3 : `$${props.type}`;
      });
      const {
        themeClasses
      } = provideTheme(props);
      const {
        colorClasses,
        colorStyles,
        variantClasses
      } = useVariant(() => {
        var _a3;
        return {
          color: (_a3 = props.color) != null ? _a3 : props.type,
          variant: props.variant
        };
      });
      const {
        densityClasses
      } = useDensity(props);
      const {
        dimensionStyles
      } = useDimension(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        locationStyles
      } = useLocation(props);
      const {
        positionClasses
      } = usePosition(props);
      const {
        roundedClasses
      } = useRounded(props);
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(() => props.borderColor);
      const {
        t
      } = useLocale();
      const closeProps = toRef(() => ({
        "aria-label": t(props.closeLabel),
        onClick(e) {
          isActive.value = false;
          emit2("click:close", e);
        }
      }));
      return () => {
        const hasPrepend = !!(slots.prepend || icon.value);
        const hasTitle = !!(slots.title || props.title);
        const hasClose = !!(slots.close || props.closable);
        return isActive.value && createVNode(props.tag, {
          "class": normalizeClass(["v-alert", props.border && {
            "v-alert--border": !!props.border,
            [`v-alert--border-${props.border === true ? "start" : props.border}`]: true
          }, {
            "v-alert--prominent": props.prominent
          }, themeClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, variantClasses.value, props.class]),
          "style": normalizeStyle([colorStyles.value, dimensionStyles.value, locationStyles.value, props.style]),
          "role": "alert"
        }, {
          default: () => {
            var _a3, _b, _c;
            return [genOverlays(false, "v-alert"), props.border && createBaseVNode("div", {
              "key": "border",
              "class": normalizeClass(["v-alert__border", textColorClasses.value]),
              "style": normalizeStyle(textColorStyles.value)
            }, null), hasPrepend && createBaseVNode("div", {
              "key": "prepend",
              "class": "v-alert__prepend"
            }, [!slots.prepend ? createVNode(VIcon, {
              "key": "prepend-icon",
              "density": props.density,
              "icon": icon.value,
              "size": props.prominent ? 44 : 28
            }, null) : createVNode(VDefaultsProvider, {
              "key": "prepend-defaults",
              "disabled": !icon.value,
              "defaults": {
                VIcon: {
                  density: props.density,
                  icon: icon.value,
                  size: props.prominent ? 44 : 28
                }
              }
            }, slots.prepend)]), createBaseVNode("div", {
              "class": "v-alert__content"
            }, [hasTitle && createVNode(VAlertTitle, {
              "key": "title"
            }, {
              default: () => {
                var _a4, _b2;
                return [(_b2 = (_a4 = slots.title) == null ? void 0 : _a4.call(slots)) != null ? _b2 : props.title];
              }
            }), (_b = (_a3 = slots.text) == null ? void 0 : _a3.call(slots)) != null ? _b : props.text, (_c = slots.default) == null ? void 0 : _c.call(slots)]), slots.append && createBaseVNode("div", {
              "key": "append",
              "class": "v-alert__append"
            }, [slots.append()]), hasClose && createBaseVNode("div", {
              "key": "close",
              "class": "v-alert__close"
            }, [!slots.close ? createVNode(VBtn, mergeProps({
              "key": "close-btn",
              "icon": props.closeIcon,
              "size": "x-small",
              "variant": "text"
            }, closeProps.value), null) : createVNode(VDefaultsProvider, {
              "key": "close-defaults",
              "defaults": {
                VBtn: {
                  icon: props.closeIcon,
                  size: "x-small",
                  variant: "text"
                }
              }
            }, {
              default: () => {
                var _a4;
                return [(_a4 = slots.close) == null ? void 0 : _a4.call(slots, {
                  props: closeProps.value
                })];
              }
            })])];
          }
        });
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VAvatar/VAvatar.js
  var makeVAvatarProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    start: Boolean,
    end: Boolean,
    icon: IconValue,
    image: String,
    text: String
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeRoundedProps()), makeSizeProps()), makeTagProps()), makeThemeProps()), makeVariantProps({
    variant: "flat"
  })), "VAvatar");
  var VAvatar = genericComponent()({
    name: "VAvatar",
    props: makeVAvatarProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        borderClasses
      } = useBorder(props);
      const {
        colorClasses,
        colorStyles,
        variantClasses
      } = useVariant(props);
      const {
        densityClasses
      } = useDensity(props);
      const {
        roundedClasses
      } = useRounded(props);
      const {
        sizeClasses,
        sizeStyles
      } = useSize(props);
      useRender(() => createVNode(props.tag, {
        "class": normalizeClass(["v-avatar", {
          "v-avatar--start": props.start,
          "v-avatar--end": props.end
        }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, props.class]),
        "style": normalizeStyle([colorStyles.value, sizeStyles.value, props.style])
      }, {
        default: () => [!slots.default ? props.image ? createVNode(VImg, {
          "key": "image",
          "src": props.image,
          "alt": "",
          "cover": true
        }, null) : props.icon ? createVNode(VIcon, {
          "key": "icon",
          "icon": props.icon
        }, null) : props.text : createVNode(VDefaultsProvider, {
          "key": "content-defaults",
          "defaults": {
            VImg: {
              cover: true,
              src: props.image
            },
            VIcon: {
              icon: props.icon
            }
          }
        }, {
          default: () => [slots.default()]
        }), genOverlays(false, "v-avatar")]
      }));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VLabel/VLabel.js
  var makeVLabelProps = propsFactory(__spreadValues(__spreadValues({
    text: String,
    onClick: EventProp()
  }, makeComponentProps()), makeThemeProps()), "VLabel");
  var VLabel = genericComponent()({
    name: "VLabel",
    props: makeVLabelProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => {
        var _a3;
        return createBaseVNode("label", {
          "class": normalizeClass(["v-label", {
            "v-label--clickable": !!props.onClick
          }, props.class]),
          "style": normalizeStyle(props.style),
          "onClick": props.onClick
        }, [props.text, (_a3 = slots.default) == null ? void 0 : _a3.call(slots)]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VSelectionControlGroup/VSelectionControlGroup.js
  var VSelectionControlGroupSymbol = Symbol.for("vuetify:selection-control-group");
  var makeSelectionControlGroupProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({
    color: String,
    disabled: {
      type: Boolean,
      default: null
    },
    defaultsTarget: String,
    error: Boolean,
    id: String,
    inline: Boolean,
    falseIcon: IconValue,
    trueIcon: IconValue,
    ripple: {
      type: [Boolean, Object],
      default: true
    },
    multiple: {
      type: Boolean,
      default: null
    },
    name: String,
    readonly: {
      type: Boolean,
      default: null
    },
    modelValue: null,
    type: String,
    valueComparator: {
      type: Function,
      default: deepEqual
    }
  }, makeComponentProps()), makeDensityProps()), makeThemeProps()), "SelectionControlGroup");
  var makeVSelectionControlGroupProps = propsFactory(__spreadValues({}, makeSelectionControlGroupProps({
    defaultsTarget: "VSelectionControl"
  })), "VSelectionControlGroup");
  var VSelectionControlGroup = genericComponent()({
    name: "VSelectionControlGroup",
    props: makeVSelectionControlGroupProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const modelValue = useProxiedModel(props, "modelValue");
      const uid2 = useId();
      const id = toRef(() => props.id || `v-selection-control-group-${uid2}`);
      const name = toRef(() => props.name || id.value);
      const updateHandlers = /* @__PURE__ */ new Set();
      provide(VSelectionControlGroupSymbol, {
        modelValue,
        forceUpdate: () => {
          updateHandlers.forEach((fn2) => fn2());
        },
        onForceUpdate: (cb) => {
          updateHandlers.add(cb);
          onScopeDispose(() => {
            updateHandlers.delete(cb);
          });
        }
      });
      provideDefaults({
        [props.defaultsTarget]: {
          color: toRef(() => props.color),
          disabled: toRef(() => props.disabled),
          density: toRef(() => props.density),
          error: toRef(() => props.error),
          inline: toRef(() => props.inline),
          modelValue,
          multiple: toRef(() => !!props.multiple || props.multiple == null && Array.isArray(modelValue.value)),
          name,
          falseIcon: toRef(() => props.falseIcon),
          trueIcon: toRef(() => props.trueIcon),
          readonly: toRef(() => props.readonly),
          ripple: toRef(() => props.ripple),
          type: toRef(() => props.type),
          valueComparator: toRef(() => props.valueComparator)
        }
      });
      useRender(() => {
        var _a3;
        return createBaseVNode("div", {
          "class": normalizeClass(["v-selection-control-group", {
            "v-selection-control-group--inline": props.inline
          }, props.class]),
          "style": normalizeStyle(props.style),
          "role": props.type === "radio" ? "radiogroup" : void 0
        }, [(_a3 = slots.default) == null ? void 0 : _a3.call(slots)]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VSelectionControl/VSelectionControl.js
  var makeVSelectionControlProps = propsFactory(__spreadValues(__spreadValues({
    label: String,
    baseColor: String,
    trueValue: null,
    falseValue: null,
    value: null
  }, makeComponentProps()), makeSelectionControlGroupProps()), "VSelectionControl");
  function useSelectionControl(props) {
    const group = inject(VSelectionControlGroupSymbol, void 0);
    const {
      densityClasses
    } = useDensity(props);
    const modelValue = useProxiedModel(props, "modelValue");
    const trueValue = computed2(() => props.trueValue !== void 0 ? props.trueValue : props.value !== void 0 ? props.value : true);
    const falseValue = computed2(() => props.falseValue !== void 0 ? props.falseValue : false);
    const isMultiple = computed2(() => !!props.multiple || props.multiple == null && Array.isArray(modelValue.value));
    const model = computed2({
      get() {
        const val = group ? group.modelValue.value : modelValue.value;
        return isMultiple.value ? wrapInArray(val).some((v) => props.valueComparator(v, trueValue.value)) : props.valueComparator(val, trueValue.value);
      },
      set(val) {
        if (props.readonly)
          return;
        const currentValue = val ? trueValue.value : falseValue.value;
        let newVal = currentValue;
        if (isMultiple.value) {
          newVal = val ? [...wrapInArray(modelValue.value), currentValue] : wrapInArray(modelValue.value).filter((item) => !props.valueComparator(item, trueValue.value));
        }
        if (group) {
          group.modelValue.value = newVal;
        } else {
          modelValue.value = newVal;
        }
      }
    });
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(() => {
      if (props.error || props.disabled)
        return void 0;
      return model.value ? props.color : props.baseColor;
    });
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(() => {
      return model.value && !props.error && !props.disabled ? props.color : props.baseColor;
    });
    const icon = computed2(() => model.value ? props.trueIcon : props.falseIcon);
    return {
      group,
      densityClasses,
      trueValue,
      falseValue,
      model,
      textColorClasses,
      textColorStyles,
      backgroundColorClasses,
      backgroundColorStyles,
      icon
    };
  }
  var VSelectionControl = genericComponent()({
    name: "VSelectionControl",
    directives: {
      vRipple: ripple_default
    },
    inheritAttrs: false,
    props: makeVSelectionControlProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const {
        group,
        densityClasses,
        icon,
        model,
        textColorClasses,
        textColorStyles,
        backgroundColorClasses,
        backgroundColorStyles,
        trueValue
      } = useSelectionControl(props);
      const uid2 = useId();
      const isFocused = shallowRef(false);
      const isFocusVisible = shallowRef(false);
      const input = ref();
      const id = toRef(() => props.id || `input-${uid2}`);
      const isInteractive = toRef(() => !props.disabled && !props.readonly);
      group == null ? void 0 : group.onForceUpdate(() => {
        if (input.value) {
          input.value.checked = model.value;
        }
      });
      function onFocus(e) {
        if (!isInteractive.value)
          return;
        isFocused.value = true;
        if (matchesSelector(e.target, ":focus-visible") !== false) {
          isFocusVisible.value = true;
        }
      }
      function onBlur() {
        isFocused.value = false;
        isFocusVisible.value = false;
      }
      function onClickLabel(e) {
        e.stopPropagation();
      }
      function onInput(e) {
        if (!isInteractive.value) {
          if (input.value) {
            input.value.checked = model.value;
          }
          return;
        }
        if (props.readonly && group) {
          nextTick(() => group.forceUpdate());
        }
        model.value = e.target.checked;
      }
      useRender(() => {
        var _a3, _b, _c;
        const label = slots.label ? slots.label({
          label: props.label,
          props: {
            for: id.value
          }
        }) : props.label;
        const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
        const inputNode = createBaseVNode("input", mergeProps({
          "ref": input,
          "checked": model.value,
          "disabled": !!props.disabled,
          "id": id.value,
          "onBlur": onBlur,
          "onFocus": onFocus,
          "onInput": onInput,
          "aria-disabled": !!props.disabled,
          "aria-label": props.label,
          "type": props.type,
          "value": trueValue.value,
          "name": props.name,
          "aria-checked": props.type === "checkbox" ? model.value : void 0
        }, inputAttrs), null);
        return createBaseVNode("div", mergeProps({
          "class": ["v-selection-control", {
            "v-selection-control--dirty": model.value,
            "v-selection-control--disabled": props.disabled,
            "v-selection-control--error": props.error,
            "v-selection-control--focused": isFocused.value,
            "v-selection-control--focus-visible": isFocusVisible.value,
            "v-selection-control--inline": props.inline
          }, densityClasses.value, props.class]
        }, rootAttrs, {
          "style": props.style
        }), [createBaseVNode("div", {
          "class": normalizeClass(["v-selection-control__wrapper", textColorClasses.value]),
          "style": normalizeStyle(textColorStyles.value)
        }, [(_a3 = slots.default) == null ? void 0 : _a3.call(slots, {
          backgroundColorClasses,
          backgroundColorStyles
        }), withDirectives(createBaseVNode("div", {
          "class": normalizeClass(["v-selection-control__input"])
        }, [(_c = (_b = slots.input) == null ? void 0 : _b.call(slots, {
          model,
          textColorClasses,
          textColorStyles,
          backgroundColorClasses,
          backgroundColorStyles,
          inputNode,
          icon: icon.value,
          props: {
            onFocus,
            onBlur,
            id: id.value
          }
        })) != null ? _c : createBaseVNode(Fragment, null, [icon.value && createVNode(VIcon, {
          "key": "icon",
          "icon": icon.value
        }, null), inputNode])]), [[ripple_default, props.ripple && [!props.disabled && !props.readonly, null, ["center", "circle"]]]])]), label && createVNode(VLabel, {
          "for": id.value,
          "onClick": onClickLabel
        }, {
          default: () => [label]
        })]);
      });
      return {
        isFocused,
        input
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VCheckbox/VCheckboxBtn.js
  var makeVCheckboxBtnProps = propsFactory(__spreadValues({
    indeterminate: Boolean,
    indeterminateIcon: {
      type: IconValue,
      default: "$checkboxIndeterminate"
    }
  }, makeVSelectionControlProps({
    falseIcon: "$checkboxOff",
    trueIcon: "$checkboxOn"
  })), "VCheckboxBtn");
  var VCheckboxBtn = genericComponent()({
    name: "VCheckboxBtn",
    props: makeVCheckboxBtnProps(),
    emits: {
      "update:modelValue": (value) => true,
      "update:indeterminate": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const indeterminate = useProxiedModel(props, "indeterminate");
      const model = useProxiedModel(props, "modelValue");
      function onChange(v) {
        if (indeterminate.value) {
          indeterminate.value = false;
        }
      }
      const falseIcon = toRef(() => {
        return indeterminate.value ? props.indeterminateIcon : props.falseIcon;
      });
      const trueIcon = toRef(() => {
        return indeterminate.value ? props.indeterminateIcon : props.trueIcon;
      });
      useRender(() => {
        const controlProps = omit(VSelectionControl.filterProps(props), ["modelValue"]);
        return createVNode(VSelectionControl, mergeProps(controlProps, {
          "modelValue": model.value,
          "onUpdate:modelValue": [($event) => model.value = $event, onChange],
          "class": ["v-checkbox-btn", props.class],
          "style": props.style,
          "type": "checkbox",
          "falseIcon": falseIcon.value,
          "trueIcon": trueIcon.value,
          "aria-checked": indeterminate.value ? "mixed" : void 0
        }), slots);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VInput/InputIcon.js
  function useInputIcon(props) {
    const {
      t
    } = useLocale();
    function InputIcon(_ref) {
      var _b;
      let _a3 = _ref, {
        name,
        color
      } = _a3, attrs = __objRest(_a3, [
        "name",
        "color"
      ]);
      const localeKey = {
        prepend: "prependAction",
        prependInner: "prependAction",
        append: "appendAction",
        appendInner: "appendAction",
        clear: "clear"
      }[name];
      const listener = props[`onClick:${name}`];
      function onKeydown(e) {
        if (e.key !== "Enter" && e.key !== " ")
          return;
        e.preventDefault();
        e.stopPropagation();
        callEvent(listener, new PointerEvent("click", e));
      }
      const label = listener && localeKey ? t(`$vuetify.input.${localeKey}`, (_b = props.label) != null ? _b : "") : void 0;
      return createVNode(VIcon, mergeProps({
        "icon": props[`${name}Icon`],
        "aria-label": label,
        "onClick": listener,
        "onKeydown": onKeydown,
        "color": color
      }, attrs), null);
    }
    return {
      InputIcon
    };
  }

  // ../posawesome/node_modules/vuetify/lib/components/VMessages/VMessages.js
  var makeVMessagesProps = propsFactory(__spreadValues(__spreadValues({
    active: Boolean,
    color: String,
    messages: {
      type: [Array, String],
      default: () => []
    }
  }, makeComponentProps()), makeTransitionProps2({
    transition: {
      component: VSlideYTransition,
      leaveAbsolute: true,
      group: true
    }
  })), "VMessages");
  var VMessages = genericComponent()({
    name: "VMessages",
    props: makeVMessagesProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const messages = computed2(() => wrapInArray(props.messages));
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(() => props.color);
      useRender(() => createVNode(MaybeTransition, {
        "transition": props.transition,
        "tag": "div",
        "class": normalizeClass(["v-messages", textColorClasses.value, props.class]),
        "style": normalizeStyle([textColorStyles.value, props.style])
      }, {
        default: () => [props.active && messages.value.map((message2, i) => createBaseVNode("div", {
          "class": "v-messages__message",
          "key": `${i}-${messages.value}`
        }, [slots.message ? slots.message({
          message: message2
        }) : message2]))]
      }));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/composables/focus.js
  var makeFocusProps = propsFactory({
    focused: Boolean,
    "onUpdate:focused": EventProp()
  }, "focus");
  function useFocus(props) {
    let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    const isFocused = useProxiedModel(props, "focused");
    const focusClasses = toRef(() => {
      return {
        [`${name}--focused`]: isFocused.value
      };
    });
    function focus() {
      isFocused.value = true;
    }
    function blur() {
      isFocused.value = false;
    }
    return {
      focusClasses,
      isFocused,
      focus,
      blur
    };
  }

  // ../posawesome/node_modules/vuetify/lib/composables/form.js
  var FormKey = Symbol.for("vuetify:form");
  var makeFormProps = propsFactory({
    disabled: Boolean,
    fastFail: Boolean,
    readonly: Boolean,
    modelValue: {
      type: Boolean,
      default: null
    },
    validateOn: {
      type: String,
      default: "input"
    }
  }, "form");
  function createForm(props) {
    const model = useProxiedModel(props, "modelValue");
    const isDisabled = toRef(() => props.disabled);
    const isReadonly2 = toRef(() => props.readonly);
    const isValidating = shallowRef(false);
    const items = ref([]);
    const errors = ref([]);
    async function validate() {
      const results = [];
      let valid = true;
      errors.value = [];
      isValidating.value = true;
      for (const item of items.value) {
        const itemErrorMessages = await item.validate();
        if (itemErrorMessages.length > 0) {
          valid = false;
          results.push({
            id: item.id,
            errorMessages: itemErrorMessages
          });
        }
        if (!valid && props.fastFail)
          break;
      }
      errors.value = results;
      isValidating.value = false;
      return {
        valid,
        errors: errors.value
      };
    }
    function reset() {
      items.value.forEach((item) => item.reset());
    }
    function resetValidation() {
      items.value.forEach((item) => item.resetValidation());
    }
    watch2(items, () => {
      let valid = 0;
      let invalid = 0;
      const results = [];
      for (const item of items.value) {
        if (item.isValid === false) {
          invalid++;
          results.push({
            id: item.id,
            errorMessages: item.errorMessages
          });
        } else if (item.isValid === true)
          valid++;
      }
      errors.value = results;
      model.value = invalid > 0 ? false : valid === items.value.length ? true : null;
    }, {
      deep: true,
      flush: "post"
    });
    provide(FormKey, {
      register: (_ref) => {
        let {
          id,
          vm: vm2,
          validate: validate2,
          reset: reset2,
          resetValidation: resetValidation2
        } = _ref;
        if (items.value.some((item) => item.id === id)) {
          consoleWarn(`Duplicate input name "${id}"`);
        }
        items.value.push({
          id,
          validate: validate2,
          reset: reset2,
          resetValidation: resetValidation2,
          vm: markRaw(vm2),
          isValid: null,
          errorMessages: []
        });
      },
      unregister: (id) => {
        items.value = items.value.filter((item) => {
          return item.id !== id;
        });
      },
      update: (id, isValid3, errorMessages) => {
        const found = items.value.find((item) => item.id === id);
        if (!found)
          return;
        found.isValid = isValid3;
        found.errorMessages = errorMessages;
      },
      isDisabled,
      isReadonly: isReadonly2,
      isValidating,
      isValid: model,
      items,
      validateOn: toRef(() => props.validateOn)
    });
    return {
      errors,
      isDisabled,
      isReadonly: isReadonly2,
      isValidating,
      isValid: model,
      items,
      validate,
      reset,
      resetValidation
    };
  }
  function useForm(props) {
    const form = inject(FormKey, null);
    return __spreadProps(__spreadValues({}, form), {
      isReadonly: computed2(() => {
        var _a3;
        return !!((_a3 = props == null ? void 0 : props.readonly) != null ? _a3 : form == null ? void 0 : form.isReadonly.value);
      }),
      isDisabled: computed2(() => {
        var _a3;
        return !!((_a3 = props == null ? void 0 : props.disabled) != null ? _a3 : form == null ? void 0 : form.isDisabled.value);
      })
    });
  }

  // ../posawesome/node_modules/vuetify/lib/labs/rules/rules.js
  var RulesSymbol = Symbol.for("vuetify:rules");
  function useRules(fn2) {
    const resolveRules = inject(RulesSymbol, null);
    if (!resolveRules)
      return toRef(fn2);
    return resolveRules(fn2);
  }

  // ../posawesome/node_modules/vuetify/lib/composables/validation.js
  var makeValidationProps = propsFactory(__spreadValues({
    disabled: {
      type: Boolean,
      default: null
    },
    error: Boolean,
    errorMessages: {
      type: [Array, String],
      default: () => []
    },
    maxErrors: {
      type: [Number, String],
      default: 1
    },
    name: String,
    label: String,
    readonly: {
      type: Boolean,
      default: null
    },
    rules: {
      type: Array,
      default: () => []
    },
    modelValue: null,
    validateOn: String,
    validationValue: null
  }, makeFocusProps()), "validation");
  function useValidation(props) {
    let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    let id = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : useId();
    const model = useProxiedModel(props, "modelValue");
    const validationModel = computed2(() => props.validationValue === void 0 ? model.value : props.validationValue);
    const form = useForm(props);
    const rules = useRules(() => props.rules);
    const internalErrorMessages = ref([]);
    const isPristine = shallowRef(true);
    const isDirty2 = computed2(() => !!(wrapInArray(model.value === "" ? null : model.value).length || wrapInArray(validationModel.value === "" ? null : validationModel.value).length));
    const errorMessages = computed2(() => {
      var _a3;
      return ((_a3 = props.errorMessages) == null ? void 0 : _a3.length) ? wrapInArray(props.errorMessages).concat(internalErrorMessages.value).slice(0, Math.max(0, Number(props.maxErrors))) : internalErrorMessages.value;
    });
    const validateOn = computed2(() => {
      var _a3, _b, _c;
      let value = ((_b = props.validateOn) != null ? _b : (_a3 = form.validateOn) == null ? void 0 : _a3.value) || "input";
      if (value === "lazy")
        value = "input lazy";
      if (value === "eager")
        value = "input eager";
      const set2 = new Set((_c = value == null ? void 0 : value.split(" ")) != null ? _c : []);
      return {
        input: set2.has("input"),
        blur: set2.has("blur") || set2.has("input") || set2.has("invalid-input"),
        invalidInput: set2.has("invalid-input"),
        lazy: set2.has("lazy"),
        eager: set2.has("eager")
      };
    });
    const isValid3 = computed2(() => {
      var _a3;
      if (props.error || ((_a3 = props.errorMessages) == null ? void 0 : _a3.length))
        return false;
      if (!props.rules.length)
        return true;
      if (isPristine.value) {
        return internalErrorMessages.value.length || validateOn.value.lazy ? null : true;
      } else {
        return !internalErrorMessages.value.length;
      }
    });
    const isValidating = shallowRef(false);
    const validationClasses = computed2(() => {
      return {
        [`${name}--error`]: isValid3.value === false,
        [`${name}--dirty`]: isDirty2.value,
        [`${name}--disabled`]: form.isDisabled.value,
        [`${name}--readonly`]: form.isReadonly.value
      };
    });
    const vm2 = getCurrentInstance2("validation");
    const uid2 = computed2(() => {
      var _a3;
      return (_a3 = props.name) != null ? _a3 : unref(id);
    });
    onBeforeMount(() => {
      var _a3;
      (_a3 = form.register) == null ? void 0 : _a3.call(form, {
        id: uid2.value,
        vm: vm2,
        validate,
        reset,
        resetValidation
      });
    });
    onBeforeUnmount(() => {
      var _a3;
      (_a3 = form.unregister) == null ? void 0 : _a3.call(form, uid2.value);
    });
    onMounted(async () => {
      var _a3;
      if (!validateOn.value.lazy) {
        await validate(!validateOn.value.eager);
      }
      (_a3 = form.update) == null ? void 0 : _a3.call(form, uid2.value, isValid3.value, errorMessages.value);
    });
    useToggleScope(() => validateOn.value.input || validateOn.value.invalidInput && isValid3.value === false, () => {
      watch2(validationModel, () => {
        if (validationModel.value != null) {
          validate();
        } else if (props.focused) {
          const unwatch = watch2(() => props.focused, (val) => {
            if (!val)
              validate();
            unwatch();
          });
        }
      });
    });
    useToggleScope(() => validateOn.value.blur, () => {
      watch2(() => props.focused, (val) => {
        if (!val)
          validate();
      });
    });
    watch2([isValid3, errorMessages], () => {
      var _a3;
      (_a3 = form.update) == null ? void 0 : _a3.call(form, uid2.value, isValid3.value, errorMessages.value);
    });
    async function reset() {
      model.value = null;
      await nextTick();
      await resetValidation();
    }
    async function resetValidation() {
      isPristine.value = true;
      if (!validateOn.value.lazy) {
        await validate(!validateOn.value.eager);
      } else {
        internalErrorMessages.value = [];
      }
    }
    async function validate() {
      var _a3;
      let silent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      const results = [];
      isValidating.value = true;
      for (const rule of rules.value) {
        if (results.length >= Number((_a3 = props.maxErrors) != null ? _a3 : 1)) {
          break;
        }
        const handler = typeof rule === "function" ? rule : () => rule;
        const result = await handler(validationModel.value);
        if (result === true)
          continue;
        if (result !== false && typeof result !== "string") {
          console.warn(`${result} is not a valid value. Rule functions must return boolean true or a string.`);
          continue;
        }
        results.push(result || "");
      }
      internalErrorMessages.value = results;
      isValidating.value = false;
      isPristine.value = silent;
      return internalErrorMessages.value;
    }
    return {
      errorMessages,
      isDirty: isDirty2,
      isDisabled: form.isDisabled,
      isReadonly: form.isReadonly,
      isPristine,
      isValid: isValid3,
      isValidating,
      reset,
      resetValidation,
      validate,
      validationClasses
    };
  }

  // ../posawesome/node_modules/vuetify/lib/components/VInput/VInput.js
  var makeVInputProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    id: String,
    appendIcon: IconValue,
    baseColor: String,
    centerAffix: {
      type: Boolean,
      default: true
    },
    color: String,
    glow: Boolean,
    iconColor: [Boolean, String],
    prependIcon: IconValue,
    hideDetails: [Boolean, String],
    hideSpinButtons: Boolean,
    hint: String,
    persistentHint: Boolean,
    messages: {
      type: [Array, String],
      default: () => []
    },
    direction: {
      type: String,
      default: "horizontal",
      validator: (v) => ["horizontal", "vertical"].includes(v)
    },
    "onClick:prepend": EventProp(),
    "onClick:append": EventProp()
  }, makeComponentProps()), makeDensityProps()), pick(makeDimensionProps(), ["maxWidth", "minWidth", "width"])), makeThemeProps()), makeValidationProps()), "VInput");
  var VInput = genericComponent()({
    name: "VInput",
    props: __spreadValues({}, makeVInputProps()),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        slots,
        emit: emit2
      } = _ref;
      const {
        densityClasses
      } = useDensity(props);
      const {
        dimensionStyles
      } = useDimension(props);
      const {
        themeClasses
      } = provideTheme(props);
      const {
        rtlClasses
      } = useRtl();
      const {
        InputIcon
      } = useInputIcon(props);
      const uid2 = useId();
      const id = computed2(() => props.id || `input-${uid2}`);
      const messagesId = computed2(() => `${id.value}-messages`);
      const {
        errorMessages,
        isDirty: isDirty2,
        isDisabled,
        isReadonly: isReadonly2,
        isPristine,
        isValid: isValid3,
        isValidating,
        reset,
        resetValidation,
        validate,
        validationClasses
      } = useValidation(props, "v-input", id);
      const slotProps = computed2(() => ({
        id,
        messagesId,
        isDirty: isDirty2,
        isDisabled,
        isReadonly: isReadonly2,
        isPristine,
        isValid: isValid3,
        isValidating,
        reset,
        resetValidation,
        validate
      }));
      const color = toRef(() => {
        return props.error || props.disabled ? void 0 : props.focused ? props.color : props.baseColor;
      });
      const iconColor = toRef(() => {
        if (!props.iconColor)
          return void 0;
        return props.iconColor === true ? color.value : props.iconColor;
      });
      const messages = computed2(() => {
        var _a3;
        if (((_a3 = props.errorMessages) == null ? void 0 : _a3.length) || !isPristine.value && errorMessages.value.length) {
          return errorMessages.value;
        } else if (props.hint && (props.persistentHint || props.focused)) {
          return props.hint;
        } else {
          return props.messages;
        }
      });
      useRender(() => {
        var _a3, _b, _c, _d;
        const hasPrepend = !!(slots.prepend || props.prependIcon);
        const hasAppend = !!(slots.append || props.appendIcon);
        const hasMessages = messages.value.length > 0;
        const hasDetails = !props.hideDetails || props.hideDetails === "auto" && (hasMessages || !!slots.details);
        return createBaseVNode("div", {
          "class": normalizeClass(["v-input", `v-input--${props.direction}`, {
            "v-input--center-affix": props.centerAffix,
            "v-input--focused": props.focused,
            "v-input--glow": props.glow,
            "v-input--hide-spin-buttons": props.hideSpinButtons
          }, densityClasses.value, themeClasses.value, rtlClasses.value, validationClasses.value, props.class]),
          "style": normalizeStyle([dimensionStyles.value, props.style])
        }, [hasPrepend && createBaseVNode("div", {
          "key": "prepend",
          "class": "v-input__prepend"
        }, [(_a3 = slots.prepend) == null ? void 0 : _a3.call(slots, slotProps.value), props.prependIcon && createVNode(InputIcon, {
          "key": "prepend-icon",
          "name": "prepend",
          "color": iconColor.value
        }, null)]), slots.default && createBaseVNode("div", {
          "class": "v-input__control"
        }, [(_b = slots.default) == null ? void 0 : _b.call(slots, slotProps.value)]), hasAppend && createBaseVNode("div", {
          "key": "append",
          "class": "v-input__append"
        }, [props.appendIcon && createVNode(InputIcon, {
          "key": "append-icon",
          "name": "append",
          "color": iconColor.value
        }, null), (_c = slots.append) == null ? void 0 : _c.call(slots, slotProps.value)]), hasDetails && createBaseVNode("div", {
          "id": messagesId.value,
          "class": "v-input__details",
          "role": "alert",
          "aria-live": "polite"
        }, [createVNode(VMessages, {
          "active": hasMessages,
          "messages": messages.value
        }, {
          message: slots.message
        }), (_d = slots.details) == null ? void 0 : _d.call(slots, slotProps.value)])]);
      });
      return {
        reset,
        resetValidation,
        validate,
        isValid: isValid3,
        errorMessages
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VCheckbox/VCheckbox.js
  var makeVCheckboxProps = propsFactory(__spreadValues(__spreadValues({}, makeVInputProps()), omit(makeVCheckboxBtnProps(), ["inline"])), "VCheckbox");
  var VCheckbox = genericComponent()({
    name: "VCheckbox",
    inheritAttrs: false,
    props: makeVCheckboxProps(),
    emits: {
      "update:modelValue": (value) => true,
      "update:focused": (focused) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const model = useProxiedModel(props, "modelValue");
      const {
        isFocused,
        focus,
        blur
      } = useFocus(props);
      const uid2 = useId();
      useRender(() => {
        const [rootAttrs, controlAttrs] = filterInputAttrs(attrs);
        const inputProps = VInput.filterProps(props);
        const checkboxProps = VCheckboxBtn.filterProps(props);
        return createVNode(VInput, mergeProps({
          "class": ["v-checkbox", props.class]
        }, rootAttrs, inputProps, {
          "modelValue": model.value,
          "onUpdate:modelValue": ($event) => model.value = $event,
          "id": props.id || `checkbox-${uid2}`,
          "focused": isFocused.value,
          "style": props.style
        }), __spreadProps(__spreadValues({}, slots), {
          default: (_ref2) => {
            let {
              id,
              messagesId,
              isDisabled,
              isReadonly: isReadonly2,
              isValid: isValid3
            } = _ref2;
            return createVNode(VCheckboxBtn, mergeProps(checkboxProps, {
              "id": id.value,
              "aria-describedby": messagesId.value,
              "disabled": isDisabled.value,
              "readonly": isReadonly2.value
            }, controlAttrs, {
              "error": isValid3.value === false,
              "modelValue": model.value,
              "onUpdate:modelValue": ($event) => model.value = $event,
              "onFocus": focus,
              "onBlur": blur
            }), slots);
          }
        }));
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VSlideGroup/helpers.js
  function calculateUpdatedTarget(_ref) {
    let {
      selectedElement,
      containerElement,
      isRtl,
      isHorizontal
    } = _ref;
    const containerSize = getOffsetSize(isHorizontal, containerElement);
    const scrollPosition = getScrollPosition(isHorizontal, isRtl, containerElement);
    const childrenSize = getOffsetSize(isHorizontal, selectedElement);
    const childrenStartPosition = getOffsetPosition(isHorizontal, selectedElement);
    const additionalOffset = childrenSize * 0.4;
    if (scrollPosition > childrenStartPosition) {
      return childrenStartPosition - additionalOffset;
    } else if (scrollPosition + containerSize < childrenStartPosition + childrenSize) {
      return childrenStartPosition - containerSize + childrenSize + additionalOffset;
    }
    return scrollPosition;
  }
  function calculateCenteredTarget(_ref2) {
    let {
      selectedElement,
      containerElement,
      isHorizontal
    } = _ref2;
    const containerOffsetSize = getOffsetSize(isHorizontal, containerElement);
    const childrenOffsetPosition = getOffsetPosition(isHorizontal, selectedElement);
    const childrenOffsetSize = getOffsetSize(isHorizontal, selectedElement);
    return childrenOffsetPosition - containerOffsetSize / 2 + childrenOffsetSize / 2;
  }
  function getScrollSize(isHorizontal, element) {
    const key = isHorizontal ? "scrollWidth" : "scrollHeight";
    return (element == null ? void 0 : element[key]) || 0;
  }
  function getClientSize(isHorizontal, element) {
    const key = isHorizontal ? "clientWidth" : "clientHeight";
    return (element == null ? void 0 : element[key]) || 0;
  }
  function getScrollPosition(isHorizontal, rtl, element) {
    if (!element) {
      return 0;
    }
    const {
      scrollLeft,
      offsetWidth,
      scrollWidth
    } = element;
    if (isHorizontal) {
      return rtl ? scrollWidth - offsetWidth + scrollLeft : scrollLeft;
    }
    return element.scrollTop;
  }
  function getOffsetSize(isHorizontal, element) {
    const key = isHorizontal ? "offsetWidth" : "offsetHeight";
    return (element == null ? void 0 : element[key]) || 0;
  }
  function getOffsetPosition(isHorizontal, element) {
    const key = isHorizontal ? "offsetLeft" : "offsetTop";
    return (element == null ? void 0 : element[key]) || 0;
  }

  // ../posawesome/node_modules/vuetify/lib/components/VSlideGroup/VSlideGroup.js
  var VSlideGroupSymbol = Symbol.for("vuetify:v-slide-group");
  var makeVSlideGroupProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    centerActive: Boolean,
    direction: {
      type: String,
      default: "horizontal"
    },
    symbol: {
      type: null,
      default: VSlideGroupSymbol
    },
    nextIcon: {
      type: IconValue,
      default: "$next"
    },
    prevIcon: {
      type: IconValue,
      default: "$prev"
    },
    showArrows: {
      type: [Boolean, String],
      validator: (v) => typeof v === "boolean" || ["always", "desktop", "mobile"].includes(v)
    }
  }, makeComponentProps()), makeDisplayProps({
    mobile: null
  })), makeTagProps()), makeGroupProps({
    selectedClass: "v-slide-group-item--active"
  })), "VSlideGroup");
  var VSlideGroup = genericComponent()({
    name: "VSlideGroup",
    props: makeVSlideGroupProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        isRtl
      } = useRtl();
      const {
        displayClasses,
        mobile
      } = useDisplay(props);
      const group = useGroup(props, props.symbol);
      const isOverflowing = shallowRef(false);
      const scrollOffset = shallowRef(0);
      const containerSize = shallowRef(0);
      const contentSize = shallowRef(0);
      const isHorizontal = computed2(() => props.direction === "horizontal");
      const {
        resizeRef: containerRef,
        contentRect: containerRect
      } = useResizeObserver();
      const {
        resizeRef: contentRef,
        contentRect
      } = useResizeObserver();
      const goTo = useGoTo();
      const goToOptions = computed2(() => {
        return {
          container: containerRef.el,
          duration: 200,
          easing: "easeOutQuart"
        };
      });
      const firstSelectedIndex = computed2(() => {
        if (!group.selected.value.length)
          return -1;
        return group.items.value.findIndex((item) => item.id === group.selected.value[0]);
      });
      const lastSelectedIndex = computed2(() => {
        if (!group.selected.value.length)
          return -1;
        return group.items.value.findIndex((item) => item.id === group.selected.value[group.selected.value.length - 1]);
      });
      if (IN_BROWSER) {
        let frame = -1;
        watch2(() => [group.selected.value, containerRect.value, contentRect.value, isHorizontal.value], () => {
          cancelAnimationFrame(frame);
          frame = requestAnimationFrame(() => {
            if (containerRect.value && contentRect.value) {
              const sizeProperty = isHorizontal.value ? "width" : "height";
              containerSize.value = containerRect.value[sizeProperty];
              contentSize.value = contentRect.value[sizeProperty];
              isOverflowing.value = containerSize.value + 1 < contentSize.value;
            }
            if (firstSelectedIndex.value >= 0 && contentRef.el) {
              const selectedElement = contentRef.el.children[lastSelectedIndex.value];
              scrollToChildren(selectedElement, props.centerActive);
            }
          });
        });
      }
      const isFocused = shallowRef(false);
      function scrollToChildren(children, center) {
        let target = 0;
        if (center) {
          target = calculateCenteredTarget({
            containerElement: containerRef.el,
            isHorizontal: isHorizontal.value,
            selectedElement: children
          });
        } else {
          target = calculateUpdatedTarget({
            containerElement: containerRef.el,
            isHorizontal: isHorizontal.value,
            isRtl: isRtl.value,
            selectedElement: children
          });
        }
        scrollToPosition(target);
      }
      function scrollToPosition(newPosition) {
        if (!IN_BROWSER || !containerRef.el)
          return;
        const offsetSize = getOffsetSize(isHorizontal.value, containerRef.el);
        const scrollPosition = getScrollPosition(isHorizontal.value, isRtl.value, containerRef.el);
        const scrollSize = getScrollSize(isHorizontal.value, containerRef.el);
        if (scrollSize <= offsetSize || Math.abs(newPosition - scrollPosition) < 16)
          return;
        if (isHorizontal.value && isRtl.value && containerRef.el) {
          const {
            scrollWidth,
            offsetWidth: containerWidth
          } = containerRef.el;
          newPosition = scrollWidth - containerWidth - newPosition;
        }
        if (isHorizontal.value) {
          goTo.horizontal(newPosition, goToOptions.value);
        } else {
          goTo(newPosition, goToOptions.value);
        }
      }
      function onScroll(e) {
        const {
          scrollTop,
          scrollLeft
        } = e.target;
        scrollOffset.value = isHorizontal.value ? scrollLeft : scrollTop;
      }
      function onFocusin(e) {
        isFocused.value = true;
        if (!isOverflowing.value || !contentRef.el)
          return;
        for (const el of e.composedPath()) {
          for (const item of contentRef.el.children) {
            if (item === el) {
              scrollToChildren(item);
              return;
            }
          }
        }
      }
      function onFocusout(e) {
        isFocused.value = false;
      }
      let ignoreFocusEvent = false;
      function onFocus(e) {
        var _a3;
        if (!ignoreFocusEvent && !isFocused.value && !(e.relatedTarget && ((_a3 = contentRef.el) == null ? void 0 : _a3.contains(e.relatedTarget))))
          focus();
        ignoreFocusEvent = false;
      }
      function onFocusAffixes() {
        ignoreFocusEvent = true;
      }
      function onKeydown(e) {
        if (!contentRef.el)
          return;
        function toFocus(location2) {
          e.preventDefault();
          focus(location2);
        }
        if (isHorizontal.value) {
          if (e.key === "ArrowRight") {
            toFocus(isRtl.value ? "prev" : "next");
          } else if (e.key === "ArrowLeft") {
            toFocus(isRtl.value ? "next" : "prev");
          }
        } else {
          if (e.key === "ArrowDown") {
            toFocus("next");
          } else if (e.key === "ArrowUp") {
            toFocus("prev");
          }
        }
        if (e.key === "Home") {
          toFocus("first");
        } else if (e.key === "End") {
          toFocus("last");
        }
      }
      function getSiblingElement(el, location2) {
        if (!el)
          return void 0;
        let sibling = el;
        do {
          sibling = sibling == null ? void 0 : sibling[location2 === "next" ? "nextElementSibling" : "previousElementSibling"];
        } while (sibling == null ? void 0 : sibling.hasAttribute("disabled"));
        return sibling;
      }
      function focus(location2) {
        if (!contentRef.el)
          return;
        let el;
        if (!location2) {
          const focusable = focusableChildren(contentRef.el);
          el = focusable[0];
        } else if (location2 === "next") {
          el = getSiblingElement(contentRef.el.querySelector(":focus"), location2);
          if (!el)
            return focus("first");
        } else if (location2 === "prev") {
          el = getSiblingElement(contentRef.el.querySelector(":focus"), location2);
          if (!el)
            return focus("last");
        } else if (location2 === "first") {
          el = contentRef.el.firstElementChild;
          if (el == null ? void 0 : el.hasAttribute("disabled"))
            el = getSiblingElement(el, "next");
        } else if (location2 === "last") {
          el = contentRef.el.lastElementChild;
          if (el == null ? void 0 : el.hasAttribute("disabled"))
            el = getSiblingElement(el, "prev");
        }
        if (el) {
          el.focus({
            preventScroll: true
          });
        }
      }
      function scrollTo2(location2) {
        const direction = isHorizontal.value && isRtl.value ? -1 : 1;
        const offsetStep = (location2 === "prev" ? -direction : direction) * containerSize.value;
        let newPosition = scrollOffset.value + offsetStep;
        if (isHorizontal.value && isRtl.value && containerRef.el) {
          const {
            scrollWidth,
            offsetWidth: containerWidth
          } = containerRef.el;
          newPosition += scrollWidth - containerWidth;
        }
        scrollToPosition(newPosition);
      }
      const slotProps = computed2(() => ({
        next: group.next,
        prev: group.prev,
        select: group.select,
        isSelected: group.isSelected
      }));
      const hasAffixes = computed2(() => {
        switch (props.showArrows) {
          case "always":
            return true;
          case "desktop":
            return !mobile.value;
          case true:
            return isOverflowing.value || Math.abs(scrollOffset.value) > 0;
          case "mobile":
            return mobile.value || isOverflowing.value || Math.abs(scrollOffset.value) > 0;
          default:
            return !mobile.value && (isOverflowing.value || Math.abs(scrollOffset.value) > 0);
        }
      });
      const hasPrev = computed2(() => {
        return Math.abs(scrollOffset.value) > 1;
      });
      const hasNext = computed2(() => {
        if (!containerRef.value)
          return false;
        const scrollSize = getScrollSize(isHorizontal.value, containerRef.el);
        const clientSize = getClientSize(isHorizontal.value, containerRef.el);
        const scrollSizeMax = scrollSize - clientSize;
        return scrollSizeMax - Math.abs(scrollOffset.value) > 1;
      });
      useRender(() => createVNode(props.tag, {
        "class": normalizeClass(["v-slide-group", {
          "v-slide-group--vertical": !isHorizontal.value,
          "v-slide-group--has-affixes": hasAffixes.value,
          "v-slide-group--is-overflowing": isOverflowing.value
        }, displayClasses.value, props.class]),
        "style": normalizeStyle(props.style),
        "tabindex": isFocused.value || group.selected.value.length ? -1 : 0,
        "onFocus": onFocus
      }, {
        default: () => {
          var _a3, _b, _c, _d, _e;
          return [hasAffixes.value && createBaseVNode("div", {
            "key": "prev",
            "class": normalizeClass(["v-slide-group__prev", {
              "v-slide-group__prev--disabled": !hasPrev.value
            }]),
            "onMousedown": onFocusAffixes,
            "onClick": () => hasPrev.value && scrollTo2("prev")
          }, [(_b = (_a3 = slots.prev) == null ? void 0 : _a3.call(slots, slotProps.value)) != null ? _b : createVNode(VFadeTransition, null, {
            default: () => [createVNode(VIcon, {
              "icon": isRtl.value ? props.nextIcon : props.prevIcon
            }, null)]
          })]), createBaseVNode("div", {
            "key": "container",
            "ref": containerRef,
            "class": "v-slide-group__container",
            "onScroll": onScroll
          }, [createBaseVNode("div", {
            "ref": contentRef,
            "class": "v-slide-group__content",
            "onFocusin": onFocusin,
            "onFocusout": onFocusout,
            "onKeydown": onKeydown
          }, [(_c = slots.default) == null ? void 0 : _c.call(slots, slotProps.value)])]), hasAffixes.value && createBaseVNode("div", {
            "key": "next",
            "class": normalizeClass(["v-slide-group__next", {
              "v-slide-group__next--disabled": !hasNext.value
            }]),
            "onMousedown": onFocusAffixes,
            "onClick": () => hasNext.value && scrollTo2("next")
          }, [(_e = (_d = slots.next) == null ? void 0 : _d.call(slots, slotProps.value)) != null ? _e : createVNode(VFadeTransition, null, {
            default: () => [createVNode(VIcon, {
              "icon": isRtl.value ? props.prevIcon : props.nextIcon
            }, null)]
          })])];
        }
      }));
      return {
        selected: group.selected,
        scrollTo: scrollTo2,
        scrollOffset,
        focus,
        hasPrev,
        hasNext
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VChipGroup/VChipGroup.js
  var VChipGroupSymbol = Symbol.for("vuetify:v-chip-group");
  var makeVChipGroupProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    baseColor: String,
    column: Boolean,
    filter: Boolean,
    valueComparator: {
      type: Function,
      default: deepEqual
    }
  }, makeVSlideGroupProps()), makeComponentProps()), makeGroupProps({
    selectedClass: "v-chip--selected"
  })), makeTagProps()), makeThemeProps()), makeVariantProps({
    variant: "tonal"
  })), "VChipGroup");
  var VChipGroup = genericComponent()({
    name: "VChipGroup",
    props: makeVChipGroupProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        isSelected,
        select,
        next,
        prev,
        selected
      } = useGroup(props, VChipGroupSymbol);
      provideDefaults({
        VChip: {
          baseColor: toRef(() => props.baseColor),
          color: toRef(() => props.color),
          disabled: toRef(() => props.disabled),
          filter: toRef(() => props.filter),
          variant: toRef(() => props.variant)
        }
      });
      useRender(() => {
        const slideGroupProps = VSlideGroup.filterProps(props);
        return createVNode(VSlideGroup, mergeProps(slideGroupProps, {
          "class": ["v-chip-group", {
            "v-chip-group--column": props.column
          }, themeClasses.value, props.class],
          "style": props.style
        }), {
          default: () => {
            var _a3;
            return [(_a3 = slots.default) == null ? void 0 : _a3.call(slots, {
              isSelected,
              select,
              next,
              prev,
              selected: selected.value
            })];
          }
        });
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VChip/VChip.js
  var makeVChipProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    activeClass: String,
    appendAvatar: String,
    appendIcon: IconValue,
    baseColor: String,
    closable: Boolean,
    closeIcon: {
      type: IconValue,
      default: "$delete"
    },
    closeLabel: {
      type: String,
      default: "$vuetify.close"
    },
    draggable: Boolean,
    filter: Boolean,
    filterIcon: {
      type: IconValue,
      default: "$complete"
    },
    label: Boolean,
    link: {
      type: Boolean,
      default: void 0
    },
    pill: Boolean,
    prependAvatar: String,
    prependIcon: IconValue,
    ripple: {
      type: [Boolean, Object],
      default: true
    },
    text: {
      type: [String, Number, Boolean],
      default: void 0
    },
    modelValue: {
      type: Boolean,
      default: true
    },
    onClick: EventProp(),
    onClickOnce: EventProp()
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeElevationProps()), makeGroupItemProps()), makeRoundedProps()), makeRouterProps()), makeSizeProps()), makeTagProps({
    tag: "span"
  })), makeThemeProps()), makeVariantProps({
    variant: "tonal"
  })), "VChip");
  var VChip = genericComponent()({
    name: "VChip",
    directives: {
      vRipple: ripple_default
    },
    props: makeVChipProps(),
    emits: {
      "click:close": (e) => true,
      "update:modelValue": (value) => true,
      "group:selected": (val) => true,
      click: (e) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        emit: emit2,
        slots
      } = _ref;
      const {
        t
      } = useLocale();
      const {
        borderClasses
      } = useBorder(props);
      const {
        densityClasses
      } = useDensity(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        roundedClasses
      } = useRounded(props);
      const {
        sizeClasses
      } = useSize(props);
      const {
        themeClasses
      } = provideTheme(props);
      const isActive = useProxiedModel(props, "modelValue");
      const group = useGroupItem(props, VChipGroupSymbol, false);
      const link = useLink(props, attrs);
      const isLink = toRef(() => props.link !== false && link.isLink.value);
      const isClickable = computed2(() => !props.disabled && props.link !== false && (!!group || props.link || link.isClickable.value));
      const closeProps = toRef(() => ({
        "aria-label": t(props.closeLabel),
        disabled: props.disabled,
        onClick(e) {
          e.preventDefault();
          e.stopPropagation();
          isActive.value = false;
          emit2("click:close", e);
        }
      }));
      const {
        colorClasses,
        colorStyles,
        variantClasses
      } = useVariant(() => {
        var _a3;
        const showColor = !group || group.isSelected.value;
        return {
          color: showColor ? (_a3 = props.color) != null ? _a3 : props.baseColor : props.baseColor,
          variant: props.variant
        };
      });
      function onClick(e) {
        var _a3;
        emit2("click", e);
        if (!isClickable.value)
          return;
        (_a3 = link.navigate) == null ? void 0 : _a3.call(link, e);
        group == null ? void 0 : group.toggle();
      }
      function onKeyDown(e) {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          onClick(e);
        }
      }
      return () => {
        var _a3;
        const Tag = link.isLink.value ? "a" : props.tag;
        const hasAppendMedia = !!(props.appendIcon || props.appendAvatar);
        const hasAppend = !!(hasAppendMedia || slots.append);
        const hasClose = !!(slots.close || props.closable);
        const hasFilter = !!(slots.filter || props.filter) && group;
        const hasPrependMedia = !!(props.prependIcon || props.prependAvatar);
        const hasPrepend = !!(hasPrependMedia || slots.prepend);
        return isActive.value && withDirectives(createVNode(Tag, mergeProps({
          "class": ["v-chip", {
            "v-chip--disabled": props.disabled,
            "v-chip--label": props.label,
            "v-chip--link": isClickable.value,
            "v-chip--filter": hasFilter,
            "v-chip--pill": props.pill,
            [`${props.activeClass}`]: props.activeClass && ((_a3 = link.isActive) == null ? void 0 : _a3.value)
          }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, group == null ? void 0 : group.selectedClass.value, props.class],
          "style": [colorStyles.value, props.style],
          "disabled": props.disabled || void 0,
          "draggable": props.draggable,
          "tabindex": isClickable.value ? 0 : void 0,
          "onClick": onClick,
          "onKeydown": isClickable.value && !isLink.value && onKeyDown
        }, link.linkProps), {
          default: () => {
            var _a4, _b;
            return [genOverlays(isClickable.value, "v-chip"), hasFilter && createVNode(VExpandXTransition, {
              "key": "filter"
            }, {
              default: () => [withDirectives(createBaseVNode("div", {
                "class": "v-chip__filter"
              }, [!slots.filter ? createVNode(VIcon, {
                "key": "filter-icon",
                "icon": props.filterIcon
              }, null) : createVNode(VDefaultsProvider, {
                "key": "filter-defaults",
                "disabled": !props.filterIcon,
                "defaults": {
                  VIcon: {
                    icon: props.filterIcon
                  }
                }
              }, slots.filter)]), [[vShow, group.isSelected.value]])]
            }), hasPrepend && createBaseVNode("div", {
              "key": "prepend",
              "class": "v-chip__prepend"
            }, [!slots.prepend ? createBaseVNode(Fragment, null, [props.prependIcon && createVNode(VIcon, {
              "key": "prepend-icon",
              "icon": props.prependIcon,
              "start": true
            }, null), props.prependAvatar && createVNode(VAvatar, {
              "key": "prepend-avatar",
              "image": props.prependAvatar,
              "start": true
            }, null)]) : createVNode(VDefaultsProvider, {
              "key": "prepend-defaults",
              "disabled": !hasPrependMedia,
              "defaults": {
                VAvatar: {
                  image: props.prependAvatar,
                  start: true
                },
                VIcon: {
                  icon: props.prependIcon,
                  start: true
                }
              }
            }, slots.prepend)]), createBaseVNode("div", {
              "class": "v-chip__content",
              "data-no-activator": ""
            }, [(_b = (_a4 = slots.default) == null ? void 0 : _a4.call(slots, {
              isSelected: group == null ? void 0 : group.isSelected.value,
              selectedClass: group == null ? void 0 : group.selectedClass.value,
              select: group == null ? void 0 : group.select,
              toggle: group == null ? void 0 : group.toggle,
              value: group == null ? void 0 : group.value.value,
              disabled: props.disabled
            })) != null ? _b : toDisplayString(props.text)]), hasAppend && createBaseVNode("div", {
              "key": "append",
              "class": "v-chip__append"
            }, [!slots.append ? createBaseVNode(Fragment, null, [props.appendIcon && createVNode(VIcon, {
              "key": "append-icon",
              "end": true,
              "icon": props.appendIcon
            }, null), props.appendAvatar && createVNode(VAvatar, {
              "key": "append-avatar",
              "end": true,
              "image": props.appendAvatar
            }, null)]) : createVNode(VDefaultsProvider, {
              "key": "append-defaults",
              "disabled": !hasAppendMedia,
              "defaults": {
                VAvatar: {
                  end: true,
                  image: props.appendAvatar
                },
                VIcon: {
                  end: true,
                  icon: props.appendIcon
                }
              }
            }, slots.append)]), hasClose && createBaseVNode("button", mergeProps({
              "key": "close",
              "class": "v-chip__close",
              "type": "button",
              "data-testid": "close-chip"
            }, closeProps.value), [!slots.close ? createVNode(VIcon, {
              "key": "close-icon",
              "icon": props.closeIcon,
              "size": "x-small"
            }, null) : createVNode(VDefaultsProvider, {
              "key": "close-defaults",
              "defaults": {
                VIcon: {
                  icon: props.closeIcon,
                  size: "x-small"
                }
              }
            }, slots.close)])];
          }
        }), [[ripple_default, isClickable.value && props.ripple, null]]);
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VList/list.js
  var DepthKey = Symbol.for("vuetify:depth");
  var ListKey = Symbol.for("vuetify:list");
  function createList() {
    const parent = inject(ListKey, {
      hasPrepend: shallowRef(false),
      updateHasPrepend: () => null
    });
    const data = {
      hasPrepend: shallowRef(false),
      updateHasPrepend: (value) => {
        if (value)
          data.hasPrepend.value = value;
      }
    };
    provide(ListKey, data);
    return parent;
  }
  function useList() {
    return inject(ListKey, null);
  }

  // ../posawesome/node_modules/vuetify/lib/composables/nested/activeStrategies.js
  var independentActiveStrategy = (mandatory) => {
    const strategy = {
      activate: (_ref) => {
        let {
          id,
          value,
          activated
        } = _ref;
        id = toRaw(id);
        if (mandatory && !value && activated.size === 1 && activated.has(id))
          return activated;
        if (value) {
          activated.add(id);
        } else {
          activated.delete(id);
        }
        return activated;
      },
      in: (v, children, parents) => {
        let set2 = /* @__PURE__ */ new Set();
        if (v != null) {
          for (const id of wrapInArray(v)) {
            set2 = strategy.activate({
              id,
              value: true,
              activated: new Set(set2),
              children,
              parents
            });
          }
        }
        return set2;
      },
      out: (v) => {
        return Array.from(v);
      }
    };
    return strategy;
  };
  var independentSingleActiveStrategy = (mandatory) => {
    const parentStrategy = independentActiveStrategy(mandatory);
    const strategy = {
      activate: (_ref2) => {
        let _a3 = _ref2, {
          activated,
          id
        } = _a3, rest = __objRest(_a3, [
          "activated",
          "id"
        ]);
        id = toRaw(id);
        const singleSelected = activated.has(id) ? /* @__PURE__ */ new Set([id]) : /* @__PURE__ */ new Set();
        return parentStrategy.activate(__spreadProps(__spreadValues({}, rest), {
          id,
          activated: singleSelected
        }));
      },
      in: (v, children, parents) => {
        let set2 = /* @__PURE__ */ new Set();
        if (v != null) {
          const arr = wrapInArray(v);
          if (arr.length) {
            set2 = parentStrategy.in(arr.slice(0, 1), children, parents);
          }
        }
        return set2;
      },
      out: (v, children, parents) => {
        return parentStrategy.out(v, children, parents);
      }
    };
    return strategy;
  };
  var leafActiveStrategy = (mandatory) => {
    const parentStrategy = independentActiveStrategy(mandatory);
    const strategy = {
      activate: (_ref3) => {
        let _a3 = _ref3, {
          id,
          activated,
          children
        } = _a3, rest = __objRest(_a3, [
          "id",
          "activated",
          "children"
        ]);
        id = toRaw(id);
        if (children.has(id))
          return activated;
        return parentStrategy.activate(__spreadValues({
          id,
          activated,
          children
        }, rest));
      },
      in: parentStrategy.in,
      out: parentStrategy.out
    };
    return strategy;
  };
  var leafSingleActiveStrategy = (mandatory) => {
    const parentStrategy = independentSingleActiveStrategy(mandatory);
    const strategy = {
      activate: (_ref4) => {
        let _a3 = _ref4, {
          id,
          activated,
          children
        } = _a3, rest = __objRest(_a3, [
          "id",
          "activated",
          "children"
        ]);
        id = toRaw(id);
        if (children.has(id))
          return activated;
        return parentStrategy.activate(__spreadValues({
          id,
          activated,
          children
        }, rest));
      },
      in: parentStrategy.in,
      out: parentStrategy.out
    };
    return strategy;
  };

  // ../posawesome/node_modules/vuetify/lib/composables/nested/openStrategies.js
  var singleOpenStrategy = {
    open: (_ref) => {
      let {
        id,
        value,
        opened,
        parents
      } = _ref;
      if (value) {
        const newOpened = /* @__PURE__ */ new Set();
        newOpened.add(id);
        let parent = parents.get(id);
        while (parent != null) {
          newOpened.add(parent);
          parent = parents.get(parent);
        }
        return newOpened;
      } else {
        opened.delete(id);
        return opened;
      }
    },
    select: () => null
  };
  var multipleOpenStrategy = {
    open: (_ref2) => {
      let {
        id,
        value,
        opened,
        parents
      } = _ref2;
      if (value) {
        let parent = parents.get(id);
        opened.add(id);
        while (parent != null && parent !== id) {
          opened.add(parent);
          parent = parents.get(parent);
        }
        return opened;
      } else {
        opened.delete(id);
      }
      return opened;
    },
    select: () => null
  };
  var listOpenStrategy = {
    open: multipleOpenStrategy.open,
    select: (_ref3) => {
      let {
        id,
        value,
        opened,
        parents
      } = _ref3;
      if (!value)
        return opened;
      const path = [];
      let parent = parents.get(id);
      while (parent != null) {
        path.push(parent);
        parent = parents.get(parent);
      }
      return new Set(path);
    }
  };

  // ../posawesome/node_modules/vuetify/lib/composables/nested/selectStrategies.js
  var independentSelectStrategy = (mandatory) => {
    const strategy = {
      select: (_ref) => {
        let {
          id,
          value,
          selected
        } = _ref;
        id = toRaw(id);
        if (mandatory && !value) {
          const on = Array.from(selected.entries()).reduce((arr, _ref2) => {
            let [key, value2] = _ref2;
            if (value2 === "on")
              arr.push(key);
            return arr;
          }, []);
          if (on.length === 1 && on[0] === id)
            return selected;
        }
        selected.set(id, value ? "on" : "off");
        return selected;
      },
      in: (v, children, parents) => {
        const map2 = /* @__PURE__ */ new Map();
        for (const id of v || []) {
          strategy.select({
            id,
            value: true,
            selected: map2,
            children,
            parents
          });
        }
        return map2;
      },
      out: (v) => {
        const arr = [];
        for (const [key, value] of v.entries()) {
          if (value === "on")
            arr.push(key);
        }
        return arr;
      }
    };
    return strategy;
  };
  var independentSingleSelectStrategy = (mandatory) => {
    const parentStrategy = independentSelectStrategy(mandatory);
    const strategy = {
      select: (_ref3) => {
        let _a3 = _ref3, {
          selected,
          id
        } = _a3, rest = __objRest(_a3, [
          "selected",
          "id"
        ]);
        id = toRaw(id);
        const singleSelected = selected.has(id) ? /* @__PURE__ */ new Map([[id, selected.get(id)]]) : /* @__PURE__ */ new Map();
        return parentStrategy.select(__spreadProps(__spreadValues({}, rest), {
          id,
          selected: singleSelected
        }));
      },
      in: (v, children, parents) => {
        if (v == null ? void 0 : v.length) {
          return parentStrategy.in(v.slice(0, 1), children, parents);
        }
        return /* @__PURE__ */ new Map();
      },
      out: (v, children, parents) => {
        return parentStrategy.out(v, children, parents);
      }
    };
    return strategy;
  };
  var leafSelectStrategy = (mandatory) => {
    const parentStrategy = independentSelectStrategy(mandatory);
    const strategy = {
      select: (_ref4) => {
        let _a3 = _ref4, {
          id,
          selected,
          children
        } = _a3, rest = __objRest(_a3, [
          "id",
          "selected",
          "children"
        ]);
        id = toRaw(id);
        if (children.has(id))
          return selected;
        return parentStrategy.select(__spreadValues({
          id,
          selected,
          children
        }, rest));
      },
      in: parentStrategy.in,
      out: parentStrategy.out
    };
    return strategy;
  };
  var leafSingleSelectStrategy = (mandatory) => {
    const parentStrategy = independentSingleSelectStrategy(mandatory);
    const strategy = {
      select: (_ref5) => {
        let _a3 = _ref5, {
          id,
          selected,
          children
        } = _a3, rest = __objRest(_a3, [
          "id",
          "selected",
          "children"
        ]);
        id = toRaw(id);
        if (children.has(id))
          return selected;
        return parentStrategy.select(__spreadValues({
          id,
          selected,
          children
        }, rest));
      },
      in: parentStrategy.in,
      out: parentStrategy.out
    };
    return strategy;
  };
  var classicSelectStrategy = (mandatory) => {
    const strategy = {
      select: (_ref6) => {
        let {
          id,
          value,
          selected,
          children,
          parents
        } = _ref6;
        id = toRaw(id);
        const original = new Map(selected);
        const items = [id];
        while (items.length) {
          const item = items.shift();
          selected.set(toRaw(item), value ? "on" : "off");
          if (children.has(item)) {
            items.push(...children.get(item));
          }
        }
        let parent = toRaw(parents.get(id));
        while (parent) {
          const childrenIds = children.get(parent);
          const everySelected = childrenIds.every((cid) => selected.get(toRaw(cid)) === "on");
          const noneSelected = childrenIds.every((cid) => !selected.has(toRaw(cid)) || selected.get(toRaw(cid)) === "off");
          selected.set(parent, everySelected ? "on" : noneSelected ? "off" : "indeterminate");
          parent = toRaw(parents.get(parent));
        }
        if (mandatory && !value) {
          const on = Array.from(selected.entries()).reduce((arr, _ref7) => {
            let [key, value2] = _ref7;
            if (value2 === "on")
              arr.push(key);
            return arr;
          }, []);
          if (on.length === 0)
            return original;
        }
        return selected;
      },
      in: (v, children, parents) => {
        let map2 = /* @__PURE__ */ new Map();
        for (const id of v || []) {
          map2 = strategy.select({
            id,
            value: true,
            selected: map2,
            children,
            parents
          });
        }
        return map2;
      },
      out: (v, children) => {
        const arr = [];
        for (const [key, value] of v.entries()) {
          if (value === "on" && !children.has(key))
            arr.push(key);
        }
        return arr;
      }
    };
    return strategy;
  };
  var trunkSelectStrategy = (mandatory) => {
    const parentStrategy = classicSelectStrategy(mandatory);
    const strategy = {
      select: parentStrategy.select,
      in: parentStrategy.in,
      out: (v, children, parents) => {
        const arr = [];
        for (const [key, value] of v.entries()) {
          if (value === "on") {
            if (parents.has(key)) {
              const parent = parents.get(key);
              if (v.get(parent) === "on")
                continue;
            }
            arr.push(key);
          }
        }
        return arr;
      }
    };
    return strategy;
  };

  // ../posawesome/node_modules/vuetify/lib/composables/nested/nested.js
  var VNestedSymbol = Symbol.for("vuetify:nested");
  var emptyNested = {
    id: shallowRef(),
    root: {
      register: () => null,
      unregister: () => null,
      parents: ref(/* @__PURE__ */ new Map()),
      children: ref(/* @__PURE__ */ new Map()),
      open: () => null,
      openOnSelect: () => null,
      activate: () => null,
      select: () => null,
      activatable: ref(false),
      selectable: ref(false),
      opened: ref(/* @__PURE__ */ new Set()),
      activated: ref(/* @__PURE__ */ new Set()),
      selected: ref(/* @__PURE__ */ new Map()),
      selectedValues: ref([]),
      getPath: () => []
    }
  };
  var makeNestedProps = propsFactory({
    activatable: Boolean,
    selectable: Boolean,
    activeStrategy: [String, Function, Object],
    selectStrategy: [String, Function, Object],
    openStrategy: [String, Object],
    opened: null,
    activated: null,
    selected: null,
    mandatory: Boolean
  }, "nested");
  var useNested = (props) => {
    let isUnmounted = false;
    const children = ref(/* @__PURE__ */ new Map());
    const parents = ref(/* @__PURE__ */ new Map());
    const opened = useProxiedModel(props, "opened", props.opened, (v) => new Set(v), (v) => [...v.values()]);
    const activeStrategy = computed2(() => {
      if (typeof props.activeStrategy === "object")
        return props.activeStrategy;
      if (typeof props.activeStrategy === "function")
        return props.activeStrategy(props.mandatory);
      switch (props.activeStrategy) {
        case "leaf":
          return leafActiveStrategy(props.mandatory);
        case "single-leaf":
          return leafSingleActiveStrategy(props.mandatory);
        case "independent":
          return independentActiveStrategy(props.mandatory);
        case "single-independent":
        default:
          return independentSingleActiveStrategy(props.mandatory);
      }
    });
    const selectStrategy = computed2(() => {
      if (typeof props.selectStrategy === "object")
        return props.selectStrategy;
      if (typeof props.selectStrategy === "function")
        return props.selectStrategy(props.mandatory);
      switch (props.selectStrategy) {
        case "single-leaf":
          return leafSingleSelectStrategy(props.mandatory);
        case "leaf":
          return leafSelectStrategy(props.mandatory);
        case "independent":
          return independentSelectStrategy(props.mandatory);
        case "single-independent":
          return independentSingleSelectStrategy(props.mandatory);
        case "trunk":
          return trunkSelectStrategy(props.mandatory);
        case "classic":
        default:
          return classicSelectStrategy(props.mandatory);
      }
    });
    const openStrategy = computed2(() => {
      if (typeof props.openStrategy === "object")
        return props.openStrategy;
      switch (props.openStrategy) {
        case "list":
          return listOpenStrategy;
        case "single":
          return singleOpenStrategy;
        case "multiple":
        default:
          return multipleOpenStrategy;
      }
    });
    const activated = useProxiedModel(props, "activated", props.activated, (v) => activeStrategy.value.in(v, children.value, parents.value), (v) => activeStrategy.value.out(v, children.value, parents.value));
    const selected = useProxiedModel(props, "selected", props.selected, (v) => selectStrategy.value.in(v, children.value, parents.value), (v) => selectStrategy.value.out(v, children.value, parents.value));
    onBeforeUnmount(() => {
      isUnmounted = true;
    });
    function getPath(id) {
      const path = [];
      let parent = id;
      while (parent != null) {
        path.unshift(parent);
        parent = parents.value.get(parent);
      }
      return path;
    }
    const vm2 = getCurrentInstance2("nested");
    const nodeIds = /* @__PURE__ */ new Set();
    const nested = {
      id: shallowRef(),
      root: {
        opened,
        activatable: toRef(() => props.activatable),
        selectable: toRef(() => props.selectable),
        activated,
        selected,
        selectedValues: computed2(() => {
          const arr = [];
          for (const [key, value] of selected.value.entries()) {
            if (value === "on")
              arr.push(key);
          }
          return arr;
        }),
        register: (id, parentId, isGroup) => {
          if (nodeIds.has(id)) {
            const path = getPath(id).map(String).join(" -> ");
            const newPath = getPath(parentId).concat(id).map(String).join(" -> ");
            consoleError(`Multiple nodes with the same ID
	${path}
	${newPath}`);
            return;
          } else {
            nodeIds.add(id);
          }
          parentId && id !== parentId && parents.value.set(id, parentId);
          isGroup && children.value.set(id, []);
          if (parentId != null) {
            children.value.set(parentId, [...children.value.get(parentId) || [], id]);
          }
        },
        unregister: (id) => {
          var _a3;
          if (isUnmounted)
            return;
          nodeIds.delete(id);
          children.value.delete(id);
          const parent = parents.value.get(id);
          if (parent) {
            const list = (_a3 = children.value.get(parent)) != null ? _a3 : [];
            children.value.set(parent, list.filter((child) => child !== id));
          }
          parents.value.delete(id);
        },
        open: (id, value, event2) => {
          vm2.emit("click:open", {
            id,
            value,
            path: getPath(id),
            event: event2
          });
          const newOpened = openStrategy.value.open({
            id,
            value,
            opened: new Set(opened.value),
            children: children.value,
            parents: parents.value,
            event: event2
          });
          newOpened && (opened.value = newOpened);
        },
        openOnSelect: (id, value, event2) => {
          const newOpened = openStrategy.value.select({
            id,
            value,
            selected: new Map(selected.value),
            opened: new Set(opened.value),
            children: children.value,
            parents: parents.value,
            event: event2
          });
          newOpened && (opened.value = newOpened);
        },
        select: (id, value, event2) => {
          vm2.emit("click:select", {
            id,
            value,
            path: getPath(id),
            event: event2
          });
          const newSelected = selectStrategy.value.select({
            id,
            value,
            selected: new Map(selected.value),
            children: children.value,
            parents: parents.value,
            event: event2
          });
          newSelected && (selected.value = newSelected);
          nested.root.openOnSelect(id, value, event2);
        },
        activate: (id, value, event2) => {
          if (!props.activatable) {
            return nested.root.select(id, true, event2);
          }
          vm2.emit("click:activate", {
            id,
            value,
            path: getPath(id),
            event: event2
          });
          const newActivated = activeStrategy.value.activate({
            id,
            value,
            activated: new Set(activated.value),
            children: children.value,
            parents: parents.value,
            event: event2
          });
          if (newActivated.size !== activated.value.size) {
            activated.value = newActivated;
          } else {
            for (const value2 of newActivated) {
              if (!activated.value.has(value2)) {
                activated.value = newActivated;
                return;
              }
            }
            for (const value2 of activated.value) {
              if (!newActivated.has(value2)) {
                activated.value = newActivated;
                return;
              }
            }
          }
        },
        children,
        parents,
        getPath
      }
    };
    provide(VNestedSymbol, nested);
    return nested.root;
  };
  var useNestedItem = (id, isGroup) => {
    const parent = inject(VNestedSymbol, emptyNested);
    const uidSymbol = Symbol("nested item");
    const computedId = computed2(() => {
      var _a3;
      return (_a3 = toValue(id)) != null ? _a3 : uidSymbol;
    });
    const item = __spreadProps(__spreadValues({}, parent), {
      id: computedId,
      open: (open, e) => parent.root.open(computedId.value, open, e),
      openOnSelect: (open, e) => parent.root.openOnSelect(computedId.value, open, e),
      isOpen: computed2(() => parent.root.opened.value.has(computedId.value)),
      parent: computed2(() => parent.root.parents.value.get(computedId.value)),
      activate: (activated, e) => parent.root.activate(computedId.value, activated, e),
      isActivated: computed2(() => parent.root.activated.value.has(toRaw(computedId.value))),
      select: (selected, e) => parent.root.select(computedId.value, selected, e),
      isSelected: computed2(() => parent.root.selected.value.get(toRaw(computedId.value)) === "on"),
      isIndeterminate: computed2(() => parent.root.selected.value.get(toRaw(computedId.value)) === "indeterminate"),
      isLeaf: computed2(() => !parent.root.children.value.get(computedId.value)),
      isGroupActivator: parent.isGroupActivator
    });
    onBeforeMount(() => {
      !parent.isGroupActivator && parent.root.register(computedId.value, parent.id.value, isGroup);
    });
    onBeforeUnmount(() => {
      !parent.isGroupActivator && parent.root.unregister(computedId.value);
    });
    isGroup && provide(VNestedSymbol, item);
    return item;
  };
  var useNestedGroupActivator = () => {
    const parent = inject(VNestedSymbol, emptyNested);
    provide(VNestedSymbol, __spreadProps(__spreadValues({}, parent), {
      isGroupActivator: true
    }));
  };

  // ../posawesome/node_modules/vuetify/lib/components/VList/VListGroup.js
  var VListGroupActivator = defineComponent2({
    name: "VListGroupActivator",
    setup(_2, _ref) {
      let {
        slots
      } = _ref;
      useNestedGroupActivator();
      return () => {
        var _a3;
        return (_a3 = slots.default) == null ? void 0 : _a3.call(slots);
      };
    }
  });
  var makeVListGroupProps = propsFactory(__spreadValues(__spreadValues({
    activeColor: String,
    baseColor: String,
    color: String,
    collapseIcon: {
      type: IconValue,
      default: "$collapse"
    },
    expandIcon: {
      type: IconValue,
      default: "$expand"
    },
    rawId: [String, Number],
    prependIcon: IconValue,
    appendIcon: IconValue,
    fluid: Boolean,
    subgroup: Boolean,
    title: String,
    value: null
  }, makeComponentProps()), makeTagProps()), "VListGroup");
  var VListGroup = genericComponent()({
    name: "VListGroup",
    props: makeVListGroupProps(),
    setup(props, _ref2) {
      let {
        slots
      } = _ref2;
      const {
        isOpen,
        open,
        id: _id
      } = useNestedItem(() => props.value, true);
      const id = computed2(() => {
        var _a3;
        return `v-list-group--id-${String((_a3 = props.rawId) != null ? _a3 : _id.value)}`;
      });
      const list = useList();
      const {
        isBooted
      } = useSsrBoot();
      function onClick(e) {
        var _a3;
        if (["INPUT", "TEXTAREA"].includes((_a3 = e.target) == null ? void 0 : _a3.tagName))
          return;
        open(!isOpen.value, e);
      }
      const activatorProps = computed2(() => ({
        onClick,
        class: "v-list-group__header",
        id: id.value
      }));
      const toggleIcon = computed2(() => isOpen.value ? props.collapseIcon : props.expandIcon);
      const activatorDefaults = computed2(() => ({
        VListItem: {
          active: isOpen.value,
          activeColor: props.activeColor,
          baseColor: props.baseColor,
          color: props.color,
          prependIcon: props.prependIcon || props.subgroup && toggleIcon.value,
          appendIcon: props.appendIcon || !props.subgroup && toggleIcon.value,
          title: props.title,
          value: props.value
        }
      }));
      useRender(() => createVNode(props.tag, {
        "class": normalizeClass(["v-list-group", {
          "v-list-group--prepend": list == null ? void 0 : list.hasPrepend.value,
          "v-list-group--fluid": props.fluid,
          "v-list-group--subgroup": props.subgroup,
          "v-list-group--open": isOpen.value
        }, props.class]),
        "style": normalizeStyle(props.style)
      }, {
        default: () => [slots.activator && createVNode(VDefaultsProvider, {
          "defaults": activatorDefaults.value
        }, {
          default: () => [createVNode(VListGroupActivator, null, {
            default: () => [slots.activator({
              props: activatorProps.value,
              isOpen: isOpen.value
            })]
          })]
        }), createVNode(MaybeTransition, {
          "transition": {
            component: VExpandTransition
          },
          "disabled": !isBooted.value
        }, {
          default: () => {
            var _a3;
            return [withDirectives(createBaseVNode("div", {
              "class": "v-list-group__items",
              "role": "group",
              "aria-labelledby": id.value
            }, [(_a3 = slots.default) == null ? void 0 : _a3.call(slots)]), [[vShow, isOpen.value]])];
          }
        })]
      }));
      return {
        isOpen
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VList/VListItemSubtitle.js
  var makeVListItemSubtitleProps = propsFactory(__spreadValues(__spreadValues({
    opacity: [Number, String]
  }, makeComponentProps()), makeTagProps()), "VListItemSubtitle");
  var VListItemSubtitle = genericComponent()({
    name: "VListItemSubtitle",
    props: makeVListItemSubtitleProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => createVNode(props.tag, {
        "class": normalizeClass(["v-list-item-subtitle", props.class]),
        "style": normalizeStyle([{
          "--v-list-item-subtitle-opacity": props.opacity
        }, props.style])
      }, slots));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VList/VListItemTitle.js
  var VListItemTitle = createSimpleFunctional("v-list-item-title");

  // ../posawesome/node_modules/vuetify/lib/components/VList/VListItem.js
  var makeVListItemProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    active: {
      type: Boolean,
      default: void 0
    },
    activeClass: String,
    activeColor: String,
    appendAvatar: String,
    appendIcon: IconValue,
    baseColor: String,
    disabled: Boolean,
    lines: [Boolean, String],
    link: {
      type: Boolean,
      default: void 0
    },
    nav: Boolean,
    prependAvatar: String,
    prependIcon: IconValue,
    ripple: {
      type: [Boolean, Object],
      default: true
    },
    slim: Boolean,
    subtitle: {
      type: [String, Number, Boolean],
      default: void 0
    },
    title: {
      type: [String, Number, Boolean],
      default: void 0
    },
    value: null,
    onClick: EventProp(),
    onClickOnce: EventProp()
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeDimensionProps()), makeElevationProps()), makeRoundedProps()), makeRouterProps()), makeTagProps()), makeThemeProps()), makeVariantProps({
    variant: "text"
  })), "VListItem");
  var VListItem = genericComponent()({
    name: "VListItem",
    directives: {
      vRipple: ripple_default
    },
    props: makeVListItemProps(),
    emits: {
      click: (e) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        slots,
        emit: emit2
      } = _ref;
      const link = useLink(props, attrs);
      const id = computed2(() => props.value === void 0 ? link.href.value : props.value);
      const {
        activate,
        isActivated,
        select,
        isOpen,
        isSelected,
        isIndeterminate,
        isGroupActivator,
        root,
        parent,
        openOnSelect,
        id: uid2
      } = useNestedItem(id, false);
      const list = useList();
      const isActive = computed2(() => {
        var _a3;
        return props.active !== false && (props.active || ((_a3 = link.isActive) == null ? void 0 : _a3.value) || (root.activatable.value ? isActivated.value : isSelected.value));
      });
      const isLink = toRef(() => props.link !== false && link.isLink.value);
      const isSelectable = computed2(() => !!list && (root.selectable.value || root.activatable.value || props.value != null));
      const isClickable = computed2(() => !props.disabled && props.link !== false && (props.link || link.isClickable.value || isSelectable.value));
      const roundedProps = toRef(() => props.rounded || props.nav);
      const color = toRef(() => {
        var _a3;
        return (_a3 = props.color) != null ? _a3 : props.activeColor;
      });
      const variantProps = toRef(() => {
        var _a3;
        return {
          color: isActive.value ? (_a3 = color.value) != null ? _a3 : props.baseColor : props.baseColor,
          variant: props.variant
        };
      });
      watch2(() => {
        var _a3;
        return (_a3 = link.isActive) == null ? void 0 : _a3.value;
      }, (val) => {
        if (!val)
          return;
        handleActiveLink();
      });
      onBeforeMount(() => {
        var _a3;
        if ((_a3 = link.isActive) == null ? void 0 : _a3.value)
          handleActiveLink();
      });
      function handleActiveLink() {
        if (parent.value != null) {
          root.open(parent.value, true);
        }
        openOnSelect(true);
      }
      const {
        themeClasses
      } = provideTheme(props);
      const {
        borderClasses
      } = useBorder(props);
      const {
        colorClasses,
        colorStyles,
        variantClasses
      } = useVariant(variantProps);
      const {
        densityClasses
      } = useDensity(props);
      const {
        dimensionStyles
      } = useDimension(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        roundedClasses
      } = useRounded(roundedProps);
      const lineClasses = toRef(() => props.lines ? `v-list-item--${props.lines}-line` : void 0);
      const slotProps = computed2(() => ({
        isActive: isActive.value,
        select,
        isOpen: isOpen.value,
        isSelected: isSelected.value,
        isIndeterminate: isIndeterminate.value
      }));
      function onClick(e) {
        var _a3, _b;
        emit2("click", e);
        if (["INPUT", "TEXTAREA"].includes((_a3 = e.target) == null ? void 0 : _a3.tagName))
          return;
        if (!isClickable.value)
          return;
        (_b = link.navigate) == null ? void 0 : _b.call(link, e);
        if (isGroupActivator)
          return;
        if (root.activatable.value) {
          activate(!isActivated.value, e);
        } else if (root.selectable.value) {
          select(!isSelected.value, e);
        } else if (props.value != null) {
          select(!isSelected.value, e);
        }
      }
      function onKeyDown(e) {
        const target = e.target;
        if (["INPUT", "TEXTAREA"].includes(target.tagName))
          return;
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          e.target.dispatchEvent(new MouseEvent("click", e));
        }
      }
      useRender(() => {
        const Tag = isLink.value ? "a" : props.tag;
        const hasTitle = slots.title || props.title != null;
        const hasSubtitle = slots.subtitle || props.subtitle != null;
        const hasAppendMedia = !!(props.appendAvatar || props.appendIcon);
        const hasAppend = !!(hasAppendMedia || slots.append);
        const hasPrependMedia = !!(props.prependAvatar || props.prependIcon);
        const hasPrepend = !!(hasPrependMedia || slots.prepend);
        list == null ? void 0 : list.updateHasPrepend(hasPrepend);
        if (props.activeColor) {
          deprecate("active-color", ["color", "base-color"]);
        }
        return withDirectives(createVNode(Tag, mergeProps({
          "class": ["v-list-item", {
            "v-list-item--active": isActive.value,
            "v-list-item--disabled": props.disabled,
            "v-list-item--link": isClickable.value,
            "v-list-item--nav": props.nav,
            "v-list-item--prepend": !hasPrepend && (list == null ? void 0 : list.hasPrepend.value),
            "v-list-item--slim": props.slim,
            [`${props.activeClass}`]: props.activeClass && isActive.value
          }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, lineClasses.value, roundedClasses.value, variantClasses.value, props.class],
          "style": [colorStyles.value, dimensionStyles.value, props.style],
          "tabindex": isClickable.value ? list ? -2 : 0 : void 0,
          "aria-selected": isSelectable.value ? root.activatable.value ? isActivated.value : root.selectable.value ? isSelected.value : isActive.value : void 0,
          "onClick": onClick,
          "onKeydown": isClickable.value && !isLink.value && onKeyDown
        }, link.linkProps), {
          default: () => {
            var _a3;
            return [genOverlays(isClickable.value || isActive.value, "v-list-item"), hasPrepend && createBaseVNode("div", {
              "key": "prepend",
              "class": "v-list-item__prepend"
            }, [!slots.prepend ? createBaseVNode(Fragment, null, [props.prependAvatar && createVNode(VAvatar, {
              "key": "prepend-avatar",
              "density": props.density,
              "image": props.prependAvatar
            }, null), props.prependIcon && createVNode(VIcon, {
              "key": "prepend-icon",
              "density": props.density,
              "icon": props.prependIcon
            }, null)]) : createVNode(VDefaultsProvider, {
              "key": "prepend-defaults",
              "disabled": !hasPrependMedia,
              "defaults": {
                VAvatar: {
                  density: props.density,
                  image: props.prependAvatar
                },
                VIcon: {
                  density: props.density,
                  icon: props.prependIcon
                },
                VListItemAction: {
                  start: true
                }
              }
            }, {
              default: () => {
                var _a4;
                return [(_a4 = slots.prepend) == null ? void 0 : _a4.call(slots, slotProps.value)];
              }
            }), createBaseVNode("div", {
              "class": "v-list-item__spacer"
            }, null)]), createBaseVNode("div", {
              "class": "v-list-item__content",
              "data-no-activator": ""
            }, [hasTitle && createVNode(VListItemTitle, {
              "key": "title"
            }, {
              default: () => {
                var _a4, _b;
                return [(_b = (_a4 = slots.title) == null ? void 0 : _a4.call(slots, {
                  title: props.title
                })) != null ? _b : toDisplayString(props.title)];
              }
            }), hasSubtitle && createVNode(VListItemSubtitle, {
              "key": "subtitle"
            }, {
              default: () => {
                var _a4, _b;
                return [(_b = (_a4 = slots.subtitle) == null ? void 0 : _a4.call(slots, {
                  subtitle: props.subtitle
                })) != null ? _b : toDisplayString(props.subtitle)];
              }
            }), (_a3 = slots.default) == null ? void 0 : _a3.call(slots, slotProps.value)]), hasAppend && createBaseVNode("div", {
              "key": "append",
              "class": "v-list-item__append"
            }, [!slots.append ? createBaseVNode(Fragment, null, [props.appendIcon && createVNode(VIcon, {
              "key": "append-icon",
              "density": props.density,
              "icon": props.appendIcon
            }, null), props.appendAvatar && createVNode(VAvatar, {
              "key": "append-avatar",
              "density": props.density,
              "image": props.appendAvatar
            }, null)]) : createVNode(VDefaultsProvider, {
              "key": "append-defaults",
              "disabled": !hasAppendMedia,
              "defaults": {
                VAvatar: {
                  density: props.density,
                  image: props.appendAvatar
                },
                VIcon: {
                  density: props.density,
                  icon: props.appendIcon
                },
                VListItemAction: {
                  end: true
                }
              }
            }, {
              default: () => {
                var _a4;
                return [(_a4 = slots.append) == null ? void 0 : _a4.call(slots, slotProps.value)];
              }
            }), createBaseVNode("div", {
              "class": "v-list-item__spacer"
            }, null)])];
          }
        }), [[ripple_default, isClickable.value && props.ripple]]);
      });
      return {
        activate,
        isActivated,
        isGroupActivator,
        isSelected,
        list,
        select,
        root,
        id: uid2,
        link
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VList/VListSubheader.js
  var makeVListSubheaderProps = propsFactory(__spreadValues(__spreadValues({
    color: String,
    inset: Boolean,
    sticky: Boolean,
    title: String
  }, makeComponentProps()), makeTagProps()), "VListSubheader");
  var VListSubheader = genericComponent()({
    name: "VListSubheader",
    props: makeVListSubheaderProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(() => props.color);
      useRender(() => {
        const hasText = !!(slots.default || props.title);
        return createVNode(props.tag, {
          "class": normalizeClass(["v-list-subheader", {
            "v-list-subheader--inset": props.inset,
            "v-list-subheader--sticky": props.sticky
          }, textColorClasses.value, props.class]),
          "style": normalizeStyle([{
            textColorStyles
          }, props.style])
        }, {
          default: () => {
            var _a3, _b;
            return [hasText && createBaseVNode("div", {
              "class": "v-list-subheader__text"
            }, [(_b = (_a3 = slots.default) == null ? void 0 : _a3.call(slots)) != null ? _b : props.title])];
          }
        });
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VDivider/VDivider.js
  var makeVDividerProps = propsFactory(__spreadValues(__spreadValues({
    color: String,
    inset: Boolean,
    length: [Number, String],
    opacity: [Number, String],
    thickness: [Number, String],
    vertical: Boolean
  }, makeComponentProps()), makeThemeProps()), "VDivider");
  var VDivider = genericComponent()({
    name: "VDivider",
    props: makeVDividerProps(),
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(() => props.color);
      const dividerStyles = computed2(() => {
        const styles = {};
        if (props.length) {
          styles[props.vertical ? "height" : "width"] = convertToUnit(props.length);
        }
        if (props.thickness) {
          styles[props.vertical ? "borderRightWidth" : "borderTopWidth"] = convertToUnit(props.thickness);
        }
        return styles;
      });
      useRender(() => {
        const divider = createBaseVNode("hr", {
          "class": normalizeClass([{
            "v-divider": true,
            "v-divider--inset": props.inset,
            "v-divider--vertical": props.vertical
          }, themeClasses.value, textColorClasses.value, props.class]),
          "style": normalizeStyle([dividerStyles.value, textColorStyles.value, {
            "--v-border-opacity": props.opacity
          }, props.style]),
          "aria-orientation": !attrs.role || attrs.role === "separator" ? props.vertical ? "vertical" : "horizontal" : void 0,
          "role": `${attrs.role || "separator"}`
        }, null);
        if (!slots.default)
          return divider;
        return createBaseVNode("div", {
          "class": normalizeClass(["v-divider__wrapper", {
            "v-divider__wrapper--vertical": props.vertical,
            "v-divider__wrapper--inset": props.inset
          }])
        }, [divider, createBaseVNode("div", {
          "class": "v-divider__content"
        }, [slots.default()]), divider]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VList/VListChildren.js
  var makeVListChildrenProps = propsFactory({
    items: Array,
    returnObject: Boolean
  }, "VListChildren");
  var VListChildren = genericComponent()({
    name: "VListChildren",
    props: makeVListChildrenProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      createList();
      return () => {
        var _a3, _b, _c;
        return (_c = (_a3 = slots.default) == null ? void 0 : _a3.call(slots)) != null ? _c : (_b = props.items) == null ? void 0 : _b.map((_ref2) => {
          var _a4, _b2, _c2, _d;
          let {
            children,
            props: itemProps,
            type,
            raw: item
          } = _ref2;
          if (type === "divider") {
            return (_b2 = (_a4 = slots.divider) == null ? void 0 : _a4.call(slots, {
              props: itemProps
            })) != null ? _b2 : createVNode(VDivider, itemProps, null);
          }
          if (type === "subheader") {
            return (_d = (_c2 = slots.subheader) == null ? void 0 : _c2.call(slots, {
              props: itemProps
            })) != null ? _d : createVNode(VListSubheader, itemProps, null);
          }
          const slotsWithItem = {
            subtitle: slots.subtitle ? (slotProps) => {
              var _a5;
              return (_a5 = slots.subtitle) == null ? void 0 : _a5.call(slots, __spreadProps(__spreadValues({}, slotProps), {
                item
              }));
            } : void 0,
            prepend: slots.prepend ? (slotProps) => {
              var _a5;
              return (_a5 = slots.prepend) == null ? void 0 : _a5.call(slots, __spreadProps(__spreadValues({}, slotProps), {
                item
              }));
            } : void 0,
            append: slots.append ? (slotProps) => {
              var _a5;
              return (_a5 = slots.append) == null ? void 0 : _a5.call(slots, __spreadProps(__spreadValues({}, slotProps), {
                item
              }));
            } : void 0,
            title: slots.title ? (slotProps) => {
              var _a5;
              return (_a5 = slots.title) == null ? void 0 : _a5.call(slots, __spreadProps(__spreadValues({}, slotProps), {
                item
              }));
            } : void 0
          };
          const listGroupProps = VListGroup.filterProps(itemProps);
          return children ? createVNode(VListGroup, mergeProps(listGroupProps, {
            "value": props.returnObject ? item : itemProps == null ? void 0 : itemProps.value,
            "rawId": itemProps == null ? void 0 : itemProps.value
          }), {
            activator: (_ref3) => {
              let {
                props: activatorProps
              } = _ref3;
              const listItemProps = __spreadProps(__spreadValues(__spreadValues({}, itemProps), activatorProps), {
                value: props.returnObject ? item : itemProps.value
              });
              return slots.header ? slots.header({
                props: listItemProps
              }) : createVNode(VListItem, listItemProps, slotsWithItem);
            },
            default: () => createVNode(VListChildren, {
              "items": children,
              "returnObject": props.returnObject
            }, slots)
          }) : slots.item ? slots.item({
            props: itemProps
          }) : createVNode(VListItem, mergeProps(itemProps, {
            "value": props.returnObject ? item : itemProps.value
          }), slotsWithItem);
        });
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/composables/list-items.js
  var makeItemsProps = propsFactory({
    items: {
      type: Array,
      default: () => []
    },
    itemTitle: {
      type: [String, Array, Function],
      default: "title"
    },
    itemValue: {
      type: [String, Array, Function],
      default: "value"
    },
    itemChildren: {
      type: [Boolean, String, Array, Function],
      default: "children"
    },
    itemProps: {
      type: [Boolean, String, Array, Function],
      default: "props"
    },
    returnObject: Boolean,
    valueComparator: Function
  }, "list-items");
  function transformItem(props, item) {
    var _a3;
    const title = getPropertyFromItem(item, props.itemTitle, item);
    const value = getPropertyFromItem(item, props.itemValue, title);
    const children = getPropertyFromItem(item, props.itemChildren);
    const itemProps = props.itemProps === true ? typeof item === "object" && item != null && !Array.isArray(item) ? "children" in item ? omit(item, ["children"]) : item : void 0 : getPropertyFromItem(item, props.itemProps);
    const _props = __spreadValues({
      title,
      value
    }, itemProps);
    return {
      title: String((_a3 = _props.title) != null ? _a3 : ""),
      value: _props.value,
      props: _props,
      children: Array.isArray(children) ? transformItems(props, children) : void 0,
      raw: item
    };
  }
  function transformItems(props, items) {
    const _props = pick(props, ["itemTitle", "itemValue", "itemChildren", "itemProps", "returnObject", "valueComparator"]);
    const array = [];
    for (const item of items) {
      array.push(transformItem(_props, item));
    }
    return array;
  }
  function useItems(props) {
    const items = computed2(() => transformItems(props, props.items));
    const hasNullItem = computed2(() => items.value.some((item) => item.value === null));
    const itemsMap = shallowRef(/* @__PURE__ */ new Map());
    const keylessItems = shallowRef([]);
    watchEffect(() => {
      const _items = items.value;
      const map2 = /* @__PURE__ */ new Map();
      const keyless = [];
      for (let i = 0; i < _items.length; i++) {
        const item = _items[i];
        if (isPrimitive(item.value) || item.value === null) {
          let values = map2.get(item.value);
          if (!values) {
            values = [];
            map2.set(item.value, values);
          }
          values.push(item);
        } else {
          keyless.push(item);
        }
      }
      itemsMap.value = map2;
      keylessItems.value = keyless;
    });
    function transformIn(value) {
      const _items = itemsMap.value;
      const _allItems = items.value;
      const _keylessItems = keylessItems.value;
      const _hasNullItem = hasNullItem.value;
      const _returnObject = props.returnObject;
      const hasValueComparator = !!props.valueComparator;
      const valueComparator = props.valueComparator || deepEqual;
      const _props = pick(props, ["itemTitle", "itemValue", "itemChildren", "itemProps", "returnObject", "valueComparator"]);
      const returnValue = [];
      main:
        for (const v of value) {
          if (!_hasNullItem && v === null)
            continue;
          if (_returnObject && typeof v === "string") {
            returnValue.push(transformItem(_props, v));
            continue;
          }
          const fastItems = _items.get(v);
          if (hasValueComparator || !fastItems) {
            for (const item of hasValueComparator ? _allItems : _keylessItems) {
              if (valueComparator(v, item.value)) {
                returnValue.push(item);
                continue main;
              }
            }
            returnValue.push(transformItem(_props, v));
            continue;
          }
          returnValue.push(...fastItems);
        }
      return returnValue;
    }
    function transformOut(value) {
      return props.returnObject ? value.map((_ref) => {
        let {
          raw
        } = _ref;
        return raw;
      }) : value.map((_ref2) => {
        let {
          value: value2
        } = _ref2;
        return value2;
      });
    }
    return {
      items,
      transformIn,
      transformOut
    };
  }

  // ../posawesome/node_modules/vuetify/lib/components/VList/VList.js
  function transformItem2(props, item) {
    const type = getPropertyFromItem(item, props.itemType, "item");
    const title = isPrimitive(item) ? item : getPropertyFromItem(item, props.itemTitle);
    const value = getPropertyFromItem(item, props.itemValue, void 0);
    const children = getPropertyFromItem(item, props.itemChildren);
    const itemProps = props.itemProps === true ? omit(item, ["children"]) : getPropertyFromItem(item, props.itemProps);
    const _props = __spreadValues({
      title,
      value
    }, itemProps);
    return {
      type,
      title: _props.title,
      value: _props.value,
      props: _props,
      children: type === "item" && children ? transformItems2(props, children) : void 0,
      raw: item
    };
  }
  function transformItems2(props, items) {
    const array = [];
    for (const item of items) {
      array.push(transformItem2(props, item));
    }
    return array;
  }
  function useListItems(props) {
    const items = computed2(() => transformItems2(props, props.items));
    return {
      items
    };
  }
  var makeVListProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    baseColor: String,
    activeColor: String,
    activeClass: String,
    bgColor: String,
    disabled: Boolean,
    expandIcon: IconValue,
    collapseIcon: IconValue,
    lines: {
      type: [Boolean, String],
      default: "one"
    },
    slim: Boolean,
    nav: Boolean,
    "onClick:open": EventProp(),
    "onClick:select": EventProp(),
    "onUpdate:opened": EventProp()
  }, makeNestedProps({
    selectStrategy: "single-leaf",
    openStrategy: "list"
  })), makeBorderProps()), makeComponentProps()), makeDensityProps()), makeDimensionProps()), makeElevationProps()), {
    itemType: {
      type: String,
      default: "type"
    }
  }), makeItemsProps()), makeRoundedProps()), makeTagProps()), makeThemeProps()), makeVariantProps({
    variant: "text"
  })), "VList");
  var VList = genericComponent()({
    name: "VList",
    props: makeVListProps(),
    emits: {
      "update:selected": (value) => true,
      "update:activated": (value) => true,
      "update:opened": (value) => true,
      "click:open": (value) => true,
      "click:activate": (value) => true,
      "click:select": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        items
      } = useListItems(props);
      const {
        themeClasses
      } = provideTheme(props);
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(() => props.bgColor);
      const {
        borderClasses
      } = useBorder(props);
      const {
        densityClasses
      } = useDensity(props);
      const {
        dimensionStyles
      } = useDimension(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        roundedClasses
      } = useRounded(props);
      const {
        children,
        open,
        parents,
        select,
        getPath
      } = useNested(props);
      const lineClasses = toRef(() => props.lines ? `v-list--${props.lines}-line` : void 0);
      const activeColor = toRef(() => props.activeColor);
      const baseColor = toRef(() => props.baseColor);
      const color = toRef(() => props.color);
      createList();
      provideDefaults({
        VListGroup: {
          activeColor,
          baseColor,
          color,
          expandIcon: toRef(() => props.expandIcon),
          collapseIcon: toRef(() => props.collapseIcon)
        },
        VListItem: {
          activeClass: toRef(() => props.activeClass),
          activeColor,
          baseColor,
          color,
          density: toRef(() => props.density),
          disabled: toRef(() => props.disabled),
          lines: toRef(() => props.lines),
          nav: toRef(() => props.nav),
          slim: toRef(() => props.slim),
          variant: toRef(() => props.variant)
        }
      });
      const isFocused = shallowRef(false);
      const contentRef = ref();
      function onFocusin(e) {
        isFocused.value = true;
      }
      function onFocusout(e) {
        isFocused.value = false;
      }
      function onFocus(e) {
        var _a3;
        if (!isFocused.value && !(e.relatedTarget && ((_a3 = contentRef.value) == null ? void 0 : _a3.contains(e.relatedTarget))))
          focus();
      }
      function onKeydown(e) {
        const target = e.target;
        if (!contentRef.value || ["INPUT", "TEXTAREA"].includes(target.tagName))
          return;
        if (e.key === "ArrowDown") {
          focus("next");
        } else if (e.key === "ArrowUp") {
          focus("prev");
        } else if (e.key === "Home") {
          focus("first");
        } else if (e.key === "End") {
          focus("last");
        } else {
          return;
        }
        e.preventDefault();
      }
      function onMousedown(e) {
        isFocused.value = true;
      }
      function focus(location2) {
        if (contentRef.value) {
          return focusChild(contentRef.value, location2);
        }
      }
      useRender(() => {
        return createVNode(props.tag, {
          "ref": contentRef,
          "class": normalizeClass(["v-list", {
            "v-list--disabled": props.disabled,
            "v-list--nav": props.nav,
            "v-list--slim": props.slim
          }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, lineClasses.value, roundedClasses.value, props.class]),
          "style": normalizeStyle([backgroundColorStyles.value, dimensionStyles.value, props.style]),
          "tabindex": props.disabled ? -1 : 0,
          "role": "listbox",
          "aria-activedescendant": void 0,
          "onFocusin": onFocusin,
          "onFocusout": onFocusout,
          "onFocus": onFocus,
          "onKeydown": onKeydown,
          "onMousedown": onMousedown
        }, {
          default: () => [createVNode(VListChildren, {
            "items": items.value,
            "returnObject": props.returnObject
          }, slots)]
        });
      });
      return {
        open,
        select,
        focus,
        children,
        parents,
        getPath
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VList/VListImg.js
  var VListImg = createSimpleFunctional("v-list-img");

  // ../posawesome/node_modules/vuetify/lib/components/VList/VListItemAction.js
  var makeVListItemActionProps = propsFactory(__spreadValues(__spreadValues({
    start: Boolean,
    end: Boolean
  }, makeComponentProps()), makeTagProps()), "VListItemAction");
  var VListItemAction = genericComponent()({
    name: "VListItemAction",
    props: makeVListItemActionProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => createVNode(props.tag, {
        "class": normalizeClass(["v-list-item-action", {
          "v-list-item-action--start": props.start,
          "v-list-item-action--end": props.end
        }, props.class]),
        "style": normalizeStyle(props.style)
      }, slots));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VList/VListItemMedia.js
  var makeVListItemMediaProps = propsFactory(__spreadValues(__spreadValues({
    start: Boolean,
    end: Boolean
  }, makeComponentProps()), makeTagProps()), "VListItemMedia");
  var VListItemMedia = genericComponent()({
    name: "VListItemMedia",
    props: makeVListItemMediaProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => {
        return createVNode(props.tag, {
          "class": normalizeClass(["v-list-item-media", {
            "v-list-item-media--start": props.start,
            "v-list-item-media--end": props.end
          }, props.class]),
          "style": normalizeStyle(props.style)
        }, slots);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VOverlay/util/point.js
  function elementToViewport(point, offset) {
    return {
      x: point.x + offset.x,
      y: point.y + offset.y
    };
  }
  function getOffset2(a, b) {
    return {
      x: a.x - b.x,
      y: a.y - b.y
    };
  }
  function anchorToPoint(anchor, box) {
    if (anchor.side === "top" || anchor.side === "bottom") {
      const {
        side,
        align
      } = anchor;
      const x = align === "left" ? 0 : align === "center" ? box.width / 2 : align === "right" ? box.width : align;
      const y = side === "top" ? 0 : side === "bottom" ? box.height : side;
      return elementToViewport({
        x,
        y
      }, box);
    } else if (anchor.side === "left" || anchor.side === "right") {
      const {
        side,
        align
      } = anchor;
      const x = side === "left" ? 0 : side === "right" ? box.width : side;
      const y = align === "top" ? 0 : align === "center" ? box.height / 2 : align === "bottom" ? box.height : align;
      return elementToViewport({
        x,
        y
      }, box);
    }
    return elementToViewport({
      x: box.width / 2,
      y: box.height / 2
    }, box);
  }

  // ../posawesome/node_modules/vuetify/lib/components/VOverlay/locationStrategies.js
  var locationStrategies = {
    static: staticLocationStrategy,
    connected: connectedLocationStrategy
  };
  var makeLocationStrategyProps = propsFactory({
    locationStrategy: {
      type: [String, Function],
      default: "static",
      validator: (val) => typeof val === "function" || val in locationStrategies
    },
    location: {
      type: String,
      default: "bottom"
    },
    origin: {
      type: String,
      default: "auto"
    },
    offset: [Number, String, Array]
  }, "VOverlay-location-strategies");
  function useLocationStrategies(props, data) {
    const contentStyles = ref({});
    const updateLocation = ref();
    if (IN_BROWSER) {
      useToggleScope(() => !!(data.isActive.value && props.locationStrategy), (reset) => {
        var _a3, _b;
        watch2(() => props.locationStrategy, reset);
        onScopeDispose(() => {
          window.removeEventListener("resize", onResize);
          visualViewport == null ? void 0 : visualViewport.removeEventListener("resize", onVisualResize);
          visualViewport == null ? void 0 : visualViewport.removeEventListener("scroll", onVisualScroll);
          updateLocation.value = void 0;
        });
        window.addEventListener("resize", onResize, {
          passive: true
        });
        visualViewport == null ? void 0 : visualViewport.addEventListener("resize", onVisualResize, {
          passive: true
        });
        visualViewport == null ? void 0 : visualViewport.addEventListener("scroll", onVisualScroll, {
          passive: true
        });
        if (typeof props.locationStrategy === "function") {
          updateLocation.value = (_a3 = props.locationStrategy(data, props, contentStyles)) == null ? void 0 : _a3.updateLocation;
        } else {
          updateLocation.value = (_b = locationStrategies[props.locationStrategy](data, props, contentStyles)) == null ? void 0 : _b.updateLocation;
        }
      });
    }
    function onResize(e) {
      var _a3;
      (_a3 = updateLocation.value) == null ? void 0 : _a3.call(updateLocation, e);
    }
    function onVisualResize(e) {
      var _a3;
      (_a3 = updateLocation.value) == null ? void 0 : _a3.call(updateLocation, e);
    }
    function onVisualScroll(e) {
      var _a3;
      (_a3 = updateLocation.value) == null ? void 0 : _a3.call(updateLocation, e);
    }
    return {
      contentStyles,
      updateLocation
    };
  }
  function staticLocationStrategy() {
  }
  function getIntrinsicSize(el, isRtl) {
    const contentBox = nullifyTransforms(el);
    if (isRtl) {
      contentBox.x += parseFloat(el.style.right || 0);
    } else {
      contentBox.x -= parseFloat(el.style.left || 0);
    }
    contentBox.y -= parseFloat(el.style.top || 0);
    return contentBox;
  }
  function connectedLocationStrategy(data, props, contentStyles) {
    const activatorFixed = Array.isArray(data.target.value) || isFixedPosition(data.target.value);
    if (activatorFixed) {
      Object.assign(contentStyles.value, {
        position: "fixed",
        top: 0,
        [data.isRtl.value ? "right" : "left"]: 0
      });
    }
    const {
      preferredAnchor,
      preferredOrigin
    } = destructComputed(() => {
      const parsedAnchor = parseAnchor(props.location, data.isRtl.value);
      const parsedOrigin = props.origin === "overlap" ? parsedAnchor : props.origin === "auto" ? flipSide(parsedAnchor) : parseAnchor(props.origin, data.isRtl.value);
      if (parsedAnchor.side === parsedOrigin.side && parsedAnchor.align === flipAlign(parsedOrigin).align) {
        return {
          preferredAnchor: flipCorner(parsedAnchor),
          preferredOrigin: flipCorner(parsedOrigin)
        };
      } else {
        return {
          preferredAnchor: parsedAnchor,
          preferredOrigin: parsedOrigin
        };
      }
    });
    const [minWidth, minHeight, maxWidth, maxHeight] = ["minWidth", "minHeight", "maxWidth", "maxHeight"].map((key) => {
      return computed2(() => {
        const val = parseFloat(props[key]);
        return isNaN(val) ? Infinity : val;
      });
    });
    const offset = computed2(() => {
      if (Array.isArray(props.offset)) {
        return props.offset;
      }
      if (typeof props.offset === "string") {
        const offset2 = props.offset.split(" ").map(parseFloat);
        if (offset2.length < 2)
          offset2.push(0);
        return offset2;
      }
      return typeof props.offset === "number" ? [props.offset, 0] : [0, 0];
    });
    let observe = false;
    let lastFrame = -1;
    const flipped = new CircularBuffer(4);
    const observer = new ResizeObserver(() => {
      if (!observe)
        return;
      requestAnimationFrame((newTime) => {
        if (newTime !== lastFrame)
          flipped.clear();
        requestAnimationFrame((newNewTime) => {
          lastFrame = newNewTime;
        });
      });
      if (flipped.isFull) {
        const values = flipped.values();
        if (deepEqual(values.at(-1), values.at(-3))) {
          return;
        }
      }
      const result = updateLocation();
      if (result)
        flipped.push(result.flipped);
    });
    watch2([data.target, data.contentEl], (_ref, _ref2) => {
      let [newTarget, newContentEl] = _ref;
      let [oldTarget, oldContentEl] = _ref2;
      if (oldTarget && !Array.isArray(oldTarget))
        observer.unobserve(oldTarget);
      if (newTarget && !Array.isArray(newTarget))
        observer.observe(newTarget);
      if (oldContentEl)
        observer.unobserve(oldContentEl);
      if (newContentEl)
        observer.observe(newContentEl);
    }, {
      immediate: true
    });
    onScopeDispose(() => {
      observer.disconnect();
    });
    let targetBox = new Box({
      x: 0,
      y: 0,
      width: 0,
      height: 0
    });
    function updateLocation() {
      observe = false;
      requestAnimationFrame(() => observe = true);
      if (!data.target.value || !data.contentEl.value)
        return;
      if (Array.isArray(data.target.value) || data.target.value.offsetParent || data.target.value.getClientRects().length) {
        targetBox = getTargetBox(data.target.value);
      }
      const contentBox = getIntrinsicSize(data.contentEl.value, data.isRtl.value);
      const scrollParents = getScrollParents(data.contentEl.value);
      const viewportMargin = 12;
      if (!scrollParents.length) {
        scrollParents.push(document.documentElement);
        if (!(data.contentEl.value.style.top && data.contentEl.value.style.left)) {
          contentBox.x -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-x") || 0);
          contentBox.y -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-y") || 0);
        }
      }
      const viewport = scrollParents.reduce((box, el) => {
        const scrollBox = getElementBox(el);
        if (box) {
          return new Box({
            x: Math.max(box.left, scrollBox.left),
            y: Math.max(box.top, scrollBox.top),
            width: Math.min(box.right, scrollBox.right) - Math.max(box.left, scrollBox.left),
            height: Math.min(box.bottom, scrollBox.bottom) - Math.max(box.top, scrollBox.top)
          });
        }
        return scrollBox;
      }, void 0);
      viewport.x += viewportMargin;
      viewport.y += viewportMargin;
      viewport.width -= viewportMargin * 2;
      viewport.height -= viewportMargin * 2;
      let placement = {
        anchor: preferredAnchor.value,
        origin: preferredOrigin.value
      };
      function checkOverflow(_placement) {
        const box = new Box(contentBox);
        const targetPoint = anchorToPoint(_placement.anchor, targetBox);
        const contentPoint = anchorToPoint(_placement.origin, box);
        let {
          x: x2,
          y: y2
        } = getOffset2(targetPoint, contentPoint);
        switch (_placement.anchor.side) {
          case "top":
            y2 -= offset.value[0];
            break;
          case "bottom":
            y2 += offset.value[0];
            break;
          case "left":
            x2 -= offset.value[0];
            break;
          case "right":
            x2 += offset.value[0];
            break;
        }
        switch (_placement.anchor.align) {
          case "top":
            y2 -= offset.value[1];
            break;
          case "bottom":
            y2 += offset.value[1];
            break;
          case "left":
            x2 -= offset.value[1];
            break;
          case "right":
            x2 += offset.value[1];
            break;
        }
        box.x += x2;
        box.y += y2;
        box.width = Math.min(box.width, maxWidth.value);
        box.height = Math.min(box.height, maxHeight.value);
        const overflows = getOverflow(box, viewport);
        return {
          overflows,
          x: x2,
          y: y2
        };
      }
      let x = 0;
      let y = 0;
      const available = {
        x: 0,
        y: 0
      };
      const flipped2 = {
        x: false,
        y: false
      };
      let resets = -1;
      while (true) {
        if (resets++ > 10) {
          consoleError("Infinite loop detected in connectedLocationStrategy");
          break;
        }
        const {
          x: _x,
          y: _y,
          overflows
        } = checkOverflow(placement);
        x += _x;
        y += _y;
        contentBox.x += _x;
        contentBox.y += _y;
        {
          const axis2 = getAxis(placement.anchor);
          const hasOverflowX = overflows.x.before || overflows.x.after;
          const hasOverflowY = overflows.y.before || overflows.y.after;
          let reset = false;
          ["x", "y"].forEach((key) => {
            if (key === "x" && hasOverflowX && !flipped2.x || key === "y" && hasOverflowY && !flipped2.y) {
              const newPlacement = {
                anchor: __spreadValues({}, placement.anchor),
                origin: __spreadValues({}, placement.origin)
              };
              const flip = key === "x" ? axis2 === "y" ? flipAlign : flipSide : axis2 === "y" ? flipSide : flipAlign;
              newPlacement.anchor = flip(newPlacement.anchor);
              newPlacement.origin = flip(newPlacement.origin);
              const {
                overflows: newOverflows
              } = checkOverflow(newPlacement);
              if (newOverflows[key].before <= overflows[key].before && newOverflows[key].after <= overflows[key].after || newOverflows[key].before + newOverflows[key].after < (overflows[key].before + overflows[key].after) / 2) {
                placement = newPlacement;
                reset = flipped2[key] = true;
              }
            }
          });
          if (reset)
            continue;
        }
        if (overflows.x.before) {
          x += overflows.x.before;
          contentBox.x += overflows.x.before;
        }
        if (overflows.x.after) {
          x -= overflows.x.after;
          contentBox.x -= overflows.x.after;
        }
        if (overflows.y.before) {
          y += overflows.y.before;
          contentBox.y += overflows.y.before;
        }
        if (overflows.y.after) {
          y -= overflows.y.after;
          contentBox.y -= overflows.y.after;
        }
        {
          const overflows2 = getOverflow(contentBox, viewport);
          available.x = viewport.width - overflows2.x.before - overflows2.x.after;
          available.y = viewport.height - overflows2.y.before - overflows2.y.after;
          x += overflows2.x.before;
          contentBox.x += overflows2.x.before;
          y += overflows2.y.before;
          contentBox.y += overflows2.y.before;
        }
        break;
      }
      const axis = getAxis(placement.anchor);
      Object.assign(contentStyles.value, {
        "--v-overlay-anchor-origin": `${placement.anchor.side} ${placement.anchor.align}`,
        transformOrigin: `${placement.origin.side} ${placement.origin.align}`,
        top: convertToUnit(pixelRound(y)),
        left: data.isRtl.value ? void 0 : convertToUnit(pixelRound(x)),
        right: data.isRtl.value ? convertToUnit(pixelRound(-x)) : void 0,
        minWidth: convertToUnit(axis === "y" ? Math.min(minWidth.value, targetBox.width) : minWidth.value),
        maxWidth: convertToUnit(pixelCeil(clamp(available.x, minWidth.value === Infinity ? 0 : minWidth.value, maxWidth.value))),
        maxHeight: convertToUnit(pixelCeil(clamp(available.y, minHeight.value === Infinity ? 0 : minHeight.value, maxHeight.value)))
      });
      return {
        available,
        contentBox,
        flipped: flipped2
      };
    }
    watch2(() => [preferredAnchor.value, preferredOrigin.value, props.offset, props.minWidth, props.minHeight, props.maxWidth, props.maxHeight], () => updateLocation());
    nextTick(() => {
      const result = updateLocation();
      if (!result)
        return;
      const {
        available,
        contentBox
      } = result;
      if (contentBox.height > available.y) {
        requestAnimationFrame(() => {
          updateLocation();
          requestAnimationFrame(() => {
            updateLocation();
          });
        });
      }
    });
    return {
      updateLocation
    };
  }
  function pixelRound(val) {
    return Math.round(val * devicePixelRatio) / devicePixelRatio;
  }
  function pixelCeil(val) {
    return Math.ceil(val * devicePixelRatio) / devicePixelRatio;
  }

  // ../posawesome/node_modules/vuetify/lib/components/VOverlay/requestNewFrame.js
  var clean = true;
  var frames = [];
  function requestNewFrame(cb) {
    if (!clean || frames.length) {
      frames.push(cb);
      run();
    } else {
      clean = false;
      cb();
      run();
    }
  }
  var raf = -1;
  function run() {
    cancelAnimationFrame(raf);
    raf = requestAnimationFrame(() => {
      const frame = frames.shift();
      if (frame)
        frame();
      if (frames.length)
        run();
      else
        clean = true;
    });
  }

  // ../posawesome/node_modules/vuetify/lib/components/VOverlay/scrollStrategies.js
  var scrollStrategies = {
    none: null,
    close: closeScrollStrategy,
    block: blockScrollStrategy,
    reposition: repositionScrollStrategy
  };
  var makeScrollStrategyProps = propsFactory({
    scrollStrategy: {
      type: [String, Function],
      default: "block",
      validator: (val) => typeof val === "function" || val in scrollStrategies
    }
  }, "VOverlay-scroll-strategies");
  function useScrollStrategies(props, data) {
    if (!IN_BROWSER)
      return;
    let scope;
    watchEffect(async () => {
      scope == null ? void 0 : scope.stop();
      if (!(data.isActive.value && props.scrollStrategy))
        return;
      scope = effectScope();
      await new Promise((resolve2) => setTimeout(resolve2));
      scope.active && scope.run(() => {
        var _a3;
        if (typeof props.scrollStrategy === "function") {
          props.scrollStrategy(data, props, scope);
        } else {
          (_a3 = scrollStrategies[props.scrollStrategy]) == null ? void 0 : _a3.call(scrollStrategies, data, props, scope);
        }
      });
    });
    onScopeDispose(() => {
      scope == null ? void 0 : scope.stop();
    });
  }
  function closeScrollStrategy(data) {
    var _a3;
    function onScroll(e) {
      data.isActive.value = false;
    }
    bindScroll((_a3 = data.targetEl.value) != null ? _a3 : data.contentEl.value, onScroll);
  }
  function blockScrollStrategy(data, props) {
    var _a3;
    const offsetParent = (_a3 = data.root.value) == null ? void 0 : _a3.offsetParent;
    const scrollElements = [.../* @__PURE__ */ new Set([...getScrollParents(data.targetEl.value, props.contained ? offsetParent : void 0), ...getScrollParents(data.contentEl.value, props.contained ? offsetParent : void 0)])].filter((el) => !el.classList.contains("v-overlay-scroll-blocked"));
    const scrollbarWidth = window.innerWidth - document.documentElement.offsetWidth;
    const scrollableParent = ((el) => hasScrollbar(el) && el)(offsetParent || document.documentElement);
    if (scrollableParent) {
      data.root.value.classList.add("v-overlay--scroll-blocked");
    }
    scrollElements.forEach((el, i) => {
      el.style.setProperty("--v-body-scroll-x", convertToUnit(-el.scrollLeft));
      el.style.setProperty("--v-body-scroll-y", convertToUnit(-el.scrollTop));
      if (el !== document.documentElement) {
        el.style.setProperty("--v-scrollbar-offset", convertToUnit(scrollbarWidth));
      }
      el.classList.add("v-overlay-scroll-blocked");
    });
    onScopeDispose(() => {
      scrollElements.forEach((el, i) => {
        const x = parseFloat(el.style.getPropertyValue("--v-body-scroll-x"));
        const y = parseFloat(el.style.getPropertyValue("--v-body-scroll-y"));
        const scrollBehavior = el.style.scrollBehavior;
        el.style.scrollBehavior = "auto";
        el.style.removeProperty("--v-body-scroll-x");
        el.style.removeProperty("--v-body-scroll-y");
        el.style.removeProperty("--v-scrollbar-offset");
        el.classList.remove("v-overlay-scroll-blocked");
        el.scrollLeft = -x;
        el.scrollTop = -y;
        el.style.scrollBehavior = scrollBehavior;
      });
      if (scrollableParent) {
        data.root.value.classList.remove("v-overlay--scroll-blocked");
      }
    });
  }
  function repositionScrollStrategy(data, props, scope) {
    let slow = false;
    let raf2 = -1;
    let ric = -1;
    function update(e) {
      requestNewFrame(() => {
        var _a3, _b;
        const start = performance.now();
        (_b = (_a3 = data.updateLocation).value) == null ? void 0 : _b.call(_a3, e);
        const time = performance.now() - start;
        slow = time / (1e3 / 60) > 2;
      });
    }
    ric = (typeof requestIdleCallback === "undefined" ? (cb) => cb() : requestIdleCallback)(() => {
      scope.run(() => {
        var _a3;
        bindScroll((_a3 = data.targetEl.value) != null ? _a3 : data.contentEl.value, (e) => {
          if (slow) {
            cancelAnimationFrame(raf2);
            raf2 = requestAnimationFrame(() => {
              raf2 = requestAnimationFrame(() => {
                update(e);
              });
            });
          } else {
            update(e);
          }
        });
      });
    });
    onScopeDispose(() => {
      typeof cancelIdleCallback !== "undefined" && cancelIdleCallback(ric);
      cancelAnimationFrame(raf2);
    });
  }
  function bindScroll(el, onScroll) {
    const scrollElements = [document, ...getScrollParents(el)];
    scrollElements.forEach((el2) => {
      el2.addEventListener("scroll", onScroll, {
        passive: true
      });
    });
    onScopeDispose(() => {
      scrollElements.forEach((el2) => {
        el2.removeEventListener("scroll", onScroll);
      });
    });
  }

  // ../posawesome/node_modules/vuetify/lib/components/VMenu/shared.js
  var VMenuSymbol = Symbol.for("vuetify:v-menu");

  // ../posawesome/node_modules/vuetify/lib/composables/delay.js
  var makeDelayProps = propsFactory({
    closeDelay: [Number, String],
    openDelay: [Number, String]
  }, "delay");
  function useDelay(props, cb) {
    let clearDelay = () => {
    };
    function runDelay(isOpening) {
      clearDelay == null ? void 0 : clearDelay();
      const delay = Number(isOpening ? props.openDelay : props.closeDelay);
      return new Promise((resolve2) => {
        clearDelay = defer(delay, () => {
          cb == null ? void 0 : cb(isOpening);
          resolve2(isOpening);
        });
      });
    }
    function runOpenDelay() {
      return runDelay(true);
    }
    function runCloseDelay() {
      return runDelay(false);
    }
    return {
      clearDelay,
      runOpenDelay,
      runCloseDelay
    };
  }

  // ../posawesome/node_modules/vuetify/lib/components/VOverlay/useActivator.js
  var makeActivatorProps = propsFactory(__spreadValues({
    target: [String, Object],
    activator: [String, Object],
    activatorProps: {
      type: Object,
      default: () => ({})
    },
    openOnClick: {
      type: Boolean,
      default: void 0
    },
    openOnHover: Boolean,
    openOnFocus: {
      type: Boolean,
      default: void 0
    },
    closeOnContentClick: Boolean
  }, makeDelayProps()), "VOverlay-activator");
  function useActivator(props, _ref) {
    let {
      isActive,
      isTop,
      contentEl
    } = _ref;
    const vm2 = getCurrentInstance2("useActivator");
    const activatorEl = ref();
    let isHovered = false;
    let isFocused = false;
    let firstEnter = true;
    const openOnFocus = computed2(() => props.openOnFocus || props.openOnFocus == null && props.openOnHover);
    const openOnClick = computed2(() => props.openOnClick || props.openOnClick == null && !props.openOnHover && !openOnFocus.value);
    const {
      runOpenDelay,
      runCloseDelay
    } = useDelay(props, (value) => {
      if (value === (props.openOnHover && isHovered || openOnFocus.value && isFocused) && !(props.openOnHover && isActive.value && !isTop.value)) {
        if (isActive.value !== value) {
          firstEnter = true;
        }
        isActive.value = value;
      }
    });
    const cursorTarget = ref();
    const availableEvents = {
      onClick: (e) => {
        e.stopPropagation();
        activatorEl.value = e.currentTarget || e.target;
        if (!isActive.value) {
          cursorTarget.value = [e.clientX, e.clientY];
        }
        isActive.value = !isActive.value;
      },
      onMouseenter: (e) => {
        var _a3;
        if ((_a3 = e.sourceCapabilities) == null ? void 0 : _a3.firesTouchEvents)
          return;
        isHovered = true;
        activatorEl.value = e.currentTarget || e.target;
        runOpenDelay();
      },
      onMouseleave: (e) => {
        isHovered = false;
        runCloseDelay();
      },
      onFocus: (e) => {
        if (matchesSelector(e.target, ":focus-visible") === false)
          return;
        isFocused = true;
        e.stopPropagation();
        activatorEl.value = e.currentTarget || e.target;
        runOpenDelay();
      },
      onBlur: (e) => {
        isFocused = false;
        e.stopPropagation();
        runCloseDelay();
      }
    };
    const activatorEvents = computed2(() => {
      const events = {};
      if (openOnClick.value) {
        events.onClick = availableEvents.onClick;
      }
      if (props.openOnHover) {
        events.onMouseenter = availableEvents.onMouseenter;
        events.onMouseleave = availableEvents.onMouseleave;
      }
      if (openOnFocus.value) {
        events.onFocus = availableEvents.onFocus;
        events.onBlur = availableEvents.onBlur;
      }
      return events;
    });
    const contentEvents = computed2(() => {
      const events = {};
      if (props.openOnHover) {
        events.onMouseenter = () => {
          isHovered = true;
          runOpenDelay();
        };
        events.onMouseleave = () => {
          isHovered = false;
          runCloseDelay();
        };
      }
      if (openOnFocus.value) {
        events.onFocusin = () => {
          isFocused = true;
          runOpenDelay();
        };
        events.onFocusout = () => {
          isFocused = false;
          runCloseDelay();
        };
      }
      if (props.closeOnContentClick) {
        const menu = inject(VMenuSymbol, null);
        events.onClick = () => {
          isActive.value = false;
          menu == null ? void 0 : menu.closeParents();
        };
      }
      return events;
    });
    const scrimEvents = computed2(() => {
      const events = {};
      if (props.openOnHover) {
        events.onMouseenter = () => {
          if (firstEnter) {
            isHovered = true;
            firstEnter = false;
            runOpenDelay();
          }
        };
        events.onMouseleave = () => {
          isHovered = false;
          runCloseDelay();
        };
      }
      return events;
    });
    watch2(isTop, (val) => {
      var _a3;
      if (val && (props.openOnHover && !isHovered && (!openOnFocus.value || !isFocused) || openOnFocus.value && !isFocused && (!props.openOnHover || !isHovered)) && !((_a3 = contentEl.value) == null ? void 0 : _a3.contains(document.activeElement))) {
        isActive.value = false;
      }
    });
    watch2(isActive, (val) => {
      if (!val) {
        setTimeout(() => {
          cursorTarget.value = void 0;
        });
      }
    }, {
      flush: "post"
    });
    const activatorRef = templateRef();
    watchEffect(() => {
      if (!activatorRef.value)
        return;
      nextTick(() => {
        activatorEl.value = activatorRef.el;
      });
    });
    const targetRef = templateRef();
    const target = computed2(() => {
      if (props.target === "cursor" && cursorTarget.value)
        return cursorTarget.value;
      if (targetRef.value)
        return targetRef.el;
      return getTarget2(props.target, vm2) || activatorEl.value;
    });
    const targetEl = computed2(() => {
      return Array.isArray(target.value) ? void 0 : target.value;
    });
    let scope;
    watch2(() => !!props.activator, (val) => {
      if (val && IN_BROWSER) {
        scope = effectScope();
        scope.run(() => {
          _useActivator(props, vm2, {
            activatorEl,
            activatorEvents
          });
        });
      } else if (scope) {
        scope.stop();
      }
    }, {
      flush: "post",
      immediate: true
    });
    onScopeDispose(() => {
      scope == null ? void 0 : scope.stop();
    });
    return {
      activatorEl,
      activatorRef,
      target,
      targetEl,
      targetRef,
      activatorEvents,
      contentEvents,
      scrimEvents
    };
  }
  function _useActivator(props, vm2, _ref2) {
    let {
      activatorEl,
      activatorEvents
    } = _ref2;
    watch2(() => props.activator, (val, oldVal) => {
      if (oldVal && val !== oldVal) {
        const activator = getActivator(oldVal);
        activator && unbindActivatorProps(activator);
      }
      if (val) {
        nextTick(() => bindActivatorProps());
      }
    }, {
      immediate: true
    });
    watch2(() => props.activatorProps, () => {
      bindActivatorProps();
    });
    onScopeDispose(() => {
      unbindActivatorProps();
    });
    function bindActivatorProps() {
      let el = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getActivator();
      let _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : props.activatorProps;
      if (!el)
        return;
      bindProps(el, mergeProps(activatorEvents.value, _props));
    }
    function unbindActivatorProps() {
      let el = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getActivator();
      let _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : props.activatorProps;
      if (!el)
        return;
      unbindProps(el, mergeProps(activatorEvents.value, _props));
    }
    function getActivator() {
      let selector = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : props.activator;
      const activator = getTarget2(selector, vm2);
      activatorEl.value = (activator == null ? void 0 : activator.nodeType) === Node.ELEMENT_NODE ? activator : void 0;
      return activatorEl.value;
    }
  }
  function getTarget2(selector, vm2) {
    var _a3, _b;
    if (!selector)
      return;
    let target;
    if (selector === "parent") {
      let el = (_b = (_a3 = vm2 == null ? void 0 : vm2.proxy) == null ? void 0 : _a3.$el) == null ? void 0 : _b.parentNode;
      while (el == null ? void 0 : el.hasAttribute("data-no-activator")) {
        el = el.parentNode;
      }
      target = el;
    } else if (typeof selector === "string") {
      target = document.querySelector(selector);
    } else if ("$el" in selector) {
      target = selector.$el;
    } else {
      target = selector;
    }
    return target;
  }

  // ../posawesome/node_modules/vuetify/lib/composables/hydration.js
  function useHydration() {
    if (!IN_BROWSER)
      return shallowRef(false);
    const {
      ssr
    } = useDisplay();
    if (ssr) {
      const isMounted = shallowRef(false);
      onMounted(() => {
        isMounted.value = true;
      });
      return isMounted;
    } else {
      return shallowRef(true);
    }
  }

  // ../posawesome/node_modules/vuetify/lib/composables/lazy.js
  var makeLazyProps = propsFactory({
    eager: Boolean
  }, "lazy");
  function useLazy(props, active) {
    const isBooted = shallowRef(false);
    const hasContent = toRef(() => isBooted.value || props.eager || active.value);
    watch2(active, () => isBooted.value = true);
    function onAfterLeave() {
      if (!props.eager)
        isBooted.value = false;
    }
    return {
      isBooted,
      hasContent,
      onAfterLeave
    };
  }

  // ../posawesome/node_modules/vuetify/lib/composables/scopeId.js
  function useScopeId() {
    const vm2 = getCurrentInstance2("useScopeId");
    const scopeId = vm2.vnode.scopeId;
    return {
      scopeId: scopeId ? {
        [scopeId]: ""
      } : void 0
    };
  }

  // ../posawesome/node_modules/vuetify/lib/composables/stack.js
  var StackSymbol = Symbol.for("vuetify:stack");
  var globalStack = reactive([]);
  function useStack(isActive, zIndex, disableGlobalStack) {
    const vm2 = getCurrentInstance2("useStack");
    const createStackEntry = !disableGlobalStack;
    const parent = inject(StackSymbol, void 0);
    const stack2 = reactive({
      activeChildren: /* @__PURE__ */ new Set()
    });
    provide(StackSymbol, stack2);
    const _zIndex = shallowRef(Number(toValue(zIndex)));
    useToggleScope(isActive, () => {
      var _a3;
      const lastZIndex = (_a3 = globalStack.at(-1)) == null ? void 0 : _a3[1];
      _zIndex.value = lastZIndex ? lastZIndex + 10 : Number(toValue(zIndex));
      if (createStackEntry) {
        globalStack.push([vm2.uid, _zIndex.value]);
      }
      parent == null ? void 0 : parent.activeChildren.add(vm2.uid);
      onScopeDispose(() => {
        if (createStackEntry) {
          const idx = toRaw(globalStack).findIndex((v) => v[0] === vm2.uid);
          globalStack.splice(idx, 1);
        }
        parent == null ? void 0 : parent.activeChildren.delete(vm2.uid);
      });
    });
    const globalTop = shallowRef(true);
    if (createStackEntry) {
      watchEffect(() => {
        var _a3;
        const _isTop = ((_a3 = globalStack.at(-1)) == null ? void 0 : _a3[0]) === vm2.uid;
        setTimeout(() => globalTop.value = _isTop);
      });
    }
    const localTop = toRef(() => !stack2.activeChildren.size);
    return {
      globalTop: readonly(globalTop),
      localTop,
      stackStyles: toRef(() => ({
        zIndex: _zIndex.value
      }))
    };
  }

  // ../posawesome/node_modules/vuetify/lib/composables/teleport.js
  function useTeleport(target) {
    const teleportTarget = computed2(() => {
      const _target = target();
      if (_target === true || !IN_BROWSER)
        return void 0;
      const targetElement = _target === false ? document.body : typeof _target === "string" ? document.querySelector(_target) : _target;
      if (targetElement == null) {
        warn2(`Unable to locate target ${_target}`);
        return void 0;
      }
      let container = [...targetElement.children].find((el) => el.matches(".v-overlay-container"));
      if (!container) {
        container = document.createElement("div");
        container.className = "v-overlay-container";
        targetElement.appendChild(container);
      }
      return container;
    });
    return {
      teleportTarget
    };
  }

  // ../posawesome/node_modules/vuetify/lib/directives/click-outside/index.js
  function defaultConditional() {
    return true;
  }
  function checkEvent(e, el, binding) {
    if (!e || checkIsActive(e, binding) === false)
      return false;
    const root = attachedRoot(el);
    if (typeof ShadowRoot !== "undefined" && root instanceof ShadowRoot && root.host === e.target)
      return false;
    const elements = (typeof binding.value === "object" && binding.value.include || (() => []))();
    elements.push(el);
    return !elements.some((el2) => el2 == null ? void 0 : el2.contains(e.target));
  }
  function checkIsActive(e, binding) {
    const isActive = typeof binding.value === "object" && binding.value.closeConditional || defaultConditional;
    return isActive(e);
  }
  function directive(e, el, binding) {
    const handler = typeof binding.value === "function" ? binding.value : binding.value.handler;
    e.shadowTarget = e.target;
    el._clickOutside.lastMousedownWasOutside && checkEvent(e, el, binding) && setTimeout(() => {
      checkIsActive(e, binding) && handler && handler(e);
    }, 0);
  }
  function handleShadow(el, callback) {
    const root = attachedRoot(el);
    callback(document);
    if (typeof ShadowRoot !== "undefined" && root instanceof ShadowRoot) {
      callback(root);
    }
  }
  var ClickOutside = {
    mounted(el, binding) {
      const onClick = (e) => directive(e, el, binding);
      const onMousedown = (e) => {
        el._clickOutside.lastMousedownWasOutside = checkEvent(e, el, binding);
      };
      handleShadow(el, (app) => {
        app.addEventListener("click", onClick, true);
        app.addEventListener("mousedown", onMousedown, true);
      });
      if (!el._clickOutside) {
        el._clickOutside = {
          lastMousedownWasOutside: false
        };
      }
      el._clickOutside[binding.instance.$.uid] = {
        onClick,
        onMousedown
      };
    },
    beforeUnmount(el, binding) {
      if (!el._clickOutside)
        return;
      handleShadow(el, (app) => {
        var _a3;
        if (!app || !((_a3 = el._clickOutside) == null ? void 0 : _a3[binding.instance.$.uid]))
          return;
        const {
          onClick,
          onMousedown
        } = el._clickOutside[binding.instance.$.uid];
        app.removeEventListener("click", onClick, true);
        app.removeEventListener("mousedown", onMousedown, true);
      });
      delete el._clickOutside[binding.instance.$.uid];
    }
  };
  var click_outside_default = ClickOutside;

  // ../posawesome/node_modules/vuetify/lib/components/VOverlay/VOverlay.js
  function Scrim(props) {
    const _a3 = props, {
      modelValue,
      color
    } = _a3, rest = __objRest(_a3, [
      "modelValue",
      "color"
    ]);
    return createVNode(Transition, {
      "name": "fade-transition",
      "appear": true
    }, {
      default: () => [props.modelValue && createBaseVNode("div", mergeProps({
        "class": ["v-overlay__scrim", props.color.backgroundColorClasses.value],
        "style": props.color.backgroundColorStyles.value
      }, rest), null)]
    });
  }
  var makeVOverlayProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    absolute: Boolean,
    attach: [Boolean, String, Object],
    closeOnBack: {
      type: Boolean,
      default: true
    },
    contained: Boolean,
    contentClass: null,
    contentProps: null,
    disabled: Boolean,
    opacity: [Number, String],
    noClickAnimation: Boolean,
    modelValue: Boolean,
    persistent: Boolean,
    scrim: {
      type: [Boolean, String],
      default: true
    },
    zIndex: {
      type: [Number, String],
      default: 2e3
    }
  }, makeActivatorProps()), makeComponentProps()), makeDimensionProps()), makeLazyProps()), makeLocationStrategyProps()), makeScrollStrategyProps()), makeThemeProps()), makeTransitionProps2()), "VOverlay");
  var VOverlay = genericComponent()({
    name: "VOverlay",
    directives: {
      vClickOutside: click_outside_default
    },
    inheritAttrs: false,
    props: __spreadValues({
      _disableGlobalStack: Boolean
    }, makeVOverlayProps()),
    emits: {
      "click:outside": (e) => true,
      "update:modelValue": (value) => true,
      keydown: (e) => true,
      afterEnter: () => true,
      afterLeave: () => true
    },
    setup(props, _ref) {
      let {
        slots,
        attrs,
        emit: emit2
      } = _ref;
      const vm2 = getCurrentInstance2("VOverlay");
      const root = ref();
      const scrimEl = ref();
      const contentEl = ref();
      const model = useProxiedModel(props, "modelValue");
      const isActive = computed2({
        get: () => model.value,
        set: (v) => {
          if (!(v && props.disabled))
            model.value = v;
        }
      });
      const {
        themeClasses
      } = provideTheme(props);
      const {
        rtlClasses,
        isRtl
      } = useRtl();
      const {
        hasContent,
        onAfterLeave: _onAfterLeave
      } = useLazy(props, isActive);
      const scrimColor = useBackgroundColor(() => {
        return typeof props.scrim === "string" ? props.scrim : null;
      });
      const {
        globalTop,
        localTop,
        stackStyles
      } = useStack(isActive, () => props.zIndex, props._disableGlobalStack);
      const {
        activatorEl,
        activatorRef,
        target,
        targetEl,
        targetRef,
        activatorEvents,
        contentEvents,
        scrimEvents
      } = useActivator(props, {
        isActive,
        isTop: localTop,
        contentEl
      });
      const {
        teleportTarget
      } = useTeleport(() => {
        var _a3, _b, _c;
        const target2 = props.attach || props.contained;
        if (target2)
          return target2;
        const rootNode = ((_a3 = activatorEl == null ? void 0 : activatorEl.value) == null ? void 0 : _a3.getRootNode()) || ((_c = (_b = vm2.proxy) == null ? void 0 : _b.$el) == null ? void 0 : _c.getRootNode());
        if (rootNode instanceof ShadowRoot)
          return rootNode;
        return false;
      });
      const {
        dimensionStyles
      } = useDimension(props);
      const isMounted = useHydration();
      const {
        scopeId
      } = useScopeId();
      watch2(() => props.disabled, (v) => {
        if (v)
          isActive.value = false;
      });
      const {
        contentStyles,
        updateLocation
      } = useLocationStrategies(props, {
        isRtl,
        contentEl,
        target,
        isActive
      });
      useScrollStrategies(props, {
        root,
        contentEl,
        targetEl,
        isActive,
        updateLocation
      });
      function onClickOutside(e) {
        emit2("click:outside", e);
        if (!props.persistent)
          isActive.value = false;
        else
          animateClick();
      }
      function closeConditional(e) {
        return isActive.value && globalTop.value && (!props.scrim || e.target === scrimEl.value || e instanceof MouseEvent && e.shadowTarget === scrimEl.value);
      }
      IN_BROWSER && watch2(isActive, (val) => {
        if (val) {
          window.addEventListener("keydown", onKeydown);
        } else {
          window.removeEventListener("keydown", onKeydown);
        }
      }, {
        immediate: true
      });
      onBeforeUnmount(() => {
        if (!IN_BROWSER)
          return;
        window.removeEventListener("keydown", onKeydown);
      });
      function onKeydown(e) {
        var _a3, _b, _c;
        if (e.key === "Escape" && globalTop.value) {
          if (!((_a3 = contentEl.value) == null ? void 0 : _a3.contains(document.activeElement))) {
            emit2("keydown", e);
          }
          if (!props.persistent) {
            isActive.value = false;
            if ((_b = contentEl.value) == null ? void 0 : _b.contains(document.activeElement)) {
              (_c = activatorEl.value) == null ? void 0 : _c.focus();
            }
          } else
            animateClick();
        }
      }
      function onKeydownSelf(e) {
        if (e.key === "Escape" && !globalTop.value)
          return;
        emit2("keydown", e);
      }
      const router = useRouter();
      useToggleScope(() => props.closeOnBack, () => {
        useBackButton(router, (next) => {
          if (globalTop.value && isActive.value) {
            next(false);
            if (!props.persistent)
              isActive.value = false;
            else
              animateClick();
          } else {
            next();
          }
        });
      });
      const top = ref();
      watch2(() => isActive.value && (props.absolute || props.contained) && teleportTarget.value == null, (val) => {
        if (val) {
          const scrollParent = getScrollParent(root.value);
          if (scrollParent && scrollParent !== document.scrollingElement) {
            top.value = scrollParent.scrollTop;
          }
        }
      });
      function animateClick() {
        if (props.noClickAnimation)
          return;
        contentEl.value && animate(contentEl.value, [{
          transformOrigin: "center"
        }, {
          transform: "scale(1.03)"
        }, {
          transformOrigin: "center"
        }], {
          duration: 150,
          easing: standardEasing
        });
      }
      function onAfterEnter() {
        emit2("afterEnter");
      }
      function onAfterLeave() {
        _onAfterLeave();
        emit2("afterLeave");
      }
      useRender(() => {
        var _a3;
        return createBaseVNode(Fragment, null, [(_a3 = slots.activator) == null ? void 0 : _a3.call(slots, {
          isActive: isActive.value,
          targetRef,
          props: mergeProps({
            ref: activatorRef
          }, activatorEvents.value, props.activatorProps)
        }), isMounted.value && hasContent.value && createVNode(Teleport, {
          "disabled": !teleportTarget.value,
          "to": teleportTarget.value
        }, {
          default: () => [createBaseVNode("div", mergeProps({
            "class": ["v-overlay", {
              "v-overlay--absolute": props.absolute || props.contained,
              "v-overlay--active": isActive.value,
              "v-overlay--contained": props.contained
            }, themeClasses.value, rtlClasses.value, props.class],
            "style": [stackStyles.value, {
              "--v-overlay-opacity": props.opacity,
              top: convertToUnit(top.value)
            }, props.style],
            "ref": root,
            "onKeydown": onKeydownSelf
          }, scopeId, attrs), [createVNode(Scrim, mergeProps({
            "color": scrimColor,
            "modelValue": isActive.value && !!props.scrim,
            "ref": scrimEl
          }, scrimEvents.value), null), createVNode(MaybeTransition, {
            "appear": true,
            "persisted": true,
            "transition": props.transition,
            "target": target.value,
            "onAfterEnter": onAfterEnter,
            "onAfterLeave": onAfterLeave
          }, {
            default: () => {
              var _a4;
              return [withDirectives(createBaseVNode("div", mergeProps({
                "ref": contentEl,
                "class": ["v-overlay__content", props.contentClass],
                "style": [dimensionStyles.value, contentStyles.value]
              }, contentEvents.value, props.contentProps), [(_a4 = slots.default) == null ? void 0 : _a4.call(slots, {
                isActive
              })]), [[vShow, isActive.value], [click_outside_default, {
                handler: onClickOutside,
                closeConditional,
                include: () => [activatorEl.value]
              }]])];
            }
          })])]
        })]);
      });
      return {
        activatorEl,
        scrimEl,
        target,
        animateClick,
        contentEl,
        globalTop,
        localTop,
        updateLocation
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/composables/forwardRefs.js
  var Refs = Symbol("Forwarded refs");
  function getDescriptor(obj, key) {
    let currentObj = obj;
    while (currentObj) {
      const descriptor = Reflect.getOwnPropertyDescriptor(currentObj, key);
      if (descriptor)
        return descriptor;
      currentObj = Object.getPrototypeOf(currentObj);
    }
    return void 0;
  }
  function forwardRefs(target) {
    for (var _len = arguments.length, refs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      refs[_key - 1] = arguments[_key];
    }
    target[Refs] = refs;
    return new Proxy(target, {
      get(target2, key) {
        if (Reflect.has(target2, key)) {
          return Reflect.get(target2, key);
        }
        if (typeof key === "symbol" || key.startsWith("$") || key.startsWith("__"))
          return;
        for (const ref2 of refs) {
          if (ref2.value && Reflect.has(ref2.value, key)) {
            const val = Reflect.get(ref2.value, key);
            return typeof val === "function" ? val.bind(ref2.value) : val;
          }
        }
      },
      has(target2, key) {
        if (Reflect.has(target2, key)) {
          return true;
        }
        if (typeof key === "symbol" || key.startsWith("$") || key.startsWith("__"))
          return false;
        for (const ref2 of refs) {
          if (ref2.value && Reflect.has(ref2.value, key)) {
            return true;
          }
        }
        return false;
      },
      set(target2, key, value) {
        if (Reflect.has(target2, key)) {
          return Reflect.set(target2, key, value);
        }
        if (typeof key === "symbol" || key.startsWith("$") || key.startsWith("__"))
          return false;
        for (const ref2 of refs) {
          if (ref2.value && Reflect.has(ref2.value, key)) {
            return Reflect.set(ref2.value, key, value);
          }
        }
        return false;
      },
      getOwnPropertyDescriptor(target2, key) {
        var _a3, _b;
        const descriptor = Reflect.getOwnPropertyDescriptor(target2, key);
        if (descriptor)
          return descriptor;
        if (typeof key === "symbol" || key.startsWith("$") || key.startsWith("__"))
          return;
        for (const ref2 of refs) {
          if (!ref2.value)
            continue;
          const descriptor2 = (_b = getDescriptor(ref2.value, key)) != null ? _b : "_" in ref2.value ? getDescriptor((_a3 = ref2.value._) == null ? void 0 : _a3.setupState, key) : void 0;
          if (descriptor2)
            return descriptor2;
        }
        for (const ref2 of refs) {
          const childRefs = ref2.value && ref2.value[Refs];
          if (!childRefs)
            continue;
          const queue2 = childRefs.slice();
          while (queue2.length) {
            const ref3 = queue2.shift();
            const descriptor2 = getDescriptor(ref3.value, key);
            if (descriptor2)
              return descriptor2;
            const childRefs2 = ref3.value && ref3.value[Refs];
            if (childRefs2)
              queue2.push(...childRefs2);
          }
        }
        return void 0;
      }
    });
  }

  // ../posawesome/node_modules/vuetify/lib/components/VMenu/VMenu.js
  var makeVMenuProps = propsFactory(__spreadValues({
    id: String,
    submenu: Boolean
  }, omit(makeVOverlayProps({
    closeDelay: 250,
    closeOnContentClick: true,
    locationStrategy: "connected",
    location: void 0,
    openDelay: 300,
    scrim: false,
    scrollStrategy: "reposition",
    transition: {
      component: VDialogTransition
    }
  }), ["absolute"])), "VMenu");
  var VMenu = genericComponent()({
    name: "VMenu",
    props: makeVMenuProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const isActive = useProxiedModel(props, "modelValue");
      const {
        scopeId
      } = useScopeId();
      const {
        isRtl
      } = useRtl();
      const uid2 = useId();
      const id = toRef(() => props.id || `v-menu-${uid2}`);
      const overlay = ref();
      const parent = inject(VMenuSymbol, null);
      const openChildren = shallowRef(/* @__PURE__ */ new Set());
      provide(VMenuSymbol, {
        register() {
          openChildren.value.add(uid2);
        },
        unregister() {
          openChildren.value.delete(uid2);
        },
        closeParents(e) {
          setTimeout(() => {
            var _a3;
            if (!openChildren.value.size && !props.persistent && (e == null || ((_a3 = overlay.value) == null ? void 0 : _a3.contentEl) && !isClickInsideElement(e, overlay.value.contentEl))) {
              isActive.value = false;
              parent == null ? void 0 : parent.closeParents();
            }
          }, 40);
        }
      });
      onBeforeUnmount(() => {
        parent == null ? void 0 : parent.unregister();
        document.removeEventListener("focusin", onFocusIn);
      });
      onDeactivated(() => isActive.value = false);
      async function onFocusIn(e) {
        var _a3, _b, _c;
        const before = e.relatedTarget;
        const after = e.target;
        await nextTick();
        if (isActive.value && before !== after && ((_a3 = overlay.value) == null ? void 0 : _a3.contentEl) && ((_b = overlay.value) == null ? void 0 : _b.globalTop) && ![document, overlay.value.contentEl].includes(after) && !overlay.value.contentEl.contains(after)) {
          const focusable = focusableChildren(overlay.value.contentEl);
          (_c = focusable[0]) == null ? void 0 : _c.focus();
        }
      }
      watch2(isActive, (val) => {
        if (val) {
          parent == null ? void 0 : parent.register();
          if (IN_BROWSER) {
            document.addEventListener("focusin", onFocusIn, {
              once: true
            });
          }
        } else {
          parent == null ? void 0 : parent.unregister();
          if (IN_BROWSER) {
            document.removeEventListener("focusin", onFocusIn);
          }
        }
      }, {
        immediate: true
      });
      function onClickOutside(e) {
        parent == null ? void 0 : parent.closeParents(e);
      }
      function onKeydown(e) {
        var _a3, _b, _c, _d, _e;
        if (props.disabled)
          return;
        if (e.key === "Tab" || e.key === "Enter" && !props.closeOnContentClick) {
          if (e.key === "Enter" && (e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLInputElement && !!e.target.closest("form")))
            return;
          if (e.key === "Enter")
            e.preventDefault();
          const nextElement = getNextElement(focusableChildren((_a3 = overlay.value) == null ? void 0 : _a3.contentEl, false), e.shiftKey ? "prev" : "next", (el) => el.tabIndex >= 0);
          if (!nextElement) {
            isActive.value = false;
            (_c = (_b = overlay.value) == null ? void 0 : _b.activatorEl) == null ? void 0 : _c.focus();
          }
        } else if (props.submenu && e.key === (isRtl.value ? "ArrowRight" : "ArrowLeft")) {
          isActive.value = false;
          (_e = (_d = overlay.value) == null ? void 0 : _d.activatorEl) == null ? void 0 : _e.focus();
        }
      }
      function onActivatorKeydown(e) {
        var _a3;
        if (props.disabled)
          return;
        const el = (_a3 = overlay.value) == null ? void 0 : _a3.contentEl;
        if (el && isActive.value) {
          if (e.key === "ArrowDown") {
            e.preventDefault();
            e.stopImmediatePropagation();
            focusChild(el, "next");
          } else if (e.key === "ArrowUp") {
            e.preventDefault();
            e.stopImmediatePropagation();
            focusChild(el, "prev");
          } else if (props.submenu) {
            if (e.key === (isRtl.value ? "ArrowRight" : "ArrowLeft")) {
              isActive.value = false;
            } else if (e.key === (isRtl.value ? "ArrowLeft" : "ArrowRight")) {
              e.preventDefault();
              focusChild(el, "first");
            }
          }
        } else if (props.submenu ? e.key === (isRtl.value ? "ArrowLeft" : "ArrowRight") : ["ArrowDown", "ArrowUp"].includes(e.key)) {
          isActive.value = true;
          e.preventDefault();
          setTimeout(() => setTimeout(() => onActivatorKeydown(e)));
        }
      }
      const activatorProps = computed2(() => mergeProps({
        "aria-haspopup": "menu",
        "aria-expanded": String(isActive.value),
        "aria-controls": id.value,
        onKeydown: onActivatorKeydown
      }, props.activatorProps));
      useRender(() => {
        var _a3;
        const overlayProps = VOverlay.filterProps(props);
        return createVNode(VOverlay, mergeProps({
          "ref": overlay,
          "id": id.value,
          "class": ["v-menu", props.class],
          "style": props.style
        }, overlayProps, {
          "modelValue": isActive.value,
          "onUpdate:modelValue": ($event) => isActive.value = $event,
          "absolute": true,
          "activatorProps": activatorProps.value,
          "location": (_a3 = props.location) != null ? _a3 : props.submenu ? "end" : "bottom",
          "onClick:outside": onClickOutside,
          "onKeydown": onKeydown
        }, scopeId), {
          activator: slots.activator,
          default: function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return createVNode(VDefaultsProvider, {
              "root": "VMenu"
            }, {
              default: () => {
                var _a4;
                return [(_a4 = slots.default) == null ? void 0 : _a4.call(slots, ...args)];
              }
            });
          }
        });
      });
      return forwardRefs({
        id,
        \u03A8openChildren: openChildren
      }, overlay);
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VCounter/VCounter.js
  var makeVCounterProps = propsFactory(__spreadValues(__spreadValues({
    active: Boolean,
    disabled: Boolean,
    max: [Number, String],
    value: {
      type: [Number, String],
      default: 0
    }
  }, makeComponentProps()), makeTransitionProps2({
    transition: {
      component: VSlideYTransition
    }
  })), "VCounter");
  var VCounter = genericComponent()({
    name: "VCounter",
    functional: true,
    props: makeVCounterProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const counter = toRef(() => {
        return props.max ? `${props.value} / ${props.max}` : String(props.value);
      });
      useRender(() => createVNode(MaybeTransition, {
        "transition": props.transition
      }, {
        default: () => [withDirectives(createBaseVNode("div", {
          "class": normalizeClass(["v-counter", {
            "text-error": props.max && !props.disabled && parseFloat(props.value) > parseFloat(props.max)
          }, props.class]),
          "style": normalizeStyle(props.style)
        }, [slots.default ? slots.default({
          counter: counter.value,
          max: props.max,
          value: props.value
        }) : counter.value]), [[vShow, props.active]])]
      }));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VField/VFieldLabel.js
  var makeVFieldLabelProps = propsFactory(__spreadValues({
    floating: Boolean
  }, makeComponentProps()), "VFieldLabel");
  var VFieldLabel = genericComponent()({
    name: "VFieldLabel",
    props: makeVFieldLabelProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => createVNode(VLabel, {
        "class": normalizeClass(["v-field-label", {
          "v-field-label--floating": props.floating
        }, props.class]),
        "style": normalizeStyle(props.style),
        "aria-hidden": props.floating || void 0
      }, slots));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VField/VField.js
  var allowedVariants2 = ["underlined", "outlined", "filled", "solo", "solo-inverted", "solo-filled", "plain"];
  var makeVFieldProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    appendInnerIcon: IconValue,
    bgColor: String,
    clearable: Boolean,
    clearIcon: {
      type: IconValue,
      default: "$clear"
    },
    active: Boolean,
    centerAffix: {
      type: Boolean,
      default: void 0
    },
    color: String,
    baseColor: String,
    dirty: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    glow: Boolean,
    error: Boolean,
    flat: Boolean,
    iconColor: [Boolean, String],
    label: String,
    persistentClear: Boolean,
    prependInnerIcon: IconValue,
    reverse: Boolean,
    singleLine: Boolean,
    variant: {
      type: String,
      default: "filled",
      validator: (v) => allowedVariants2.includes(v)
    },
    "onClick:clear": EventProp(),
    "onClick:appendInner": EventProp(),
    "onClick:prependInner": EventProp()
  }, makeComponentProps()), makeLoaderProps()), makeRoundedProps()), makeThemeProps()), "VField");
  var VField = genericComponent()({
    name: "VField",
    inheritAttrs: false,
    props: __spreadValues(__spreadValues({
      id: String
    }, makeFocusProps()), makeVFieldProps()),
    emits: {
      "update:focused": (focused) => true,
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        emit: emit2,
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        loaderClasses
      } = useLoader(props);
      const {
        focusClasses,
        isFocused,
        focus,
        blur
      } = useFocus(props);
      const {
        InputIcon
      } = useInputIcon(props);
      const {
        roundedClasses
      } = useRounded(props);
      const {
        rtlClasses
      } = useRtl();
      const isActive = toRef(() => props.dirty || props.active);
      const hasLabel = toRef(() => !!(props.label || slots.label));
      const hasFloatingLabel = toRef(() => !props.singleLine && hasLabel.value);
      const uid2 = useId();
      const id = computed2(() => props.id || `input-${uid2}`);
      const messagesId = toRef(() => `${id.value}-messages`);
      const labelRef = ref();
      const floatingLabelRef = ref();
      const controlRef = ref();
      const isPlainOrUnderlined = computed2(() => ["plain", "underlined"].includes(props.variant));
      const color = computed2(() => {
        return props.error || props.disabled ? void 0 : isActive.value && isFocused.value ? props.color : props.baseColor;
      });
      const iconColor = computed2(() => {
        if (!props.iconColor || props.glow && !isFocused.value)
          return void 0;
        return props.iconColor === true ? color.value : props.iconColor;
      });
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(() => props.bgColor);
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(color);
      watch2(isActive, (val) => {
        if (hasFloatingLabel.value) {
          const el = labelRef.value.$el;
          const targetEl = floatingLabelRef.value.$el;
          requestAnimationFrame(() => {
            const rect = nullifyTransforms(el);
            const targetRect = targetEl.getBoundingClientRect();
            const x = targetRect.x - rect.x;
            const y = targetRect.y - rect.y - (rect.height / 2 - targetRect.height / 2);
            const targetWidth = targetRect.width / 0.75;
            const width = Math.abs(targetWidth - rect.width) > 1 ? {
              maxWidth: convertToUnit(targetWidth)
            } : void 0;
            const style = getComputedStyle(el);
            const targetStyle = getComputedStyle(targetEl);
            const duration = parseFloat(style.transitionDuration) * 1e3 || 150;
            const scale = parseFloat(targetStyle.getPropertyValue("--v-field-label-scale"));
            const color2 = targetStyle.getPropertyValue("color");
            el.style.visibility = "visible";
            targetEl.style.visibility = "hidden";
            animate(el, __spreadValues({
              transform: `translate(${x}px, ${y}px) scale(${scale})`,
              color: color2
            }, width), {
              duration,
              easing: standardEasing,
              direction: val ? "normal" : "reverse"
            }).finished.then(() => {
              el.style.removeProperty("visibility");
              targetEl.style.removeProperty("visibility");
            });
          });
        }
      }, {
        flush: "post"
      });
      const slotProps = computed2(() => ({
        isActive,
        isFocused,
        controlRef,
        blur,
        focus
      }));
      function onClick(e) {
        if (e.target !== document.activeElement) {
          e.preventDefault();
        }
      }
      useRender(() => {
        var _a3, _b, _c, _d, _e;
        const isOutlined = props.variant === "outlined";
        const hasPrepend = !!(slots["prepend-inner"] || props.prependInnerIcon);
        const hasClear = !!(props.clearable || slots.clear) && !props.disabled;
        const hasAppend = !!(slots["append-inner"] || props.appendInnerIcon || hasClear);
        const label = () => slots.label ? slots.label(__spreadProps(__spreadValues({}, slotProps.value), {
          label: props.label,
          props: {
            for: id.value
          }
        })) : props.label;
        return createBaseVNode("div", mergeProps({
          "class": ["v-field", {
            "v-field--active": isActive.value,
            "v-field--appended": hasAppend,
            "v-field--center-affix": (_a3 = props.centerAffix) != null ? _a3 : !isPlainOrUnderlined.value,
            "v-field--disabled": props.disabled,
            "v-field--dirty": props.dirty,
            "v-field--error": props.error,
            "v-field--glow": props.glow,
            "v-field--flat": props.flat,
            "v-field--has-background": !!props.bgColor,
            "v-field--persistent-clear": props.persistentClear,
            "v-field--prepended": hasPrepend,
            "v-field--reverse": props.reverse,
            "v-field--single-line": props.singleLine,
            "v-field--no-label": !label(),
            [`v-field--variant-${props.variant}`]: true
          }, themeClasses.value, backgroundColorClasses.value, focusClasses.value, loaderClasses.value, roundedClasses.value, rtlClasses.value, props.class],
          "style": [backgroundColorStyles.value, props.style],
          "onClick": onClick
        }, attrs), [createBaseVNode("div", {
          "class": "v-field__overlay"
        }, null), createVNode(LoaderSlot, {
          "name": "v-field",
          "active": !!props.loading,
          "color": props.error ? "error" : typeof props.loading === "string" ? props.loading : props.color
        }, {
          default: slots.loader
        }), hasPrepend && createBaseVNode("div", {
          "key": "prepend",
          "class": "v-field__prepend-inner",
          "onMousedown": (e) => {
            e.preventDefault();
            e.stopPropagation();
          }
        }, [props.prependInnerIcon && createVNode(InputIcon, {
          "key": "prepend-icon",
          "name": "prependInner",
          "color": iconColor.value
        }, null), (_b = slots["prepend-inner"]) == null ? void 0 : _b.call(slots, slotProps.value)]), createBaseVNode("div", {
          "class": "v-field__field",
          "data-no-activator": ""
        }, [["filled", "solo", "solo-inverted", "solo-filled"].includes(props.variant) && hasFloatingLabel.value && createVNode(VFieldLabel, {
          "key": "floating-label",
          "ref": floatingLabelRef,
          "class": normalizeClass([textColorClasses.value]),
          "floating": true,
          "for": id.value,
          "style": normalizeStyle(textColorStyles.value)
        }, {
          default: () => [label()]
        }), hasLabel.value && createVNode(VFieldLabel, {
          "key": "label",
          "ref": labelRef,
          "for": id.value
        }, {
          default: () => [label()]
        }), (_d = (_c = slots.default) == null ? void 0 : _c.call(slots, __spreadProps(__spreadValues({}, slotProps.value), {
          props: {
            id: id.value,
            class: "v-field__input",
            "aria-describedby": messagesId.value
          },
          focus,
          blur
        }))) != null ? _d : createBaseVNode("div", {
          "id": id.value,
          "class": "v-field__input",
          "aria-describedby": messagesId.value
        }, null)]), hasClear && createVNode(VExpandXTransition, {
          "key": "clear"
        }, {
          default: () => [withDirectives(createBaseVNode("div", {
            "class": "v-field__clearable",
            "onMousedown": (e) => {
              e.preventDefault();
              e.stopPropagation();
            }
          }, [createVNode(VDefaultsProvider, {
            "defaults": {
              VIcon: {
                icon: props.clearIcon
              }
            }
          }, {
            default: () => [slots.clear ? slots.clear(__spreadProps(__spreadValues({}, slotProps.value), {
              props: {
                onFocus: focus,
                onBlur: blur,
                onClick: props["onClick:clear"],
                tabindex: -1
              }
            })) : createVNode(InputIcon, {
              "name": "clear",
              "onFocus": focus,
              "onBlur": blur,
              "tabindex": -1
            }, null)]
          })]), [[vShow, props.dirty]])]
        }), hasAppend && createBaseVNode("div", {
          "key": "append",
          "class": "v-field__append-inner",
          "onMousedown": (e) => {
            e.preventDefault();
            e.stopPropagation();
          }
        }, [(_e = slots["append-inner"]) == null ? void 0 : _e.call(slots, slotProps.value), props.appendInnerIcon && createVNode(InputIcon, {
          "key": "append-icon",
          "name": "appendInner",
          "color": iconColor.value
        }, null)]), createBaseVNode("div", {
          "class": normalizeClass(["v-field__outline", textColorClasses.value]),
          "style": normalizeStyle(textColorStyles.value)
        }, [isOutlined && createBaseVNode(Fragment, null, [createBaseVNode("div", {
          "class": "v-field__outline__start"
        }, null), hasFloatingLabel.value && createBaseVNode("div", {
          "class": "v-field__outline__notch"
        }, [createVNode(VFieldLabel, {
          "ref": floatingLabelRef,
          "floating": true,
          "for": id.value
        }, {
          default: () => [label()]
        })]), createBaseVNode("div", {
          "class": "v-field__outline__end"
        }, null)]), isPlainOrUnderlined.value && hasFloatingLabel.value && createVNode(VFieldLabel, {
          "ref": floatingLabelRef,
          "floating": true,
          "for": id.value
        }, {
          default: () => [label()]
        })])]);
      });
      return {
        controlRef,
        fieldIconColor: iconColor
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/composables/autofocus.js
  function useAutofocus(props) {
    function onIntersect(isIntersecting, entries) {
      var _a3, _b;
      if (!props.autofocus || !isIntersecting)
        return;
      (_b = (_a3 = entries[0].target) == null ? void 0 : _a3.focus) == null ? void 0 : _b.call(_a3);
    }
    return {
      onIntersect
    };
  }

  // ../posawesome/node_modules/vuetify/lib/components/VTextField/VTextField.js
  var activeTypes = ["color", "file", "time", "date", "datetime-local", "week", "month"];
  var makeVTextFieldProps = propsFactory(__spreadValues(__spreadValues({
    autofocus: Boolean,
    counter: [Boolean, Number, String],
    counterValue: [Number, Function],
    prefix: String,
    placeholder: String,
    persistentPlaceholder: Boolean,
    persistentCounter: Boolean,
    suffix: String,
    role: String,
    type: {
      type: String,
      default: "text"
    },
    modelModifiers: Object
  }, makeVInputProps()), makeVFieldProps()), "VTextField");
  var VTextField = genericComponent()({
    name: "VTextField",
    directives: {
      vIntersect: intersect_default
    },
    inheritAttrs: false,
    props: makeVTextFieldProps(),
    emits: {
      "click:control": (e) => true,
      "mousedown:control": (e) => true,
      "update:focused": (focused) => true,
      "update:modelValue": (val) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        emit: emit2,
        slots
      } = _ref;
      const model = useProxiedModel(props, "modelValue");
      const {
        isFocused,
        focus,
        blur
      } = useFocus(props);
      const {
        onIntersect
      } = useAutofocus(props);
      const counterValue = computed2(() => {
        var _a3;
        return typeof props.counterValue === "function" ? props.counterValue(model.value) : typeof props.counterValue === "number" ? props.counterValue : ((_a3 = model.value) != null ? _a3 : "").toString().length;
      });
      const max = computed2(() => {
        if (attrs.maxlength)
          return attrs.maxlength;
        if (!props.counter || typeof props.counter !== "number" && typeof props.counter !== "string")
          return void 0;
        return props.counter;
      });
      const isPlainOrUnderlined = computed2(() => ["plain", "underlined"].includes(props.variant));
      const vInputRef = ref();
      const vFieldRef = ref();
      const inputRef = ref();
      const isActive = computed2(() => activeTypes.includes(props.type) || props.persistentPlaceholder || isFocused.value || props.active);
      function onFocus() {
        if (!isFocused.value)
          focus();
        nextTick(() => {
          var _a3;
          if (inputRef.value !== document.activeElement) {
            (_a3 = inputRef.value) == null ? void 0 : _a3.focus();
          }
        });
      }
      function onControlMousedown(e) {
        emit2("mousedown:control", e);
        if (e.target === inputRef.value)
          return;
        onFocus();
        e.preventDefault();
      }
      function onControlClick(e) {
        emit2("click:control", e);
      }
      function onClear(e, reset) {
        e.stopPropagation();
        onFocus();
        nextTick(() => {
          model.value = null;
          reset();
          callEvent(props["onClick:clear"], e);
        });
      }
      function onInput(e) {
        var _a3;
        const el = e.target;
        model.value = el.value;
        if (((_a3 = props.modelModifiers) == null ? void 0 : _a3.trim) && ["text", "search", "password", "tel", "url"].includes(props.type)) {
          const caretPosition = [el.selectionStart, el.selectionEnd];
          nextTick(() => {
            el.selectionStart = caretPosition[0];
            el.selectionEnd = caretPosition[1];
          });
        }
      }
      useRender(() => {
        const hasCounter = !!(slots.counter || props.counter !== false && props.counter != null);
        const hasDetails = !!(hasCounter || slots.details);
        const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
        const _a3 = VInput.filterProps(props), {
          modelValue: _2
        } = _a3, inputProps = __objRest(_a3, [
          "modelValue"
        ]);
        const fieldProps = VField.filterProps(props);
        return createVNode(VInput, mergeProps({
          "ref": vInputRef,
          "modelValue": model.value,
          "onUpdate:modelValue": ($event) => model.value = $event,
          "class": ["v-text-field", {
            "v-text-field--prefixed": props.prefix,
            "v-text-field--suffixed": props.suffix,
            "v-input--plain-underlined": isPlainOrUnderlined.value
          }, props.class],
          "style": props.style
        }, rootAttrs, inputProps, {
          "centerAffix": !isPlainOrUnderlined.value,
          "focused": isFocused.value
        }), __spreadProps(__spreadValues({}, slots), {
          default: (_ref2) => {
            let {
              id,
              isDisabled,
              isDirty: isDirty2,
              isReadonly: isReadonly2,
              isValid: isValid3,
              reset
            } = _ref2;
            return createVNode(VField, mergeProps({
              "ref": vFieldRef,
              "onMousedown": onControlMousedown,
              "onClick": onControlClick,
              "onClick:clear": (e) => onClear(e, reset),
              "onClick:prependInner": props["onClick:prependInner"],
              "onClick:appendInner": props["onClick:appendInner"],
              "role": props.role
            }, fieldProps, {
              "id": id.value,
              "active": isActive.value || isDirty2.value,
              "dirty": isDirty2.value || props.dirty,
              "disabled": isDisabled.value,
              "focused": isFocused.value,
              "error": isValid3.value === false
            }), __spreadProps(__spreadValues({}, slots), {
              default: (_ref3) => {
                let {
                  props: _a4
                } = _ref3, _b = _a4, {
                  class: fieldClass
                } = _b, slotProps = __objRest(_b, [
                  "class"
                ]);
                const inputNode = withDirectives(createBaseVNode("input", mergeProps({
                  "ref": inputRef,
                  "value": model.value,
                  "onInput": onInput,
                  "autofocus": props.autofocus,
                  "readonly": isReadonly2.value,
                  "disabled": isDisabled.value,
                  "name": props.name,
                  "placeholder": props.placeholder,
                  "size": 1,
                  "type": props.type,
                  "onFocus": onFocus,
                  "onBlur": blur
                }, slotProps, inputAttrs), null), [[intersect_default, {
                  handler: onIntersect
                }, null, {
                  once: true
                }]]);
                return createBaseVNode(Fragment, null, [props.prefix && createBaseVNode("span", {
                  "class": "v-text-field__prefix"
                }, [createBaseVNode("span", {
                  "class": "v-text-field__prefix__text"
                }, [props.prefix])]), slots.default ? createBaseVNode("div", {
                  "class": normalizeClass(fieldClass),
                  "data-no-activator": ""
                }, [slots.default(), inputNode]) : cloneVNode(inputNode, {
                  class: fieldClass
                }), props.suffix && createBaseVNode("span", {
                  "class": "v-text-field__suffix"
                }, [createBaseVNode("span", {
                  "class": "v-text-field__suffix__text"
                }, [props.suffix])])]);
              }
            }));
          },
          details: hasDetails ? (slotProps) => {
            var _a4;
            return createBaseVNode(Fragment, null, [(_a4 = slots.details) == null ? void 0 : _a4.call(slots, slotProps), hasCounter && createBaseVNode(Fragment, null, [createBaseVNode("span", null, null), createVNode(VCounter, {
              "active": props.persistentCounter || isFocused.value,
              "value": counterValue.value,
              "max": max.value,
              "disabled": props.disabled
            }, slots.counter)])]);
          } : void 0
        }));
      });
      return forwardRefs({}, vInputRef, vFieldRef, inputRef);
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VVirtualScroll/VVirtualScrollItem.js
  var makeVVirtualScrollItemProps = propsFactory(__spreadValues({
    renderless: Boolean
  }, makeComponentProps()), "VVirtualScrollItem");
  var VVirtualScrollItem = genericComponent()({
    name: "VVirtualScrollItem",
    inheritAttrs: false,
    props: makeVVirtualScrollItemProps(),
    emits: {
      "update:height": (height) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        emit: emit2,
        slots
      } = _ref;
      const {
        resizeRef,
        contentRect
      } = useResizeObserver(void 0, "border");
      watch2(() => {
        var _a3;
        return (_a3 = contentRect.value) == null ? void 0 : _a3.height;
      }, (height) => {
        if (height != null)
          emit2("update:height", height);
      });
      useRender(() => {
        var _a3, _b;
        return props.renderless ? createBaseVNode(Fragment, null, [(_a3 = slots.default) == null ? void 0 : _a3.call(slots, {
          itemRef: resizeRef
        })]) : createBaseVNode("div", mergeProps({
          "ref": resizeRef,
          "class": ["v-virtual-scroll__item", props.class],
          "style": props.style
        }, attrs), [(_b = slots.default) == null ? void 0 : _b.call(slots)]);
      });
    }
  });

  // ../posawesome/node_modules/vuetify/lib/composables/virtual.js
  var UP = -1;
  var DOWN = 1;
  var BUFFER_PX = 100;
  var makeVirtualProps = propsFactory({
    itemHeight: {
      type: [Number, String],
      default: null
    },
    itemKey: {
      type: [String, Array, Function],
      default: null
    },
    height: [Number, String]
  }, "virtual");
  function useVirtual(props, items) {
    const display = useDisplay();
    const itemHeight = shallowRef(0);
    watchEffect(() => {
      itemHeight.value = parseFloat(props.itemHeight || 0);
    });
    const first = shallowRef(0);
    const last = shallowRef(Math.ceil(
      (parseInt(props.height) || display.height.value) / (itemHeight.value || 16)
    ) || 1);
    const paddingTop = shallowRef(0);
    const paddingBottom = shallowRef(0);
    const containerRef = ref();
    const markerRef = ref();
    let markerOffset = 0;
    const {
      resizeRef,
      contentRect
    } = useResizeObserver();
    watchEffect(() => {
      resizeRef.value = containerRef.value;
    });
    const viewportHeight = computed2(() => {
      var _a3;
      return containerRef.value === document.documentElement ? display.height.value : ((_a3 = contentRect.value) == null ? void 0 : _a3.height) || parseInt(props.height) || 0;
    });
    const hasInitialRender = computed2(() => {
      return !!(containerRef.value && markerRef.value && viewportHeight.value && itemHeight.value);
    });
    let sizes = Array.from({
      length: items.value.length
    });
    let offsets = Array.from({
      length: items.value.length
    });
    const updateTime = shallowRef(0);
    let targetScrollIndex = -1;
    function getSize(index) {
      return sizes[index] || itemHeight.value;
    }
    const updateOffsets = debounce(() => {
      const start = performance.now();
      offsets[0] = 0;
      const length = items.value.length;
      for (let i = 1; i <= length - 1; i++) {
        offsets[i] = (offsets[i - 1] || 0) + getSize(i - 1);
      }
      updateTime.value = Math.max(updateTime.value, performance.now() - start);
    }, updateTime);
    const unwatch = watch2(hasInitialRender, (v) => {
      if (!v)
        return;
      unwatch();
      markerOffset = markerRef.value.offsetTop;
      updateOffsets.immediate();
      calculateVisibleItems();
      if (!~targetScrollIndex)
        return;
      nextTick(() => {
        IN_BROWSER && window.requestAnimationFrame(() => {
          scrollToIndex(targetScrollIndex);
          targetScrollIndex = -1;
        });
      });
    });
    onScopeDispose(() => {
      updateOffsets.clear();
    });
    function handleItemResize(index, height) {
      const prevHeight = sizes[index];
      const prevMinHeight = itemHeight.value;
      itemHeight.value = prevMinHeight ? Math.min(itemHeight.value, height) : height;
      if (prevHeight !== height || prevMinHeight !== itemHeight.value) {
        sizes[index] = height;
        updateOffsets();
      }
    }
    function calculateOffset(index) {
      index = clamp(index, 0, items.value.length - 1);
      return offsets[index] || 0;
    }
    function calculateIndex(scrollTop) {
      return binaryClosest(offsets, scrollTop);
    }
    let lastScrollTop = 0;
    let scrollVelocity = 0;
    let lastScrollTime = 0;
    watch2(viewportHeight, (val, oldVal) => {
      if (oldVal) {
        calculateVisibleItems();
        if (val < oldVal) {
          requestAnimationFrame(() => {
            scrollVelocity = 0;
            calculateVisibleItems();
          });
        }
      }
    });
    let scrollTimeout = -1;
    function handleScroll() {
      if (!containerRef.value || !markerRef.value)
        return;
      const scrollTop = containerRef.value.scrollTop;
      const scrollTime = performance.now();
      const scrollDeltaT = scrollTime - lastScrollTime;
      if (scrollDeltaT > 500) {
        scrollVelocity = Math.sign(scrollTop - lastScrollTop);
        markerOffset = markerRef.value.offsetTop;
      } else {
        scrollVelocity = scrollTop - lastScrollTop;
      }
      lastScrollTop = scrollTop;
      lastScrollTime = scrollTime;
      window.clearTimeout(scrollTimeout);
      scrollTimeout = window.setTimeout(handleScrollend, 500);
      calculateVisibleItems();
    }
    function handleScrollend() {
      if (!containerRef.value || !markerRef.value)
        return;
      scrollVelocity = 0;
      lastScrollTime = 0;
      window.clearTimeout(scrollTimeout);
      calculateVisibleItems();
    }
    let raf2 = -1;
    function calculateVisibleItems() {
      cancelAnimationFrame(raf2);
      raf2 = requestAnimationFrame(_calculateVisibleItems);
    }
    function _calculateVisibleItems() {
      if (!containerRef.value || !viewportHeight.value)
        return;
      const scrollTop = lastScrollTop - markerOffset;
      const direction = Math.sign(scrollVelocity);
      const startPx = Math.max(0, scrollTop - BUFFER_PX);
      const start = clamp(calculateIndex(startPx), 0, items.value.length);
      const endPx = scrollTop + viewportHeight.value + BUFFER_PX;
      const end = clamp(calculateIndex(endPx) + 1, start + 1, items.value.length);
      if ((direction !== UP || start < first.value) && (direction !== DOWN || end > last.value)) {
        const topOverflow = calculateOffset(first.value) - calculateOffset(start);
        const bottomOverflow = calculateOffset(end) - calculateOffset(last.value);
        const bufferOverflow = Math.max(topOverflow, bottomOverflow);
        if (bufferOverflow > BUFFER_PX) {
          first.value = start;
          last.value = end;
        } else {
          if (start <= 0)
            first.value = start;
          if (end >= items.value.length)
            last.value = end;
        }
      }
      paddingTop.value = calculateOffset(first.value);
      paddingBottom.value = calculateOffset(items.value.length) - calculateOffset(last.value);
    }
    function scrollToIndex(index) {
      const offset = calculateOffset(index);
      if (!containerRef.value || index && !offset) {
        targetScrollIndex = index;
      } else {
        containerRef.value.scrollTop = offset;
      }
    }
    const computedItems = computed2(() => {
      return items.value.slice(first.value, last.value).map((item, index) => {
        const _index = index + first.value;
        return {
          raw: item,
          index: _index,
          key: getPropertyFromItem(item, props.itemKey, _index)
        };
      });
    });
    watch2(items, () => {
      sizes = Array.from({
        length: items.value.length
      });
      offsets = Array.from({
        length: items.value.length
      });
      updateOffsets.immediate();
      calculateVisibleItems();
    }, {
      deep: 1
    });
    return {
      calculateVisibleItems,
      containerRef,
      markerRef,
      computedItems,
      paddingTop,
      paddingBottom,
      scrollToIndex,
      handleScroll,
      handleScrollend,
      handleItemResize
    };
  }
  function binaryClosest(arr, val) {
    let high = arr.length - 1;
    let low = 0;
    let mid = 0;
    let item = null;
    let target = -1;
    if (arr[high] < val) {
      return high;
    }
    while (low <= high) {
      mid = low + high >> 1;
      item = arr[mid];
      if (item > val) {
        high = mid - 1;
      } else if (item < val) {
        target = mid;
        low = mid + 1;
      } else if (item === val) {
        return mid;
      } else {
        return low;
      }
    }
    return target;
  }

  // ../posawesome/node_modules/vuetify/lib/components/VVirtualScroll/VVirtualScroll.js
  var makeVVirtualScrollProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({
    items: {
      type: Array,
      default: () => []
    },
    renderless: Boolean
  }, makeVirtualProps()), makeComponentProps()), makeDimensionProps()), "VVirtualScroll");
  var VVirtualScroll = genericComponent()({
    name: "VVirtualScroll",
    props: makeVVirtualScrollProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const vm2 = getCurrentInstance2("VVirtualScroll");
      const {
        dimensionStyles
      } = useDimension(props);
      const {
        calculateVisibleItems,
        containerRef,
        markerRef,
        handleScroll,
        handleScrollend,
        handleItemResize,
        scrollToIndex,
        paddingTop,
        paddingBottom,
        computedItems
      } = useVirtual(props, toRef(() => props.items));
      useToggleScope(() => props.renderless, () => {
        function handleListeners() {
          var _a3, _b;
          let add3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
          const method = add3 ? "addEventListener" : "removeEventListener";
          if (containerRef.value === document.documentElement) {
            document[method]("scroll", handleScroll, {
              passive: true
            });
            document[method]("scrollend", handleScrollend);
          } else {
            (_a3 = containerRef.value) == null ? void 0 : _a3[method]("scroll", handleScroll, {
              passive: true
            });
            (_b = containerRef.value) == null ? void 0 : _b[method]("scrollend", handleScrollend);
          }
        }
        onMounted(() => {
          containerRef.value = getScrollParent(vm2.vnode.el, true);
          handleListeners(true);
        });
        onScopeDispose(handleListeners);
      });
      useRender(() => {
        const children = computedItems.value.map((item) => createVNode(VVirtualScrollItem, {
          "key": item.key,
          "renderless": props.renderless,
          "onUpdate:height": (height) => handleItemResize(item.index, height)
        }, {
          default: (slotProps) => {
            var _a3;
            return (_a3 = slots.default) == null ? void 0 : _a3.call(slots, __spreadValues({
              item: item.raw,
              index: item.index
            }, slotProps));
          }
        }));
        return props.renderless ? createBaseVNode(Fragment, null, [createBaseVNode("div", {
          "ref": markerRef,
          "class": "v-virtual-scroll__spacer",
          "style": {
            paddingTop: convertToUnit(paddingTop.value)
          }
        }, null), children, createBaseVNode("div", {
          "class": "v-virtual-scroll__spacer",
          "style": {
            paddingBottom: convertToUnit(paddingBottom.value)
          }
        }, null)]) : createBaseVNode("div", {
          "ref": containerRef,
          "class": normalizeClass(["v-virtual-scroll", props.class]),
          "onScrollPassive": handleScroll,
          "onScrollend": handleScrollend,
          "style": normalizeStyle([dimensionStyles.value, props.style])
        }, [createBaseVNode("div", {
          "ref": markerRef,
          "class": "v-virtual-scroll__container",
          "style": {
            paddingTop: convertToUnit(paddingTop.value),
            paddingBottom: convertToUnit(paddingBottom.value)
          }
        }, [children])]);
      });
      return {
        calculateVisibleItems,
        scrollToIndex
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VSelect/useScrolling.js
  function useScrolling(listRef, textFieldRef) {
    const isScrolling = shallowRef(false);
    let scrollTimeout;
    function onListScroll(e) {
      cancelAnimationFrame(scrollTimeout);
      isScrolling.value = true;
      scrollTimeout = requestAnimationFrame(() => {
        scrollTimeout = requestAnimationFrame(() => {
          isScrolling.value = false;
        });
      });
    }
    async function finishScrolling() {
      await new Promise((resolve2) => requestAnimationFrame(resolve2));
      await new Promise((resolve2) => requestAnimationFrame(resolve2));
      await new Promise((resolve2) => requestAnimationFrame(resolve2));
      await new Promise((resolve2) => {
        if (isScrolling.value) {
          const stop2 = watch2(isScrolling, () => {
            stop2();
            resolve2();
          });
        } else
          resolve2();
      });
    }
    async function onListKeydown(e) {
      var _a3, _b;
      if (e.key === "Tab") {
        (_a3 = textFieldRef.value) == null ? void 0 : _a3.focus();
      }
      if (!["PageDown", "PageUp", "Home", "End"].includes(e.key))
        return;
      const el = (_b = listRef.value) == null ? void 0 : _b.$el;
      if (!el)
        return;
      if (e.key === "Home" || e.key === "End") {
        el.scrollTo({
          top: e.key === "Home" ? 0 : el.scrollHeight,
          behavior: "smooth"
        });
      }
      await finishScrolling();
      const children = el.querySelectorAll(":scope > :not(.v-virtual-scroll__spacer)");
      if (e.key === "PageDown" || e.key === "Home") {
        const top = el.getBoundingClientRect().top;
        for (const child of children) {
          if (child.getBoundingClientRect().top >= top) {
            child.focus();
            break;
          }
        }
      } else {
        const bottom = el.getBoundingClientRect().bottom;
        for (const child of [...children].reverse()) {
          if (child.getBoundingClientRect().bottom <= bottom) {
            child.focus();
            break;
          }
        }
      }
    }
    return {
      onScrollPassive: onListScroll,
      onKeydown: onListKeydown
    };
  }

  // ../posawesome/node_modules/vuetify/lib/components/VSelect/VSelect.js
  var makeSelectProps = propsFactory(__spreadValues({
    chips: Boolean,
    closableChips: Boolean,
    closeText: {
      type: String,
      default: "$vuetify.close"
    },
    openText: {
      type: String,
      default: "$vuetify.open"
    },
    eager: Boolean,
    hideNoData: Boolean,
    hideSelected: Boolean,
    listProps: {
      type: Object
    },
    menu: Boolean,
    menuIcon: {
      type: IconValue,
      default: "$dropdown"
    },
    menuProps: {
      type: Object
    },
    multiple: Boolean,
    noDataText: {
      type: String,
      default: "$vuetify.noDataText"
    },
    openOnClear: Boolean,
    itemColor: String
  }, makeItemsProps({
    itemChildren: false
  })), "Select");
  var makeVSelectProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({}, makeSelectProps()), omit(makeVTextFieldProps({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"])), makeTransitionProps2({
    transition: {
      component: VDialogTransition
    }
  })), "VSelect");
  var VSelect = genericComponent()({
    name: "VSelect",
    props: makeVSelectProps(),
    emits: {
      "update:focused": (focused) => true,
      "update:modelValue": (value) => true,
      "update:menu": (ue) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        t
      } = useLocale();
      const vTextFieldRef = ref();
      const vMenuRef = ref();
      const vVirtualScrollRef = ref();
      const {
        items,
        transformIn,
        transformOut
      } = useItems(props);
      const model = useProxiedModel(props, "modelValue", [], (v) => transformIn(v === null ? [null] : wrapInArray(v)), (v) => {
        var _a3;
        const transformed = transformOut(v);
        return props.multiple ? transformed : (_a3 = transformed[0]) != null ? _a3 : null;
      });
      const counterValue = computed2(() => {
        return typeof props.counterValue === "function" ? props.counterValue(model.value) : typeof props.counterValue === "number" ? props.counterValue : model.value.length;
      });
      const form = useForm(props);
      const selectedValues = computed2(() => model.value.map((selection) => selection.value));
      const isFocused = shallowRef(false);
      let keyboardLookupPrefix = "";
      let keyboardLookupIndex = -1;
      let keyboardLookupLastTime;
      const displayItems = computed2(() => {
        if (props.hideSelected) {
          return items.value.filter((item) => !model.value.some((s) => (props.valueComparator || deepEqual)(s, item)));
        }
        return items.value;
      });
      const menuDisabled = computed2(() => props.hideNoData && !displayItems.value.length || form.isReadonly.value || form.isDisabled.value);
      const _menu = useProxiedModel(props, "menu");
      const menu = computed2({
        get: () => _menu.value,
        set: (v) => {
          var _a3;
          if (_menu.value && !v && ((_a3 = vMenuRef.value) == null ? void 0 : _a3.\u03A8openChildren.size))
            return;
          if (v && menuDisabled.value)
            return;
          _menu.value = v;
        }
      });
      const label = toRef(() => menu.value ? props.closeText : props.openText);
      const computedMenuProps = computed2(() => {
        var _a3;
        return __spreadProps(__spreadValues({}, props.menuProps), {
          activatorProps: __spreadProps(__spreadValues({}, ((_a3 = props.menuProps) == null ? void 0 : _a3.activatorProps) || {}), {
            "aria-haspopup": "listbox"
          })
        });
      });
      const listRef = ref();
      const listEvents = useScrolling(listRef, vTextFieldRef);
      function onClear(e) {
        if (props.openOnClear) {
          menu.value = true;
        }
      }
      function onMousedownControl() {
        if (menuDisabled.value)
          return;
        menu.value = !menu.value;
      }
      function onListKeydown(e) {
        if (checkPrintable(e)) {
          onKeydown(e);
        }
      }
      function onKeydown(e) {
        var _a3, _b, _c;
        if (!e.key || form.isReadonly.value)
          return;
        if (["Enter", " ", "ArrowDown", "ArrowUp", "Home", "End"].includes(e.key)) {
          e.preventDefault();
        }
        if (["Enter", "ArrowDown", " "].includes(e.key)) {
          menu.value = true;
        }
        if (["Escape", "Tab"].includes(e.key)) {
          menu.value = false;
        }
        if (e.key === "Home") {
          (_a3 = listRef.value) == null ? void 0 : _a3.focus("first");
        } else if (e.key === "End") {
          (_b = listRef.value) == null ? void 0 : _b.focus("last");
        }
        const KEYBOARD_LOOKUP_THRESHOLD = 1e3;
        if (!checkPrintable(e))
          return;
        const now = performance.now();
        if (now - keyboardLookupLastTime > KEYBOARD_LOOKUP_THRESHOLD) {
          keyboardLookupPrefix = "";
          keyboardLookupIndex = -1;
        }
        keyboardLookupPrefix += e.key.toLowerCase();
        keyboardLookupLastTime = now;
        const items2 = displayItems.value;
        function findItem() {
          let result2 = findItemBase();
          if (result2)
            return result2;
          if (keyboardLookupPrefix.at(-1) === keyboardLookupPrefix.at(-2)) {
            keyboardLookupPrefix = keyboardLookupPrefix.slice(0, -1);
            result2 = findItemBase();
            if (result2)
              return result2;
          }
          keyboardLookupIndex = -1;
          result2 = findItemBase();
          if (result2)
            return result2;
          keyboardLookupPrefix = e.key.toLowerCase();
          return findItemBase();
        }
        function findItemBase() {
          for (let i = keyboardLookupIndex + 1; i < items2.length; i++) {
            const _item = items2[i];
            if (_item.title.toLowerCase().startsWith(keyboardLookupPrefix)) {
              return [_item, i];
            }
          }
          return void 0;
        }
        const result = findItem();
        if (!result)
          return;
        const [item, index] = result;
        keyboardLookupIndex = index;
        (_c = listRef.value) == null ? void 0 : _c.focus(index);
        if (!props.multiple) {
          model.value = [item];
        }
      }
      function select(item) {
        let set2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        if (item.props.disabled)
          return;
        if (props.multiple) {
          const index = model.value.findIndex((selection) => (props.valueComparator || deepEqual)(selection.value, item.value));
          const add3 = set2 == null ? !~index : set2;
          if (~index) {
            const value = add3 ? [...model.value, item] : [...model.value];
            value.splice(index, 1);
            model.value = value;
          } else if (add3) {
            model.value = [...model.value, item];
          }
        } else {
          const add3 = set2 !== false;
          model.value = add3 ? [item] : [];
          nextTick(() => {
            menu.value = false;
          });
        }
      }
      function onBlur(e) {
        var _a3;
        if (!((_a3 = listRef.value) == null ? void 0 : _a3.$el.contains(e.relatedTarget))) {
          menu.value = false;
        }
      }
      function onAfterEnter() {
        var _a3;
        if (props.eager) {
          (_a3 = vVirtualScrollRef.value) == null ? void 0 : _a3.calculateVisibleItems();
        }
      }
      function onAfterLeave() {
        var _a3;
        if (isFocused.value) {
          (_a3 = vTextFieldRef.value) == null ? void 0 : _a3.focus();
        }
      }
      function onFocusin(e) {
        isFocused.value = true;
      }
      function onModelUpdate(v) {
        if (v == null)
          model.value = [];
        else if (matchesSelector(vTextFieldRef.value, ":autofill") || matchesSelector(vTextFieldRef.value, ":-webkit-autofill")) {
          const item = items.value.find((item2) => item2.title === v);
          if (item) {
            select(item);
          }
        } else if (vTextFieldRef.value) {
          vTextFieldRef.value.value = "";
        }
      }
      watch2(menu, () => {
        if (!props.hideSelected && menu.value && model.value.length) {
          const index = displayItems.value.findIndex((item) => model.value.some((s) => (props.valueComparator || deepEqual)(s.value, item.value)));
          IN_BROWSER && window.requestAnimationFrame(() => {
            var _a3;
            index >= 0 && ((_a3 = vVirtualScrollRef.value) == null ? void 0 : _a3.scrollToIndex(index));
          });
        }
      });
      watch2(() => props.items, (newVal, oldVal) => {
        if (menu.value)
          return;
        if (isFocused.value && !oldVal.length && newVal.length) {
          menu.value = true;
        }
      });
      useRender(() => {
        const hasChips = !!(props.chips || slots.chip);
        const hasList = !!(!props.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
        const isDirty2 = model.value.length > 0;
        const textFieldProps = VTextField.filterProps(props);
        const placeholder = isDirty2 || !isFocused.value && props.label && !props.persistentPlaceholder ? void 0 : props.placeholder;
        return createVNode(VTextField, mergeProps({
          "ref": vTextFieldRef
        }, textFieldProps, {
          "modelValue": model.value.map((v) => v.props.value).join(", "),
          "onUpdate:modelValue": onModelUpdate,
          "focused": isFocused.value,
          "onUpdate:focused": ($event) => isFocused.value = $event,
          "validationValue": model.externalValue,
          "counterValue": counterValue.value,
          "dirty": isDirty2,
          "class": ["v-select", {
            "v-select--active-menu": menu.value,
            "v-select--chips": !!props.chips,
            [`v-select--${props.multiple ? "multiple" : "single"}`]: true,
            "v-select--selected": model.value.length,
            "v-select--selection-slot": !!slots.selection
          }, props.class],
          "style": props.style,
          "inputmode": "none",
          "placeholder": placeholder,
          "onClick:clear": onClear,
          "onMousedown:control": onMousedownControl,
          "onBlur": onBlur,
          "onKeydown": onKeydown,
          "aria-label": t(label.value),
          "title": t(label.value)
        }), __spreadProps(__spreadValues({}, slots), {
          default: () => createBaseVNode(Fragment, null, [createVNode(VMenu, mergeProps({
            "ref": vMenuRef,
            "modelValue": menu.value,
            "onUpdate:modelValue": ($event) => menu.value = $event,
            "activator": "parent",
            "contentClass": "v-select__content",
            "disabled": menuDisabled.value,
            "eager": props.eager,
            "maxHeight": 310,
            "openOnClick": false,
            "closeOnContentClick": false,
            "transition": props.transition,
            "onAfterEnter": onAfterEnter,
            "onAfterLeave": onAfterLeave
          }, computedMenuProps.value), {
            default: () => {
              var _a3;
              return [hasList && createVNode(VList, mergeProps({
                "ref": listRef,
                "selected": selectedValues.value,
                "selectStrategy": props.multiple ? "independent" : "single-independent",
                "onMousedown": (e) => e.preventDefault(),
                "onKeydown": onListKeydown,
                "onFocusin": onFocusin,
                "tabindex": "-1",
                "aria-live": "polite",
                "aria-label": `${props.label}-list`,
                "color": (_a3 = props.itemColor) != null ? _a3 : props.color
              }, listEvents, props.listProps), {
                default: () => {
                  var _a4, _b, _c, _d;
                  return [(_a4 = slots["prepend-item"]) == null ? void 0 : _a4.call(slots), !displayItems.value.length && !props.hideNoData && ((_c = (_b = slots["no-data"]) == null ? void 0 : _b.call(slots)) != null ? _c : createVNode(VListItem, {
                    "key": "no-data",
                    "title": t(props.noDataText)
                  }, null)), createVNode(VVirtualScroll, {
                    "ref": vVirtualScrollRef,
                    "renderless": true,
                    "items": displayItems.value,
                    "itemKey": "value"
                  }, {
                    default: (_ref2) => {
                      var _a5, _b2;
                      let {
                        item,
                        index,
                        itemRef
                      } = _ref2;
                      const camelizedProps = camelizeProps(item.props);
                      const itemProps = mergeProps(item.props, {
                        ref: itemRef,
                        key: item.value,
                        onClick: () => select(item, null)
                      });
                      return (_b2 = (_a5 = slots.item) == null ? void 0 : _a5.call(slots, {
                        item,
                        index,
                        props: itemProps
                      })) != null ? _b2 : createVNode(VListItem, mergeProps(itemProps, {
                        "role": "option"
                      }), {
                        prepend: (_ref3) => {
                          let {
                            isSelected
                          } = _ref3;
                          return createBaseVNode(Fragment, null, [props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                            "key": item.value,
                            "modelValue": isSelected,
                            "ripple": false,
                            "tabindex": "-1"
                          }, null) : void 0, camelizedProps.prependAvatar && createVNode(VAvatar, {
                            "image": camelizedProps.prependAvatar
                          }, null), camelizedProps.prependIcon && createVNode(VIcon, {
                            "icon": camelizedProps.prependIcon
                          }, null)]);
                        }
                      });
                    }
                  }), (_d = slots["append-item"]) == null ? void 0 : _d.call(slots)];
                }
              })];
            }
          }), model.value.map((item, index) => {
            function onChipClose(e) {
              e.stopPropagation();
              e.preventDefault();
              select(item, false);
            }
            const slotProps = {
              "onClick:close": onChipClose,
              onKeydown(e) {
                if (e.key !== "Enter" && e.key !== " ")
                  return;
                e.preventDefault();
                e.stopPropagation();
                onChipClose(e);
              },
              onMousedown(e) {
                e.preventDefault();
                e.stopPropagation();
              },
              modelValue: true,
              "onUpdate:modelValue": void 0
            };
            const hasSlot = hasChips ? !!slots.chip : !!slots.selection;
            const slotContent = hasSlot ? ensureValidVNode2(hasChips ? slots.chip({
              item,
              index,
              props: slotProps
            }) : slots.selection({
              item,
              index
            })) : void 0;
            if (hasSlot && !slotContent)
              return void 0;
            return createBaseVNode("div", {
              "key": item.value,
              "class": "v-select__selection"
            }, [hasChips ? !slots.chip ? createVNode(VChip, mergeProps({
              "key": "chip",
              "closable": props.closableChips,
              "size": "small",
              "text": item.title,
              "disabled": item.props.disabled
            }, slotProps), null) : createVNode(VDefaultsProvider, {
              "key": "chip-defaults",
              "defaults": {
                VChip: {
                  closable: props.closableChips,
                  size: "small",
                  text: item.title
                }
              }
            }, {
              default: () => [slotContent]
            }) : slotContent != null ? slotContent : createBaseVNode("span", {
              "class": "v-select__selection-text"
            }, [item.title, props.multiple && index < model.value.length - 1 && createBaseVNode("span", {
              "class": "v-select__selection-comma"
            }, [createTextVNode(",")])])]);
          })]),
          "append-inner": function() {
            var _a3, _b;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return createBaseVNode(Fragment, null, [(_a3 = slots["append-inner"]) == null ? void 0 : _a3.call(slots, ...args), props.menuIcon ? createVNode(VIcon, {
              "class": "v-select__menu-icon",
              "color": (_b = vTextFieldRef.value) == null ? void 0 : _b.fieldIconColor,
              "icon": props.menuIcon
            }, null) : void 0]);
          }
        }));
      });
      return forwardRefs({
        isFocused,
        menu,
        select
      }, vTextFieldRef);
    }
  });

  // ../posawesome/node_modules/vuetify/lib/composables/filter.js
  var defaultFilter = (value, query, item) => {
    if (value == null || query == null)
      return -1;
    if (!query.length)
      return 0;
    value = value.toString().toLocaleLowerCase();
    query = query.toString().toLocaleLowerCase();
    const result = [];
    let idx = value.indexOf(query);
    while (~idx) {
      result.push([idx, idx + query.length]);
      idx = value.indexOf(query, idx + query.length);
    }
    return result.length ? result : -1;
  };
  function normaliseMatch(match2, query) {
    if (match2 == null || typeof match2 === "boolean" || match2 === -1)
      return;
    if (typeof match2 === "number")
      return [[match2, match2 + query.length]];
    if (Array.isArray(match2[0]))
      return match2;
    return [match2];
  }
  var makeFilterProps = propsFactory({
    customFilter: Function,
    customKeyFilter: Object,
    filterKeys: [Array, String],
    filterMode: {
      type: String,
      default: "intersection"
    },
    noFilter: Boolean
  }, "filter");
  function filterItems(items, query, options) {
    var _a3, _b, _c;
    const array = [];
    const filter = (_a3 = options == null ? void 0 : options.default) != null ? _a3 : defaultFilter;
    const keys2 = (options == null ? void 0 : options.filterKeys) ? wrapInArray(options.filterKeys) : false;
    const customFiltersLength = Object.keys((_b = options == null ? void 0 : options.customKeyFilter) != null ? _b : {}).length;
    if (!(items == null ? void 0 : items.length))
      return array;
    loop:
      for (let i = 0; i < items.length; i++) {
        const [item, transformed = item] = wrapInArray(items[i]);
        const customMatches = {};
        const defaultMatches = {};
        let match2 = -1;
        if ((query || customFiltersLength > 0) && !(options == null ? void 0 : options.noFilter)) {
          if (typeof item === "object") {
            const filterKeys = keys2 || Object.keys(transformed);
            for (const key of filterKeys) {
              const value = getPropertyFromItem(transformed, key);
              const keyFilter = (_c = options == null ? void 0 : options.customKeyFilter) == null ? void 0 : _c[key];
              match2 = keyFilter ? keyFilter(value, query, item) : filter(value, query, item);
              if (match2 !== -1 && match2 !== false) {
                if (keyFilter)
                  customMatches[key] = normaliseMatch(match2, query);
                else
                  defaultMatches[key] = normaliseMatch(match2, query);
              } else if ((options == null ? void 0 : options.filterMode) === "every") {
                continue loop;
              }
            }
          } else {
            match2 = filter(item, query, item);
            if (match2 !== -1 && match2 !== false) {
              defaultMatches.title = normaliseMatch(match2, query);
            }
          }
          const defaultMatchesLength = Object.keys(defaultMatches).length;
          const customMatchesLength = Object.keys(customMatches).length;
          if (!defaultMatchesLength && !customMatchesLength)
            continue;
          if ((options == null ? void 0 : options.filterMode) === "union" && customMatchesLength !== customFiltersLength && !defaultMatchesLength)
            continue;
          if ((options == null ? void 0 : options.filterMode) === "intersection" && (customMatchesLength !== customFiltersLength || !defaultMatchesLength))
            continue;
        }
        array.push({
          index: i,
          matches: __spreadValues(__spreadValues({}, defaultMatches), customMatches)
        });
      }
    return array;
  }
  function useFilter(props, items, query, options) {
    const filteredItems = shallowRef([]);
    const filteredMatches = shallowRef(/* @__PURE__ */ new Map());
    const transformedItems = computed2(() => (options == null ? void 0 : options.transform) ? unref(items).map((item) => [item, options.transform(item)]) : unref(items));
    watchEffect(() => {
      const _query = typeof query === "function" ? query() : unref(query);
      const strQuery = typeof _query !== "string" && typeof _query !== "number" ? "" : String(_query);
      const results = filterItems(transformedItems.value, strQuery, {
        customKeyFilter: __spreadValues(__spreadValues({}, props.customKeyFilter), unref(options == null ? void 0 : options.customKeyFilter)),
        default: props.customFilter,
        filterKeys: props.filterKeys,
        filterMode: props.filterMode,
        noFilter: props.noFilter
      });
      const originalItems = unref(items);
      const _filteredItems = [];
      const _filteredMatches = /* @__PURE__ */ new Map();
      results.forEach((_ref) => {
        let {
          index,
          matches
        } = _ref;
        const item = originalItems[index];
        _filteredItems.push(item);
        _filteredMatches.set(item.value, matches);
      });
      filteredItems.value = _filteredItems;
      filteredMatches.value = _filteredMatches;
    });
    function getMatches(item) {
      return filteredMatches.value.get(item.value);
    }
    return {
      filteredItems,
      filteredMatches,
      getMatches
    };
  }
  function highlightResult(name, text, matches) {
    if (matches == null || !matches.length)
      return text;
    return matches.map((match2, i) => {
      const start = i === 0 ? 0 : matches[i - 1][1];
      const result = [createBaseVNode("span", {
        "class": normalizeClass(`${name}__unmask`)
      }, [text.slice(start, match2[0])]), createBaseVNode("span", {
        "class": normalizeClass(`${name}__mask`)
      }, [text.slice(match2[0], match2[1])])];
      if (i === matches.length - 1) {
        result.push(createBaseVNode("span", {
          "class": normalizeClass(`${name}__unmask`)
        }, [text.slice(match2[1])]));
      }
      return createBaseVNode(Fragment, null, [result]);
    });
  }

  // ../posawesome/node_modules/vuetify/lib/components/VAutocomplete/VAutocomplete.js
  var makeVAutocompleteProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    autoSelectFirst: {
      type: [Boolean, String]
    },
    clearOnSelect: Boolean,
    search: String
  }, makeFilterProps({
    filterKeys: ["title"]
  })), makeSelectProps()), omit(makeVTextFieldProps({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"])), makeTransitionProps2({
    transition: false
  })), "VAutocomplete");
  var VAutocomplete = genericComponent()({
    name: "VAutocomplete",
    props: makeVAutocompleteProps(),
    emits: {
      "update:focused": (focused) => true,
      "update:search": (value) => true,
      "update:modelValue": (value) => true,
      "update:menu": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        t
      } = useLocale();
      const vTextFieldRef = ref();
      const isFocused = shallowRef(false);
      const isPristine = shallowRef(true);
      const listHasFocus = shallowRef(false);
      const vMenuRef = ref();
      const vVirtualScrollRef = ref();
      const selectionIndex = shallowRef(-1);
      const {
        items,
        transformIn,
        transformOut
      } = useItems(props);
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(() => {
        var _a3;
        return (_a3 = vTextFieldRef.value) == null ? void 0 : _a3.color;
      });
      const search = useProxiedModel(props, "search", "");
      const model = useProxiedModel(props, "modelValue", [], (v) => transformIn(v === null ? [null] : wrapInArray(v)), (v) => {
        var _a3;
        const transformed = transformOut(v);
        return props.multiple ? transformed : (_a3 = transformed[0]) != null ? _a3 : null;
      });
      const counterValue = computed2(() => {
        return typeof props.counterValue === "function" ? props.counterValue(model.value) : typeof props.counterValue === "number" ? props.counterValue : model.value.length;
      });
      const form = useForm(props);
      const {
        filteredItems,
        getMatches
      } = useFilter(props, items, () => isPristine.value ? "" : search.value);
      const displayItems = computed2(() => {
        if (props.hideSelected) {
          return filteredItems.value.filter((filteredItem) => !model.value.some((s) => s.value === filteredItem.value));
        }
        return filteredItems.value;
      });
      const hasChips = computed2(() => !!(props.chips || slots.chip));
      const hasSelectionSlot = computed2(() => hasChips.value || !!slots.selection);
      const selectedValues = computed2(() => model.value.map((selection) => selection.props.value));
      const highlightFirst = computed2(() => {
        var _a3;
        const selectFirst = props.autoSelectFirst === true || props.autoSelectFirst === "exact" && search.value === ((_a3 = displayItems.value[0]) == null ? void 0 : _a3.title);
        return selectFirst && displayItems.value.length > 0 && !isPristine.value && !listHasFocus.value;
      });
      const menuDisabled = computed2(() => props.hideNoData && !displayItems.value.length || form.isReadonly.value || form.isDisabled.value);
      const _menu = useProxiedModel(props, "menu");
      const menu = computed2({
        get: () => _menu.value,
        set: (v) => {
          var _a3;
          if (_menu.value && !v && ((_a3 = vMenuRef.value) == null ? void 0 : _a3.\u03A8openChildren.size))
            return;
          if (v && menuDisabled.value)
            return;
          _menu.value = v;
        }
      });
      const label = computed2(() => menu.value ? props.closeText : props.openText);
      const listRef = ref();
      const listEvents = useScrolling(listRef, vTextFieldRef);
      function onClear(e) {
        if (props.openOnClear) {
          menu.value = true;
        }
        search.value = "";
      }
      function onMousedownControl() {
        if (menuDisabled.value)
          return;
        menu.value = true;
      }
      function onMousedownMenuIcon(e) {
        if (menuDisabled.value)
          return;
        if (isFocused.value) {
          e.preventDefault();
          e.stopPropagation();
        }
        menu.value = !menu.value;
      }
      function onListKeydown(e) {
        var _a3;
        if (e.key !== " " && checkPrintable(e)) {
          (_a3 = vTextFieldRef.value) == null ? void 0 : _a3.focus();
        }
      }
      function onKeydown(e) {
        var _a3, _b, _c, _d, _e, _f;
        if (form.isReadonly.value)
          return;
        const selectionStart = (_a3 = vTextFieldRef.value) == null ? void 0 : _a3.selectionStart;
        const length = model.value.length;
        if (["Enter", "ArrowDown", "ArrowUp"].includes(e.key)) {
          e.preventDefault();
        }
        if (["Enter", "ArrowDown"].includes(e.key)) {
          menu.value = true;
        }
        if (["Escape"].includes(e.key)) {
          menu.value = false;
        }
        if (highlightFirst.value && ["Enter", "Tab"].includes(e.key) && !model.value.some((_ref2) => {
          let {
            value
          } = _ref2;
          return value === displayItems.value[0].value;
        })) {
          select(displayItems.value[0]);
        }
        if (e.key === "ArrowDown" && highlightFirst.value) {
          (_b = listRef.value) == null ? void 0 : _b.focus("next");
        }
        if (["Backspace", "Delete"].includes(e.key)) {
          if (!props.multiple && hasSelectionSlot.value && model.value.length > 0 && !search.value)
            return select(model.value[0], false);
          if (~selectionIndex.value) {
            e.preventDefault();
            const originalSelectionIndex = selectionIndex.value;
            select(model.value[selectionIndex.value], false);
            selectionIndex.value = originalSelectionIndex >= length - 1 ? length - 2 : originalSelectionIndex;
          } else if (e.key === "Backspace" && !search.value) {
            selectionIndex.value = length - 1;
          }
          return;
        }
        if (!props.multiple)
          return;
        if (e.key === "ArrowLeft") {
          if (selectionIndex.value < 0 && selectionStart && selectionStart > 0)
            return;
          const prev = selectionIndex.value > -1 ? selectionIndex.value - 1 : length - 1;
          if (model.value[prev]) {
            selectionIndex.value = prev;
          } else {
            const searchLength = (_d = (_c = search.value) == null ? void 0 : _c.length) != null ? _d : null;
            selectionIndex.value = -1;
            (_e = vTextFieldRef.value) == null ? void 0 : _e.setSelectionRange(searchLength, searchLength);
          }
        } else if (e.key === "ArrowRight") {
          if (selectionIndex.value < 0)
            return;
          const next = selectionIndex.value + 1;
          if (model.value[next]) {
            selectionIndex.value = next;
          } else {
            selectionIndex.value = -1;
            (_f = vTextFieldRef.value) == null ? void 0 : _f.setSelectionRange(0, 0);
          }
        } else if (~selectionIndex.value && checkPrintable(e)) {
          selectionIndex.value = -1;
        }
      }
      function onChange(e) {
        if (matchesSelector(vTextFieldRef.value, ":autofill") || matchesSelector(vTextFieldRef.value, ":-webkit-autofill")) {
          const item = items.value.find((item2) => item2.title === e.target.value);
          if (item) {
            select(item);
          }
        }
      }
      function onAfterEnter() {
        var _a3;
        if (props.eager) {
          (_a3 = vVirtualScrollRef.value) == null ? void 0 : _a3.calculateVisibleItems();
        }
      }
      function onAfterLeave() {
        var _a3;
        if (isFocused.value) {
          isPristine.value = true;
          (_a3 = vTextFieldRef.value) == null ? void 0 : _a3.focus();
        }
      }
      function onFocusin(e) {
        isFocused.value = true;
        setTimeout(() => {
          listHasFocus.value = true;
        });
      }
      function onFocusout(e) {
        listHasFocus.value = false;
      }
      function onUpdateModelValue(v) {
        if (v == null || v === "" && !props.multiple && !hasSelectionSlot.value)
          model.value = [];
      }
      const isSelecting = shallowRef(false);
      function select(item) {
        let set2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        if (!item || item.props.disabled)
          return;
        if (props.multiple) {
          const index = model.value.findIndex((selection) => (props.valueComparator || deepEqual)(selection.value, item.value));
          const add3 = set2 == null ? !~index : set2;
          if (~index) {
            const value = add3 ? [...model.value, item] : [...model.value];
            value.splice(index, 1);
            model.value = value;
          } else if (add3) {
            model.value = [...model.value, item];
          }
          if (props.clearOnSelect) {
            search.value = "";
          }
        } else {
          const add3 = set2 !== false;
          model.value = add3 ? [item] : [];
          search.value = add3 && !hasSelectionSlot.value ? item.title : "";
          nextTick(() => {
            menu.value = false;
            isPristine.value = true;
          });
        }
      }
      watch2(isFocused, (val, oldVal) => {
        var _a3, _b;
        if (val === oldVal)
          return;
        if (val) {
          isSelecting.value = true;
          search.value = props.multiple || hasSelectionSlot.value ? "" : String((_b = (_a3 = model.value.at(-1)) == null ? void 0 : _a3.props.title) != null ? _b : "");
          isPristine.value = true;
          nextTick(() => isSelecting.value = false);
        } else {
          if (!props.multiple && search.value == null)
            model.value = [];
          menu.value = false;
          if (props.multiple || hasSelectionSlot.value)
            search.value = "";
          selectionIndex.value = -1;
        }
      });
      watch2(search, (val) => {
        if (!isFocused.value || isSelecting.value)
          return;
        if (val)
          menu.value = true;
        isPristine.value = !val;
      });
      watch2(menu, () => {
        if (!props.hideSelected && menu.value && model.value.length) {
          const index = displayItems.value.findIndex((item) => model.value.some((s) => item.value === s.value));
          IN_BROWSER && window.requestAnimationFrame(() => {
            var _a3;
            index >= 0 && ((_a3 = vVirtualScrollRef.value) == null ? void 0 : _a3.scrollToIndex(index));
          });
        }
      });
      watch2(() => props.items, (newVal, oldVal) => {
        if (menu.value)
          return;
        if (isFocused.value && !oldVal.length && newVal.length) {
          menu.value = true;
        }
      });
      useRender(() => {
        const hasList = !!(!props.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
        const isDirty2 = model.value.length > 0;
        const textFieldProps = VTextField.filterProps(props);
        return createVNode(VTextField, mergeProps({
          "ref": vTextFieldRef
        }, textFieldProps, {
          "modelValue": search.value,
          "onUpdate:modelValue": [($event) => search.value = $event, onUpdateModelValue],
          "focused": isFocused.value,
          "onUpdate:focused": ($event) => isFocused.value = $event,
          "validationValue": model.externalValue,
          "counterValue": counterValue.value,
          "dirty": isDirty2,
          "onChange": onChange,
          "class": ["v-autocomplete", `v-autocomplete--${props.multiple ? "multiple" : "single"}`, {
            "v-autocomplete--active-menu": menu.value,
            "v-autocomplete--chips": !!props.chips,
            "v-autocomplete--selection-slot": !!hasSelectionSlot.value,
            "v-autocomplete--selecting-index": selectionIndex.value > -1
          }, props.class],
          "style": props.style,
          "readonly": form.isReadonly.value,
          "placeholder": isDirty2 ? void 0 : props.placeholder,
          "onClick:clear": onClear,
          "onMousedown:control": onMousedownControl,
          "onKeydown": onKeydown
        }), __spreadProps(__spreadValues({}, slots), {
          default: () => createBaseVNode(Fragment, null, [createVNode(VMenu, mergeProps({
            "ref": vMenuRef,
            "modelValue": menu.value,
            "onUpdate:modelValue": ($event) => menu.value = $event,
            "activator": "parent",
            "contentClass": "v-autocomplete__content",
            "disabled": menuDisabled.value,
            "eager": props.eager,
            "maxHeight": 310,
            "openOnClick": false,
            "closeOnContentClick": false,
            "transition": props.transition,
            "onAfterEnter": onAfterEnter,
            "onAfterLeave": onAfterLeave
          }, props.menuProps), {
            default: () => {
              var _a3;
              return [hasList && createVNode(VList, mergeProps({
                "ref": listRef,
                "selected": selectedValues.value,
                "selectStrategy": props.multiple ? "independent" : "single-independent",
                "onMousedown": (e) => e.preventDefault(),
                "onKeydown": onListKeydown,
                "onFocusin": onFocusin,
                "onFocusout": onFocusout,
                "tabindex": "-1",
                "aria-live": "polite",
                "color": (_a3 = props.itemColor) != null ? _a3 : props.color
              }, listEvents, props.listProps), {
                default: () => {
                  var _a4, _b, _c, _d;
                  return [(_a4 = slots["prepend-item"]) == null ? void 0 : _a4.call(slots), !displayItems.value.length && !props.hideNoData && ((_c = (_b = slots["no-data"]) == null ? void 0 : _b.call(slots)) != null ? _c : createVNode(VListItem, {
                    "key": "no-data",
                    "title": t(props.noDataText)
                  }, null)), createVNode(VVirtualScroll, {
                    "ref": vVirtualScrollRef,
                    "renderless": true,
                    "items": displayItems.value,
                    "itemKey": "value"
                  }, {
                    default: (_ref3) => {
                      var _a5, _b2;
                      let {
                        item,
                        index,
                        itemRef
                      } = _ref3;
                      const itemProps = mergeProps(item.props, {
                        ref: itemRef,
                        key: item.value,
                        active: highlightFirst.value && index === 0 ? true : void 0,
                        onClick: () => select(item, null)
                      });
                      return (_b2 = (_a5 = slots.item) == null ? void 0 : _a5.call(slots, {
                        item,
                        index,
                        props: itemProps
                      })) != null ? _b2 : createVNode(VListItem, mergeProps(itemProps, {
                        "role": "option"
                      }), {
                        prepend: (_ref4) => {
                          let {
                            isSelected
                          } = _ref4;
                          return createBaseVNode(Fragment, null, [props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                            "key": item.value,
                            "modelValue": isSelected,
                            "ripple": false,
                            "tabindex": "-1"
                          }, null) : void 0, item.props.prependAvatar && createVNode(VAvatar, {
                            "image": item.props.prependAvatar
                          }, null), item.props.prependIcon && createVNode(VIcon, {
                            "icon": item.props.prependIcon
                          }, null)]);
                        },
                        title: () => {
                          var _a6;
                          return isPristine.value ? item.title : highlightResult("v-autocomplete", item.title, (_a6 = getMatches(item)) == null ? void 0 : _a6.title);
                        }
                      });
                    }
                  }), (_d = slots["append-item"]) == null ? void 0 : _d.call(slots)];
                }
              })];
            }
          }), model.value.map((item, index) => {
            function onChipClose(e) {
              e.stopPropagation();
              e.preventDefault();
              select(item, false);
            }
            const slotProps = {
              "onClick:close": onChipClose,
              onKeydown(e) {
                if (e.key !== "Enter" && e.key !== " ")
                  return;
                e.preventDefault();
                e.stopPropagation();
                onChipClose(e);
              },
              onMousedown(e) {
                e.preventDefault();
                e.stopPropagation();
              },
              modelValue: true,
              "onUpdate:modelValue": void 0
            };
            const hasSlot = hasChips.value ? !!slots.chip : !!slots.selection;
            const slotContent = hasSlot ? ensureValidVNode2(hasChips.value ? slots.chip({
              item,
              index,
              props: slotProps
            }) : slots.selection({
              item,
              index
            })) : void 0;
            if (hasSlot && !slotContent)
              return void 0;
            return createBaseVNode("div", {
              "key": item.value,
              "class": normalizeClass(["v-autocomplete__selection", index === selectionIndex.value && ["v-autocomplete__selection--selected", textColorClasses.value]]),
              "style": normalizeStyle(index === selectionIndex.value ? textColorStyles.value : {})
            }, [hasChips.value ? !slots.chip ? createVNode(VChip, mergeProps({
              "key": "chip",
              "closable": props.closableChips,
              "size": "small",
              "text": item.title,
              "disabled": item.props.disabled
            }, slotProps), null) : createVNode(VDefaultsProvider, {
              "key": "chip-defaults",
              "defaults": {
                VChip: {
                  closable: props.closableChips,
                  size: "small",
                  text: item.title
                }
              }
            }, {
              default: () => [slotContent]
            }) : slotContent != null ? slotContent : createBaseVNode("span", {
              "class": "v-autocomplete__selection-text"
            }, [item.title, props.multiple && index < model.value.length - 1 && createBaseVNode("span", {
              "class": "v-autocomplete__selection-comma"
            }, [createTextVNode(",")])])]);
          })]),
          "append-inner": function() {
            var _a3, _b;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return createBaseVNode(Fragment, null, [(_a3 = slots["append-inner"]) == null ? void 0 : _a3.call(slots, ...args), props.menuIcon ? createVNode(VIcon, {
              "class": "v-autocomplete__menu-icon",
              "color": (_b = vTextFieldRef.value) == null ? void 0 : _b.fieldIconColor,
              "icon": props.menuIcon,
              "onMousedown": onMousedownMenuIcon,
              "onClick": noop,
              "aria-label": t(label.value),
              "title": t(label.value),
              "tabindex": "-1"
            }, null) : void 0]);
          }
        }));
      });
      return forwardRefs({
        isFocused,
        isPristine,
        menu,
        search,
        filteredItems,
        select
      }, vTextFieldRef);
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VBadge/VBadge.js
  var makeVBadgeProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    bordered: Boolean,
    color: String,
    content: [Number, String],
    dot: Boolean,
    floating: Boolean,
    icon: IconValue,
    inline: Boolean,
    label: {
      type: String,
      default: "$vuetify.badge"
    },
    max: [Number, String],
    modelValue: {
      type: Boolean,
      default: true
    },
    offsetX: [Number, String],
    offsetY: [Number, String],
    textColor: String
  }, makeComponentProps()), makeLocationProps({
    location: "top end"
  })), makeRoundedProps()), makeTagProps()), makeThemeProps()), makeTransitionProps2({
    transition: "scale-rotate-transition"
  })), "VBadge");
  var VBadge = genericComponent()({
    name: "VBadge",
    inheritAttrs: false,
    props: makeVBadgeProps(),
    setup(props, ctx) {
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(() => props.color);
      const {
        roundedClasses
      } = useRounded(props);
      const {
        t
      } = useLocale();
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(() => props.textColor);
      const {
        themeClasses
      } = useTheme();
      const {
        locationStyles
      } = useLocation(props, true, (side) => {
        var _a3, _b;
        const base = props.floating ? props.dot ? 2 : 4 : props.dot ? 8 : 12;
        return base + (["top", "bottom"].includes(side) ? Number((_a3 = props.offsetY) != null ? _a3 : 0) : ["left", "right"].includes(side) ? Number((_b = props.offsetX) != null ? _b : 0) : 0);
      });
      useRender(() => {
        const value = Number(props.content);
        const content = !props.max || isNaN(value) ? props.content : value <= Number(props.max) ? value : `${props.max}+`;
        const [badgeAttrs, attrs] = pickWithRest(ctx.attrs, ["aria-atomic", "aria-label", "aria-live", "role", "title"]);
        return createVNode(props.tag, mergeProps({
          "class": ["v-badge", {
            "v-badge--bordered": props.bordered,
            "v-badge--dot": props.dot,
            "v-badge--floating": props.floating,
            "v-badge--inline": props.inline
          }, props.class]
        }, attrs, {
          "style": props.style
        }), {
          default: () => {
            var _a3, _b;
            return [createBaseVNode("div", {
              "class": "v-badge__wrapper"
            }, [(_b = (_a3 = ctx.slots).default) == null ? void 0 : _b.call(_a3), createVNode(MaybeTransition, {
              "transition": props.transition
            }, {
              default: () => {
                var _a4, _b2;
                return [withDirectives(createBaseVNode("span", mergeProps({
                  "class": ["v-badge__badge", themeClasses.value, backgroundColorClasses.value, roundedClasses.value, textColorClasses.value],
                  "style": [backgroundColorStyles.value, textColorStyles.value, props.inline ? {} : locationStyles.value],
                  "aria-atomic": "true",
                  "aria-label": t(props.label, value),
                  "aria-live": "polite",
                  "role": "status"
                }, badgeAttrs), [props.dot ? void 0 : ctx.slots.badge ? (_b2 = (_a4 = ctx.slots).badge) == null ? void 0 : _b2.call(_a4) : props.icon ? createVNode(VIcon, {
                  "icon": props.icon
                }, null) : content]), [[vShow, props.modelValue]])];
              }
            })])];
          }
        });
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VBanner/VBannerActions.js
  var makeVBannerActionsProps = propsFactory(__spreadValues({
    color: String,
    density: String
  }, makeComponentProps()), "VBannerActions");
  var VBannerActions = genericComponent()({
    name: "VBannerActions",
    props: makeVBannerActionsProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      provideDefaults({
        VBtn: {
          color: props.color,
          density: props.density,
          slim: true,
          variant: "text"
        }
      });
      useRender(() => {
        var _a3;
        return createBaseVNode("div", {
          "class": normalizeClass(["v-banner-actions", props.class]),
          "style": normalizeStyle(props.style)
        }, [(_a3 = slots.default) == null ? void 0 : _a3.call(slots)]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VBanner/VBannerText.js
  var VBannerText = createSimpleFunctional("v-banner-text");

  // ../posawesome/node_modules/vuetify/lib/components/VBanner/VBanner.js
  var makeVBannerProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    avatar: String,
    bgColor: String,
    color: String,
    icon: IconValue,
    lines: String,
    stacked: Boolean,
    sticky: Boolean,
    text: String
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeDimensionProps()), makeDisplayProps({
    mobile: null
  })), makeElevationProps()), makeLocationProps()), makePositionProps()), makeRoundedProps()), makeTagProps()), makeThemeProps()), "VBanner");
  var VBanner = genericComponent()({
    name: "VBanner",
    props: makeVBannerProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(() => props.bgColor);
      const {
        borderClasses
      } = useBorder(props);
      const {
        densityClasses
      } = useDensity(props);
      const {
        displayClasses,
        mobile
      } = useDisplay(props);
      const {
        dimensionStyles
      } = useDimension(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        locationStyles
      } = useLocation(props);
      const {
        positionClasses
      } = usePosition(props);
      const {
        roundedClasses
      } = useRounded(props);
      const {
        themeClasses
      } = provideTheme(props);
      const color = toRef(() => props.color);
      const density = toRef(() => props.density);
      provideDefaults({
        VBannerActions: {
          color,
          density
        }
      });
      useRender(() => {
        const hasText = !!(props.text || slots.text);
        const hasPrependMedia = !!(props.avatar || props.icon);
        const hasPrepend = !!(hasPrependMedia || slots.prepend);
        return createVNode(props.tag, {
          "class": normalizeClass(["v-banner", {
            "v-banner--stacked": props.stacked || mobile.value,
            "v-banner--sticky": props.sticky,
            [`v-banner--${props.lines}-line`]: !!props.lines
          }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, densityClasses.value, displayClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, props.class]),
          "style": normalizeStyle([backgroundColorStyles.value, dimensionStyles.value, locationStyles.value, props.style]),
          "role": "banner"
        }, {
          default: () => {
            var _a3;
            return [hasPrepend && createBaseVNode("div", {
              "key": "prepend",
              "class": "v-banner__prepend"
            }, [!slots.prepend ? createVNode(VAvatar, {
              "key": "prepend-avatar",
              "color": color.value,
              "density": density.value,
              "icon": props.icon,
              "image": props.avatar
            }, null) : createVNode(VDefaultsProvider, {
              "key": "prepend-defaults",
              "disabled": !hasPrependMedia,
              "defaults": {
                VAvatar: {
                  color: color.value,
                  density: density.value,
                  icon: props.icon,
                  image: props.avatar
                }
              }
            }, slots.prepend)]), createBaseVNode("div", {
              "class": "v-banner__content"
            }, [hasText && createVNode(VBannerText, {
              "key": "text"
            }, {
              default: () => {
                var _a4, _b;
                return [(_b = (_a4 = slots.text) == null ? void 0 : _a4.call(slots)) != null ? _b : props.text];
              }
            }), (_a3 = slots.default) == null ? void 0 : _a3.call(slots)]), slots.actions && createVNode(VBannerActions, {
              "key": "actions"
            }, slots.actions)];
          }
        });
      });
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VBottomNavigation/VBottomNavigation.js
  var makeVBottomNavigationProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    baseColor: String,
    bgColor: String,
    color: String,
    grow: Boolean,
    mode: {
      type: String,
      validator: (v) => !v || ["horizontal", "shift"].includes(v)
    },
    height: {
      type: [Number, String],
      default: 56
    },
    active: {
      type: Boolean,
      default: true
    }
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeElevationProps()), makeRoundedProps()), makeLayoutItemProps({
    name: "bottom-navigation"
  })), makeTagProps({
    tag: "header"
  })), makeGroupProps({
    selectedClass: "v-btn--selected"
  })), makeThemeProps()), "VBottomNavigation");
  var VBottomNavigation = genericComponent()({
    name: "VBottomNavigation",
    props: makeVBottomNavigationProps(),
    emits: {
      "update:active": (value) => true,
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        themeClasses
      } = useTheme();
      const {
        borderClasses
      } = useBorder(props);
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(() => props.bgColor);
      const {
        densityClasses
      } = useDensity(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        roundedClasses
      } = useRounded(props);
      const {
        ssrBootStyles
      } = useSsrBoot();
      const height = computed2(() => Number(props.height) - (props.density === "comfortable" ? 8 : 0) - (props.density === "compact" ? 16 : 0));
      const isActive = useProxiedModel(props, "active", props.active);
      const {
        layoutItemStyles
      } = useLayoutItem({
        id: props.name,
        order: computed2(() => parseInt(props.order, 10)),
        position: toRef(() => "bottom"),
        layoutSize: toRef(() => isActive.value ? height.value : 0),
        elementSize: height,
        active: isActive,
        absolute: toRef(() => props.absolute)
      });
      useGroup(props, VBtnToggleSymbol);
      provideDefaults({
        VBtn: {
          baseColor: toRef(() => props.baseColor),
          color: toRef(() => props.color),
          density: toRef(() => props.density),
          stacked: toRef(() => props.mode !== "horizontal"),
          variant: "text"
        }
      }, {
        scoped: true
      });
      useRender(() => {
        return createVNode(props.tag, {
          "class": normalizeClass(["v-bottom-navigation", {
            "v-bottom-navigation--active": isActive.value,
            "v-bottom-navigation--grow": props.grow,
            "v-bottom-navigation--shift": props.mode === "shift"
          }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value, props.class]),
          "style": normalizeStyle([backgroundColorStyles.value, layoutItemStyles.value, {
            height: convertToUnit(height.value)
          }, ssrBootStyles.value, props.style])
        }, {
          default: () => [slots.default && createBaseVNode("div", {
            "class": "v-bottom-navigation__content"
          }, [slots.default()])]
        });
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VDialog/VDialog.js
  var makeVDialogProps = propsFactory(__spreadValues({
    fullscreen: Boolean,
    retainFocus: {
      type: Boolean,
      default: true
    },
    scrollable: Boolean
  }, makeVOverlayProps({
    origin: "center center",
    scrollStrategy: "block",
    transition: {
      component: VDialogTransition
    },
    zIndex: 2400
  })), "VDialog");
  var VDialog = genericComponent()({
    name: "VDialog",
    props: makeVDialogProps(),
    emits: {
      "update:modelValue": (value) => true,
      afterEnter: () => true,
      afterLeave: () => true
    },
    setup(props, _ref) {
      let {
        emit: emit2,
        slots
      } = _ref;
      const isActive = useProxiedModel(props, "modelValue");
      const {
        scopeId
      } = useScopeId();
      const overlay = ref();
      function onFocusin(e) {
        var _a3, _b;
        const before = e.relatedTarget;
        const after = e.target;
        if (before !== after && ((_a3 = overlay.value) == null ? void 0 : _a3.contentEl) && ((_b = overlay.value) == null ? void 0 : _b.globalTop) && ![document, overlay.value.contentEl].includes(after) && !overlay.value.contentEl.contains(after)) {
          const focusable = focusableChildren(overlay.value.contentEl);
          if (!focusable.length)
            return;
          const firstElement = focusable[0];
          const lastElement = focusable[focusable.length - 1];
          if (before === firstElement) {
            lastElement.focus();
          } else {
            firstElement.focus();
          }
        }
      }
      onBeforeUnmount(() => {
        document.removeEventListener("focusin", onFocusin);
      });
      if (IN_BROWSER) {
        watch2(() => isActive.value && props.retainFocus, (val) => {
          val ? document.addEventListener("focusin", onFocusin) : document.removeEventListener("focusin", onFocusin);
        }, {
          immediate: true
        });
      }
      function onAfterEnter() {
        var _a3;
        emit2("afterEnter");
        if ((props.scrim || props.retainFocus) && ((_a3 = overlay.value) == null ? void 0 : _a3.contentEl) && !overlay.value.contentEl.contains(document.activeElement)) {
          overlay.value.contentEl.focus({
            preventScroll: true
          });
        }
      }
      function onAfterLeave() {
        emit2("afterLeave");
      }
      watch2(isActive, async (val) => {
        var _a3;
        if (!val) {
          await nextTick();
          (_a3 = overlay.value.activatorEl) == null ? void 0 : _a3.focus({
            preventScroll: true
          });
        }
      });
      useRender(() => {
        const overlayProps = VOverlay.filterProps(props);
        const activatorProps = mergeProps({
          "aria-haspopup": "dialog"
        }, props.activatorProps);
        const contentProps = mergeProps({
          tabindex: -1
        }, props.contentProps);
        return createVNode(VOverlay, mergeProps({
          "ref": overlay,
          "class": ["v-dialog", {
            "v-dialog--fullscreen": props.fullscreen,
            "v-dialog--scrollable": props.scrollable
          }, props.class],
          "style": props.style
        }, overlayProps, {
          "modelValue": isActive.value,
          "onUpdate:modelValue": ($event) => isActive.value = $event,
          "aria-modal": "true",
          "activatorProps": activatorProps,
          "contentProps": contentProps,
          "height": !props.fullscreen ? props.height : void 0,
          "width": !props.fullscreen ? props.width : void 0,
          "maxHeight": !props.fullscreen ? props.maxHeight : void 0,
          "maxWidth": !props.fullscreen ? props.maxWidth : void 0,
          "role": "dialog",
          "onAfterEnter": onAfterEnter,
          "onAfterLeave": onAfterLeave
        }, scopeId), {
          activator: slots.activator,
          default: function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return createVNode(VDefaultsProvider, {
              "root": "VDialog"
            }, {
              default: () => {
                var _a3;
                return [(_a3 = slots.default) == null ? void 0 : _a3.call(slots, ...args)];
              }
            });
          }
        });
      });
      return forwardRefs({}, overlay);
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VBottomSheet/VBottomSheet.js
  var makeVBottomSheetProps = propsFactory(__spreadValues({
    inset: Boolean
  }, makeVDialogProps({
    transition: "bottom-sheet-transition"
  })), "VBottomSheet");
  var VBottomSheet = genericComponent()({
    name: "VBottomSheet",
    props: makeVBottomSheetProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const isActive = useProxiedModel(props, "modelValue");
      useRender(() => {
        const dialogProps = VDialog.filterProps(props);
        return createVNode(VDialog, mergeProps(dialogProps, {
          "contentClass": ["v-bottom-sheet__content", props.contentClass],
          "modelValue": isActive.value,
          "onUpdate:modelValue": ($event) => isActive.value = $event,
          "class": ["v-bottom-sheet", {
            "v-bottom-sheet--inset": props.inset
          }, props.class],
          "style": props.style
        }), slots);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VBreadcrumbs/VBreadcrumbsDivider.js
  var makeVBreadcrumbsDividerProps = propsFactory(__spreadValues({
    divider: [Number, String]
  }, makeComponentProps()), "VBreadcrumbsDivider");
  var VBreadcrumbsDivider = genericComponent()({
    name: "VBreadcrumbsDivider",
    props: makeVBreadcrumbsDividerProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => {
        var _a3, _b;
        return createBaseVNode("li", {
          "aria-hidden": "true",
          "class": normalizeClass(["v-breadcrumbs-divider", props.class]),
          "style": normalizeStyle(props.style)
        }, [(_b = (_a3 = slots == null ? void 0 : slots.default) == null ? void 0 : _a3.call(slots)) != null ? _b : props.divider]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VBreadcrumbs/VBreadcrumbsItem.js
  var makeVBreadcrumbsItemProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({
    active: Boolean,
    activeClass: String,
    activeColor: String,
    color: String,
    disabled: Boolean,
    title: String
  }, makeComponentProps()), makeRouterProps()), makeTagProps({
    tag: "li"
  })), "VBreadcrumbsItem");
  var VBreadcrumbsItem = genericComponent()({
    name: "VBreadcrumbsItem",
    props: makeVBreadcrumbsItemProps(),
    setup(props, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      const link = useLink(props, attrs);
      const isActive = computed2(() => {
        var _a3;
        return props.active || ((_a3 = link.isActive) == null ? void 0 : _a3.value);
      });
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(() => isActive.value ? props.activeColor : props.color);
      useRender(() => {
        return createVNode(props.tag, {
          "class": normalizeClass(["v-breadcrumbs-item", {
            "v-breadcrumbs-item--active": isActive.value,
            "v-breadcrumbs-item--disabled": props.disabled,
            [`${props.activeClass}`]: isActive.value && props.activeClass
          }, textColorClasses.value, props.class]),
          "style": normalizeStyle([textColorStyles.value, props.style]),
          "aria-current": isActive.value ? "page" : void 0
        }, {
          default: () => {
            var _a3, _b, _c, _d;
            return [!link.isLink.value ? (_b = (_a3 = slots.default) == null ? void 0 : _a3.call(slots)) != null ? _b : props.title : createBaseVNode("a", mergeProps({
              "class": "v-breadcrumbs-item--link",
              "onClick": link.navigate
            }, link.linkProps), [(_d = (_c = slots.default) == null ? void 0 : _c.call(slots)) != null ? _d : props.title])];
          }
        });
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VBreadcrumbs/VBreadcrumbs.js
  var makeVBreadcrumbsProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    activeClass: String,
    activeColor: String,
    bgColor: String,
    color: String,
    disabled: Boolean,
    divider: {
      type: String,
      default: "/"
    },
    icon: IconValue,
    items: {
      type: Array,
      default: () => []
    }
  }, makeComponentProps()), makeDensityProps()), makeRoundedProps()), makeTagProps({
    tag: "ul"
  })), "VBreadcrumbs");
  var VBreadcrumbs = genericComponent()({
    name: "VBreadcrumbs",
    props: makeVBreadcrumbsProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(() => props.bgColor);
      const {
        densityClasses
      } = useDensity(props);
      const {
        roundedClasses
      } = useRounded(props);
      provideDefaults({
        VBreadcrumbsDivider: {
          divider: toRef(() => props.divider)
        },
        VBreadcrumbsItem: {
          activeClass: toRef(() => props.activeClass),
          activeColor: toRef(() => props.activeColor),
          color: toRef(() => props.color),
          disabled: toRef(() => props.disabled)
        }
      });
      const items = computed2(() => props.items.map((item) => {
        return typeof item === "string" ? {
          item: {
            title: item
          },
          raw: item
        } : {
          item,
          raw: item
        };
      }));
      useRender(() => {
        const hasPrepend = !!(slots.prepend || props.icon);
        return createVNode(props.tag, {
          "class": normalizeClass(["v-breadcrumbs", backgroundColorClasses.value, densityClasses.value, roundedClasses.value, props.class]),
          "style": normalizeStyle([backgroundColorStyles.value, props.style])
        }, {
          default: () => {
            var _a3;
            return [hasPrepend && createBaseVNode("li", {
              "key": "prepend",
              "class": "v-breadcrumbs__prepend"
            }, [!slots.prepend ? createVNode(VIcon, {
              "key": "prepend-icon",
              "start": true,
              "icon": props.icon
            }, null) : createVNode(VDefaultsProvider, {
              "key": "prepend-defaults",
              "disabled": !props.icon,
              "defaults": {
                VIcon: {
                  icon: props.icon,
                  start: true
                }
              }
            }, slots.prepend)]), items.value.map((_ref2, index, array) => {
              var _a4, _b;
              let {
                item,
                raw
              } = _ref2;
              return createBaseVNode(Fragment, null, [(_b = (_a4 = slots.item) == null ? void 0 : _a4.call(slots, {
                item,
                index
              })) != null ? _b : createVNode(VBreadcrumbsItem, mergeProps({
                "key": index,
                "disabled": index >= array.length - 1
              }, typeof item === "string" ? {
                title: item
              } : item), {
                default: slots.title ? () => {
                  var _a5;
                  return (_a5 = slots.title) == null ? void 0 : _a5.call(slots, {
                    item,
                    index
                  });
                } : void 0
              }), index < array.length - 1 && createVNode(VBreadcrumbsDivider, null, {
                default: slots.divider ? () => {
                  var _a5;
                  return (_a5 = slots.divider) == null ? void 0 : _a5.call(slots, {
                    item: raw,
                    index
                  });
                } : void 0
              })]);
            }), (_a3 = slots.default) == null ? void 0 : _a3.call(slots)];
          }
        });
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VCard/VCardActions.js
  var VCardActions = genericComponent()({
    name: "VCardActions",
    props: makeComponentProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      provideDefaults({
        VBtn: {
          slim: true,
          variant: "text"
        }
      });
      useRender(() => {
        var _a3;
        return createBaseVNode("div", {
          "class": normalizeClass(["v-card-actions", props.class]),
          "style": normalizeStyle(props.style)
        }, [(_a3 = slots.default) == null ? void 0 : _a3.call(slots)]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VCard/VCardSubtitle.js
  var makeVCardSubtitleProps = propsFactory(__spreadValues(__spreadValues({
    opacity: [Number, String]
  }, makeComponentProps()), makeTagProps()), "VCardSubtitle");
  var VCardSubtitle = genericComponent()({
    name: "VCardSubtitle",
    props: makeVCardSubtitleProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => createVNode(props.tag, {
        "class": normalizeClass(["v-card-subtitle", props.class]),
        "style": normalizeStyle([{
          "--v-card-subtitle-opacity": props.opacity
        }, props.style])
      }, slots));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VCard/VCardTitle.js
  var VCardTitle = createSimpleFunctional("v-card-title");

  // ../posawesome/node_modules/vuetify/lib/components/VCard/VCardItem.js
  var makeCardItemProps = propsFactory(__spreadValues(__spreadValues({
    appendAvatar: String,
    appendIcon: IconValue,
    prependAvatar: String,
    prependIcon: IconValue,
    subtitle: {
      type: [String, Number, Boolean],
      default: void 0
    },
    title: {
      type: [String, Number, Boolean],
      default: void 0
    }
  }, makeComponentProps()), makeDensityProps()), "VCardItem");
  var VCardItem = genericComponent()({
    name: "VCardItem",
    props: makeCardItemProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => {
        var _a3;
        const hasPrependMedia = !!(props.prependAvatar || props.prependIcon);
        const hasPrepend = !!(hasPrependMedia || slots.prepend);
        const hasAppendMedia = !!(props.appendAvatar || props.appendIcon);
        const hasAppend = !!(hasAppendMedia || slots.append);
        const hasTitle = !!(props.title != null || slots.title);
        const hasSubtitle = !!(props.subtitle != null || slots.subtitle);
        return createBaseVNode("div", {
          "class": normalizeClass(["v-card-item", props.class]),
          "style": normalizeStyle(props.style)
        }, [hasPrepend && createBaseVNode("div", {
          "key": "prepend",
          "class": "v-card-item__prepend"
        }, [!slots.prepend ? createBaseVNode(Fragment, null, [props.prependAvatar && createVNode(VAvatar, {
          "key": "prepend-avatar",
          "density": props.density,
          "image": props.prependAvatar
        }, null), props.prependIcon && createVNode(VIcon, {
          "key": "prepend-icon",
          "density": props.density,
          "icon": props.prependIcon
        }, null)]) : createVNode(VDefaultsProvider, {
          "key": "prepend-defaults",
          "disabled": !hasPrependMedia,
          "defaults": {
            VAvatar: {
              density: props.density,
              image: props.prependAvatar
            },
            VIcon: {
              density: props.density,
              icon: props.prependIcon
            }
          }
        }, slots.prepend)]), createBaseVNode("div", {
          "class": "v-card-item__content"
        }, [hasTitle && createVNode(VCardTitle, {
          "key": "title"
        }, {
          default: () => {
            var _a4, _b;
            return [(_b = (_a4 = slots.title) == null ? void 0 : _a4.call(slots)) != null ? _b : toDisplayString(props.title)];
          }
        }), hasSubtitle && createVNode(VCardSubtitle, {
          "key": "subtitle"
        }, {
          default: () => {
            var _a4, _b;
            return [(_b = (_a4 = slots.subtitle) == null ? void 0 : _a4.call(slots)) != null ? _b : toDisplayString(props.subtitle)];
          }
        }), (_a3 = slots.default) == null ? void 0 : _a3.call(slots)]), hasAppend && createBaseVNode("div", {
          "key": "append",
          "class": "v-card-item__append"
        }, [!slots.append ? createBaseVNode(Fragment, null, [props.appendIcon && createVNode(VIcon, {
          "key": "append-icon",
          "density": props.density,
          "icon": props.appendIcon
        }, null), props.appendAvatar && createVNode(VAvatar, {
          "key": "append-avatar",
          "density": props.density,
          "image": props.appendAvatar
        }, null)]) : createVNode(VDefaultsProvider, {
          "key": "append-defaults",
          "disabled": !hasAppendMedia,
          "defaults": {
            VAvatar: {
              density: props.density,
              image: props.appendAvatar
            },
            VIcon: {
              density: props.density,
              icon: props.appendIcon
            }
          }
        }, slots.append)])]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VCard/VCardText.js
  var makeVCardTextProps = propsFactory(__spreadValues(__spreadValues({
    opacity: [Number, String]
  }, makeComponentProps()), makeTagProps()), "VCardText");
  var VCardText = genericComponent()({
    name: "VCardText",
    props: makeVCardTextProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => createVNode(props.tag, {
        "class": normalizeClass(["v-card-text", props.class]),
        "style": normalizeStyle([{
          "--v-card-text-opacity": props.opacity
        }, props.style])
      }, slots));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VCard/VCard.js
  var makeVCardProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    appendAvatar: String,
    appendIcon: IconValue,
    disabled: Boolean,
    flat: Boolean,
    hover: Boolean,
    image: String,
    link: {
      type: Boolean,
      default: void 0
    },
    prependAvatar: String,
    prependIcon: IconValue,
    ripple: {
      type: [Boolean, Object],
      default: true
    },
    subtitle: {
      type: [String, Number, Boolean],
      default: void 0
    },
    text: {
      type: [String, Number, Boolean],
      default: void 0
    },
    title: {
      type: [String, Number, Boolean],
      default: void 0
    }
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeDimensionProps()), makeElevationProps()), makeLoaderProps()), makeLocationProps()), makePositionProps()), makeRoundedProps()), makeRouterProps()), makeTagProps()), makeThemeProps()), makeVariantProps({
    variant: "elevated"
  })), "VCard");
  var VCard = genericComponent()({
    name: "VCard",
    directives: {
      vRipple: ripple_default
    },
    props: makeVCardProps(),
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        borderClasses
      } = useBorder(props);
      const {
        colorClasses,
        colorStyles,
        variantClasses
      } = useVariant(props);
      const {
        densityClasses
      } = useDensity(props);
      const {
        dimensionStyles
      } = useDimension(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        loaderClasses
      } = useLoader(props);
      const {
        locationStyles
      } = useLocation(props);
      const {
        positionClasses
      } = usePosition(props);
      const {
        roundedClasses
      } = useRounded(props);
      const link = useLink(props, attrs);
      useRender(() => {
        const isLink = props.link !== false && link.isLink.value;
        const isClickable = !props.disabled && props.link !== false && (props.link || link.isClickable.value);
        const Tag = isLink ? "a" : props.tag;
        const hasTitle = !!(slots.title || props.title != null);
        const hasSubtitle = !!(slots.subtitle || props.subtitle != null);
        const hasHeader = hasTitle || hasSubtitle;
        const hasAppend = !!(slots.append || props.appendAvatar || props.appendIcon);
        const hasPrepend = !!(slots.prepend || props.prependAvatar || props.prependIcon);
        const hasImage = !!(slots.image || props.image);
        const hasCardItem = hasHeader || hasPrepend || hasAppend;
        const hasText = !!(slots.text || props.text != null);
        return withDirectives(createVNode(Tag, mergeProps({
          "class": ["v-card", {
            "v-card--disabled": props.disabled,
            "v-card--flat": props.flat,
            "v-card--hover": props.hover && !(props.disabled || props.flat),
            "v-card--link": isClickable
          }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, loaderClasses.value, positionClasses.value, roundedClasses.value, variantClasses.value, props.class],
          "style": [colorStyles.value, dimensionStyles.value, locationStyles.value, props.style],
          "onClick": isClickable && link.navigate,
          "tabindex": props.disabled ? -1 : void 0
        }, link.linkProps), {
          default: () => {
            var _a3;
            return [hasImage && createBaseVNode("div", {
              "key": "image",
              "class": "v-card__image"
            }, [!slots.image ? createVNode(VImg, {
              "key": "image-img",
              "cover": true,
              "src": props.image
            }, null) : createVNode(VDefaultsProvider, {
              "key": "image-defaults",
              "disabled": !props.image,
              "defaults": {
                VImg: {
                  cover: true,
                  src: props.image
                }
              }
            }, slots.image)]), createVNode(LoaderSlot, {
              "name": "v-card",
              "active": !!props.loading,
              "color": typeof props.loading === "boolean" ? void 0 : props.loading
            }, {
              default: slots.loader
            }), hasCardItem && createVNode(VCardItem, {
              "key": "item",
              "prependAvatar": props.prependAvatar,
              "prependIcon": props.prependIcon,
              "title": props.title,
              "subtitle": props.subtitle,
              "appendAvatar": props.appendAvatar,
              "appendIcon": props.appendIcon
            }, {
              default: slots.item,
              prepend: slots.prepend,
              title: slots.title,
              subtitle: slots.subtitle,
              append: slots.append
            }), hasText && createVNode(VCardText, {
              "key": "text"
            }, {
              default: () => {
                var _a4, _b;
                return [(_b = (_a4 = slots.text) == null ? void 0 : _a4.call(slots)) != null ? _b : props.text];
              }
            }), (_a3 = slots.default) == null ? void 0 : _a3.call(slots), slots.actions && createVNode(VCardActions, null, {
              default: slots.actions
            }), genOverlays(isClickable, "v-card")];
          }
        }), [[ripple_default, isClickable && props.ripple]]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/directives/touch/index.js
  var handleGesture = (wrapper) => {
    const {
      touchstartX,
      touchendX,
      touchstartY,
      touchendY
    } = wrapper;
    const dirRatio = 0.5;
    const minDistance = 16;
    wrapper.offsetX = touchendX - touchstartX;
    wrapper.offsetY = touchendY - touchstartY;
    if (Math.abs(wrapper.offsetY) < dirRatio * Math.abs(wrapper.offsetX)) {
      wrapper.left && touchendX < touchstartX - minDistance && wrapper.left(wrapper);
      wrapper.right && touchendX > touchstartX + minDistance && wrapper.right(wrapper);
    }
    if (Math.abs(wrapper.offsetX) < dirRatio * Math.abs(wrapper.offsetY)) {
      wrapper.up && touchendY < touchstartY - minDistance && wrapper.up(wrapper);
      wrapper.down && touchendY > touchstartY + minDistance && wrapper.down(wrapper);
    }
  };
  function touchstart(event2, wrapper) {
    var _a3;
    const touch = event2.changedTouches[0];
    wrapper.touchstartX = touch.clientX;
    wrapper.touchstartY = touch.clientY;
    (_a3 = wrapper.start) == null ? void 0 : _a3.call(wrapper, __spreadValues({
      originalEvent: event2
    }, wrapper));
  }
  function touchend(event2, wrapper) {
    var _a3;
    const touch = event2.changedTouches[0];
    wrapper.touchendX = touch.clientX;
    wrapper.touchendY = touch.clientY;
    (_a3 = wrapper.end) == null ? void 0 : _a3.call(wrapper, __spreadValues({
      originalEvent: event2
    }, wrapper));
    handleGesture(wrapper);
  }
  function touchmove(event2, wrapper) {
    var _a3;
    const touch = event2.changedTouches[0];
    wrapper.touchmoveX = touch.clientX;
    wrapper.touchmoveY = touch.clientY;
    (_a3 = wrapper.move) == null ? void 0 : _a3.call(wrapper, __spreadValues({
      originalEvent: event2
    }, wrapper));
  }
  function createHandlers() {
    let value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const wrapper = {
      touchstartX: 0,
      touchstartY: 0,
      touchendX: 0,
      touchendY: 0,
      touchmoveX: 0,
      touchmoveY: 0,
      offsetX: 0,
      offsetY: 0,
      left: value.left,
      right: value.right,
      up: value.up,
      down: value.down,
      start: value.start,
      move: value.move,
      end: value.end
    };
    return {
      touchstart: (e) => touchstart(e, wrapper),
      touchend: (e) => touchend(e, wrapper),
      touchmove: (e) => touchmove(e, wrapper)
    };
  }
  function mounted3(el, binding) {
    var _a3, _b, _c;
    const value = binding.value;
    const target = (value == null ? void 0 : value.parent) ? el.parentElement : el;
    const options = (_a3 = value == null ? void 0 : value.options) != null ? _a3 : {
      passive: true
    };
    const uid2 = (_b = binding.instance) == null ? void 0 : _b.$.uid;
    if (!target || !uid2)
      return;
    const handlers3 = createHandlers(binding.value);
    target._touchHandlers = (_c = target._touchHandlers) != null ? _c : /* @__PURE__ */ Object.create(null);
    target._touchHandlers[uid2] = handlers3;
    keys(handlers3).forEach((eventName2) => {
      target.addEventListener(eventName2, handlers3[eventName2], options);
    });
  }
  function unmounted3(el, binding) {
    var _a3, _b;
    const target = ((_a3 = binding.value) == null ? void 0 : _a3.parent) ? el.parentElement : el;
    const uid2 = (_b = binding.instance) == null ? void 0 : _b.$.uid;
    if (!(target == null ? void 0 : target._touchHandlers) || !uid2)
      return;
    const handlers3 = target._touchHandlers[uid2];
    keys(handlers3).forEach((eventName2) => {
      target.removeEventListener(eventName2, handlers3[eventName2]);
    });
    delete target._touchHandlers[uid2];
  }
  var Touch = {
    mounted: mounted3,
    unmounted: unmounted3
  };
  var touch_default = Touch;

  // ../posawesome/node_modules/vuetify/lib/components/VWindow/VWindow.js
  var VWindowSymbol = Symbol.for("vuetify:v-window");
  var VWindowGroupSymbol = Symbol.for("vuetify:v-window-group");
  var makeVWindowProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({
    continuous: Boolean,
    nextIcon: {
      type: [Boolean, String, Function, Object],
      default: "$next"
    },
    prevIcon: {
      type: [Boolean, String, Function, Object],
      default: "$prev"
    },
    reverse: Boolean,
    showArrows: {
      type: [Boolean, String],
      validator: (v) => typeof v === "boolean" || v === "hover"
    },
    touch: {
      type: [Object, Boolean],
      default: void 0
    },
    direction: {
      type: String,
      default: "horizontal"
    },
    modelValue: null,
    disabled: Boolean,
    selectedClass: {
      type: String,
      default: "v-window-item--active"
    },
    mandatory: {
      type: [Boolean, String],
      default: "force"
    }
  }, makeComponentProps()), makeTagProps()), makeThemeProps()), "VWindow");
  var VWindow = genericComponent()({
    name: "VWindow",
    directives: {
      vTouch: touch_default
    },
    props: makeVWindowProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        isRtl
      } = useRtl();
      const {
        t
      } = useLocale();
      const group = useGroup(props, VWindowGroupSymbol);
      const rootRef = ref();
      const isRtlReverse = computed2(() => isRtl.value ? !props.reverse : props.reverse);
      const isReversed = shallowRef(false);
      const transition = computed2(() => {
        const axis = props.direction === "vertical" ? "y" : "x";
        const reverse = isRtlReverse.value ? !isReversed.value : isReversed.value;
        const direction = reverse ? "-reverse" : "";
        return `v-window-${axis}${direction}-transition`;
      });
      const transitionCount = shallowRef(0);
      const transitionHeight = ref(void 0);
      const activeIndex = computed2(() => {
        return group.items.value.findIndex((item) => group.selected.value.includes(item.id));
      });
      watch2(activeIndex, (newVal, oldVal) => {
        const itemsLength = group.items.value.length;
        const lastIndex = itemsLength - 1;
        if (itemsLength <= 2) {
          isReversed.value = newVal < oldVal;
        } else if (newVal === lastIndex && oldVal === 0) {
          isReversed.value = true;
        } else if (newVal === 0 && oldVal === lastIndex) {
          isReversed.value = false;
        } else {
          isReversed.value = newVal < oldVal;
        }
      });
      provide(VWindowSymbol, {
        transition,
        isReversed,
        transitionCount,
        transitionHeight,
        rootRef
      });
      const canMoveBack = toRef(() => props.continuous || activeIndex.value !== 0);
      const canMoveForward = toRef(() => props.continuous || activeIndex.value !== group.items.value.length - 1);
      function prev() {
        canMoveBack.value && group.prev();
      }
      function next() {
        canMoveForward.value && group.next();
      }
      const arrows = computed2(() => {
        const arrows2 = [];
        const prevProps = {
          icon: isRtl.value ? props.nextIcon : props.prevIcon,
          class: `v-window__${isRtlReverse.value ? "right" : "left"}`,
          onClick: group.prev,
          "aria-label": t("$vuetify.carousel.prev")
        };
        arrows2.push(canMoveBack.value ? slots.prev ? slots.prev({
          props: prevProps
        }) : createVNode(VBtn, prevProps, null) : createBaseVNode("div", null, null));
        const nextProps = {
          icon: isRtl.value ? props.prevIcon : props.nextIcon,
          class: `v-window__${isRtlReverse.value ? "left" : "right"}`,
          onClick: group.next,
          "aria-label": t("$vuetify.carousel.next")
        };
        arrows2.push(canMoveForward.value ? slots.next ? slots.next({
          props: nextProps
        }) : createVNode(VBtn, nextProps, null) : createBaseVNode("div", null, null));
        return arrows2;
      });
      const touchOptions = computed2(() => {
        if (props.touch === false)
          return props.touch;
        const options = {
          left: () => {
            isRtlReverse.value ? prev() : next();
          },
          right: () => {
            isRtlReverse.value ? next() : prev();
          },
          start: (_ref2) => {
            let {
              originalEvent
            } = _ref2;
            originalEvent.stopPropagation();
          }
        };
        return __spreadValues(__spreadValues({}, options), props.touch === true ? {} : props.touch);
      });
      useRender(() => withDirectives(createVNode(props.tag, {
        "ref": rootRef,
        "class": normalizeClass(["v-window", {
          "v-window--show-arrows-on-hover": props.showArrows === "hover"
        }, themeClasses.value, props.class]),
        "style": normalizeStyle(props.style)
      }, {
        default: () => {
          var _a3, _b;
          return [createBaseVNode("div", {
            "class": "v-window__container",
            "style": {
              height: transitionHeight.value
            }
          }, [(_a3 = slots.default) == null ? void 0 : _a3.call(slots, {
            group
          }), props.showArrows !== false && createBaseVNode("div", {
            "class": "v-window__controls"
          }, [arrows.value])]), (_b = slots.additional) == null ? void 0 : _b.call(slots, {
            group
          })];
        }
      }), [[touch_default, touchOptions.value]]));
      return {
        group
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VCarousel/VCarousel.js
  var makeVCarouselProps = propsFactory(__spreadValues({
    color: String,
    cycle: Boolean,
    delimiterIcon: {
      type: IconValue,
      default: "$delimiter"
    },
    height: {
      type: [Number, String],
      default: 500
    },
    hideDelimiters: Boolean,
    hideDelimiterBackground: Boolean,
    interval: {
      type: [Number, String],
      default: 6e3,
      validator: (value) => Number(value) > 0
    },
    progress: [Boolean, String],
    verticalDelimiters: [Boolean, String]
  }, makeVWindowProps({
    continuous: true,
    mandatory: "force",
    showArrows: true
  })), "VCarousel");
  var VCarousel = genericComponent()({
    name: "VCarousel",
    props: makeVCarouselProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const model = useProxiedModel(props, "modelValue");
      const {
        t
      } = useLocale();
      const windowRef = ref();
      let slideTimeout = -1;
      watch2(model, restartTimeout);
      watch2(() => props.interval, restartTimeout);
      watch2(() => props.cycle, (val) => {
        if (val)
          restartTimeout();
        else
          window.clearTimeout(slideTimeout);
      });
      onMounted(startTimeout);
      function startTimeout() {
        if (!props.cycle || !windowRef.value)
          return;
        slideTimeout = window.setTimeout(windowRef.value.group.next, Number(props.interval) > 0 ? Number(props.interval) : 6e3);
      }
      function restartTimeout() {
        window.clearTimeout(slideTimeout);
        window.requestAnimationFrame(startTimeout);
      }
      useRender(() => {
        const windowProps = VWindow.filterProps(props);
        return createVNode(VWindow, mergeProps({
          "ref": windowRef
        }, windowProps, {
          "modelValue": model.value,
          "onUpdate:modelValue": ($event) => model.value = $event,
          "class": ["v-carousel", {
            "v-carousel--hide-delimiter-background": props.hideDelimiterBackground,
            "v-carousel--vertical-delimiters": props.verticalDelimiters
          }, props.class],
          "style": [{
            height: convertToUnit(props.height)
          }, props.style]
        }), {
          default: slots.default,
          additional: (_ref2) => {
            let {
              group
            } = _ref2;
            return createBaseVNode(Fragment, null, [!props.hideDelimiters && createBaseVNode("div", {
              "class": "v-carousel__controls",
              "style": {
                left: props.verticalDelimiters === "left" && props.verticalDelimiters ? 0 : "auto",
                right: props.verticalDelimiters === "right" ? 0 : "auto"
              }
            }, [group.items.value.length > 0 && createVNode(VDefaultsProvider, {
              "defaults": {
                VBtn: {
                  color: props.color,
                  icon: props.delimiterIcon,
                  size: "x-small",
                  variant: "text"
                }
              },
              "scoped": true
            }, {
              default: () => [group.items.value.map((item, index) => {
                const props2 = {
                  id: `carousel-item-${item.id}`,
                  "aria-label": t("$vuetify.carousel.ariaLabel.delimiter", index + 1, group.items.value.length),
                  class: ["v-carousel__controls__item", group.isSelected(item.id) && "v-btn--active"],
                  onClick: () => group.select(item.id, true)
                };
                return slots.item ? slots.item({
                  props: props2,
                  item
                }) : createVNode(VBtn, mergeProps(item, props2), null);
              })]
            })]), props.progress && createVNode(VProgressLinear, {
              "class": "v-carousel__progress",
              "color": typeof props.progress === "string" ? props.progress : void 0,
              "modelValue": (group.getItemIndex(model.value) + 1) / group.items.value.length * 100
            }, null)]);
          },
          prev: slots.prev,
          next: slots.next
        });
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VWindow/VWindowItem.js
  var makeVWindowItemProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({
    reverseTransition: {
      type: [Boolean, String],
      default: void 0
    },
    transition: {
      type: [Boolean, String],
      default: void 0
    }
  }, makeComponentProps()), makeGroupItemProps()), makeLazyProps()), "VWindowItem");
  var VWindowItem = genericComponent()({
    name: "VWindowItem",
    directives: {
      vTouch: touch_default
    },
    props: makeVWindowItemProps(),
    emits: {
      "group:selected": (val) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const window2 = inject(VWindowSymbol);
      const groupItem = useGroupItem(props, VWindowGroupSymbol);
      const {
        isBooted
      } = useSsrBoot();
      if (!window2 || !groupItem)
        throw new Error("[Vuetify] VWindowItem must be used inside VWindow");
      const isTransitioning = shallowRef(false);
      const hasTransition = computed2(() => isBooted.value && (window2.isReversed.value ? props.reverseTransition !== false : props.transition !== false));
      function onAfterTransition() {
        if (!isTransitioning.value || !window2) {
          return;
        }
        isTransitioning.value = false;
        if (window2.transitionCount.value > 0) {
          window2.transitionCount.value -= 1;
          if (window2.transitionCount.value === 0) {
            window2.transitionHeight.value = void 0;
          }
        }
      }
      function onBeforeTransition() {
        var _a3;
        if (isTransitioning.value || !window2) {
          return;
        }
        isTransitioning.value = true;
        if (window2.transitionCount.value === 0) {
          window2.transitionHeight.value = convertToUnit((_a3 = window2.rootRef.value) == null ? void 0 : _a3.clientHeight);
        }
        window2.transitionCount.value += 1;
      }
      function onTransitionCancelled() {
        onAfterTransition();
      }
      function onEnterTransition(el) {
        if (!isTransitioning.value) {
          return;
        }
        nextTick(() => {
          if (!hasTransition.value || !isTransitioning.value || !window2) {
            return;
          }
          window2.transitionHeight.value = convertToUnit(el.clientHeight);
        });
      }
      const transition = computed2(() => {
        const name = window2.isReversed.value ? props.reverseTransition : props.transition;
        return !hasTransition.value ? false : {
          name: typeof name !== "string" ? window2.transition.value : name,
          onBeforeEnter: onBeforeTransition,
          onAfterEnter: onAfterTransition,
          onEnterCancelled: onTransitionCancelled,
          onBeforeLeave: onBeforeTransition,
          onAfterLeave: onAfterTransition,
          onLeaveCancelled: onTransitionCancelled,
          onEnter: onEnterTransition
        };
      });
      const {
        hasContent
      } = useLazy(props, groupItem.isSelected);
      useRender(() => createVNode(MaybeTransition, {
        "transition": transition.value,
        "disabled": !isBooted.value
      }, {
        default: () => {
          var _a3;
          return [withDirectives(createBaseVNode("div", {
            "class": normalizeClass(["v-window-item", groupItem.selectedClass.value, props.class]),
            "style": normalizeStyle(props.style)
          }, [hasContent.value && ((_a3 = slots.default) == null ? void 0 : _a3.call(slots))]), [[vShow, groupItem.isSelected.value]])];
        }
      }));
      return {
        groupItem
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VCarousel/VCarouselItem.js
  var makeVCarouselItemProps = propsFactory(__spreadValues(__spreadValues({}, makeVImgProps()), makeVWindowItemProps()), "VCarouselItem");
  var VCarouselItem = genericComponent()({
    name: "VCarouselItem",
    inheritAttrs: false,
    props: makeVCarouselItemProps(),
    setup(props, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      useRender(() => {
        const imgProps = VImg.filterProps(props);
        const windowItemProps = VWindowItem.filterProps(props);
        return createVNode(VWindowItem, mergeProps({
          "class": ["v-carousel-item", props.class]
        }, windowItemProps), {
          default: () => [createVNode(VImg, mergeProps(attrs, imgProps), slots)]
        });
      });
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VCode/index.js
  var VCode = createSimpleFunctional("v-code", "code");

  // ../posawesome/node_modules/vuetify/lib/components/VColorPicker/VColorPickerCanvas.js
  var makeVColorPickerCanvasProps = propsFactory(__spreadValues({
    color: {
      type: Object
    },
    disabled: Boolean,
    dotSize: {
      type: [Number, String],
      default: 10
    },
    height: {
      type: [Number, String],
      default: 150
    },
    width: {
      type: [Number, String],
      default: 300
    }
  }, makeComponentProps()), "VColorPickerCanvas");
  var VColorPickerCanvas = defineComponent2({
    name: "VColorPickerCanvas",
    props: makeVColorPickerCanvasProps(),
    emits: {
      "update:color": (color) => true,
      "update:position": (hue) => true
    },
    setup(props, _ref) {
      let {
        emit: emit2
      } = _ref;
      const isInteracting = shallowRef(false);
      const canvasRef = ref();
      const canvasWidth = shallowRef(parseFloat(props.width));
      const canvasHeight = shallowRef(parseFloat(props.height));
      const _dotPosition = ref({
        x: 0,
        y: 0
      });
      const dotPosition = computed2({
        get: () => _dotPosition.value,
        set(val) {
          var _a3, _b, _c, _d;
          if (!canvasRef.value)
            return;
          const {
            x,
            y
          } = val;
          _dotPosition.value = val;
          emit2("update:color", {
            h: (_b = (_a3 = props.color) == null ? void 0 : _a3.h) != null ? _b : 0,
            s: clamp(x, 0, canvasWidth.value) / canvasWidth.value,
            v: 1 - clamp(y, 0, canvasHeight.value) / canvasHeight.value,
            a: (_d = (_c = props.color) == null ? void 0 : _c.a) != null ? _d : 1
          });
        }
      });
      const dotStyles = computed2(() => {
        const {
          x,
          y
        } = dotPosition.value;
        const radius = parseInt(props.dotSize, 10) / 2;
        return {
          width: convertToUnit(props.dotSize),
          height: convertToUnit(props.dotSize),
          transform: `translate(${convertToUnit(x - radius)}, ${convertToUnit(y - radius)})`
        };
      });
      const {
        resizeRef
      } = useResizeObserver((entries) => {
        var _a3;
        if (!((_a3 = resizeRef.el) == null ? void 0 : _a3.offsetParent))
          return;
        const {
          width,
          height
        } = entries[0].contentRect;
        canvasWidth.value = width;
        canvasHeight.value = height;
      });
      function updateDotPosition(x, y, rect) {
        const {
          left,
          top,
          width,
          height
        } = rect;
        dotPosition.value = {
          x: clamp(x - left, 0, width),
          y: clamp(y - top, 0, height)
        };
      }
      function handleMouseDown(e) {
        if (e.type === "mousedown") {
          e.preventDefault();
        }
        if (props.disabled)
          return;
        handleMouseMove(e);
        window.addEventListener("mousemove", handleMouseMove);
        window.addEventListener("mouseup", handleMouseUp);
        window.addEventListener("touchmove", handleMouseMove);
        window.addEventListener("touchend", handleMouseUp);
      }
      function handleMouseMove(e) {
        if (props.disabled || !canvasRef.value)
          return;
        isInteracting.value = true;
        const coords = getEventCoordinates(e);
        updateDotPosition(coords.clientX, coords.clientY, canvasRef.value.getBoundingClientRect());
      }
      function handleMouseUp() {
        window.removeEventListener("mousemove", handleMouseMove);
        window.removeEventListener("mouseup", handleMouseUp);
        window.removeEventListener("touchmove", handleMouseMove);
        window.removeEventListener("touchend", handleMouseUp);
      }
      function updateCanvas() {
        var _a3, _b;
        if (!canvasRef.value)
          return;
        const canvas = canvasRef.value;
        const ctx = canvas.getContext("2d");
        if (!ctx)
          return;
        const saturationGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
        saturationGradient.addColorStop(0, "hsla(0, 0%, 100%, 1)");
        saturationGradient.addColorStop(1, `hsla(${(_b = (_a3 = props.color) == null ? void 0 : _a3.h) != null ? _b : 0}, 100%, 50%, 1)`);
        ctx.fillStyle = saturationGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        const valueGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        valueGradient.addColorStop(0, "hsla(0, 0%, 0%, 0)");
        valueGradient.addColorStop(1, "hsla(0, 0%, 0%, 1)");
        ctx.fillStyle = valueGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      watch2(() => {
        var _a3;
        return (_a3 = props.color) == null ? void 0 : _a3.h;
      }, updateCanvas, {
        immediate: true
      });
      watch2(() => [canvasWidth.value, canvasHeight.value], (newVal, oldVal) => {
        updateCanvas();
        _dotPosition.value = {
          x: dotPosition.value.x * newVal[0] / oldVal[0],
          y: dotPosition.value.y * newVal[1] / oldVal[1]
        };
      }, {
        flush: "post"
      });
      watch2(() => props.color, () => {
        if (isInteracting.value) {
          isInteracting.value = false;
          return;
        }
        _dotPosition.value = props.color ? {
          x: props.color.s * canvasWidth.value,
          y: (1 - props.color.v) * canvasHeight.value
        } : {
          x: 0,
          y: 0
        };
      }, {
        deep: true,
        immediate: true
      });
      onMounted(() => updateCanvas());
      useRender(() => createBaseVNode("div", {
        "ref": resizeRef,
        "class": normalizeClass(["v-color-picker-canvas", props.class]),
        "style": normalizeStyle(props.style),
        "onMousedown": handleMouseDown,
        "onTouchstartPassive": handleMouseDown
      }, [createBaseVNode("canvas", {
        "ref": canvasRef,
        "width": canvasWidth.value,
        "height": canvasHeight.value
      }, null), props.color && createBaseVNode("div", {
        "class": normalizeClass(["v-color-picker-canvas__dot", {
          "v-color-picker-canvas__dot--disabled": props.disabled
        }]),
        "style": normalizeStyle(dotStyles.value)
      }, null)]));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VColorPicker/util/index.js
  function stripAlpha(color, stripAlpha2) {
    if (stripAlpha2) {
      const _a3 = color, {
        a
      } = _a3, rest = __objRest(_a3, [
        "a"
      ]);
      return rest;
    }
    return color;
  }
  function extractColor(color, input) {
    if (input == null || typeof input === "string") {
      const hasA = color.a !== 1;
      if (input == null ? void 0 : input.startsWith("rgb(")) {
        const {
          r,
          g,
          b,
          a
        } = HSVtoRGB(color);
        return `rgb(${r} ${g} ${b}` + (hasA ? ` / ${a})` : ")");
      } else if (input == null ? void 0 : input.startsWith("hsl(")) {
        const {
          h: h2,
          s,
          l,
          a
        } = HSVtoHSL(color);
        return `hsl(${h2} ${Math.round(s * 100)} ${Math.round(l * 100)}` + (hasA ? ` / ${a})` : ")");
      }
      const hex2 = HSVtoHex(color);
      if (color.a === 1)
        return hex2.slice(0, 7);
      else
        return hex2;
    }
    if (typeof input === "object") {
      let converted;
      if (has(input, ["r", "g", "b"]))
        converted = HSVtoRGB(color);
      else if (has(input, ["h", "s", "l"]))
        converted = HSVtoHSL(color);
      else if (has(input, ["h", "s", "v"]))
        converted = color;
      return stripAlpha(converted, !has(input, ["a"]) && color.a === 1);
    }
    return color;
  }
  var nullColor = {
    h: 0,
    s: 0,
    v: 0,
    a: 1
  };
  var rgba = {
    inputProps: {
      type: "number",
      min: 0
    },
    inputs: [{
      label: "R",
      max: 255,
      step: 1,
      getValue: (c) => Math.round(c.r),
      getColor: (c, v) => __spreadProps(__spreadValues({}, c), {
        r: Number(v)
      })
    }, {
      label: "G",
      max: 255,
      step: 1,
      getValue: (c) => Math.round(c.g),
      getColor: (c, v) => __spreadProps(__spreadValues({}, c), {
        g: Number(v)
      })
    }, {
      label: "B",
      max: 255,
      step: 1,
      getValue: (c) => Math.round(c.b),
      getColor: (c, v) => __spreadProps(__spreadValues({}, c), {
        b: Number(v)
      })
    }, {
      label: "A",
      max: 1,
      step: 0.01,
      getValue: (_ref) => {
        let {
          a
        } = _ref;
        return a != null ? Math.round(a * 100) / 100 : 1;
      },
      getColor: (c, v) => __spreadProps(__spreadValues({}, c), {
        a: Number(v)
      })
    }],
    to: HSVtoRGB,
    from: RGBtoHSV
  };
  var _a2;
  var rgb = __spreadProps(__spreadValues({}, rgba), {
    inputs: (_a2 = rgba.inputs) == null ? void 0 : _a2.slice(0, 3)
  });
  var hsla = {
    inputProps: {
      type: "number",
      min: 0
    },
    inputs: [{
      label: "H",
      max: 360,
      step: 1,
      getValue: (c) => Math.round(c.h),
      getColor: (c, v) => __spreadProps(__spreadValues({}, c), {
        h: Number(v)
      })
    }, {
      label: "S",
      max: 1,
      step: 0.01,
      getValue: (c) => Math.round(c.s * 100) / 100,
      getColor: (c, v) => __spreadProps(__spreadValues({}, c), {
        s: Number(v)
      })
    }, {
      label: "L",
      max: 1,
      step: 0.01,
      getValue: (c) => Math.round(c.l * 100) / 100,
      getColor: (c, v) => __spreadProps(__spreadValues({}, c), {
        l: Number(v)
      })
    }, {
      label: "A",
      max: 1,
      step: 0.01,
      getValue: (_ref2) => {
        let {
          a
        } = _ref2;
        return a != null ? Math.round(a * 100) / 100 : 1;
      },
      getColor: (c, v) => __spreadProps(__spreadValues({}, c), {
        a: Number(v)
      })
    }],
    to: HSVtoHSL,
    from: HSLtoHSV
  };
  var hsl = __spreadProps(__spreadValues({}, hsla), {
    inputs: hsla.inputs.slice(0, 3)
  });
  var hexa = {
    inputProps: {
      type: "text"
    },
    inputs: [{
      label: "HEXA",
      getValue: (c) => c,
      getColor: (c, v) => v
    }],
    to: HSVtoHex,
    from: HexToHSV
  };
  var hex = __spreadProps(__spreadValues({}, hexa), {
    inputs: [{
      label: "HEX",
      getValue: (c) => c.slice(0, 7),
      getColor: (c, v) => v
    }]
  });
  var modes = {
    rgb,
    rgba,
    hsl,
    hsla,
    hex,
    hexa
  };

  // ../posawesome/node_modules/vuetify/lib/components/VColorPicker/VColorPickerEdit.js
  var VColorPickerInput = (_ref) => {
    let _a3 = _ref, {
      label
    } = _a3, rest = __objRest(_a3, [
      "label"
    ]);
    return createBaseVNode("div", {
      "class": "v-color-picker-edit__input"
    }, [createBaseVNode("input", normalizeProps(guardReactiveProps(rest)), null), createBaseVNode("span", null, [label])]);
  };
  var makeVColorPickerEditProps = propsFactory(__spreadValues({
    color: Object,
    disabled: Boolean,
    mode: {
      type: String,
      default: "rgba",
      validator: (v) => Object.keys(modes).includes(v)
    },
    modes: {
      type: Array,
      default: () => Object.keys(modes),
      validator: (v) => Array.isArray(v) && v.every((m) => Object.keys(modes).includes(m))
    }
  }, makeComponentProps()), "VColorPickerEdit");
  var VColorPickerEdit = defineComponent2({
    name: "VColorPickerEdit",
    props: makeVColorPickerEditProps(),
    emits: {
      "update:color": (color) => true,
      "update:mode": (mode) => true
    },
    setup(props, _ref2) {
      let {
        emit: emit2
      } = _ref2;
      const enabledModes = computed2(() => {
        return props.modes.map((key) => __spreadProps(__spreadValues({}, modes[key]), {
          name: key
        }));
      });
      const inputs = computed2(() => {
        var _a3;
        const mode = enabledModes.value.find((m) => m.name === props.mode);
        if (!mode)
          return [];
        const color = props.color ? mode.to(props.color) : null;
        return (_a3 = mode.inputs) == null ? void 0 : _a3.map((_ref3) => {
          let _a4 = _ref3, {
            getValue,
            getColor
          } = _a4, inputProps = __objRest(_a4, [
            "getValue",
            "getColor"
          ]);
          return __spreadProps(__spreadValues(__spreadValues({}, mode.inputProps), inputProps), {
            disabled: props.disabled,
            value: color && getValue(color),
            onChange: (e) => {
              const target = e.target;
              if (!target)
                return;
              emit2("update:color", mode.from(getColor(color != null ? color : mode.to(nullColor), target.value)));
            }
          });
        });
      });
      useRender(() => {
        var _a3;
        return createBaseVNode("div", {
          "class": normalizeClass(["v-color-picker-edit", props.class]),
          "style": normalizeStyle(props.style)
        }, [(_a3 = inputs.value) == null ? void 0 : _a3.map((props2) => createVNode(VColorPickerInput, props2, null)), enabledModes.value.length > 1 && createVNode(VBtn, {
          "icon": "$unfold",
          "size": "x-small",
          "variant": "plain",
          "onClick": () => {
            const mi2 = enabledModes.value.findIndex((m) => m.name === props.mode);
            emit2("update:mode", enabledModes.value[(mi2 + 1) % enabledModes.value.length].name);
          }
        }, null)]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VSlider/slider.js
  var VSliderSymbol = Symbol.for("vuetify:v-slider");
  function getOffset3(e, el, direction) {
    const vertical = direction === "vertical";
    const rect = el.getBoundingClientRect();
    const touch = "touches" in e ? e.touches[0] : e;
    return vertical ? touch.clientY - (rect.top + rect.height / 2) : touch.clientX - (rect.left + rect.width / 2);
  }
  function getPosition(e, position) {
    if ("touches" in e && e.touches.length)
      return e.touches[0][position];
    else if ("changedTouches" in e && e.changedTouches.length)
      return e.changedTouches[0][position];
    else
      return e[position];
  }
  var makeSliderProps = propsFactory(__spreadProps(__spreadValues(__spreadValues({
    disabled: {
      type: Boolean,
      default: null
    },
    error: Boolean,
    readonly: {
      type: Boolean,
      default: null
    },
    max: {
      type: [Number, String],
      default: 100
    },
    min: {
      type: [Number, String],
      default: 0
    },
    step: {
      type: [Number, String],
      default: 0
    },
    thumbColor: String,
    thumbLabel: {
      type: [Boolean, String],
      default: void 0,
      validator: (v) => typeof v === "boolean" || v === "always"
    },
    thumbSize: {
      type: [Number, String],
      default: 20
    },
    showTicks: {
      type: [Boolean, String],
      default: false,
      validator: (v) => typeof v === "boolean" || v === "always"
    },
    ticks: {
      type: [Array, Object]
    },
    tickSize: {
      type: [Number, String],
      default: 2
    },
    color: String,
    trackColor: String,
    trackFillColor: String,
    trackSize: {
      type: [Number, String],
      default: 4
    },
    direction: {
      type: String,
      default: "horizontal",
      validator: (v) => ["vertical", "horizontal"].includes(v)
    },
    reverse: Boolean
  }, makeRoundedProps()), makeElevationProps({
    elevation: 2
  })), {
    ripple: {
      type: Boolean,
      default: true
    }
  }), "Slider");
  var useSteps = (props) => {
    const min = computed2(() => parseFloat(props.min));
    const max = computed2(() => parseFloat(props.max));
    const step = computed2(() => Number(props.step) > 0 ? parseFloat(props.step) : 0);
    const decimals = computed2(() => Math.max(getDecimals(step.value), getDecimals(min.value)));
    function roundValue(value) {
      value = parseFloat(value);
      if (step.value <= 0)
        return value;
      const clamped = clamp(value, min.value, max.value);
      const offset = min.value % step.value;
      let newValue = Math.round((clamped - offset) / step.value) * step.value + offset;
      if (clamped > newValue && newValue + step.value > max.value) {
        newValue = max.value;
      }
      return parseFloat(Math.min(newValue, max.value).toFixed(decimals.value));
    }
    return {
      min,
      max,
      step,
      decimals,
      roundValue
    };
  };
  var useSlider = (_ref) => {
    let {
      props,
      steps,
      onSliderStart,
      onSliderMove,
      onSliderEnd,
      getActiveThumb
    } = _ref;
    const {
      isRtl
    } = useRtl();
    const isReversed = toRef(() => props.reverse);
    const vertical = computed2(() => props.direction === "vertical");
    const indexFromEnd = computed2(() => vertical.value !== isReversed.value);
    const {
      min,
      max,
      step,
      decimals,
      roundValue
    } = steps;
    const thumbSize = computed2(() => parseInt(props.thumbSize, 10));
    const tickSize = computed2(() => parseInt(props.tickSize, 10));
    const trackSize = computed2(() => parseInt(props.trackSize, 10));
    const numTicks = computed2(() => (max.value - min.value) / step.value);
    const disabled = toRef(() => props.disabled);
    const thumbColor = computed2(() => {
      var _a3;
      return props.error || props.disabled ? void 0 : (_a3 = props.thumbColor) != null ? _a3 : props.color;
    });
    const trackColor = computed2(() => {
      var _a3;
      return props.error || props.disabled ? void 0 : (_a3 = props.trackColor) != null ? _a3 : props.color;
    });
    const trackFillColor = computed2(() => {
      var _a3;
      return props.error || props.disabled ? void 0 : (_a3 = props.trackFillColor) != null ? _a3 : props.color;
    });
    const mousePressed = shallowRef(false);
    const startOffset = shallowRef(0);
    const trackContainerRef = ref();
    const activeThumbRef = ref();
    function parseMouseMove(e) {
      var _a3;
      const el = (_a3 = trackContainerRef.value) == null ? void 0 : _a3.$el;
      if (!el)
        return;
      const vertical2 = props.direction === "vertical";
      const start = vertical2 ? "top" : "left";
      const length = vertical2 ? "height" : "width";
      const position2 = vertical2 ? "clientY" : "clientX";
      const {
        [start]: trackStart,
        [length]: trackLength
      } = el.getBoundingClientRect();
      const clickOffset = getPosition(e, position2);
      let clickPos = clamp((clickOffset - trackStart - startOffset.value) / trackLength) || 0;
      if (vertical2 ? indexFromEnd.value : indexFromEnd.value !== isRtl.value)
        clickPos = 1 - clickPos;
      return roundValue(min.value + clickPos * (max.value - min.value));
    }
    const handleStop = (e) => {
      const value = parseMouseMove(e);
      if (value != null) {
        onSliderEnd({
          value
        });
      }
      mousePressed.value = false;
      startOffset.value = 0;
    };
    const handleStart = (e) => {
      const value = parseMouseMove(e);
      activeThumbRef.value = getActiveThumb(e);
      if (!activeThumbRef.value)
        return;
      mousePressed.value = true;
      if (activeThumbRef.value.contains(e.target)) {
        startOffset.value = getOffset3(e, activeThumbRef.value, props.direction);
      } else {
        startOffset.value = 0;
        if (value != null) {
          onSliderMove({
            value
          });
        }
      }
      if (value != null) {
        onSliderStart({
          value
        });
      }
      nextTick(() => {
        var _a3;
        return (_a3 = activeThumbRef.value) == null ? void 0 : _a3.focus();
      });
    };
    const moveListenerOptions = {
      passive: true,
      capture: true
    };
    function onMouseMove(e) {
      const value = parseMouseMove(e);
      if (value != null) {
        onSliderMove({
          value
        });
      }
    }
    function onSliderMouseUp(e) {
      e.stopPropagation();
      e.preventDefault();
      handleStop(e);
      window.removeEventListener("mousemove", onMouseMove, moveListenerOptions);
      window.removeEventListener("mouseup", onSliderMouseUp);
    }
    function onSliderTouchend(e) {
      var _a3;
      handleStop(e);
      window.removeEventListener("touchmove", onMouseMove, moveListenerOptions);
      (_a3 = e.target) == null ? void 0 : _a3.removeEventListener("touchend", onSliderTouchend);
    }
    function onSliderTouchstart(e) {
      var _a3;
      handleStart(e);
      window.addEventListener("touchmove", onMouseMove, moveListenerOptions);
      (_a3 = e.target) == null ? void 0 : _a3.addEventListener("touchend", onSliderTouchend, {
        passive: false
      });
    }
    function onSliderMousedown(e) {
      if (e.button !== 0)
        return;
      e.preventDefault();
      handleStart(e);
      window.addEventListener("mousemove", onMouseMove, moveListenerOptions);
      window.addEventListener("mouseup", onSliderMouseUp, {
        passive: false
      });
    }
    const position = (val) => {
      const percentage = (val - min.value) / (max.value - min.value) * 100;
      return clamp(isNaN(percentage) ? 0 : percentage, 0, 100);
    };
    const showTicks = toRef(() => props.showTicks);
    const parsedTicks = computed2(() => {
      if (!showTicks.value)
        return [];
      if (!props.ticks) {
        return numTicks.value !== Infinity ? createRange(numTicks.value + 1).map((t) => {
          const value = min.value + t * step.value;
          return {
            value,
            position: position(value)
          };
        }) : [];
      }
      if (Array.isArray(props.ticks))
        return props.ticks.map((t) => ({
          value: t,
          position: position(t),
          label: t.toString()
        }));
      return Object.keys(props.ticks).map((key) => ({
        value: parseFloat(key),
        position: position(parseFloat(key)),
        label: props.ticks[key]
      }));
    });
    const hasLabels = computed2(() => parsedTicks.value.some((_ref2) => {
      let {
        label
      } = _ref2;
      return !!label;
    }));
    const data = {
      activeThumbRef,
      color: toRef(() => props.color),
      decimals,
      disabled,
      direction: toRef(() => props.direction),
      elevation: toRef(() => props.elevation),
      hasLabels,
      isReversed,
      indexFromEnd,
      min,
      max,
      mousePressed,
      numTicks,
      onSliderMousedown,
      onSliderTouchstart,
      parsedTicks,
      parseMouseMove,
      position,
      readonly: toRef(() => props.readonly),
      rounded: toRef(() => props.rounded),
      roundValue,
      showTicks,
      startOffset,
      step,
      thumbSize,
      thumbColor,
      thumbLabel: toRef(() => props.thumbLabel),
      ticks: toRef(() => props.ticks),
      tickSize,
      trackColor,
      trackContainerRef,
      trackFillColor,
      trackSize,
      vertical
    };
    provide(VSliderSymbol, data);
    return data;
  };

  // ../posawesome/node_modules/vuetify/lib/components/VSlider/VSliderThumb.js
  var makeVSliderThumbProps = propsFactory(__spreadValues({
    focused: Boolean,
    max: {
      type: Number,
      required: true
    },
    min: {
      type: Number,
      required: true
    },
    modelValue: {
      type: Number,
      required: true
    },
    position: {
      type: Number,
      required: true
    },
    ripple: {
      type: [Boolean, Object],
      default: true
    },
    name: String
  }, makeComponentProps()), "VSliderThumb");
  var VSliderThumb = genericComponent()({
    name: "VSliderThumb",
    directives: {
      vRipple: ripple_default
    },
    props: makeVSliderThumbProps(),
    emits: {
      "update:modelValue": (v) => true
    },
    setup(props, _ref) {
      let {
        slots,
        emit: emit2
      } = _ref;
      const slider = inject(VSliderSymbol);
      const {
        isRtl,
        rtlClasses
      } = useRtl();
      if (!slider)
        throw new Error("[Vuetify] v-slider-thumb must be used inside v-slider or v-range-slider");
      const {
        min,
        max,
        thumbColor,
        step,
        disabled,
        thumbSize,
        thumbLabel,
        direction,
        isReversed,
        vertical,
        readonly: readonly2,
        elevation,
        mousePressed,
        decimals,
        indexFromEnd
      } = slider;
      const elevationProps = computed2(() => !disabled.value ? elevation.value : void 0);
      const {
        elevationClasses
      } = useElevation(elevationProps);
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(thumbColor);
      const {
        pageup,
        pagedown,
        end,
        home,
        left,
        right,
        down,
        up
      } = keyValues;
      const relevantKeys = [pageup, pagedown, end, home, left, right, down, up];
      const multipliers = computed2(() => {
        if (step.value)
          return [1, 2, 3];
        else
          return [1, 5, 10];
      });
      function parseKeydown(e, value) {
        if (!relevantKeys.includes(e.key))
          return;
        e.preventDefault();
        const _step = step.value || 0.1;
        const steps = (max.value - min.value) / _step;
        if ([left, right, down, up].includes(e.key)) {
          const increase = vertical.value ? [isRtl.value ? left : right, isReversed.value ? down : up] : indexFromEnd.value !== isRtl.value ? [left, up] : [right, up];
          const direction2 = increase.includes(e.key) ? 1 : -1;
          const multiplier = e.shiftKey ? 2 : e.ctrlKey ? 1 : 0;
          if (direction2 === -1 && value === max.value && !multiplier && !Number.isInteger(steps)) {
            value = value - steps % 1 * _step;
          } else {
            value = value + direction2 * _step * multipliers.value[multiplier];
          }
        } else if (e.key === home) {
          value = min.value;
        } else if (e.key === end) {
          value = max.value;
        } else {
          const direction2 = e.key === pagedown ? 1 : -1;
          value = value - direction2 * _step * (steps > 100 ? steps / 10 : 10);
        }
        return Math.max(props.min, Math.min(props.max, value));
      }
      function onKeydown(e) {
        const newValue = parseKeydown(e, props.modelValue);
        newValue != null && emit2("update:modelValue", newValue);
      }
      useRender(() => {
        const positionPercentage = convertToUnit(indexFromEnd.value ? 100 - props.position : props.position, "%");
        return createBaseVNode("div", {
          "class": normalizeClass(["v-slider-thumb", {
            "v-slider-thumb--focused": props.focused,
            "v-slider-thumb--pressed": props.focused && mousePressed.value
          }, props.class, rtlClasses.value]),
          "style": normalizeStyle([{
            "--v-slider-thumb-position": positionPercentage,
            "--v-slider-thumb-size": convertToUnit(thumbSize.value)
          }, props.style]),
          "role": "slider",
          "tabindex": disabled.value ? -1 : 0,
          "aria-label": props.name,
          "aria-valuemin": min.value,
          "aria-valuemax": max.value,
          "aria-valuenow": props.modelValue,
          "aria-readonly": !!readonly2.value,
          "aria-orientation": direction.value,
          "onKeydown": !readonly2.value ? onKeydown : void 0
        }, [createBaseVNode("div", {
          "class": normalizeClass(["v-slider-thumb__surface", textColorClasses.value, elevationClasses.value]),
          "style": __spreadValues({}, textColorStyles.value)
        }, null), withDirectives(createBaseVNode("div", {
          "class": normalizeClass(["v-slider-thumb__ripple", textColorClasses.value]),
          "style": normalizeStyle(textColorStyles.value)
        }, null), [[ripple_default, props.ripple, null, {
          circle: true,
          center: true
        }]]), createVNode(VScaleTransition, {
          "origin": "bottom center"
        }, {
          default: () => {
            var _a3, _b;
            return [withDirectives(createBaseVNode("div", {
              "class": "v-slider-thumb__label-container"
            }, [createBaseVNode("div", {
              "class": normalizeClass(["v-slider-thumb__label", textColorClasses.value])
            }, [createBaseVNode("div", null, [(_b = (_a3 = slots["thumb-label"]) == null ? void 0 : _a3.call(slots, {
              modelValue: props.modelValue
            })) != null ? _b : props.modelValue.toFixed(step.value ? decimals.value : 1)])])]), [[vShow, thumbLabel.value && props.focused || thumbLabel.value === "always"]])];
          }
        })]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VSlider/VSliderTrack.js
  var makeVSliderTrackProps = propsFactory(__spreadValues({
    start: {
      type: Number,
      required: true
    },
    stop: {
      type: Number,
      required: true
    }
  }, makeComponentProps()), "VSliderTrack");
  var VSliderTrack = genericComponent()({
    name: "VSliderTrack",
    props: makeVSliderTrackProps(),
    emits: {},
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const slider = inject(VSliderSymbol);
      if (!slider)
        throw new Error("[Vuetify] v-slider-track must be inside v-slider or v-range-slider");
      const {
        color,
        parsedTicks,
        rounded,
        showTicks,
        tickSize,
        trackColor,
        trackFillColor,
        trackSize,
        vertical,
        min,
        max,
        indexFromEnd
      } = slider;
      const {
        roundedClasses
      } = useRounded(rounded);
      const {
        backgroundColorClasses: trackFillColorClasses,
        backgroundColorStyles: trackFillColorStyles
      } = useBackgroundColor(trackFillColor);
      const {
        backgroundColorClasses: trackColorClasses,
        backgroundColorStyles: trackColorStyles
      } = useBackgroundColor(trackColor);
      const startDir = computed2(() => `inset-${vertical.value ? "block" : "inline"}-${indexFromEnd.value ? "end" : "start"}`);
      const endDir = computed2(() => vertical.value ? "height" : "width");
      const backgroundStyles = computed2(() => {
        return {
          [startDir.value]: "0%",
          [endDir.value]: "100%"
        };
      });
      const trackFillWidth = computed2(() => props.stop - props.start);
      const trackFillStyles = computed2(() => {
        return {
          [startDir.value]: convertToUnit(props.start, "%"),
          [endDir.value]: convertToUnit(trackFillWidth.value, "%")
        };
      });
      const computedTicks = computed2(() => {
        if (!showTicks.value)
          return [];
        const ticks = vertical.value ? parsedTicks.value.slice().reverse() : parsedTicks.value;
        return ticks.map((tick, index) => {
          var _a3, _b;
          const directionValue = tick.value !== min.value && tick.value !== max.value ? convertToUnit(tick.position, "%") : void 0;
          return createBaseVNode("div", {
            "key": tick.value,
            "class": normalizeClass(["v-slider-track__tick", {
              "v-slider-track__tick--filled": tick.position >= props.start && tick.position <= props.stop,
              "v-slider-track__tick--first": tick.value === min.value,
              "v-slider-track__tick--last": tick.value === max.value
            }]),
            "style": {
              [startDir.value]: directionValue
            }
          }, [(tick.label || slots["tick-label"]) && createBaseVNode("div", {
            "class": "v-slider-track__tick-label"
          }, [(_b = (_a3 = slots["tick-label"]) == null ? void 0 : _a3.call(slots, {
            tick,
            index
          })) != null ? _b : tick.label])]);
        });
      });
      useRender(() => {
        return createBaseVNode("div", {
          "class": normalizeClass(["v-slider-track", roundedClasses.value, props.class]),
          "style": normalizeStyle([{
            "--v-slider-track-size": convertToUnit(trackSize.value),
            "--v-slider-tick-size": convertToUnit(tickSize.value)
          }, props.style])
        }, [createBaseVNode("div", {
          "class": normalizeClass(["v-slider-track__background", trackColorClasses.value, {
            "v-slider-track__background--opacity": !!color.value || !trackFillColor.value
          }]),
          "style": __spreadValues(__spreadValues({}, backgroundStyles.value), trackColorStyles.value)
        }, null), createBaseVNode("div", {
          "class": normalizeClass(["v-slider-track__fill", trackFillColorClasses.value]),
          "style": __spreadValues(__spreadValues({}, trackFillStyles.value), trackFillColorStyles.value)
        }, null), showTicks.value && createBaseVNode("div", {
          "class": normalizeClass(["v-slider-track__ticks", {
            "v-slider-track__ticks--always-show": showTicks.value === "always"
          }])
        }, [computedTicks.value])]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VSlider/VSlider.js
  var makeVSliderProps = propsFactory(__spreadProps(__spreadValues(__spreadValues(__spreadValues({}, makeFocusProps()), makeSliderProps()), makeVInputProps()), {
    modelValue: {
      type: [Number, String],
      default: 0
    }
  }), "VSlider");
  var VSlider = genericComponent()({
    name: "VSlider",
    props: makeVSliderProps(),
    emits: {
      "update:focused": (value) => true,
      "update:modelValue": (v) => true,
      start: (value) => true,
      end: (value) => true
    },
    setup(props, _ref) {
      let {
        slots,
        emit: emit2
      } = _ref;
      const thumbContainerRef = ref();
      const {
        rtlClasses
      } = useRtl();
      const steps = useSteps(props);
      const model = useProxiedModel(props, "modelValue", void 0, (value) => {
        return steps.roundValue(value == null ? steps.min.value : value);
      });
      const {
        min,
        max,
        mousePressed,
        roundValue,
        onSliderMousedown,
        onSliderTouchstart,
        trackContainerRef,
        position,
        hasLabels,
        readonly: readonly2
      } = useSlider({
        props,
        steps,
        onSliderStart: () => {
          emit2("start", model.value);
        },
        onSliderEnd: (_ref2) => {
          let {
            value
          } = _ref2;
          const roundedValue = roundValue(value);
          model.value = roundedValue;
          emit2("end", roundedValue);
        },
        onSliderMove: (_ref3) => {
          let {
            value
          } = _ref3;
          return model.value = roundValue(value);
        },
        getActiveThumb: () => {
          var _a3;
          return (_a3 = thumbContainerRef.value) == null ? void 0 : _a3.$el;
        }
      });
      const {
        isFocused,
        focus,
        blur
      } = useFocus(props);
      const trackStop = computed2(() => position(model.value));
      useRender(() => {
        const inputProps = VInput.filterProps(props);
        const hasPrepend = !!(props.label || slots.label || slots.prepend);
        return createVNode(VInput, mergeProps({
          "class": ["v-slider", {
            "v-slider--has-labels": !!slots["tick-label"] || hasLabels.value,
            "v-slider--focused": isFocused.value,
            "v-slider--pressed": mousePressed.value,
            "v-slider--disabled": props.disabled
          }, rtlClasses.value, props.class],
          "style": props.style
        }, inputProps, {
          "focused": isFocused.value
        }), __spreadProps(__spreadValues({}, slots), {
          prepend: hasPrepend ? (slotProps) => {
            var _a3, _b, _c;
            return createBaseVNode(Fragment, null, [(_b = (_a3 = slots.label) == null ? void 0 : _a3.call(slots, slotProps)) != null ? _b : props.label ? createVNode(VLabel, {
              "id": slotProps.id.value,
              "class": "v-slider__label",
              "text": props.label
            }, null) : void 0, (_c = slots.prepend) == null ? void 0 : _c.call(slots, slotProps)]);
          } : void 0,
          default: (_ref4) => {
            let {
              id,
              messagesId
            } = _ref4;
            return createBaseVNode("div", {
              "class": "v-slider__container",
              "onMousedown": !readonly2.value ? onSliderMousedown : void 0,
              "onTouchstartPassive": !readonly2.value ? onSliderTouchstart : void 0
            }, [createBaseVNode("input", {
              "id": id.value,
              "name": props.name || id.value,
              "disabled": !!props.disabled,
              "readonly": !!props.readonly,
              "tabindex": "-1",
              "value": model.value
            }, null), createVNode(VSliderTrack, {
              "ref": trackContainerRef,
              "start": 0,
              "stop": trackStop.value
            }, {
              "tick-label": slots["tick-label"]
            }), createVNode(VSliderThumb, {
              "ref": thumbContainerRef,
              "aria-describedby": messagesId.value,
              "focused": isFocused.value,
              "min": min.value,
              "max": max.value,
              "modelValue": model.value,
              "onUpdate:modelValue": (v) => model.value = v,
              "position": trackStop.value,
              "elevation": props.elevation,
              "onFocus": focus,
              "onBlur": blur,
              "ripple": props.ripple,
              "name": props.name
            }, {
              "thumb-label": slots["thumb-label"]
            })]);
          }
        }));
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VColorPicker/VColorPickerPreview.js
  var makeVColorPickerPreviewProps = propsFactory(__spreadValues({
    color: {
      type: Object
    },
    disabled: Boolean,
    hideAlpha: Boolean
  }, makeComponentProps()), "VColorPickerPreview");
  var VColorPickerPreview = defineComponent2({
    name: "VColorPickerPreview",
    props: makeVColorPickerPreviewProps(),
    emits: {
      "update:color": (color) => true
    },
    setup(props, _ref) {
      let {
        emit: emit2
      } = _ref;
      const abortController = new AbortController();
      onUnmounted(() => abortController.abort());
      async function openEyeDropper() {
        var _a3;
        if (!SUPPORTS_EYE_DROPPER || props.disabled)
          return;
        const eyeDropper = new window.EyeDropper();
        try {
          const result = await eyeDropper.open({
            signal: abortController.signal
          });
          const colorHexValue = RGBtoHSV(parseColor(result.sRGBHex));
          emit2("update:color", __spreadValues(__spreadValues({}, (_a3 = props.color) != null ? _a3 : nullColor), colorHexValue));
        } catch (e) {
        }
      }
      useRender(() => {
        var _a3, _b, _c, _d;
        return createBaseVNode("div", {
          "class": normalizeClass(["v-color-picker-preview", {
            "v-color-picker-preview--hide-alpha": props.hideAlpha
          }, props.class]),
          "style": normalizeStyle(props.style)
        }, [SUPPORTS_EYE_DROPPER && createBaseVNode("div", {
          "class": "v-color-picker-preview__eye-dropper",
          "key": "eyeDropper"
        }, [createVNode(VBtn, {
          "density": "comfortable",
          "disabled": props.disabled,
          "icon": "$eyeDropper",
          "variant": "plain",
          "onClick": openEyeDropper
        }, null)]), createBaseVNode("div", {
          "class": "v-color-picker-preview__dot"
        }, [createBaseVNode("div", {
          "style": {
            background: HSVtoCSS((_a3 = props.color) != null ? _a3 : nullColor)
          }
        }, null)]), createBaseVNode("div", {
          "class": "v-color-picker-preview__sliders"
        }, [createVNode(VSlider, {
          "class": "v-color-picker-preview__track v-color-picker-preview__hue",
          "modelValue": (_b = props.color) == null ? void 0 : _b.h,
          "onUpdate:modelValue": (h2) => {
            var _a4;
            return emit2("update:color", __spreadProps(__spreadValues({}, (_a4 = props.color) != null ? _a4 : nullColor), {
              h: h2
            }));
          },
          "step": 0,
          "min": 0,
          "max": 360,
          "disabled": props.disabled,
          "thumbSize": 14,
          "trackSize": 8,
          "trackFillColor": "white",
          "hideDetails": true
        }, null), !props.hideAlpha && createVNode(VSlider, {
          "class": "v-color-picker-preview__track v-color-picker-preview__alpha",
          "modelValue": (_d = (_c = props.color) == null ? void 0 : _c.a) != null ? _d : 1,
          "onUpdate:modelValue": (a) => {
            var _a4;
            return emit2("update:color", __spreadProps(__spreadValues({}, (_a4 = props.color) != null ? _a4 : nullColor), {
              a
            }));
          },
          "step": 1 / 256,
          "min": 0,
          "max": 1,
          "disabled": props.disabled,
          "thumbSize": 14,
          "trackSize": 8,
          "trackFillColor": "white",
          "hideDetails": true
        }, null)])]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/util/colors.js
  var red = {
    base: "#f44336",
    lighten5: "#ffebee",
    lighten4: "#ffcdd2",
    lighten3: "#ef9a9a",
    lighten2: "#e57373",
    lighten1: "#ef5350",
    darken1: "#e53935",
    darken2: "#d32f2f",
    darken3: "#c62828",
    darken4: "#b71c1c",
    accent1: "#ff8a80",
    accent2: "#ff5252",
    accent3: "#ff1744",
    accent4: "#d50000"
  };
  var pink = {
    base: "#e91e63",
    lighten5: "#fce4ec",
    lighten4: "#f8bbd0",
    lighten3: "#f48fb1",
    lighten2: "#f06292",
    lighten1: "#ec407a",
    darken1: "#d81b60",
    darken2: "#c2185b",
    darken3: "#ad1457",
    darken4: "#880e4f",
    accent1: "#ff80ab",
    accent2: "#ff4081",
    accent3: "#f50057",
    accent4: "#c51162"
  };
  var purple = {
    base: "#9c27b0",
    lighten5: "#f3e5f5",
    lighten4: "#e1bee7",
    lighten3: "#ce93d8",
    lighten2: "#ba68c8",
    lighten1: "#ab47bc",
    darken1: "#8e24aa",
    darken2: "#7b1fa2",
    darken3: "#6a1b9a",
    darken4: "#4a148c",
    accent1: "#ea80fc",
    accent2: "#e040fb",
    accent3: "#d500f9",
    accent4: "#aa00ff"
  };
  var deepPurple = {
    base: "#673ab7",
    lighten5: "#ede7f6",
    lighten4: "#d1c4e9",
    lighten3: "#b39ddb",
    lighten2: "#9575cd",
    lighten1: "#7e57c2",
    darken1: "#5e35b1",
    darken2: "#512da8",
    darken3: "#4527a0",
    darken4: "#311b92",
    accent1: "#b388ff",
    accent2: "#7c4dff",
    accent3: "#651fff",
    accent4: "#6200ea"
  };
  var indigo = {
    base: "#3f51b5",
    lighten5: "#e8eaf6",
    lighten4: "#c5cae9",
    lighten3: "#9fa8da",
    lighten2: "#7986cb",
    lighten1: "#5c6bc0",
    darken1: "#3949ab",
    darken2: "#303f9f",
    darken3: "#283593",
    darken4: "#1a237e",
    accent1: "#8c9eff",
    accent2: "#536dfe",
    accent3: "#3d5afe",
    accent4: "#304ffe"
  };
  var blue = {
    base: "#2196f3",
    lighten5: "#e3f2fd",
    lighten4: "#bbdefb",
    lighten3: "#90caf9",
    lighten2: "#64b5f6",
    lighten1: "#42a5f5",
    darken1: "#1e88e5",
    darken2: "#1976d2",
    darken3: "#1565c0",
    darken4: "#0d47a1",
    accent1: "#82b1ff",
    accent2: "#448aff",
    accent3: "#2979ff",
    accent4: "#2962ff"
  };
  var lightBlue = {
    base: "#03a9f4",
    lighten5: "#e1f5fe",
    lighten4: "#b3e5fc",
    lighten3: "#81d4fa",
    lighten2: "#4fc3f7",
    lighten1: "#29b6f6",
    darken1: "#039be5",
    darken2: "#0288d1",
    darken3: "#0277bd",
    darken4: "#01579b",
    accent1: "#80d8ff",
    accent2: "#40c4ff",
    accent3: "#00b0ff",
    accent4: "#0091ea"
  };
  var cyan = {
    base: "#00bcd4",
    lighten5: "#e0f7fa",
    lighten4: "#b2ebf2",
    lighten3: "#80deea",
    lighten2: "#4dd0e1",
    lighten1: "#26c6da",
    darken1: "#00acc1",
    darken2: "#0097a7",
    darken3: "#00838f",
    darken4: "#006064",
    accent1: "#84ffff",
    accent2: "#18ffff",
    accent3: "#00e5ff",
    accent4: "#00b8d4"
  };
  var teal = {
    base: "#009688",
    lighten5: "#e0f2f1",
    lighten4: "#b2dfdb",
    lighten3: "#80cbc4",
    lighten2: "#4db6ac",
    lighten1: "#26a69a",
    darken1: "#00897b",
    darken2: "#00796b",
    darken3: "#00695c",
    darken4: "#004d40",
    accent1: "#a7ffeb",
    accent2: "#64ffda",
    accent3: "#1de9b6",
    accent4: "#00bfa5"
  };
  var green = {
    base: "#4caf50",
    lighten5: "#e8f5e9",
    lighten4: "#c8e6c9",
    lighten3: "#a5d6a7",
    lighten2: "#81c784",
    lighten1: "#66bb6a",
    darken1: "#43a047",
    darken2: "#388e3c",
    darken3: "#2e7d32",
    darken4: "#1b5e20",
    accent1: "#b9f6ca",
    accent2: "#69f0ae",
    accent3: "#00e676",
    accent4: "#00c853"
  };
  var lightGreen = {
    base: "#8bc34a",
    lighten5: "#f1f8e9",
    lighten4: "#dcedc8",
    lighten3: "#c5e1a5",
    lighten2: "#aed581",
    lighten1: "#9ccc65",
    darken1: "#7cb342",
    darken2: "#689f38",
    darken3: "#558b2f",
    darken4: "#33691e",
    accent1: "#ccff90",
    accent2: "#b2ff59",
    accent3: "#76ff03",
    accent4: "#64dd17"
  };
  var lime = {
    base: "#cddc39",
    lighten5: "#f9fbe7",
    lighten4: "#f0f4c3",
    lighten3: "#e6ee9c",
    lighten2: "#dce775",
    lighten1: "#d4e157",
    darken1: "#c0ca33",
    darken2: "#afb42b",
    darken3: "#9e9d24",
    darken4: "#827717",
    accent1: "#f4ff81",
    accent2: "#eeff41",
    accent3: "#c6ff00",
    accent4: "#aeea00"
  };
  var yellow = {
    base: "#ffeb3b",
    lighten5: "#fffde7",
    lighten4: "#fff9c4",
    lighten3: "#fff59d",
    lighten2: "#fff176",
    lighten1: "#ffee58",
    darken1: "#fdd835",
    darken2: "#fbc02d",
    darken3: "#f9a825",
    darken4: "#f57f17",
    accent1: "#ffff8d",
    accent2: "#ffff00",
    accent3: "#ffea00",
    accent4: "#ffd600"
  };
  var amber = {
    base: "#ffc107",
    lighten5: "#fff8e1",
    lighten4: "#ffecb3",
    lighten3: "#ffe082",
    lighten2: "#ffd54f",
    lighten1: "#ffca28",
    darken1: "#ffb300",
    darken2: "#ffa000",
    darken3: "#ff8f00",
    darken4: "#ff6f00",
    accent1: "#ffe57f",
    accent2: "#ffd740",
    accent3: "#ffc400",
    accent4: "#ffab00"
  };
  var orange = {
    base: "#ff9800",
    lighten5: "#fff3e0",
    lighten4: "#ffe0b2",
    lighten3: "#ffcc80",
    lighten2: "#ffb74d",
    lighten1: "#ffa726",
    darken1: "#fb8c00",
    darken2: "#f57c00",
    darken3: "#ef6c00",
    darken4: "#e65100",
    accent1: "#ffd180",
    accent2: "#ffab40",
    accent3: "#ff9100",
    accent4: "#ff6d00"
  };
  var deepOrange = {
    base: "#ff5722",
    lighten5: "#fbe9e7",
    lighten4: "#ffccbc",
    lighten3: "#ffab91",
    lighten2: "#ff8a65",
    lighten1: "#ff7043",
    darken1: "#f4511e",
    darken2: "#e64a19",
    darken3: "#d84315",
    darken4: "#bf360c",
    accent1: "#ff9e80",
    accent2: "#ff6e40",
    accent3: "#ff3d00",
    accent4: "#dd2c00"
  };
  var brown = {
    base: "#795548",
    lighten5: "#efebe9",
    lighten4: "#d7ccc8",
    lighten3: "#bcaaa4",
    lighten2: "#a1887f",
    lighten1: "#8d6e63",
    darken1: "#6d4c41",
    darken2: "#5d4037",
    darken3: "#4e342e",
    darken4: "#3e2723"
  };
  var blueGrey = {
    base: "#607d8b",
    lighten5: "#eceff1",
    lighten4: "#cfd8dc",
    lighten3: "#b0bec5",
    lighten2: "#90a4ae",
    lighten1: "#78909c",
    darken1: "#546e7a",
    darken2: "#455a64",
    darken3: "#37474f",
    darken4: "#263238"
  };
  var grey = {
    base: "#9e9e9e",
    lighten5: "#fafafa",
    lighten4: "#f5f5f5",
    lighten3: "#eeeeee",
    lighten2: "#e0e0e0",
    lighten1: "#bdbdbd",
    darken1: "#757575",
    darken2: "#616161",
    darken3: "#424242",
    darken4: "#212121"
  };
  var shades = {
    black: "#000000",
    white: "#ffffff",
    transparent: "#ffffff00"
  };
  var colors_default = {
    red,
    pink,
    purple,
    deepPurple,
    indigo,
    blue,
    lightBlue,
    cyan,
    teal,
    green,
    lightGreen,
    lime,
    yellow,
    amber,
    orange,
    deepOrange,
    brown,
    blueGrey,
    grey,
    shades
  };

  // ../posawesome/node_modules/vuetify/lib/components/VColorPicker/VColorPickerSwatches.js
  var makeVColorPickerSwatchesProps = propsFactory(__spreadValues({
    swatches: {
      type: Array,
      default: () => parseDefaultColors(colors_default)
    },
    disabled: Boolean,
    color: Object,
    maxHeight: [Number, String]
  }, makeComponentProps()), "VColorPickerSwatches");
  function parseDefaultColors(colors) {
    return Object.keys(colors).map((key) => {
      const color = colors[key];
      return color.base ? [color.base, color.darken4, color.darken3, color.darken2, color.darken1, color.lighten1, color.lighten2, color.lighten3, color.lighten4, color.lighten5] : [color.black, color.white, color.transparent];
    });
  }
  var VColorPickerSwatches = defineComponent2({
    name: "VColorPickerSwatches",
    props: makeVColorPickerSwatchesProps(),
    emits: {
      "update:color": (color) => true
    },
    setup(props, _ref) {
      let {
        emit: emit2
      } = _ref;
      useRender(() => createBaseVNode("div", {
        "class": normalizeClass(["v-color-picker-swatches", props.class]),
        "style": normalizeStyle([{
          maxHeight: convertToUnit(props.maxHeight)
        }, props.style])
      }, [createBaseVNode("div", null, [props.swatches.map((swatch) => createBaseVNode("div", {
        "class": "v-color-picker-swatches__swatch"
      }, [swatch.map((color) => {
        const rgba2 = parseColor(color);
        const hsva = RGBtoHSV(rgba2);
        const background = RGBtoCSS(rgba2);
        return createBaseVNode("div", {
          "class": "v-color-picker-swatches__color",
          "onClick": () => hsva && emit2("update:color", hsva)
        }, [createBaseVNode("div", {
          "style": {
            background
          }
        }, [props.color && deepEqual(props.color, hsva) ? createVNode(VIcon, {
          "size": "x-small",
          "icon": "$success",
          "color": getContrast(color, "#FFFFFF") > 2 ? "white" : "black"
        }, null) : void 0])]);
      })]))])]));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/labs/VPicker/VPickerTitle.js
  var VPickerTitle = createSimpleFunctional("v-picker-title");

  // ../posawesome/node_modules/vuetify/lib/components/VSheet/VSheet.js
  var makeVSheetProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    color: String
  }, makeBorderProps()), makeComponentProps()), makeDimensionProps()), makeElevationProps()), makeLocationProps()), makePositionProps()), makeRoundedProps()), makeTagProps()), makeThemeProps()), "VSheet");
  var VSheet = genericComponent()({
    name: "VSheet",
    props: makeVSheetProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(() => props.color);
      const {
        borderClasses
      } = useBorder(props);
      const {
        dimensionStyles
      } = useDimension(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        locationStyles
      } = useLocation(props);
      const {
        positionClasses
      } = usePosition(props);
      const {
        roundedClasses
      } = useRounded(props);
      useRender(() => createVNode(props.tag, {
        "class": normalizeClass(["v-sheet", themeClasses.value, backgroundColorClasses.value, borderClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, props.class]),
        "style": normalizeStyle([backgroundColorStyles.value, dimensionStyles.value, locationStyles.value, props.style])
      }, slots));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/labs/VPicker/VPicker.js
  var makeVPickerProps = propsFactory(__spreadValues({
    bgColor: String,
    divided: Boolean,
    landscape: Boolean,
    title: String,
    hideHeader: Boolean
  }, makeVSheetProps()), "VPicker");
  var VPicker = genericComponent()({
    name: "VPicker",
    props: makeVPickerProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(() => props.color);
      useRender(() => {
        const sheetProps = VSheet.filterProps(props);
        const hasTitle = !!(props.title || slots.title);
        return createVNode(VSheet, mergeProps(sheetProps, {
          "color": props.bgColor,
          "class": ["v-picker", {
            "v-picker--divided": props.divided,
            "v-picker--landscape": props.landscape,
            "v-picker--with-actions": !!slots.actions
          }, props.class],
          "style": props.style
        }), {
          default: () => {
            var _a3;
            return [!props.hideHeader && createBaseVNode("div", {
              "key": "header",
              "class": normalizeClass([backgroundColorClasses.value]),
              "style": normalizeStyle([backgroundColorStyles.value])
            }, [hasTitle && createVNode(VPickerTitle, {
              "key": "picker-title"
            }, {
              default: () => {
                var _a4, _b;
                return [(_b = (_a4 = slots.title) == null ? void 0 : _a4.call(slots)) != null ? _b : props.title];
              }
            }), slots.header && createBaseVNode("div", {
              "class": "v-picker__header"
            }, [slots.header()])]), createBaseVNode("div", {
              "class": "v-picker__body"
            }, [(_a3 = slots.default) == null ? void 0 : _a3.call(slots)]), slots.actions && createVNode(VDefaultsProvider, {
              "defaults": {
                VBtn: {
                  slim: true,
                  variant: "text"
                }
              }
            }, {
              default: () => [createBaseVNode("div", {
                "class": "v-picker__actions"
              }, [slots.actions()])]
            })];
          }
        });
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VColorPicker/VColorPicker.js
  var makeVColorPickerProps = propsFactory(__spreadValues({
    canvasHeight: {
      type: [String, Number],
      default: 150
    },
    disabled: Boolean,
    dotSize: {
      type: [Number, String],
      default: 10
    },
    hideCanvas: Boolean,
    hideSliders: Boolean,
    hideInputs: Boolean,
    mode: {
      type: String,
      default: "rgba",
      validator: (v) => Object.keys(modes).includes(v)
    },
    modes: {
      type: Array,
      default: () => Object.keys(modes),
      validator: (v) => Array.isArray(v) && v.every((m) => Object.keys(modes).includes(m))
    },
    showSwatches: Boolean,
    swatches: Array,
    swatchesMaxHeight: {
      type: [Number, String],
      default: 150
    },
    modelValue: {
      type: [Object, String]
    }
  }, makeVPickerProps({
    hideHeader: true
  })), "VColorPicker");
  var VColorPicker = defineComponent2({
    name: "VColorPicker",
    props: makeVColorPickerProps(),
    emits: {
      "update:modelValue": (color) => true,
      "update:mode": (mode) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const mode = useProxiedModel(props, "mode");
      const hue = ref(null);
      const model = useProxiedModel(props, "modelValue", void 0, (v) => {
        if (v == null || v === "")
          return null;
        let c;
        try {
          c = RGBtoHSV(parseColor(v));
        } catch (err) {
          consoleWarn(err);
          return null;
        }
        return c;
      }, (v) => {
        if (!v)
          return null;
        return extractColor(v, props.modelValue);
      });
      const currentColor = computed2(() => {
        var _a3;
        return model.value ? __spreadProps(__spreadValues({}, model.value), {
          h: (_a3 = hue.value) != null ? _a3 : model.value.h
        }) : null;
      });
      const {
        rtlClasses
      } = useRtl();
      let externalChange = true;
      watch2(model, (v) => {
        if (!externalChange) {
          externalChange = true;
          return;
        }
        if (!v)
          return;
        hue.value = v.h;
      }, {
        immediate: true
      });
      const updateColor = (hsva) => {
        externalChange = false;
        hue.value = hsva.h;
        model.value = hsva;
      };
      onBeforeMount(() => {
        if (!props.modes.includes(mode.value))
          mode.value = props.modes[0];
      });
      provideDefaults({
        VSlider: {
          color: void 0,
          trackColor: void 0,
          trackFillColor: void 0
        }
      });
      useRender(() => {
        var _a3;
        const pickerProps = VPicker.filterProps(props);
        return createVNode(VPicker, mergeProps(pickerProps, {
          "class": ["v-color-picker", rtlClasses.value, props.class],
          "style": [{
            "--v-color-picker-color-hsv": HSVtoCSS(__spreadProps(__spreadValues({}, (_a3 = currentColor.value) != null ? _a3 : nullColor), {
              a: 1
            }))
          }, props.style]
        }), __spreadProps(__spreadValues({}, slots), {
          default: () => createBaseVNode(Fragment, null, [!props.hideCanvas && createVNode(VColorPickerCanvas, {
            "key": "canvas",
            "color": currentColor.value,
            "onUpdate:color": updateColor,
            "disabled": props.disabled,
            "dotSize": props.dotSize,
            "width": props.width,
            "height": props.canvasHeight
          }, null), (!props.hideSliders || !props.hideInputs) && createBaseVNode("div", {
            "key": "controls",
            "class": "v-color-picker__controls"
          }, [!props.hideSliders && createVNode(VColorPickerPreview, {
            "key": "preview",
            "color": currentColor.value,
            "onUpdate:color": updateColor,
            "hideAlpha": !mode.value.endsWith("a"),
            "disabled": props.disabled
          }, null), !props.hideInputs && createVNode(VColorPickerEdit, {
            "key": "edit",
            "modes": props.modes,
            "mode": mode.value,
            "onUpdate:mode": (m) => mode.value = m,
            "color": currentColor.value,
            "onUpdate:color": updateColor,
            "disabled": props.disabled
          }, null)]), props.showSwatches && createVNode(VColorPickerSwatches, {
            "key": "swatches",
            "color": currentColor.value,
            "onUpdate:color": updateColor,
            "maxHeight": props.swatchesMaxHeight,
            "swatches": props.swatches,
            "disabled": props.disabled
          }, null)])
        }));
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VCombobox/VCombobox.js
  var makeVComboboxProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    autoSelectFirst: {
      type: [Boolean, String]
    },
    clearOnSelect: {
      type: Boolean,
      default: true
    },
    delimiters: Array
  }, makeFilterProps({
    filterKeys: ["title"]
  })), makeSelectProps({
    hideNoData: true,
    returnObject: true
  })), omit(makeVTextFieldProps({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"])), makeTransitionProps2({
    transition: false
  })), "VCombobox");
  var VCombobox = genericComponent()({
    name: "VCombobox",
    props: makeVComboboxProps(),
    emits: {
      "update:focused": (focused) => true,
      "update:modelValue": (value) => true,
      "update:search": (value) => true,
      "update:menu": (value) => true
    },
    setup(props, _ref) {
      var _a3, _b;
      let {
        emit: emit2,
        slots
      } = _ref;
      const {
        t
      } = useLocale();
      const vTextFieldRef = ref();
      const isFocused = shallowRef(false);
      const isPristine = shallowRef(true);
      const listHasFocus = shallowRef(false);
      const vMenuRef = ref();
      const vVirtualScrollRef = ref();
      const selectionIndex = shallowRef(-1);
      let cleared = false;
      const {
        items,
        transformIn,
        transformOut
      } = useItems(props);
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(() => {
        var _a4;
        return (_a4 = vTextFieldRef.value) == null ? void 0 : _a4.color;
      });
      const model = useProxiedModel(props, "modelValue", [], (v) => transformIn(wrapInArray(v)), (v) => {
        var _a4;
        const transformed = transformOut(v);
        return props.multiple ? transformed : (_a4 = transformed[0]) != null ? _a4 : null;
      });
      const form = useForm(props);
      const hasChips = computed2(() => !!(props.chips || slots.chip));
      const hasSelectionSlot = computed2(() => hasChips.value || !!slots.selection);
      const _search = shallowRef(!props.multiple && !hasSelectionSlot.value ? (_b = (_a3 = model.value[0]) == null ? void 0 : _a3.title) != null ? _b : "" : "");
      const search = computed2({
        get: () => {
          return _search.value;
        },
        set: (val) => {
          var _a4;
          _search.value = val != null ? val : "";
          if (!props.multiple && !hasSelectionSlot.value) {
            model.value = [transformItem(props, val)];
          }
          if (val && props.multiple && ((_a4 = props.delimiters) == null ? void 0 : _a4.length)) {
            const values = val.split(new RegExp(`(?:${props.delimiters.join("|")})+`));
            if (values.length > 1) {
              values.forEach((v) => {
                v = v.trim();
                if (v)
                  select(transformItem(props, v));
              });
              _search.value = "";
            }
          }
          if (!val)
            selectionIndex.value = -1;
          isPristine.value = !val;
        }
      });
      const counterValue = computed2(() => {
        return typeof props.counterValue === "function" ? props.counterValue(model.value) : typeof props.counterValue === "number" ? props.counterValue : props.multiple ? model.value.length : search.value.length;
      });
      const {
        filteredItems,
        getMatches
      } = useFilter(props, items, () => isPristine.value ? "" : search.value);
      const displayItems = computed2(() => {
        if (props.hideSelected) {
          return filteredItems.value.filter((filteredItem) => !model.value.some((s) => s.value === filteredItem.value));
        }
        return filteredItems.value;
      });
      const menuDisabled = computed2(() => props.hideNoData && !displayItems.value.length || form.isReadonly.value || form.isDisabled.value);
      const _menu = useProxiedModel(props, "menu");
      const menu = computed2({
        get: () => _menu.value,
        set: (v) => {
          var _a4;
          if (_menu.value && !v && ((_a4 = vMenuRef.value) == null ? void 0 : _a4.\u03A8openChildren.size))
            return;
          if (v && menuDisabled.value)
            return;
          _menu.value = v;
        }
      });
      const label = toRef(() => menu.value ? props.closeText : props.openText);
      watch2(_search, (value) => {
        if (cleared) {
          nextTick(() => cleared = false);
        } else if (isFocused.value && !menu.value) {
          menu.value = true;
        }
        emit2("update:search", value);
      });
      watch2(model, (value) => {
        var _a4, _b2;
        if (!props.multiple && !hasSelectionSlot.value) {
          _search.value = (_b2 = (_a4 = value[0]) == null ? void 0 : _a4.title) != null ? _b2 : "";
        }
      });
      const selectedValues = computed2(() => model.value.map((selection) => selection.value));
      const highlightFirst = computed2(() => {
        var _a4;
        const selectFirst = props.autoSelectFirst === true || props.autoSelectFirst === "exact" && search.value === ((_a4 = displayItems.value[0]) == null ? void 0 : _a4.title);
        return selectFirst && displayItems.value.length > 0 && !isPristine.value && !listHasFocus.value;
      });
      const listRef = ref();
      const listEvents = useScrolling(listRef, vTextFieldRef);
      function onClear(e) {
        cleared = true;
        if (props.openOnClear) {
          menu.value = true;
        }
      }
      function onMousedownControl() {
        if (menuDisabled.value)
          return;
        menu.value = true;
      }
      function onMousedownMenuIcon(e) {
        if (menuDisabled.value)
          return;
        if (isFocused.value) {
          e.preventDefault();
          e.stopPropagation();
        }
        menu.value = !menu.value;
      }
      function onListKeydown(e) {
        var _a4;
        if (e.key !== " " && checkPrintable(e)) {
          (_a4 = vTextFieldRef.value) == null ? void 0 : _a4.focus();
        }
      }
      function onKeydown(e) {
        var _a4, _b2, _c, _d;
        if (isComposingIgnoreKey(e) || form.isReadonly.value)
          return;
        const selectionStart = (_a4 = vTextFieldRef.value) == null ? void 0 : _a4.selectionStart;
        const length = model.value.length;
        if (["Enter", "ArrowDown", "ArrowUp"].includes(e.key)) {
          e.preventDefault();
        }
        if (["Enter", "ArrowDown"].includes(e.key)) {
          menu.value = true;
        }
        if (["Escape"].includes(e.key)) {
          menu.value = false;
        }
        if (["Enter", "Escape", "Tab"].includes(e.key)) {
          if (highlightFirst.value && ["Enter", "Tab"].includes(e.key) && !model.value.some((_ref2) => {
            let {
              value
            } = _ref2;
            return value === displayItems.value[0].value;
          })) {
            select(filteredItems.value[0]);
          }
          isPristine.value = true;
        }
        if (e.key === "ArrowDown" && highlightFirst.value) {
          (_b2 = listRef.value) == null ? void 0 : _b2.focus("next");
        }
        if (e.key === "Enter" && search.value) {
          select(transformItem(props, search.value));
          if (hasSelectionSlot.value)
            _search.value = "";
        }
        if (["Backspace", "Delete"].includes(e.key)) {
          if (!props.multiple && hasSelectionSlot.value && model.value.length > 0 && !search.value)
            return select(model.value[0], false);
          if (~selectionIndex.value) {
            e.preventDefault();
            const originalSelectionIndex = selectionIndex.value;
            select(model.value[selectionIndex.value], false);
            selectionIndex.value = originalSelectionIndex >= length - 1 ? length - 2 : originalSelectionIndex;
          } else if (e.key === "Backspace" && !search.value) {
            selectionIndex.value = length - 1;
          }
          return;
        }
        if (!props.multiple)
          return;
        if (e.key === "ArrowLeft") {
          if (selectionIndex.value < 0 && selectionStart && selectionStart > 0)
            return;
          const prev = selectionIndex.value > -1 ? selectionIndex.value - 1 : length - 1;
          if (model.value[prev]) {
            selectionIndex.value = prev;
          } else {
            selectionIndex.value = -1;
            (_c = vTextFieldRef.value) == null ? void 0 : _c.setSelectionRange(search.value.length, search.value.length);
          }
        } else if (e.key === "ArrowRight") {
          if (selectionIndex.value < 0)
            return;
          const next = selectionIndex.value + 1;
          if (model.value[next]) {
            selectionIndex.value = next;
          } else {
            selectionIndex.value = -1;
            (_d = vTextFieldRef.value) == null ? void 0 : _d.setSelectionRange(0, 0);
          }
        } else if (~selectionIndex.value && checkPrintable(e)) {
          selectionIndex.value = -1;
        }
      }
      function onAfterEnter() {
        var _a4;
        if (props.eager) {
          (_a4 = vVirtualScrollRef.value) == null ? void 0 : _a4.calculateVisibleItems();
        }
      }
      function onAfterLeave() {
        var _a4;
        if (isFocused.value) {
          isPristine.value = true;
          (_a4 = vTextFieldRef.value) == null ? void 0 : _a4.focus();
        }
      }
      function select(item) {
        let set2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        if (!item || item.props.disabled)
          return;
        if (props.multiple) {
          const index = model.value.findIndex((selection) => (props.valueComparator || deepEqual)(selection.value, item.value));
          const add3 = set2 == null ? !~index : set2;
          if (~index) {
            const value = add3 ? [...model.value, item] : [...model.value];
            value.splice(index, 1);
            model.value = value;
          } else if (add3) {
            model.value = [...model.value, item];
          }
          if (props.clearOnSelect) {
            search.value = "";
          }
        } else {
          const add3 = set2 !== false;
          model.value = add3 ? [item] : [];
          _search.value = add3 && !hasSelectionSlot.value ? item.title : "";
          nextTick(() => {
            menu.value = false;
            isPristine.value = true;
          });
        }
      }
      function onFocusin(e) {
        isFocused.value = true;
        setTimeout(() => {
          listHasFocus.value = true;
        });
      }
      function onFocusout(e) {
        listHasFocus.value = false;
      }
      function onUpdateModelValue(v) {
        if (v == null || v === "" && !props.multiple && !hasSelectionSlot.value)
          model.value = [];
      }
      watch2(isFocused, (val, oldVal) => {
        if (val || val === oldVal)
          return;
        selectionIndex.value = -1;
        menu.value = false;
        if (search.value) {
          if (props.multiple) {
            select(transformItem(props, search.value));
            return;
          }
          if (!hasSelectionSlot.value)
            return;
          if (model.value.some((_ref3) => {
            let {
              title
            } = _ref3;
            return title === search.value;
          })) {
            _search.value = "";
          } else {
            select(transformItem(props, search.value));
          }
        }
      });
      watch2(menu, () => {
        if (!props.hideSelected && menu.value && model.value.length) {
          const index = displayItems.value.findIndex((item) => model.value.some((s) => (props.valueComparator || deepEqual)(s.value, item.value)));
          IN_BROWSER && window.requestAnimationFrame(() => {
            var _a4;
            index >= 0 && ((_a4 = vVirtualScrollRef.value) == null ? void 0 : _a4.scrollToIndex(index));
          });
        }
      });
      watch2(() => props.items, (newVal, oldVal) => {
        if (menu.value)
          return;
        if (isFocused.value && !oldVal.length && newVal.length) {
          menu.value = true;
        }
      });
      useRender(() => {
        const hasList = !!(!props.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
        const isDirty2 = model.value.length > 0;
        const textFieldProps = VTextField.filterProps(props);
        return createVNode(VTextField, mergeProps({
          "ref": vTextFieldRef
        }, textFieldProps, {
          "modelValue": search.value,
          "onUpdate:modelValue": [($event) => search.value = $event, onUpdateModelValue],
          "focused": isFocused.value,
          "onUpdate:focused": ($event) => isFocused.value = $event,
          "validationValue": model.externalValue,
          "counterValue": counterValue.value,
          "dirty": isDirty2,
          "class": ["v-combobox", {
            "v-combobox--active-menu": menu.value,
            "v-combobox--chips": !!props.chips,
            "v-combobox--selection-slot": !!hasSelectionSlot.value,
            "v-combobox--selecting-index": selectionIndex.value > -1,
            [`v-combobox--${props.multiple ? "multiple" : "single"}`]: true
          }, props.class],
          "style": props.style,
          "readonly": form.isReadonly.value,
          "placeholder": isDirty2 ? void 0 : props.placeholder,
          "onClick:clear": onClear,
          "onMousedown:control": onMousedownControl,
          "onKeydown": onKeydown
        }), __spreadProps(__spreadValues({}, slots), {
          default: () => createBaseVNode(Fragment, null, [createVNode(VMenu, mergeProps({
            "ref": vMenuRef,
            "modelValue": menu.value,
            "onUpdate:modelValue": ($event) => menu.value = $event,
            "activator": "parent",
            "contentClass": "v-combobox__content",
            "disabled": menuDisabled.value,
            "eager": props.eager,
            "maxHeight": 310,
            "openOnClick": false,
            "closeOnContentClick": false,
            "transition": props.transition,
            "onAfterEnter": onAfterEnter,
            "onAfterLeave": onAfterLeave
          }, props.menuProps), {
            default: () => {
              var _a4;
              return [hasList && createVNode(VList, mergeProps({
                "ref": listRef,
                "selected": selectedValues.value,
                "selectStrategy": props.multiple ? "independent" : "single-independent",
                "onMousedown": (e) => e.preventDefault(),
                "onKeydown": onListKeydown,
                "onFocusin": onFocusin,
                "onFocusout": onFocusout,
                "tabindex": "-1",
                "aria-live": "polite",
                "color": (_a4 = props.itemColor) != null ? _a4 : props.color
              }, listEvents, props.listProps), {
                default: () => {
                  var _a5, _b2, _c, _d;
                  return [(_a5 = slots["prepend-item"]) == null ? void 0 : _a5.call(slots), !displayItems.value.length && !props.hideNoData && ((_c = (_b2 = slots["no-data"]) == null ? void 0 : _b2.call(slots)) != null ? _c : createVNode(VListItem, {
                    "key": "no-data",
                    "title": t(props.noDataText)
                  }, null)), createVNode(VVirtualScroll, {
                    "ref": vVirtualScrollRef,
                    "renderless": true,
                    "items": displayItems.value,
                    "itemKey": "value"
                  }, {
                    default: (_ref4) => {
                      var _a6, _b3;
                      let {
                        item,
                        index,
                        itemRef
                      } = _ref4;
                      const itemProps = mergeProps(item.props, {
                        ref: itemRef,
                        key: item.value,
                        active: highlightFirst.value && index === 0 ? true : void 0,
                        onClick: () => select(item, null)
                      });
                      return (_b3 = (_a6 = slots.item) == null ? void 0 : _a6.call(slots, {
                        item,
                        index,
                        props: itemProps
                      })) != null ? _b3 : createVNode(VListItem, mergeProps(itemProps, {
                        "role": "option"
                      }), {
                        prepend: (_ref5) => {
                          let {
                            isSelected
                          } = _ref5;
                          return createBaseVNode(Fragment, null, [props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                            "key": item.value,
                            "modelValue": isSelected,
                            "ripple": false,
                            "tabindex": "-1"
                          }, null) : void 0, item.props.prependAvatar && createVNode(VAvatar, {
                            "image": item.props.prependAvatar
                          }, null), item.props.prependIcon && createVNode(VIcon, {
                            "icon": item.props.prependIcon
                          }, null)]);
                        },
                        title: () => {
                          var _a7;
                          return isPristine.value ? item.title : highlightResult("v-combobox", item.title, (_a7 = getMatches(item)) == null ? void 0 : _a7.title);
                        }
                      });
                    }
                  }), (_d = slots["append-item"]) == null ? void 0 : _d.call(slots)];
                }
              })];
            }
          }), model.value.map((item, index) => {
            function onChipClose(e) {
              e.stopPropagation();
              e.preventDefault();
              select(item, false);
            }
            const slotProps = {
              "onClick:close": onChipClose,
              onKeydown(e) {
                if (e.key !== "Enter" && e.key !== " ")
                  return;
                e.preventDefault();
                e.stopPropagation();
                onChipClose(e);
              },
              onMousedown(e) {
                e.preventDefault();
                e.stopPropagation();
              },
              modelValue: true,
              "onUpdate:modelValue": void 0
            };
            const hasSlot = hasChips.value ? !!slots.chip : !!slots.selection;
            const slotContent = hasSlot ? ensureValidVNode2(hasChips.value ? slots.chip({
              item,
              index,
              props: slotProps
            }) : slots.selection({
              item,
              index
            })) : void 0;
            if (hasSlot && !slotContent)
              return void 0;
            return createBaseVNode("div", {
              "key": item.value,
              "class": normalizeClass(["v-combobox__selection", index === selectionIndex.value && ["v-combobox__selection--selected", textColorClasses.value]]),
              "style": normalizeStyle(index === selectionIndex.value ? textColorStyles.value : {})
            }, [hasChips.value ? !slots.chip ? createVNode(VChip, mergeProps({
              "key": "chip",
              "closable": props.closableChips,
              "size": "small",
              "text": item.title,
              "disabled": item.props.disabled
            }, slotProps), null) : createVNode(VDefaultsProvider, {
              "key": "chip-defaults",
              "defaults": {
                VChip: {
                  closable: props.closableChips,
                  size: "small",
                  text: item.title
                }
              }
            }, {
              default: () => [slotContent]
            }) : slotContent != null ? slotContent : createBaseVNode("span", {
              "class": "v-combobox__selection-text"
            }, [item.title, props.multiple && index < model.value.length - 1 && createBaseVNode("span", {
              "class": "v-combobox__selection-comma"
            }, [createTextVNode(",")])])]);
          })]),
          "append-inner": function() {
            var _a4, _b2;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return createBaseVNode(Fragment, null, [(_a4 = slots["append-inner"]) == null ? void 0 : _a4.call(slots, ...args), (!props.hideNoData || props.items.length) && props.menuIcon ? createVNode(VIcon, {
              "class": "v-combobox__menu-icon",
              "color": (_b2 = vTextFieldRef.value) == null ? void 0 : _b2.fieldIconColor,
              "icon": props.menuIcon,
              "onMousedown": onMousedownMenuIcon,
              "onClick": noop,
              "aria-label": t(label.value),
              "title": t(label.value),
              "tabindex": "-1"
            }, null) : void 0]);
          }
        }));
      });
      return forwardRefs({
        isFocused,
        isPristine,
        menu,
        search,
        selectionIndex,
        filteredItems,
        select
      }, vTextFieldRef);
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VConfirmEdit/VConfirmEdit.js
  var makeVConfirmEditProps = propsFactory({
    modelValue: null,
    color: String,
    cancelText: {
      type: String,
      default: "$vuetify.confirmEdit.cancel"
    },
    okText: {
      type: String,
      default: "$vuetify.confirmEdit.ok"
    },
    disabled: {
      type: [Boolean, Array],
      default: void 0
    },
    hideActions: Boolean
  }, "VConfirmEdit");
  var VConfirmEdit = genericComponent()({
    name: "VConfirmEdit",
    props: makeVConfirmEditProps(),
    emits: {
      cancel: () => true,
      save: (value) => true,
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        emit: emit2,
        slots
      } = _ref;
      const model = useProxiedModel(props, "modelValue");
      const internalModel = ref();
      watchEffect(() => {
        internalModel.value = structuredClone(toRaw(model.value));
      });
      const {
        t
      } = useLocale();
      const isPristine = computed2(() => {
        return deepEqual(model.value, internalModel.value);
      });
      function isActionDisabled(action) {
        if (typeof props.disabled === "boolean") {
          return props.disabled;
        }
        if (Array.isArray(props.disabled)) {
          return props.disabled.includes(action);
        }
        return isPristine.value;
      }
      const isSaveDisabled = computed2(() => isActionDisabled("save"));
      const isCancelDisabled = computed2(() => isActionDisabled("cancel"));
      function save() {
        model.value = internalModel.value;
        emit2("save", internalModel.value);
      }
      function cancel() {
        internalModel.value = structuredClone(toRaw(model.value));
        emit2("cancel");
      }
      function actions(actionsProps) {
        return createBaseVNode(Fragment, null, [createVNode(VBtn, mergeProps({
          "disabled": isCancelDisabled.value,
          "variant": "text",
          "color": props.color,
          "onClick": cancel,
          "text": t(props.cancelText)
        }, actionsProps), null), createVNode(VBtn, mergeProps({
          "disabled": isSaveDisabled.value,
          "variant": "text",
          "color": props.color,
          "onClick": save,
          "text": t(props.okText)
        }, actionsProps), null)]);
      }
      let actionsUsed = false;
      useRender(() => {
        var _a3;
        return createBaseVNode(Fragment, null, [(_a3 = slots.default) == null ? void 0 : _a3.call(slots, {
          model: internalModel,
          save,
          cancel,
          isPristine: isPristine.value,
          get actions() {
            actionsUsed = true;
            return actions;
          }
        }), !props.hideActions && !actionsUsed && actions()]);
      });
      return {
        save,
        cancel,
        isPristine
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VDataTable/composables/expand.js
  var makeDataTableExpandProps = propsFactory({
    expandOnClick: Boolean,
    showExpand: Boolean,
    expanded: {
      type: Array,
      default: () => []
    }
  }, "DataTable-expand");
  var VDataTableExpandedKey = Symbol.for("vuetify:datatable:expanded");
  function provideExpanded(props) {
    const expandOnClick = toRef(() => props.expandOnClick);
    const expanded = useProxiedModel(props, "expanded", props.expanded, (v) => {
      return new Set(v);
    }, (v) => {
      return [...v.values()];
    });
    function expand(item, value) {
      const newExpanded = new Set(expanded.value);
      if (!value) {
        newExpanded.delete(item.value);
      } else {
        newExpanded.add(item.value);
      }
      expanded.value = newExpanded;
    }
    function isExpanded(item) {
      return expanded.value.has(item.value);
    }
    function toggleExpand(item) {
      expand(item, !isExpanded(item));
    }
    const data = {
      expand,
      expanded,
      expandOnClick,
      isExpanded,
      toggleExpand
    };
    provide(VDataTableExpandedKey, data);
    return data;
  }
  function useExpanded() {
    const data = inject(VDataTableExpandedKey);
    if (!data)
      throw new Error("foo");
    return data;
  }

  // ../posawesome/node_modules/vuetify/lib/components/VDataTable/composables/group.js
  var makeDataTableGroupProps = propsFactory({
    groupBy: {
      type: Array,
      default: () => []
    }
  }, "DataTable-group");
  var VDataTableGroupSymbol = Symbol.for("vuetify:data-table-group");
  function createGroupBy(props) {
    const groupBy = useProxiedModel(props, "groupBy");
    return {
      groupBy
    };
  }
  function provideGroupBy(options) {
    const {
      disableSort,
      groupBy,
      sortBy
    } = options;
    const opened = ref(/* @__PURE__ */ new Set());
    const sortByWithGroups = computed2(() => {
      return groupBy.value.map((val) => {
        var _a3;
        return __spreadProps(__spreadValues({}, val), {
          order: (_a3 = val.order) != null ? _a3 : false
        });
      }).concat((disableSort == null ? void 0 : disableSort.value) ? [] : sortBy.value);
    });
    function isGroupOpen(group) {
      return opened.value.has(group.id);
    }
    function toggleGroup(group) {
      const newOpened = new Set(opened.value);
      if (!isGroupOpen(group))
        newOpened.add(group.id);
      else
        newOpened.delete(group.id);
      opened.value = newOpened;
    }
    function extractRows(items) {
      function dive(group) {
        const arr = [];
        for (const item of group.items) {
          if ("type" in item && item.type === "group") {
            arr.push(...dive(item));
          } else {
            arr.push(item);
          }
        }
        return [...new Set(arr)];
      }
      return dive({
        type: "group",
        items,
        id: "dummy",
        key: "dummy",
        value: "dummy",
        depth: 0
      });
    }
    const data = {
      sortByWithGroups,
      toggleGroup,
      opened,
      groupBy,
      extractRows,
      isGroupOpen
    };
    provide(VDataTableGroupSymbol, data);
    return data;
  }
  function useGroupBy() {
    const data = inject(VDataTableGroupSymbol);
    if (!data)
      throw new Error("Missing group!");
    return data;
  }
  function groupItemsByProperty(items, groupBy) {
    if (!items.length)
      return [];
    const groups = /* @__PURE__ */ new Map();
    for (const item of items) {
      const value = getObjectValueByPath(item.raw, groupBy);
      if (!groups.has(value)) {
        groups.set(value, []);
      }
      groups.get(value).push(item);
    }
    return groups;
  }
  function groupItems(items, groupBy) {
    let depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    let prefix = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "root";
    if (!groupBy.length)
      return [];
    const groupedItems = groupItemsByProperty(items, groupBy[0]);
    const groups = [];
    const rest = groupBy.slice(1);
    groupedItems.forEach((items2, value) => {
      const key = groupBy[0];
      const id = `${prefix}_${key}_${value}`;
      groups.push({
        depth,
        id,
        key,
        value,
        items: rest.length ? groupItems(items2, rest, depth + 1, id) : items2,
        type: "group"
      });
    });
    return groups;
  }
  function flattenItems(items, opened) {
    const flatItems = [];
    for (const item of items) {
      if ("type" in item && item.type === "group") {
        if (item.value != null) {
          flatItems.push(item);
        }
        if (opened.has(item.id) || item.value == null) {
          flatItems.push(...flattenItems(item.items, opened));
        }
      } else {
        flatItems.push(item);
      }
    }
    return flatItems;
  }
  function useGroupedItems(items, groupBy, opened) {
    const flatItems = computed2(() => {
      if (!groupBy.value.length)
        return items.value;
      const groupedItems = groupItems(items.value, groupBy.value.map((item) => item.key));
      return flattenItems(groupedItems, opened.value);
    });
    return {
      flatItems
    };
  }

  // ../posawesome/node_modules/vuetify/lib/components/VDataTable/composables/options.js
  function useOptions(_ref) {
    let {
      page,
      itemsPerPage,
      sortBy,
      groupBy,
      search
    } = _ref;
    const vm2 = getCurrentInstance2("VDataTable");
    const options = () => ({
      page: page.value,
      itemsPerPage: itemsPerPage.value,
      sortBy: sortBy.value,
      groupBy: groupBy.value,
      search: search.value
    });
    let oldOptions = null;
    watch2(options, (value) => {
      if (deepEqual(oldOptions, value))
        return;
      if (oldOptions && oldOptions.search !== value.search) {
        page.value = 1;
      }
      vm2.emit("update:options", value);
      oldOptions = value;
    }, {
      deep: true,
      immediate: true
    });
  }

  // ../posawesome/node_modules/vuetify/lib/components/VDataTable/composables/paginate.js
  var makeDataTablePaginateProps = propsFactory({
    page: {
      type: [Number, String],
      default: 1
    },
    itemsPerPage: {
      type: [Number, String],
      default: 10
    }
  }, "DataTable-paginate");
  var VDataTablePaginationSymbol = Symbol.for("vuetify:data-table-pagination");
  function createPagination(props) {
    const page = useProxiedModel(props, "page", void 0, (value) => Number(value != null ? value : 1));
    const itemsPerPage = useProxiedModel(props, "itemsPerPage", void 0, (value) => Number(value != null ? value : 10));
    return {
      page,
      itemsPerPage
    };
  }
  function providePagination(options) {
    const {
      page,
      itemsPerPage,
      itemsLength
    } = options;
    const startIndex = computed2(() => {
      if (itemsPerPage.value === -1)
        return 0;
      return itemsPerPage.value * (page.value - 1);
    });
    const stopIndex = computed2(() => {
      if (itemsPerPage.value === -1)
        return itemsLength.value;
      return Math.min(itemsLength.value, startIndex.value + itemsPerPage.value);
    });
    const pageCount = computed2(() => {
      if (itemsPerPage.value === -1 || itemsLength.value === 0)
        return 1;
      return Math.ceil(itemsLength.value / itemsPerPage.value);
    });
    watch2([page, pageCount], () => {
      if (page.value > pageCount.value) {
        page.value = pageCount.value;
      }
    });
    function setItemsPerPage(value) {
      itemsPerPage.value = value;
      page.value = 1;
    }
    function nextPage() {
      page.value = clamp(page.value + 1, 1, pageCount.value);
    }
    function prevPage() {
      page.value = clamp(page.value - 1, 1, pageCount.value);
    }
    function setPage(value) {
      page.value = clamp(value, 1, pageCount.value);
    }
    const data = {
      page,
      itemsPerPage,
      startIndex,
      stopIndex,
      pageCount,
      itemsLength,
      nextPage,
      prevPage,
      setPage,
      setItemsPerPage
    };
    provide(VDataTablePaginationSymbol, data);
    return data;
  }
  function usePagination() {
    const data = inject(VDataTablePaginationSymbol);
    if (!data)
      throw new Error("Missing pagination!");
    return data;
  }
  function usePaginatedItems(options) {
    const vm2 = getCurrentInstance2("usePaginatedItems");
    const {
      items,
      startIndex,
      stopIndex,
      itemsPerPage
    } = options;
    const paginatedItems = computed2(() => {
      if (itemsPerPage.value <= 0)
        return items.value;
      return items.value.slice(startIndex.value, stopIndex.value);
    });
    watch2(paginatedItems, (val) => {
      vm2.emit("update:currentItems", val);
    }, {
      immediate: true
    });
    return {
      paginatedItems
    };
  }

  // ../posawesome/node_modules/vuetify/lib/components/VDataTable/composables/select.js
  var singleSelectStrategy = {
    showSelectAll: false,
    allSelected: () => [],
    select: (_ref) => {
      var _a3;
      let {
        items,
        value
      } = _ref;
      return new Set(value ? [(_a3 = items[0]) == null ? void 0 : _a3.value] : []);
    },
    selectAll: (_ref2) => {
      let {
        selected
      } = _ref2;
      return selected;
    }
  };
  var pageSelectStrategy = {
    showSelectAll: true,
    allSelected: (_ref3) => {
      let {
        currentPage
      } = _ref3;
      return currentPage;
    },
    select: (_ref4) => {
      let {
        items,
        value,
        selected
      } = _ref4;
      for (const item of items) {
        if (value)
          selected.add(item.value);
        else
          selected.delete(item.value);
      }
      return selected;
    },
    selectAll: (_ref5) => {
      let {
        value,
        currentPage,
        selected
      } = _ref5;
      return pageSelectStrategy.select({
        items: currentPage,
        value,
        selected
      });
    }
  };
  var allSelectStrategy = {
    showSelectAll: true,
    allSelected: (_ref6) => {
      let {
        allItems
      } = _ref6;
      return allItems;
    },
    select: (_ref7) => {
      let {
        items,
        value,
        selected
      } = _ref7;
      for (const item of items) {
        if (value)
          selected.add(item.value);
        else
          selected.delete(item.value);
      }
      return selected;
    },
    selectAll: (_ref8) => {
      let {
        value,
        allItems,
        selected
      } = _ref8;
      return allSelectStrategy.select({
        items: allItems,
        value,
        selected
      });
    }
  };
  var makeDataTableSelectProps = propsFactory({
    showSelect: Boolean,
    selectStrategy: {
      type: [String, Object],
      default: "page"
    },
    modelValue: {
      type: Array,
      default: () => []
    },
    valueComparator: {
      type: Function,
      default: deepEqual
    }
  }, "DataTable-select");
  var VDataTableSelectionSymbol = Symbol.for("vuetify:data-table-selection");
  function provideSelection(props, _ref9) {
    let {
      allItems,
      currentPage
    } = _ref9;
    const selected = useProxiedModel(props, "modelValue", props.modelValue, (v) => {
      return new Set(wrapInArray(v).map((v2) => {
        var _a3, _b;
        return (_b = (_a3 = allItems.value.find((item) => props.valueComparator(v2, item.value))) == null ? void 0 : _a3.value) != null ? _b : v2;
      }));
    }, (v) => {
      return [...v.values()];
    });
    const allSelectable = computed2(() => allItems.value.filter((item) => item.selectable));
    const currentPageSelectable = computed2(() => currentPage.value.filter((item) => item.selectable));
    const selectStrategy = computed2(() => {
      if (typeof props.selectStrategy === "object")
        return props.selectStrategy;
      switch (props.selectStrategy) {
        case "single":
          return singleSelectStrategy;
        case "all":
          return allSelectStrategy;
        case "page":
        default:
          return pageSelectStrategy;
      }
    });
    const lastSelectedIndex = shallowRef(null);
    function isSelected(items) {
      return wrapInArray(items).every((item) => selected.value.has(item.value));
    }
    function isSomeSelected(items) {
      return wrapInArray(items).some((item) => selected.value.has(item.value));
    }
    function select(items, value) {
      const newSelected = selectStrategy.value.select({
        items,
        value,
        selected: new Set(selected.value)
      });
      selected.value = newSelected;
    }
    function toggleSelect(item, index, event2) {
      const items = [];
      index = index != null ? index : currentPage.value.findIndex((i) => i.value === item.value);
      if (props.selectStrategy !== "single" && (event2 == null ? void 0 : event2.shiftKey) && lastSelectedIndex.value !== null) {
        const [start, end] = [lastSelectedIndex.value, index].sort((a, b) => a - b);
        items.push(...currentPage.value.slice(start, end + 1).filter((item2) => item2.selectable));
      } else {
        items.push(item);
        lastSelectedIndex.value = index;
      }
      select(items, !isSelected([item]));
    }
    function selectAll(value) {
      const newSelected = selectStrategy.value.selectAll({
        value,
        allItems: allSelectable.value,
        currentPage: currentPageSelectable.value,
        selected: new Set(selected.value)
      });
      selected.value = newSelected;
    }
    const someSelected = computed2(() => selected.value.size > 0);
    const allSelected = computed2(() => {
      const items = selectStrategy.value.allSelected({
        allItems: allSelectable.value,
        currentPage: currentPageSelectable.value
      });
      return !!items.length && isSelected(items);
    });
    const showSelectAll = toRef(() => selectStrategy.value.showSelectAll);
    const data = {
      toggleSelect,
      select,
      selectAll,
      isSelected,
      isSomeSelected,
      someSelected,
      allSelected,
      showSelectAll,
      lastSelectedIndex,
      selectStrategy
    };
    provide(VDataTableSelectionSymbol, data);
    return data;
  }
  function useSelection() {
    const data = inject(VDataTableSelectionSymbol);
    if (!data)
      throw new Error("Missing selection!");
    return data;
  }

  // ../posawesome/node_modules/vuetify/lib/components/VDataTable/composables/sort.js
  var makeDataTableSortProps = propsFactory({
    sortBy: {
      type: Array,
      default: () => []
    },
    customKeySort: Object,
    multiSort: Boolean,
    mustSort: Boolean
  }, "DataTable-sort");
  var VDataTableSortSymbol = Symbol.for("vuetify:data-table-sort");
  function createSort(props) {
    const sortBy = useProxiedModel(props, "sortBy");
    const mustSort = toRef(() => props.mustSort);
    const multiSort = toRef(() => props.multiSort);
    return {
      sortBy,
      mustSort,
      multiSort
    };
  }
  function provideSort(options) {
    const {
      sortBy,
      mustSort,
      multiSort,
      page
    } = options;
    const toggleSort = (column) => {
      var _a3;
      if (column.key == null)
        return;
      let newSortBy = (_a3 = sortBy.value.map((x) => __spreadValues({}, x))) != null ? _a3 : [];
      const item = newSortBy.find((x) => x.key === column.key);
      if (!item) {
        if (multiSort.value) {
          newSortBy.push({
            key: column.key,
            order: "asc"
          });
        } else {
          newSortBy = [{
            key: column.key,
            order: "asc"
          }];
        }
      } else if (item.order === "desc") {
        if (mustSort.value && newSortBy.length === 1) {
          item.order = "asc";
        } else {
          newSortBy = newSortBy.filter((x) => x.key !== column.key);
        }
      } else {
        item.order = "desc";
      }
      sortBy.value = newSortBy;
      if (page)
        page.value = 1;
    };
    function isSorted(column) {
      return !!sortBy.value.find((item) => item.key === column.key);
    }
    const data = {
      sortBy,
      toggleSort,
      isSorted
    };
    provide(VDataTableSortSymbol, data);
    return data;
  }
  function useSort() {
    const data = inject(VDataTableSortSymbol);
    if (!data)
      throw new Error("Missing sort!");
    return data;
  }
  function useSortedItems(props, items, sortBy, options) {
    const locale = useLocale();
    const sortedItems = computed2(() => {
      var _a3, _b;
      if (!sortBy.value.length)
        return items.value;
      return sortItems(items.value, sortBy.value, locale.current.value, {
        transform: options == null ? void 0 : options.transform,
        sortFunctions: __spreadValues(__spreadValues({}, props.customKeySort), (_a3 = options == null ? void 0 : options.sortFunctions) == null ? void 0 : _a3.value),
        sortRawFunctions: (_b = options == null ? void 0 : options.sortRawFunctions) == null ? void 0 : _b.value
      });
    });
    return {
      sortedItems
    };
  }
  function sortItems(items, sortByItems, locale, options) {
    const stringCollator = new Intl.Collator(locale, {
      sensitivity: "accent",
      usage: "sort"
    });
    const transformedItems = items.map((item) => [item, (options == null ? void 0 : options.transform) ? options.transform(item) : item]);
    return transformedItems.sort((a, b) => {
      var _a3, _b, _c;
      for (let i = 0; i < sortByItems.length; i++) {
        let hasCustomResult = false;
        const sortKey = sortByItems[i].key;
        const sortOrder = (_a3 = sortByItems[i].order) != null ? _a3 : "asc";
        if (sortOrder === false)
          continue;
        let sortA = getObjectValueByPath(a[1], sortKey);
        let sortB = getObjectValueByPath(b[1], sortKey);
        let sortARaw = a[0].raw;
        let sortBRaw = b[0].raw;
        if (sortOrder === "desc") {
          [sortA, sortB] = [sortB, sortA];
          [sortARaw, sortBRaw] = [sortBRaw, sortARaw];
        }
        if ((_b = options == null ? void 0 : options.sortRawFunctions) == null ? void 0 : _b[sortKey]) {
          const customResult = options.sortRawFunctions[sortKey](sortARaw, sortBRaw);
          if (customResult == null)
            continue;
          hasCustomResult = true;
          if (customResult)
            return customResult;
        }
        if ((_c = options == null ? void 0 : options.sortFunctions) == null ? void 0 : _c[sortKey]) {
          const customResult = options.sortFunctions[sortKey](sortA, sortB);
          if (customResult == null)
            continue;
          hasCustomResult = true;
          if (customResult)
            return customResult;
        }
        if (hasCustomResult)
          continue;
        if (sortA instanceof Date && sortB instanceof Date) {
          return sortA.getTime() - sortB.getTime();
        }
        [sortA, sortB] = [sortA, sortB].map((s) => s != null ? s.toString().toLocaleLowerCase() : s);
        if (sortA !== sortB) {
          if (isEmpty(sortA) && isEmpty(sortB))
            return 0;
          if (isEmpty(sortA))
            return -1;
          if (isEmpty(sortB))
            return 1;
          if (!isNaN(sortA) && !isNaN(sortB))
            return Number(sortA) - Number(sortB);
          return stringCollator.compare(sortA, sortB);
        }
      }
      return 0;
    }).map((_ref) => {
      let [item] = _ref;
      return item;
    });
  }

  // ../posawesome/node_modules/vuetify/lib/components/VDataIterator/composables/items.js
  var makeDataIteratorItemsProps = propsFactory({
    items: {
      type: Array,
      default: () => []
    },
    itemValue: {
      type: [String, Array, Function],
      default: "id"
    },
    itemSelectable: {
      type: [String, Array, Function],
      default: null
    },
    returnObject: Boolean
  }, "DataIterator-items");
  function transformItem3(props, item) {
    const value = props.returnObject ? item : getPropertyFromItem(item, props.itemValue);
    const selectable = getPropertyFromItem(item, props.itemSelectable, true);
    return {
      type: "item",
      value,
      selectable,
      raw: item
    };
  }
  function transformItems3(props, items) {
    const array = [];
    for (const item of items) {
      array.push(transformItem3(props, item));
    }
    return array;
  }
  function useDataIteratorItems(props) {
    const items = computed2(() => transformItems3(props, props.items));
    return {
      items
    };
  }

  // ../posawesome/node_modules/vuetify/lib/components/VDataIterator/VDataIterator.js
  var makeVDataIteratorProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    search: String,
    loading: Boolean
  }, makeComponentProps()), makeDataIteratorItemsProps()), makeDataTableSelectProps()), makeDataTableSortProps()), makeDataTablePaginateProps({
    itemsPerPage: 5
  })), makeDataTableExpandProps()), makeDataTableGroupProps()), makeFilterProps()), makeTagProps()), makeTransitionProps2({
    transition: {
      component: VFadeTransition,
      hideOnLeave: true
    }
  })), "VDataIterator");
  var VDataIterator = genericComponent()({
    name: "VDataIterator",
    props: makeVDataIteratorProps(),
    emits: {
      "update:modelValue": (value) => true,
      "update:groupBy": (value) => true,
      "update:page": (value) => true,
      "update:itemsPerPage": (value) => true,
      "update:sortBy": (value) => true,
      "update:options": (value) => true,
      "update:expanded": (value) => true,
      "update:currentItems": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const groupBy = useProxiedModel(props, "groupBy");
      const search = toRef(() => props.search);
      const {
        items
      } = useDataIteratorItems(props);
      const {
        filteredItems
      } = useFilter(props, items, search, {
        transform: (item) => item.raw
      });
      const {
        sortBy,
        multiSort,
        mustSort
      } = createSort(props);
      const {
        page,
        itemsPerPage
      } = createPagination(props);
      const {
        toggleSort
      } = provideSort({
        sortBy,
        multiSort,
        mustSort,
        page
      });
      const {
        sortByWithGroups,
        opened,
        extractRows,
        isGroupOpen,
        toggleGroup
      } = provideGroupBy({
        groupBy,
        sortBy
      });
      const {
        sortedItems
      } = useSortedItems(props, filteredItems, sortByWithGroups, {
        transform: (item) => item.raw
      });
      const {
        flatItems
      } = useGroupedItems(sortedItems, groupBy, opened);
      const itemsLength = toRef(() => flatItems.value.length);
      const {
        startIndex,
        stopIndex,
        pageCount,
        prevPage,
        nextPage,
        setItemsPerPage,
        setPage
      } = providePagination({
        page,
        itemsPerPage,
        itemsLength
      });
      const {
        paginatedItems
      } = usePaginatedItems({
        items: flatItems,
        startIndex,
        stopIndex,
        itemsPerPage
      });
      const paginatedItemsWithoutGroups = computed2(() => extractRows(paginatedItems.value));
      const {
        isSelected,
        select,
        selectAll,
        toggleSelect
      } = provideSelection(props, {
        allItems: items,
        currentPage: paginatedItemsWithoutGroups
      });
      const {
        isExpanded,
        toggleExpand
      } = provideExpanded(props);
      useOptions({
        page,
        itemsPerPage,
        sortBy,
        groupBy,
        search
      });
      const slotProps = computed2(() => ({
        page: page.value,
        itemsPerPage: itemsPerPage.value,
        sortBy: sortBy.value,
        pageCount: pageCount.value,
        toggleSort,
        prevPage,
        nextPage,
        setPage,
        setItemsPerPage,
        isSelected,
        select,
        selectAll,
        toggleSelect,
        isExpanded,
        toggleExpand,
        isGroupOpen,
        toggleGroup,
        items: paginatedItemsWithoutGroups.value,
        groupedItems: paginatedItems.value
      }));
      useRender(() => createVNode(props.tag, {
        "class": normalizeClass(["v-data-iterator", {
          "v-data-iterator--loading": props.loading
        }, props.class]),
        "style": normalizeStyle(props.style)
      }, {
        default: () => {
          var _a3, _b;
          return [(_a3 = slots.header) == null ? void 0 : _a3.call(slots, slotProps.value), createVNode(MaybeTransition, {
            "transition": props.transition
          }, {
            default: () => {
              var _a4, _b2;
              return [props.loading ? createVNode(LoaderSlot, {
                "key": "loader",
                "name": "v-data-iterator",
                "active": true
              }, {
                default: (slotProps2) => {
                  var _a5;
                  return (_a5 = slots.loader) == null ? void 0 : _a5.call(slots, slotProps2);
                }
              }) : createBaseVNode("div", {
                "key": "items"
              }, [!paginatedItems.value.length ? (_a4 = slots["no-data"]) == null ? void 0 : _a4.call(slots) : (_b2 = slots.default) == null ? void 0 : _b2.call(slots, slotProps.value)])];
            }
          }), (_b = slots.footer) == null ? void 0 : _b.call(slots, slotProps.value)];
        }
      }));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/composables/refs.js
  function useRefs() {
    const refs = ref([]);
    onBeforeUpdate(() => refs.value = []);
    function updateRef(e, i) {
      refs.value[i] = e;
    }
    return {
      refs,
      updateRef
    };
  }

  // ../posawesome/node_modules/vuetify/lib/components/VPagination/VPagination.js
  var makeVPaginationProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    activeColor: String,
    start: {
      type: [Number, String],
      default: 1
    },
    modelValue: {
      type: Number,
      default: (props) => props.start
    },
    disabled: Boolean,
    length: {
      type: [Number, String],
      default: 1,
      validator: (val) => val % 1 === 0
    },
    totalVisible: [Number, String],
    firstIcon: {
      type: IconValue,
      default: "$first"
    },
    prevIcon: {
      type: IconValue,
      default: "$prev"
    },
    nextIcon: {
      type: IconValue,
      default: "$next"
    },
    lastIcon: {
      type: IconValue,
      default: "$last"
    },
    ariaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.root"
    },
    pageAriaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.page"
    },
    currentPageAriaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.currentPage"
    },
    firstAriaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.first"
    },
    previousAriaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.previous"
    },
    nextAriaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.next"
    },
    lastAriaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.last"
    },
    ellipsis: {
      type: String,
      default: "..."
    },
    showFirstLastPage: Boolean
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeElevationProps()), makeRoundedProps()), makeSizeProps()), makeTagProps({
    tag: "nav"
  })), makeThemeProps()), makeVariantProps({
    variant: "text"
  })), "VPagination");
  var VPagination = genericComponent()({
    name: "VPagination",
    props: makeVPaginationProps(),
    emits: {
      "update:modelValue": (value) => true,
      first: (value) => true,
      prev: (value) => true,
      next: (value) => true,
      last: (value) => true
    },
    setup(props, _ref) {
      let {
        slots,
        emit: emit2
      } = _ref;
      const page = useProxiedModel(props, "modelValue");
      const {
        t,
        n
      } = useLocale();
      const {
        isRtl
      } = useRtl();
      const {
        themeClasses
      } = provideTheme(props);
      const {
        width
      } = useDisplay();
      const maxButtons = shallowRef(-1);
      provideDefaults(void 0, {
        scoped: true
      });
      const {
        resizeRef
      } = useResizeObserver((entries) => {
        if (!entries.length)
          return;
        const {
          target,
          contentRect
        } = entries[0];
        const firstItem = target.querySelector(".v-pagination__list > *");
        if (!firstItem)
          return;
        const totalWidth = contentRect.width;
        const itemWidth = firstItem.offsetWidth + parseFloat(getComputedStyle(firstItem).marginRight) * 2;
        maxButtons.value = getMax(totalWidth, itemWidth);
      });
      const length = computed2(() => parseInt(props.length, 10));
      const start = computed2(() => parseInt(props.start, 10));
      const totalVisible = computed2(() => {
        if (props.totalVisible != null)
          return parseInt(props.totalVisible, 10);
        else if (maxButtons.value >= 0)
          return maxButtons.value;
        return getMax(width.value, 58);
      });
      function getMax(totalWidth, itemWidth) {
        const minButtons = props.showFirstLastPage ? 5 : 3;
        return Math.max(0, Math.floor(
          Number(((totalWidth - itemWidth * minButtons) / itemWidth).toFixed(2))
        ));
      }
      const range = computed2(() => {
        if (length.value <= 0 || isNaN(length.value) || length.value > Number.MAX_SAFE_INTEGER)
          return [];
        if (totalVisible.value <= 0)
          return [];
        else if (totalVisible.value === 1)
          return [page.value];
        if (length.value <= totalVisible.value) {
          return createRange(length.value, start.value);
        }
        const even = totalVisible.value % 2 === 0;
        const middle = even ? totalVisible.value / 2 : Math.floor(totalVisible.value / 2);
        const left = even ? middle : middle + 1;
        const right = length.value - middle;
        if (left - page.value >= 0) {
          return [...createRange(Math.max(1, totalVisible.value - 1), start.value), props.ellipsis, length.value];
        } else if (page.value - right >= (even ? 1 : 0)) {
          const rangeLength = totalVisible.value - 1;
          const rangeStart = length.value - rangeLength + start.value;
          return [start.value, props.ellipsis, ...createRange(rangeLength, rangeStart)];
        } else {
          const rangeLength = Math.max(1, totalVisible.value - 2);
          const rangeStart = rangeLength === 1 ? page.value : page.value - Math.ceil(rangeLength / 2) + start.value;
          return [start.value, props.ellipsis, ...createRange(rangeLength, rangeStart), props.ellipsis, length.value];
        }
      });
      function setValue(e, value, event2) {
        e.preventDefault();
        page.value = value;
        event2 && emit2(event2, value);
      }
      const {
        refs,
        updateRef
      } = useRefs();
      provideDefaults({
        VPaginationBtn: {
          color: toRef(() => props.color),
          border: toRef(() => props.border),
          density: toRef(() => props.density),
          size: toRef(() => props.size),
          variant: toRef(() => props.variant),
          rounded: toRef(() => props.rounded),
          elevation: toRef(() => props.elevation)
        }
      });
      const items = computed2(() => {
        return range.value.map((item, index) => {
          const ref2 = (e) => updateRef(e, index);
          if (typeof item === "string") {
            return {
              isActive: false,
              key: `ellipsis-${index}`,
              page: item,
              props: {
                ref: ref2,
                ellipsis: true,
                icon: true,
                disabled: true
              }
            };
          } else {
            const isActive = item === page.value;
            return {
              isActive,
              key: item,
              page: n(item),
              props: {
                ref: ref2,
                ellipsis: false,
                icon: true,
                disabled: !!props.disabled || Number(props.length) < 2,
                color: isActive ? props.activeColor : props.color,
                "aria-current": isActive,
                "aria-label": t(isActive ? props.currentPageAriaLabel : props.pageAriaLabel, item),
                onClick: (e) => setValue(e, item)
              }
            };
          }
        });
      });
      const controls = computed2(() => {
        const prevDisabled = !!props.disabled || page.value <= start.value;
        const nextDisabled = !!props.disabled || page.value >= start.value + length.value - 1;
        return {
          first: props.showFirstLastPage ? {
            icon: isRtl.value ? props.lastIcon : props.firstIcon,
            onClick: (e) => setValue(e, start.value, "first"),
            disabled: prevDisabled,
            "aria-label": t(props.firstAriaLabel),
            "aria-disabled": prevDisabled
          } : void 0,
          prev: {
            icon: isRtl.value ? props.nextIcon : props.prevIcon,
            onClick: (e) => setValue(e, page.value - 1, "prev"),
            disabled: prevDisabled,
            "aria-label": t(props.previousAriaLabel),
            "aria-disabled": prevDisabled
          },
          next: {
            icon: isRtl.value ? props.prevIcon : props.nextIcon,
            onClick: (e) => setValue(e, page.value + 1, "next"),
            disabled: nextDisabled,
            "aria-label": t(props.nextAriaLabel),
            "aria-disabled": nextDisabled
          },
          last: props.showFirstLastPage ? {
            icon: isRtl.value ? props.firstIcon : props.lastIcon,
            onClick: (e) => setValue(e, start.value + length.value - 1, "last"),
            disabled: nextDisabled,
            "aria-label": t(props.lastAriaLabel),
            "aria-disabled": nextDisabled
          } : void 0
        };
      });
      function updateFocus() {
        var _a3;
        const currentIndex = page.value - start.value;
        (_a3 = refs.value[currentIndex]) == null ? void 0 : _a3.$el.focus();
      }
      function onKeydown(e) {
        if (e.key === keyValues.left && !props.disabled && page.value > Number(props.start)) {
          page.value = page.value - 1;
          nextTick(updateFocus);
        } else if (e.key === keyValues.right && !props.disabled && page.value < start.value + length.value - 1) {
          page.value = page.value + 1;
          nextTick(updateFocus);
        }
      }
      useRender(() => createVNode(props.tag, {
        "ref": resizeRef,
        "class": normalizeClass(["v-pagination", themeClasses.value, props.class]),
        "style": normalizeStyle(props.style),
        "role": "navigation",
        "aria-label": t(props.ariaLabel),
        "onKeydown": onKeydown,
        "data-test": "v-pagination-root"
      }, {
        default: () => [createBaseVNode("ul", {
          "class": "v-pagination__list"
        }, [props.showFirstLastPage && createBaseVNode("li", {
          "key": "first",
          "class": "v-pagination__first",
          "data-test": "v-pagination-first"
        }, [slots.first ? slots.first(controls.value.first) : createVNode(VBtn, mergeProps({
          "_as": "VPaginationBtn"
        }, controls.value.first), null)]), createBaseVNode("li", {
          "key": "prev",
          "class": "v-pagination__prev",
          "data-test": "v-pagination-prev"
        }, [slots.prev ? slots.prev(controls.value.prev) : createVNode(VBtn, mergeProps({
          "_as": "VPaginationBtn"
        }, controls.value.prev), null)]), items.value.map((item, index) => createBaseVNode("li", {
          "key": item.key,
          "class": normalizeClass(["v-pagination__item", {
            "v-pagination__item--is-active": item.isActive
          }]),
          "data-test": "v-pagination-item"
        }, [slots.item ? slots.item(item) : createVNode(VBtn, mergeProps({
          "_as": "VPaginationBtn"
        }, item.props), {
          default: () => [item.page]
        })])), createBaseVNode("li", {
          "key": "next",
          "class": "v-pagination__next",
          "data-test": "v-pagination-next"
        }, [slots.next ? slots.next(controls.value.next) : createVNode(VBtn, mergeProps({
          "_as": "VPaginationBtn"
        }, controls.value.next), null)]), props.showFirstLastPage && createBaseVNode("li", {
          "key": "last",
          "class": "v-pagination__last",
          "data-test": "v-pagination-last"
        }, [slots.last ? slots.last(controls.value.last) : createVNode(VBtn, mergeProps({
          "_as": "VPaginationBtn"
        }, controls.value.last), null)])])]
      }));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VDataTable/VDataTableFooter.js
  var makeVDataTableFooterProps = propsFactory({
    prevIcon: {
      type: IconValue,
      default: "$prev"
    },
    nextIcon: {
      type: IconValue,
      default: "$next"
    },
    firstIcon: {
      type: IconValue,
      default: "$first"
    },
    lastIcon: {
      type: IconValue,
      default: "$last"
    },
    itemsPerPageText: {
      type: String,
      default: "$vuetify.dataFooter.itemsPerPageText"
    },
    pageText: {
      type: String,
      default: "$vuetify.dataFooter.pageText"
    },
    firstPageLabel: {
      type: String,
      default: "$vuetify.dataFooter.firstPage"
    },
    prevPageLabel: {
      type: String,
      default: "$vuetify.dataFooter.prevPage"
    },
    nextPageLabel: {
      type: String,
      default: "$vuetify.dataFooter.nextPage"
    },
    lastPageLabel: {
      type: String,
      default: "$vuetify.dataFooter.lastPage"
    },
    itemsPerPageOptions: {
      type: Array,
      default: () => [{
        value: 10,
        title: "10"
      }, {
        value: 25,
        title: "25"
      }, {
        value: 50,
        title: "50"
      }, {
        value: 100,
        title: "100"
      }, {
        value: -1,
        title: "$vuetify.dataFooter.itemsPerPageAll"
      }]
    },
    showCurrentPage: Boolean
  }, "VDataTableFooter");
  var VDataTableFooter = genericComponent()({
    name: "VDataTableFooter",
    props: makeVDataTableFooterProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        t
      } = useLocale();
      const {
        page,
        pageCount,
        startIndex,
        stopIndex,
        itemsLength,
        itemsPerPage,
        setItemsPerPage
      } = usePagination();
      const itemsPerPageOptions = computed2(() => props.itemsPerPageOptions.map((option) => {
        if (typeof option === "number") {
          return {
            value: option,
            title: option === -1 ? t("$vuetify.dataFooter.itemsPerPageAll") : String(option)
          };
        }
        return __spreadProps(__spreadValues({}, option), {
          title: !isNaN(Number(option.title)) ? option.title : t(option.title)
        });
      }));
      useRender(() => {
        var _a3;
        const paginationProps = VPagination.filterProps(props);
        return createBaseVNode("div", {
          "class": "v-data-table-footer"
        }, [(_a3 = slots.prepend) == null ? void 0 : _a3.call(slots), createBaseVNode("div", {
          "class": "v-data-table-footer__items-per-page"
        }, [createBaseVNode("span", {
          "aria-label": t(props.itemsPerPageText)
        }, [t(props.itemsPerPageText)]), createVNode(VSelect, {
          "items": itemsPerPageOptions.value,
          "modelValue": itemsPerPage.value,
          "onUpdate:modelValue": (v) => setItemsPerPage(Number(v)),
          "density": "compact",
          "variant": "outlined",
          "hide-details": true
        }, null)]), createBaseVNode("div", {
          "class": "v-data-table-footer__info"
        }, [createBaseVNode("div", null, [t(props.pageText, !itemsLength.value ? 0 : startIndex.value + 1, stopIndex.value, itemsLength.value)])]), createBaseVNode("div", {
          "class": "v-data-table-footer__pagination"
        }, [createVNode(VPagination, mergeProps({
          "modelValue": page.value,
          "onUpdate:modelValue": ($event) => page.value = $event,
          "density": "comfortable",
          "first-aria-label": props.firstPageLabel,
          "last-aria-label": props.lastPageLabel,
          "length": pageCount.value,
          "next-aria-label": props.nextPageLabel,
          "previous-aria-label": props.prevPageLabel,
          "rounded": true,
          "show-first-last-page": true,
          "total-visible": props.showCurrentPage ? 1 : 0,
          "variant": "plain"
        }, paginationProps), null)])]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VDataTable/VDataTableColumn.js
  var VDataTableColumn = defineFunctionalComponent({
    align: {
      type: String,
      default: "start"
    },
    fixed: Boolean,
    fixedOffset: [Number, String],
    height: [Number, String],
    lastFixed: Boolean,
    noPadding: Boolean,
    tag: String,
    width: [Number, String],
    maxWidth: [Number, String],
    nowrap: Boolean
  }, (props, _ref) => {
    var _a3;
    let {
      slots
    } = _ref;
    const Tag = (_a3 = props.tag) != null ? _a3 : "td";
    return createVNode(Tag, {
      "tabindex": "0",
      "class": normalizeClass(["v-data-table__td", {
        "v-data-table-column--fixed": props.fixed,
        "v-data-table-column--last-fixed": props.lastFixed,
        "v-data-table-column--no-padding": props.noPadding,
        "v-data-table-column--nowrap": props.nowrap
      }, `v-data-table-column--align-${props.align}`]),
      "style": {
        height: convertToUnit(props.height),
        width: convertToUnit(props.width),
        maxWidth: convertToUnit(props.maxWidth),
        left: convertToUnit(props.fixedOffset || null)
      }
    }, {
      default: () => {
        var _a4;
        return [(_a4 = slots.default) == null ? void 0 : _a4.call(slots)];
      }
    });
  });

  // ../posawesome/node_modules/vuetify/lib/components/VDataTable/composables/headers.js
  var makeDataTableHeaderProps = propsFactory({
    headers: Array
  }, "DataTable-header");
  var VDataTableHeadersSymbol = Symbol.for("vuetify:data-table-headers");
  var defaultHeader = {
    title: "",
    sortable: false
  };
  var defaultActionHeader = __spreadProps(__spreadValues({}, defaultHeader), {
    width: 48
  });
  function priorityQueue() {
    let arr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const queue2 = arr.map((element) => ({
      element,
      priority: 0
    }));
    return {
      enqueue: (element, priority) => {
        let added = false;
        for (let i = 0; i < queue2.length; i++) {
          const item = queue2[i];
          if (item.priority > priority) {
            queue2.splice(i, 0, {
              element,
              priority
            });
            added = true;
            break;
          }
        }
        if (!added)
          queue2.push({
            element,
            priority
          });
      },
      size: () => queue2.length,
      count: () => {
        let count = 0;
        if (!queue2.length)
          return 0;
        const whole = Math.floor(queue2[0].priority);
        for (let i = 0; i < queue2.length; i++) {
          if (Math.floor(queue2[i].priority) === whole)
            count += 1;
        }
        return count;
      },
      dequeue: () => {
        return queue2.shift();
      }
    };
  }
  function extractLeaves(item) {
    let columns = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    if (!item.children) {
      columns.push(item);
    } else {
      for (const child of item.children) {
        extractLeaves(child, columns);
      }
    }
    return columns;
  }
  function extractKeys(headers) {
    let keys2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new Set();
    for (const item of headers) {
      if (item.key)
        keys2.add(item.key);
      if (item.children) {
        extractKeys(item.children, keys2);
      }
    }
    return keys2;
  }
  function getDefaultItem(item) {
    if (!item.key)
      return void 0;
    if (item.key === "data-table-group")
      return defaultHeader;
    if (["data-table-expand", "data-table-select"].includes(item.key))
      return defaultActionHeader;
    return void 0;
  }
  function getDepth(item) {
    let depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (!item.children)
      return depth;
    return Math.max(depth, ...item.children.map((child) => getDepth(child, depth + 1)));
  }
  function parseFixedColumns(items) {
    let seenFixed = false;
    function setFixed(item) {
      let parentFixed = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!item)
        return;
      if (parentFixed) {
        item.fixed = true;
      }
      if (item.fixed) {
        if (item.children) {
          for (let i = item.children.length - 1; i >= 0; i--) {
            setFixed(item.children[i], true);
          }
        } else {
          if (!seenFixed) {
            item.lastFixed = true;
          } else if (isNaN(Number(item.width))) {
            consoleError(`Multiple fixed columns should have a static width (key: ${item.key})`);
          } else {
            item.minWidth = Math.max(Number(item.width) || 0, Number(item.minWidth) || 0);
          }
          seenFixed = true;
        }
      } else {
        if (item.children) {
          for (let i = item.children.length - 1; i >= 0; i--) {
            setFixed(item.children[i]);
          }
        } else {
          seenFixed = false;
        }
      }
    }
    for (let i = items.length - 1; i >= 0; i--) {
      setFixed(items[i]);
    }
    function setFixedOffset(item) {
      let fixedOffset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      if (!item)
        return fixedOffset2;
      if (item.children) {
        item.fixedOffset = fixedOffset2;
        for (const child of item.children) {
          fixedOffset2 = setFixedOffset(child, fixedOffset2);
        }
      } else if (item.fixed) {
        item.fixedOffset = fixedOffset2;
        fixedOffset2 += parseFloat(item.width || "0") || 0;
      }
      return fixedOffset2;
    }
    let fixedOffset = 0;
    for (const item of items) {
      fixedOffset = setFixedOffset(item, fixedOffset);
    }
  }
  function parse2(items, maxDepth) {
    const headers = [];
    let currentDepth = 0;
    const queue2 = priorityQueue(items);
    while (queue2.size() > 0) {
      let rowSize = queue2.count();
      const row = [];
      let fraction = 1;
      while (rowSize > 0) {
        const {
          element: item,
          priority
        } = queue2.dequeue();
        const diff = maxDepth - currentDepth - getDepth(item);
        row.push(__spreadProps(__spreadValues({}, item), {
          rowspan: diff != null ? diff : 1,
          colspan: item.children ? extractLeaves(item).length : 1
        }));
        if (item.children) {
          for (const child of item.children) {
            const sort = priority % 1 + fraction / Math.pow(10, currentDepth + 2);
            queue2.enqueue(child, currentDepth + diff + sort);
          }
        }
        fraction += 1;
        rowSize -= 1;
      }
      currentDepth += 1;
      headers.push(row);
    }
    const columns = items.map((item) => extractLeaves(item)).flat();
    return {
      columns,
      headers
    };
  }
  function convertToInternalHeaders(items) {
    var _a3, _b, _c, _d;
    const internalHeaders = [];
    for (const item of items) {
      const defaultItem = __spreadValues(__spreadValues({}, getDefaultItem(item)), item);
      const key = (_a3 = defaultItem.key) != null ? _a3 : typeof defaultItem.value === "string" ? defaultItem.value : null;
      const value = (_c = (_b = defaultItem.value) != null ? _b : key) != null ? _c : null;
      const internalItem = __spreadProps(__spreadValues({}, defaultItem), {
        key,
        value,
        sortable: (_d = defaultItem.sortable) != null ? _d : defaultItem.key != null || !!defaultItem.sort,
        children: defaultItem.children ? convertToInternalHeaders(defaultItem.children) : void 0
      });
      internalHeaders.push(internalItem);
    }
    return internalHeaders;
  }
  function createHeaders(props, options) {
    const headers = ref([]);
    const columns = ref([]);
    const sortFunctions = ref({});
    const sortRawFunctions = ref({});
    const filterFunctions = ref({});
    watchEffect(() => {
      var _a3, _b, _c, _d;
      const _headers = props.headers || Object.keys((_a3 = props.items[0]) != null ? _a3 : {}).map((key) => ({
        key,
        title: capitalize(key)
      }));
      const items = _headers.slice();
      const keys2 = extractKeys(items);
      if (((_b = options == null ? void 0 : options.groupBy) == null ? void 0 : _b.value.length) && !keys2.has("data-table-group")) {
        items.unshift({
          key: "data-table-group",
          title: "Group"
        });
      }
      if (((_c = options == null ? void 0 : options.showSelect) == null ? void 0 : _c.value) && !keys2.has("data-table-select")) {
        items.unshift({
          key: "data-table-select"
        });
      }
      if (((_d = options == null ? void 0 : options.showExpand) == null ? void 0 : _d.value) && !keys2.has("data-table-expand")) {
        items.push({
          key: "data-table-expand"
        });
      }
      const internalHeaders = convertToInternalHeaders(items);
      parseFixedColumns(internalHeaders);
      const maxDepth = Math.max(...internalHeaders.map((item) => getDepth(item))) + 1;
      const parsed = parse2(internalHeaders, maxDepth);
      headers.value = parsed.headers;
      columns.value = parsed.columns;
      const flatHeaders = parsed.headers.flat(1);
      for (const header of flatHeaders) {
        if (!header.key)
          continue;
        if (header.sortable) {
          if (header.sort) {
            sortFunctions.value[header.key] = header.sort;
          }
          if (header.sortRaw) {
            sortRawFunctions.value[header.key] = header.sortRaw;
          }
        }
        if (header.filter) {
          filterFunctions.value[header.key] = header.filter;
        }
      }
    });
    const data = {
      headers,
      columns,
      sortFunctions,
      sortRawFunctions,
      filterFunctions
    };
    provide(VDataTableHeadersSymbol, data);
    return data;
  }
  function useHeaders() {
    const data = inject(VDataTableHeadersSymbol);
    if (!data)
      throw new Error("Missing headers!");
    return data;
  }

  // ../posawesome/node_modules/vuetify/lib/components/VDataTable/VDataTableHeaders.js
  var makeVDataTableHeadersProps = propsFactory(__spreadValues(__spreadValues({
    color: String,
    disableSort: Boolean,
    fixedHeader: Boolean,
    multiSort: Boolean,
    sortAscIcon: {
      type: IconValue,
      default: "$sortAsc"
    },
    sortDescIcon: {
      type: IconValue,
      default: "$sortDesc"
    },
    headerProps: {
      type: Object
    },
    sticky: Boolean
  }, makeDisplayProps()), makeLoaderProps()), "VDataTableHeaders");
  var VDataTableHeaders = genericComponent()({
    name: "VDataTableHeaders",
    props: makeVDataTableHeadersProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        t
      } = useLocale();
      const {
        toggleSort,
        sortBy,
        isSorted
      } = useSort();
      const {
        someSelected,
        allSelected,
        selectAll,
        showSelectAll
      } = useSelection();
      const {
        columns,
        headers
      } = useHeaders();
      const {
        loaderClasses
      } = useLoader(props);
      function getFixedStyles(column, y) {
        if (!(props.sticky || props.fixedHeader) && !column.fixed)
          return void 0;
        return {
          position: "sticky",
          left: column.fixed ? convertToUnit(column.fixedOffset) : void 0,
          top: props.sticky || props.fixedHeader ? `calc(var(--v-table-header-height) * ${y})` : void 0
        };
      }
      function handleEnterKeyPress(event2, column) {
        if (event2.key === "Enter" && !props.disableSort) {
          toggleSort(column);
        }
      }
      function getSortIcon(column) {
        const item = sortBy.value.find((item2) => item2.key === column.key);
        if (!item)
          return props.sortAscIcon;
        return item.order === "asc" ? props.sortAscIcon : props.sortDescIcon;
      }
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(() => props.color);
      const {
        displayClasses,
        mobile
      } = useDisplay(props);
      const slotProps = computed2(() => ({
        headers: headers.value,
        columns: columns.value,
        toggleSort,
        isSorted,
        sortBy: sortBy.value,
        someSelected: someSelected.value,
        allSelected: allSelected.value,
        selectAll,
        getSortIcon
      }));
      const headerCellClasses = computed2(() => ["v-data-table__th", {
        "v-data-table__th--sticky": props.sticky || props.fixedHeader
      }, displayClasses.value, loaderClasses.value]);
      const VDataTableHeaderCell = (_ref2) => {
        var _a3, _b;
        let {
          column,
          x,
          y
        } = _ref2;
        const noPadding = column.key === "data-table-select" || column.key === "data-table-expand";
        const headerProps = mergeProps((_a3 = props.headerProps) != null ? _a3 : {}, (_b = column.headerProps) != null ? _b : {});
        return createVNode(VDataTableColumn, mergeProps({
          "tag": "th",
          "align": column.align,
          "class": [{
            "v-data-table__th--sortable": column.sortable && !props.disableSort,
            "v-data-table__th--sorted": isSorted(column),
            "v-data-table__th--fixed": column.fixed
          }, ...headerCellClasses.value],
          "style": __spreadValues({
            width: convertToUnit(column.width),
            minWidth: convertToUnit(column.minWidth),
            maxWidth: convertToUnit(column.maxWidth)
          }, getFixedStyles(column, y)),
          "colspan": column.colspan,
          "rowspan": column.rowspan,
          "onClick": column.sortable ? () => toggleSort(column) : void 0,
          "fixed": column.fixed,
          "nowrap": column.nowrap,
          "lastFixed": column.lastFixed,
          "noPadding": noPadding
        }, headerProps, {
          "onKeydown": (event2) => column.sortable && handleEnterKeyPress(event2, column)
        }), {
          default: () => {
            var _a4, _b2;
            const columnSlotName = `header.${column.key}`;
            const columnSlotProps = {
              column,
              selectAll,
              isSorted,
              toggleSort,
              sortBy: sortBy.value,
              someSelected: someSelected.value,
              allSelected: allSelected.value,
              getSortIcon
            };
            if (slots[columnSlotName])
              return slots[columnSlotName](columnSlotProps);
            if (column.key === "data-table-select") {
              return (_b2 = (_a4 = slots["header.data-table-select"]) == null ? void 0 : _a4.call(slots, columnSlotProps)) != null ? _b2 : showSelectAll.value && createVNode(VCheckboxBtn, {
                "modelValue": allSelected.value,
                "indeterminate": someSelected.value && !allSelected.value,
                "onUpdate:modelValue": selectAll
              }, null);
            }
            return createBaseVNode("div", {
              "class": "v-data-table-header__content"
            }, [createBaseVNode("span", null, [column.title]), column.sortable && !props.disableSort && createVNode(VIcon, {
              "key": "icon",
              "class": "v-data-table-header__sort-icon",
              "icon": getSortIcon(column)
            }, null), props.multiSort && isSorted(column) && createBaseVNode("div", {
              "key": "badge",
              "class": normalizeClass(["v-data-table-header__sort-badge", ...backgroundColorClasses.value]),
              "style": normalizeStyle(backgroundColorStyles.value)
            }, [sortBy.value.findIndex((x2) => x2.key === column.key) + 1])]);
          }
        });
      };
      const VDataTableMobileHeaderCell = () => {
        const displayItems = computed2(() => {
          return columns.value.filter((column) => (column == null ? void 0 : column.sortable) && !props.disableSort);
        });
        const appendIcon = computed2(() => {
          const showSelectColumn = columns.value.find((column) => column.key === "data-table-select");
          if (showSelectColumn == null)
            return;
          return allSelected.value ? "$checkboxOn" : someSelected.value ? "$checkboxIndeterminate" : "$checkboxOff";
        });
        return createVNode(VDataTableColumn, mergeProps({
          "tag": "th",
          "class": [...headerCellClasses.value],
          "colspan": headers.value.length + 1
        }, props.headerProps), {
          default: () => [createBaseVNode("div", {
            "class": "v-data-table-header__content"
          }, [createVNode(VSelect, {
            "chips": true,
            "class": "v-data-table__td-sort-select",
            "clearable": true,
            "density": "default",
            "items": displayItems.value,
            "label": t("$vuetify.dataTable.sortBy"),
            "multiple": props.multiSort,
            "variant": "underlined",
            "onClick:clear": () => sortBy.value = [],
            "appendIcon": appendIcon.value,
            "onClick:append": () => selectAll(!allSelected.value)
          }, __spreadProps(__spreadValues({}, slots), {
            chip: (props2) => {
              var _a3;
              return createVNode(VChip, {
                "onClick": ((_a3 = props2.item.raw) == null ? void 0 : _a3.sortable) ? () => toggleSort(props2.item.raw) : void 0,
                "onMousedown": (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                }
              }, {
                default: () => [props2.item.title, createVNode(VIcon, {
                  "class": normalizeClass(["v-data-table__td-sort-icon", isSorted(props2.item.raw) && "v-data-table__td-sort-icon-active"]),
                  "icon": getSortIcon(props2.item.raw),
                  "size": "small"
                }, null)]
              });
            }
          }))])]
        });
      };
      useRender(() => {
        return mobile.value ? createBaseVNode("tr", null, [createVNode(VDataTableMobileHeaderCell, null, null)]) : createBaseVNode(Fragment, null, [slots.headers ? slots.headers(slotProps.value) : headers.value.map((row, y) => createBaseVNode("tr", null, [row.map((column, x) => createVNode(VDataTableHeaderCell, {
          "column": column,
          "x": x,
          "y": y
        }, null))])), props.loading && createBaseVNode("tr", {
          "class": "v-data-table-progress"
        }, [createBaseVNode("th", {
          "colspan": columns.value.length
        }, [createVNode(LoaderSlot, {
          "name": "v-data-table-progress",
          "absolute": true,
          "active": true,
          "color": typeof props.loading === "boolean" ? void 0 : props.loading,
          "indeterminate": true
        }, {
          default: slots.loader
        })])])]);
      });
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VDataTable/VDataTableGroupHeaderRow.js
  var makeVDataTableGroupHeaderRowProps = propsFactory({
    item: {
      type: Object,
      required: true
    }
  }, "VDataTableGroupHeaderRow");
  var VDataTableGroupHeaderRow = genericComponent()({
    name: "VDataTableGroupHeaderRow",
    props: makeVDataTableGroupHeaderRowProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        isGroupOpen,
        toggleGroup,
        extractRows
      } = useGroupBy();
      const {
        isSelected,
        isSomeSelected,
        select
      } = useSelection();
      const {
        columns
      } = useHeaders();
      const rows = computed2(() => {
        return extractRows([props.item]);
      });
      return () => createBaseVNode("tr", {
        "class": "v-data-table-group-header-row",
        "style": {
          "--v-data-table-group-header-row-depth": props.item.depth
        }
      }, [columns.value.map((column) => {
        var _a3, _b, _c, _d;
        if (column.key === "data-table-group") {
          const icon = isGroupOpen(props.item) ? "$expand" : "$next";
          const onClick = () => toggleGroup(props.item);
          return (_b = (_a3 = slots["data-table-group"]) == null ? void 0 : _a3.call(slots, {
            item: props.item,
            count: rows.value.length,
            props: {
              icon,
              onClick
            }
          })) != null ? _b : createVNode(VDataTableColumn, {
            "class": "v-data-table-group-header-row__column"
          }, {
            default: () => [createVNode(VBtn, {
              "size": "small",
              "variant": "text",
              "icon": icon,
              "onClick": onClick
            }, null), createBaseVNode("span", null, [props.item.value]), createBaseVNode("span", null, [createTextVNode("("), rows.value.length, createTextVNode(")")])]
          });
        }
        if (column.key === "data-table-select") {
          const modelValue = isSelected(rows.value);
          const indeterminate = isSomeSelected(rows.value) && !modelValue;
          const selectGroup = (v) => select(rows.value, v);
          return (_d = (_c = slots["data-table-select"]) == null ? void 0 : _c.call(slots, {
            props: {
              modelValue,
              indeterminate,
              "onUpdate:modelValue": selectGroup
            }
          })) != null ? _d : createBaseVNode("td", null, [createVNode(VCheckboxBtn, {
            "modelValue": modelValue,
            "indeterminate": indeterminate,
            "onUpdate:modelValue": selectGroup
          }, null)]);
        }
        return createBaseVNode("td", null, null);
      })]);
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VDataTable/VDataTableRow.js
  var makeVDataTableRowProps = propsFactory(__spreadValues({
    index: Number,
    item: Object,
    cellProps: [Object, Function],
    onClick: EventProp(),
    onContextmenu: EventProp(),
    onDblclick: EventProp()
  }, makeDisplayProps()), "VDataTableRow");
  var VDataTableRow = genericComponent()({
    name: "VDataTableRow",
    props: makeVDataTableRowProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        displayClasses,
        mobile
      } = useDisplay(props, "v-data-table__tr");
      const {
        isSelected,
        toggleSelect,
        someSelected,
        allSelected,
        selectAll
      } = useSelection();
      const {
        isExpanded,
        toggleExpand
      } = useExpanded();
      const {
        toggleSort,
        sortBy,
        isSorted
      } = useSort();
      const {
        columns
      } = useHeaders();
      useRender(() => createBaseVNode("tr", {
        "class": normalizeClass(["v-data-table__tr", {
          "v-data-table__tr--clickable": !!(props.onClick || props.onContextmenu || props.onDblclick)
        }, displayClasses.value]),
        "onClick": props.onClick,
        "onContextmenu": props.onContextmenu,
        "onDblclick": props.onDblclick
      }, [props.item && columns.value.map((column, i) => {
        const item = props.item;
        const slotName = `item.${column.key}`;
        const headerSlotName = `header.${column.key}`;
        const slotProps = {
          index: props.index,
          item: item.raw,
          internalItem: item,
          value: getObjectValueByPath(item.columns, column.key),
          column,
          isSelected,
          toggleSelect,
          isExpanded,
          toggleExpand
        };
        const columnSlotProps = {
          column,
          selectAll,
          isSorted,
          toggleSort,
          sortBy: sortBy.value,
          someSelected: someSelected.value,
          allSelected: allSelected.value,
          getSortIcon: () => ""
        };
        const cellProps = typeof props.cellProps === "function" ? props.cellProps({
          index: slotProps.index,
          item: slotProps.item,
          internalItem: slotProps.internalItem,
          value: slotProps.value,
          column
        }) : props.cellProps;
        const columnCellProps = typeof column.cellProps === "function" ? column.cellProps({
          index: slotProps.index,
          item: slotProps.item,
          internalItem: slotProps.internalItem,
          value: slotProps.value
        }) : column.cellProps;
        return createVNode(VDataTableColumn, mergeProps({
          "align": column.align,
          "class": {
            "v-data-table__td--expanded-row": column.key === "data-table-expand",
            "v-data-table__td--select-row": column.key === "data-table-select"
          },
          "fixed": column.fixed,
          "fixedOffset": column.fixedOffset,
          "lastFixed": column.lastFixed,
          "maxWidth": !mobile.value ? column.maxWidth : void 0,
          "noPadding": column.key === "data-table-select" || column.key === "data-table-expand",
          "nowrap": column.nowrap,
          "width": !mobile.value ? column.width : void 0
        }, cellProps, columnCellProps), {
          default: () => {
            var _a3, _b, _c, _d, _e, _f, _g, _h;
            if (column.key === "data-table-select") {
              return (_b = (_a3 = slots["item.data-table-select"]) == null ? void 0 : _a3.call(slots, __spreadProps(__spreadValues({}, slotProps), {
                props: {
                  disabled: !item.selectable,
                  modelValue: isSelected([item]),
                  onClick: withModifiers(() => toggleSelect(item), ["stop"])
                }
              }))) != null ? _b : createVNode(VCheckboxBtn, {
                "disabled": !item.selectable,
                "modelValue": isSelected([item]),
                "onClick": withModifiers((event2) => toggleSelect(item, props.index, event2), ["stop"])
              }, null);
            }
            if (column.key === "data-table-expand") {
              return (_d = (_c = slots["item.data-table-expand"]) == null ? void 0 : _c.call(slots, __spreadProps(__spreadValues({}, slotProps), {
                props: {
                  icon: isExpanded(item) ? "$collapse" : "$expand",
                  size: "small",
                  variant: "text",
                  onClick: withModifiers(() => toggleExpand(item), ["stop"])
                }
              }))) != null ? _d : createVNode(VBtn, {
                "icon": isExpanded(item) ? "$collapse" : "$expand",
                "size": "small",
                "variant": "text",
                "onClick": withModifiers(() => toggleExpand(item), ["stop"])
              }, null);
            }
            if (slots[slotName] && !mobile.value)
              return slots[slotName](slotProps);
            const displayValue = toDisplayString(slotProps.value);
            return !mobile.value ? displayValue : createBaseVNode(Fragment, null, [createBaseVNode("div", {
              "class": "v-data-table__td-title"
            }, [(_f = (_e = slots[headerSlotName]) == null ? void 0 : _e.call(slots, columnSlotProps)) != null ? _f : column.title]), createBaseVNode("div", {
              "class": "v-data-table__td-value"
            }, [(_h = (_g = slots[slotName]) == null ? void 0 : _g.call(slots, slotProps)) != null ? _h : displayValue])]);
          }
        });
      })]));
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VDataTable/VDataTableRows.js
  var makeVDataTableRowsProps = propsFactory(__spreadValues({
    loading: [Boolean, String],
    loadingText: {
      type: String,
      default: "$vuetify.dataIterator.loadingText"
    },
    hideNoData: Boolean,
    items: {
      type: Array,
      default: () => []
    },
    noDataText: {
      type: String,
      default: "$vuetify.noDataText"
    },
    rowProps: [Object, Function],
    cellProps: [Object, Function]
  }, makeDisplayProps()), "VDataTableRows");
  var VDataTableRows = genericComponent()({
    name: "VDataTableRows",
    inheritAttrs: false,
    props: makeVDataTableRowsProps(),
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const {
        columns
      } = useHeaders();
      const {
        expandOnClick,
        toggleExpand,
        isExpanded
      } = useExpanded();
      const {
        isSelected,
        toggleSelect
      } = useSelection();
      const {
        toggleGroup,
        isGroupOpen
      } = useGroupBy();
      const {
        t
      } = useLocale();
      const {
        mobile
      } = useDisplay(props);
      useRender(() => {
        var _a3, _b, _c, _d;
        if (props.loading && (!props.items.length || slots.loading)) {
          return createBaseVNode("tr", {
            "class": "v-data-table-rows-loading",
            "key": "loading"
          }, [createBaseVNode("td", {
            "colspan": columns.value.length
          }, [(_b = (_a3 = slots.loading) == null ? void 0 : _a3.call(slots)) != null ? _b : t(props.loadingText)])]);
        }
        if (!props.loading && !props.items.length && !props.hideNoData) {
          return createBaseVNode("tr", {
            "class": "v-data-table-rows-no-data",
            "key": "no-data"
          }, [createBaseVNode("td", {
            "colspan": columns.value.length
          }, [(_d = (_c = slots["no-data"]) == null ? void 0 : _c.call(slots)) != null ? _d : t(props.noDataText)])]);
        }
        return createBaseVNode(Fragment, null, [props.items.map((item, index) => {
          var _a4, _b2;
          if (item.type === "group") {
            const slotProps2 = {
              index,
              item,
              columns: columns.value,
              isExpanded,
              toggleExpand,
              isSelected,
              toggleSelect,
              toggleGroup,
              isGroupOpen
            };
            return slots["group-header"] ? slots["group-header"](slotProps2) : createVNode(VDataTableGroupHeaderRow, mergeProps({
              "key": `group-header_${item.id}`,
              "item": item
            }, getPrefixedEventHandlers(attrs, ":group-header", () => slotProps2)), slots);
          }
          const slotProps = {
            index,
            item: item.raw,
            internalItem: item,
            columns: columns.value,
            isExpanded,
            toggleExpand,
            isSelected,
            toggleSelect
          };
          const itemSlotProps = __spreadProps(__spreadValues({}, slotProps), {
            props: mergeProps({
              key: `item_${(_a4 = item.key) != null ? _a4 : item.index}`,
              onClick: expandOnClick.value ? () => {
                toggleExpand(item);
              } : void 0,
              index,
              item,
              cellProps: props.cellProps,
              mobile: mobile.value
            }, getPrefixedEventHandlers(attrs, ":row", () => slotProps), typeof props.rowProps === "function" ? props.rowProps({
              item: slotProps.item,
              index: slotProps.index,
              internalItem: slotProps.internalItem
            }) : props.rowProps)
          });
          return createBaseVNode(Fragment, {
            "key": itemSlotProps.props.key
          }, [slots.item ? slots.item(itemSlotProps) : createVNode(VDataTableRow, itemSlotProps.props, slots), isExpanded(item) && ((_b2 = slots["expanded-row"]) == null ? void 0 : _b2.call(slots, slotProps))]);
        })]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VTable/VTable.js
  var makeVTableProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    fixedHeader: Boolean,
    fixedFooter: Boolean,
    height: [Number, String],
    hover: Boolean
  }, makeComponentProps()), makeDensityProps()), makeTagProps()), makeThemeProps()), "VTable");
  var VTable = genericComponent()({
    name: "VTable",
    props: makeVTableProps(),
    setup(props, _ref) {
      let {
        slots,
        emit: emit2
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        densityClasses
      } = useDensity(props);
      useRender(() => createVNode(props.tag, {
        "class": normalizeClass(["v-table", {
          "v-table--fixed-height": !!props.height,
          "v-table--fixed-header": props.fixedHeader,
          "v-table--fixed-footer": props.fixedFooter,
          "v-table--has-top": !!slots.top,
          "v-table--has-bottom": !!slots.bottom,
          "v-table--hover": props.hover
        }, themeClasses.value, densityClasses.value, props.class]),
        "style": normalizeStyle(props.style)
      }, {
        default: () => {
          var _a3, _b, _c;
          return [(_a3 = slots.top) == null ? void 0 : _a3.call(slots), slots.default ? createBaseVNode("div", {
            "class": "v-table__wrapper",
            "style": {
              height: convertToUnit(props.height)
            }
          }, [createBaseVNode("table", null, [slots.default()])]) : (_b = slots.wrapper) == null ? void 0 : _b.call(slots), (_c = slots.bottom) == null ? void 0 : _c.call(slots)];
        }
      }));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VDataTable/composables/items.js
  var makeDataTableItemsProps = propsFactory({
    items: {
      type: Array,
      default: () => []
    },
    itemValue: {
      type: [String, Array, Function],
      default: "id"
    },
    itemSelectable: {
      type: [String, Array, Function],
      default: null
    },
    rowProps: [Object, Function],
    cellProps: [Object, Function],
    returnObject: Boolean
  }, "DataTable-items");
  function transformItem4(props, item, index, columns) {
    const value = props.returnObject ? item : getPropertyFromItem(item, props.itemValue);
    const selectable = getPropertyFromItem(item, props.itemSelectable, true);
    const itemColumns = columns.reduce((obj, column) => {
      if (column.key != null)
        obj[column.key] = getPropertyFromItem(item, column.value);
      return obj;
    }, {});
    return {
      type: "item",
      key: props.returnObject ? getPropertyFromItem(item, props.itemValue) : value,
      index,
      value,
      selectable,
      columns: itemColumns,
      raw: item
    };
  }
  function transformItems4(props, items, columns) {
    return items.map((item, index) => transformItem4(props, item, index, columns));
  }
  function useDataTableItems(props, columns) {
    const items = computed2(() => transformItems4(props, props.items, columns.value));
    return {
      items
    };
  }

  // ../posawesome/node_modules/vuetify/lib/components/VDataTable/VDataTable.js
  var makeDataTableProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadProps(__spreadValues({}, makeVDataTableRowsProps()), {
    hideDefaultBody: Boolean,
    hideDefaultFooter: Boolean,
    hideDefaultHeader: Boolean,
    width: [String, Number],
    search: String
  }), makeDataTableExpandProps()), makeDataTableGroupProps()), makeDataTableHeaderProps()), makeDataTableItemsProps()), makeDataTableSelectProps()), makeDataTableSortProps()), makeVDataTableHeadersProps()), makeVTableProps()), "DataTable");
  var makeVDataTableProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, makeDataTablePaginateProps()), makeDataTableProps()), makeFilterProps()), makeVDataTableFooterProps()), "VDataTable");
  var VDataTable = genericComponent()({
    name: "VDataTable",
    props: makeVDataTableProps(),
    emits: {
      "update:modelValue": (value) => true,
      "update:page": (value) => true,
      "update:itemsPerPage": (value) => true,
      "update:sortBy": (value) => true,
      "update:options": (value) => true,
      "update:groupBy": (value) => true,
      "update:expanded": (value) => true,
      "update:currentItems": (value) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const {
        groupBy
      } = createGroupBy(props);
      const {
        sortBy,
        multiSort,
        mustSort
      } = createSort(props);
      const {
        page,
        itemsPerPage
      } = createPagination(props);
      const {
        disableSort
      } = toRefs(props);
      const {
        columns,
        headers,
        sortFunctions,
        sortRawFunctions,
        filterFunctions
      } = createHeaders(props, {
        groupBy,
        showSelect: toRef(() => props.showSelect),
        showExpand: toRef(() => props.showExpand)
      });
      const {
        items
      } = useDataTableItems(props, columns);
      const search = toRef(() => props.search);
      const {
        filteredItems
      } = useFilter(props, items, search, {
        transform: (item) => item.columns,
        customKeyFilter: filterFunctions
      });
      const {
        toggleSort
      } = provideSort({
        sortBy,
        multiSort,
        mustSort,
        page
      });
      const {
        sortByWithGroups,
        opened,
        extractRows,
        isGroupOpen,
        toggleGroup
      } = provideGroupBy({
        groupBy,
        sortBy,
        disableSort
      });
      const {
        sortedItems
      } = useSortedItems(props, filteredItems, sortByWithGroups, {
        transform: (item) => __spreadValues(__spreadValues({}, item.raw), item.columns),
        sortFunctions,
        sortRawFunctions
      });
      const {
        flatItems
      } = useGroupedItems(sortedItems, groupBy, opened);
      const itemsLength = computed2(() => flatItems.value.length);
      const {
        startIndex,
        stopIndex,
        pageCount,
        setItemsPerPage
      } = providePagination({
        page,
        itemsPerPage,
        itemsLength
      });
      const {
        paginatedItems
      } = usePaginatedItems({
        items: flatItems,
        startIndex,
        stopIndex,
        itemsPerPage
      });
      const paginatedItemsWithoutGroups = computed2(() => extractRows(paginatedItems.value));
      const {
        isSelected,
        select,
        selectAll,
        toggleSelect,
        someSelected,
        allSelected
      } = provideSelection(props, {
        allItems: items,
        currentPage: paginatedItemsWithoutGroups
      });
      const {
        isExpanded,
        toggleExpand
      } = provideExpanded(props);
      useOptions({
        page,
        itemsPerPage,
        sortBy,
        groupBy,
        search
      });
      provideDefaults({
        VDataTableRows: {
          hideNoData: toRef(() => props.hideNoData),
          noDataText: toRef(() => props.noDataText),
          loading: toRef(() => props.loading),
          loadingText: toRef(() => props.loadingText)
        }
      });
      const slotProps = computed2(() => ({
        page: page.value,
        itemsPerPage: itemsPerPage.value,
        sortBy: sortBy.value,
        pageCount: pageCount.value,
        toggleSort,
        setItemsPerPage,
        someSelected: someSelected.value,
        allSelected: allSelected.value,
        isSelected,
        select,
        selectAll,
        toggleSelect,
        isExpanded,
        toggleExpand,
        isGroupOpen,
        toggleGroup,
        items: paginatedItemsWithoutGroups.value.map((item) => item.raw),
        internalItems: paginatedItemsWithoutGroups.value,
        groupedItems: paginatedItems.value,
        columns: columns.value,
        headers: headers.value
      }));
      useRender(() => {
        const dataTableFooterProps = VDataTableFooter.filterProps(props);
        const dataTableHeadersProps = VDataTableHeaders.filterProps(props);
        const dataTableRowsProps = VDataTableRows.filterProps(props);
        const tableProps = VTable.filterProps(props);
        return createVNode(VTable, mergeProps({
          "class": ["v-data-table", {
            "v-data-table--show-select": props.showSelect,
            "v-data-table--loading": props.loading
          }, props.class],
          "style": props.style
        }, tableProps, {
          "fixedHeader": props.fixedHeader || props.sticky
        }), {
          top: () => {
            var _a3;
            return (_a3 = slots.top) == null ? void 0 : _a3.call(slots, slotProps.value);
          },
          default: () => {
            var _a3, _b, _c, _d, _e, _f;
            return slots.default ? slots.default(slotProps.value) : createBaseVNode(Fragment, null, [(_a3 = slots.colgroup) == null ? void 0 : _a3.call(slots, slotProps.value), !props.hideDefaultHeader && createBaseVNode("thead", {
              "key": "thead"
            }, [createVNode(VDataTableHeaders, dataTableHeadersProps, slots)]), (_b = slots.thead) == null ? void 0 : _b.call(slots, slotProps.value), !props.hideDefaultBody && createBaseVNode("tbody", null, [(_c = slots["body.prepend"]) == null ? void 0 : _c.call(slots, slotProps.value), slots.body ? slots.body(slotProps.value) : createVNode(VDataTableRows, mergeProps(attrs, dataTableRowsProps, {
              "items": paginatedItems.value
            }), slots), (_d = slots["body.append"]) == null ? void 0 : _d.call(slots, slotProps.value)]), (_e = slots.tbody) == null ? void 0 : _e.call(slots, slotProps.value), (_f = slots.tfoot) == null ? void 0 : _f.call(slots, slotProps.value)]);
          },
          bottom: () => slots.bottom ? slots.bottom(slotProps.value) : !props.hideDefaultFooter && createBaseVNode(Fragment, null, [createVNode(VDivider, null, null), createVNode(VDataTableFooter, dataTableFooterProps, {
            prepend: slots["footer.prepend"]
          })])
        });
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VDataTable/VDataTableVirtual.js
  var makeVDataTableVirtualProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, omit(makeDataTableProps(), ["hideDefaultFooter"])), makeDataTableGroupProps()), makeVirtualProps()), makeFilterProps()), "VDataTableVirtual");
  var VDataTableVirtual = genericComponent()({
    name: "VDataTableVirtual",
    props: makeVDataTableVirtualProps(),
    emits: {
      "update:modelValue": (value) => true,
      "update:sortBy": (value) => true,
      "update:options": (value) => true,
      "update:groupBy": (value) => true,
      "update:expanded": (value) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const {
        groupBy
      } = createGroupBy(props);
      const {
        sortBy,
        multiSort,
        mustSort
      } = createSort(props);
      const {
        disableSort
      } = toRefs(props);
      const {
        columns,
        headers,
        filterFunctions,
        sortFunctions,
        sortRawFunctions
      } = createHeaders(props, {
        groupBy,
        showSelect: toRef(() => props.showSelect),
        showExpand: toRef(() => props.showExpand)
      });
      const {
        items
      } = useDataTableItems(props, columns);
      const search = toRef(() => props.search);
      const {
        filteredItems
      } = useFilter(props, items, search, {
        transform: (item) => item.columns,
        customKeyFilter: filterFunctions
      });
      const {
        toggleSort
      } = provideSort({
        sortBy,
        multiSort,
        mustSort
      });
      const {
        sortByWithGroups,
        opened,
        extractRows,
        isGroupOpen,
        toggleGroup
      } = provideGroupBy({
        groupBy,
        sortBy,
        disableSort
      });
      const {
        sortedItems
      } = useSortedItems(props, filteredItems, sortByWithGroups, {
        transform: (item) => __spreadValues(__spreadValues({}, item.raw), item.columns),
        sortFunctions,
        sortRawFunctions
      });
      const {
        flatItems
      } = useGroupedItems(sortedItems, groupBy, opened);
      const allItems = computed2(() => extractRows(flatItems.value));
      const {
        isSelected,
        select,
        selectAll,
        toggleSelect,
        someSelected,
        allSelected
      } = provideSelection(props, {
        allItems,
        currentPage: allItems
      });
      const {
        isExpanded,
        toggleExpand
      } = provideExpanded(props);
      const {
        containerRef,
        markerRef,
        paddingTop,
        paddingBottom,
        computedItems,
        handleItemResize,
        handleScroll,
        handleScrollend,
        calculateVisibleItems,
        scrollToIndex
      } = useVirtual(props, flatItems);
      const displayItems = computed2(() => computedItems.value.map((item) => item.raw));
      useOptions({
        sortBy,
        page: shallowRef(1),
        itemsPerPage: shallowRef(-1),
        groupBy,
        search
      });
      provideDefaults({
        VDataTableRows: {
          hideNoData: toRef(() => props.hideNoData),
          noDataText: toRef(() => props.noDataText),
          loading: toRef(() => props.loading),
          loadingText: toRef(() => props.loadingText)
        }
      });
      const slotProps = computed2(() => ({
        sortBy: sortBy.value,
        toggleSort,
        someSelected: someSelected.value,
        allSelected: allSelected.value,
        isSelected,
        select,
        selectAll,
        toggleSelect,
        isExpanded,
        toggleExpand,
        isGroupOpen,
        toggleGroup,
        items: allItems.value.map((item) => item.raw),
        internalItems: allItems.value,
        groupedItems: flatItems.value,
        columns: columns.value,
        headers: headers.value
      }));
      useRender(() => {
        const dataTableHeadersProps = VDataTableHeaders.filterProps(props);
        const dataTableRowsProps = VDataTableRows.filterProps(props);
        const tableProps = VTable.filterProps(props);
        return createVNode(VTable, mergeProps({
          "class": ["v-data-table", {
            "v-data-table--loading": props.loading
          }, props.class],
          "style": props.style
        }, tableProps, {
          "fixedHeader": props.fixedHeader || props.sticky
        }), {
          top: () => {
            var _a3;
            return (_a3 = slots.top) == null ? void 0 : _a3.call(slots, slotProps.value);
          },
          wrapper: () => {
            var _a3, _b, _c, _d, _e, _f;
            return createBaseVNode("div", {
              "ref": containerRef,
              "onScrollPassive": handleScroll,
              "onScrollend": handleScrollend,
              "class": "v-table__wrapper",
              "style": {
                height: convertToUnit(props.height)
              }
            }, [createBaseVNode("table", null, [(_a3 = slots.colgroup) == null ? void 0 : _a3.call(slots, slotProps.value), !props.hideDefaultHeader && createBaseVNode("thead", {
              "key": "thead"
            }, [createVNode(VDataTableHeaders, dataTableHeadersProps, slots)]), (_b = slots.thead) == null ? void 0 : _b.call(slots, slotProps.value), !props.hideDefaultBody && createBaseVNode("tbody", {
              "key": "tbody"
            }, [createBaseVNode("tr", {
              "ref": markerRef,
              "style": {
                height: convertToUnit(paddingTop.value),
                border: 0
              }
            }, [createBaseVNode("td", {
              "colspan": columns.value.length,
              "style": {
                height: 0,
                border: 0
              }
            }, null)]), (_c = slots["body.prepend"]) == null ? void 0 : _c.call(slots, slotProps.value), createVNode(VDataTableRows, mergeProps(attrs, dataTableRowsProps, {
              "items": displayItems.value
            }), __spreadProps(__spreadValues({}, slots), {
              item: (itemSlotProps) => createVNode(VVirtualScrollItem, {
                "key": itemSlotProps.internalItem.index,
                "renderless": true,
                "onUpdate:height": (height) => handleItemResize(itemSlotProps.internalItem.index, height)
              }, {
                default: (_ref2) => {
                  var _a4, _b2;
                  let {
                    itemRef
                  } = _ref2;
                  return (_b2 = (_a4 = slots.item) == null ? void 0 : _a4.call(slots, __spreadProps(__spreadValues({}, itemSlotProps), {
                    itemRef
                  }))) != null ? _b2 : createVNode(VDataTableRow, mergeProps(itemSlotProps.props, {
                    "ref": itemRef,
                    "key": itemSlotProps.internalItem.index,
                    "index": itemSlotProps.internalItem.index
                  }), slots);
                }
              })
            })), (_d = slots["body.append"]) == null ? void 0 : _d.call(slots, slotProps.value), createBaseVNode("tr", {
              "style": {
                height: convertToUnit(paddingBottom.value),
                border: 0
              }
            }, [createBaseVNode("td", {
              "colspan": columns.value.length,
              "style": {
                height: 0,
                border: 0
              }
            }, null)])]), (_e = slots.tbody) == null ? void 0 : _e.call(slots, slotProps.value), (_f = slots.tfoot) == null ? void 0 : _f.call(slots, slotProps.value)])]);
          },
          bottom: () => {
            var _a3;
            return (_a3 = slots.bottom) == null ? void 0 : _a3.call(slots, slotProps.value);
          }
        });
      });
      return {
        calculateVisibleItems,
        scrollToIndex
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VDataTable/VDataTableServer.js
  var makeVDataTableServerProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({
    itemsLength: {
      type: [Number, String],
      required: true
    }
  }, makeDataTablePaginateProps()), makeDataTableProps()), makeVDataTableFooterProps()), "VDataTableServer");
  var VDataTableServer = genericComponent()({
    name: "VDataTableServer",
    props: makeVDataTableServerProps(),
    emits: {
      "update:modelValue": (value) => true,
      "update:page": (page) => true,
      "update:itemsPerPage": (page) => true,
      "update:sortBy": (sortBy) => true,
      "update:options": (options) => true,
      "update:expanded": (options) => true,
      "update:groupBy": (value) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const {
        groupBy
      } = createGroupBy(props);
      const {
        sortBy,
        multiSort,
        mustSort
      } = createSort(props);
      const {
        page,
        itemsPerPage
      } = createPagination(props);
      const {
        disableSort
      } = toRefs(props);
      const itemsLength = computed2(() => parseInt(props.itemsLength, 10));
      const {
        columns,
        headers
      } = createHeaders(props, {
        groupBy,
        showSelect: toRef(() => props.showSelect),
        showExpand: toRef(() => props.showExpand)
      });
      const {
        items
      } = useDataTableItems(props, columns);
      const {
        toggleSort
      } = provideSort({
        sortBy,
        multiSort,
        mustSort,
        page
      });
      const {
        opened,
        isGroupOpen,
        toggleGroup,
        extractRows
      } = provideGroupBy({
        groupBy,
        sortBy,
        disableSort
      });
      const {
        pageCount,
        setItemsPerPage
      } = providePagination({
        page,
        itemsPerPage,
        itemsLength
      });
      const {
        flatItems
      } = useGroupedItems(items, groupBy, opened);
      const {
        isSelected,
        select,
        selectAll,
        toggleSelect,
        someSelected,
        allSelected
      } = provideSelection(props, {
        allItems: items,
        currentPage: items
      });
      const {
        isExpanded,
        toggleExpand
      } = provideExpanded(props);
      const itemsWithoutGroups = computed2(() => extractRows(items.value));
      useOptions({
        page,
        itemsPerPage,
        sortBy,
        groupBy,
        search: toRef(() => props.search)
      });
      provide("v-data-table", {
        toggleSort,
        sortBy
      });
      provideDefaults({
        VDataTableRows: {
          hideNoData: toRef(() => props.hideNoData),
          noDataText: toRef(() => props.noDataText),
          loading: toRef(() => props.loading),
          loadingText: toRef(() => props.loadingText)
        }
      });
      const slotProps = computed2(() => ({
        page: page.value,
        itemsPerPage: itemsPerPage.value,
        sortBy: sortBy.value,
        pageCount: pageCount.value,
        toggleSort,
        setItemsPerPage,
        someSelected: someSelected.value,
        allSelected: allSelected.value,
        isSelected,
        select,
        selectAll,
        toggleSelect,
        isExpanded,
        toggleExpand,
        isGroupOpen,
        toggleGroup,
        items: itemsWithoutGroups.value.map((item) => item.raw),
        internalItems: itemsWithoutGroups.value,
        groupedItems: flatItems.value,
        columns: columns.value,
        headers: headers.value
      }));
      useRender(() => {
        const dataTableFooterProps = VDataTableFooter.filterProps(props);
        const dataTableHeadersProps = VDataTableHeaders.filterProps(props);
        const dataTableRowsProps = VDataTableRows.filterProps(props);
        const tableProps = VTable.filterProps(props);
        return createVNode(VTable, mergeProps({
          "class": ["v-data-table", {
            "v-data-table--loading": props.loading
          }, props.class],
          "style": props.style
        }, tableProps, {
          "fixedHeader": props.fixedHeader || props.sticky
        }), {
          top: () => {
            var _a3;
            return (_a3 = slots.top) == null ? void 0 : _a3.call(slots, slotProps.value);
          },
          default: () => {
            var _a3, _b, _c, _d, _e, _f;
            return slots.default ? slots.default(slotProps.value) : createBaseVNode(Fragment, null, [(_a3 = slots.colgroup) == null ? void 0 : _a3.call(slots, slotProps.value), !props.hideDefaultHeader && createBaseVNode("thead", {
              "key": "thead",
              "class": "v-data-table__thead",
              "role": "rowgroup"
            }, [createVNode(VDataTableHeaders, dataTableHeadersProps, slots)]), (_b = slots.thead) == null ? void 0 : _b.call(slots, slotProps.value), !props.hideDefaultBody && createBaseVNode("tbody", {
              "class": "v-data-table__tbody",
              "role": "rowgroup"
            }, [(_c = slots["body.prepend"]) == null ? void 0 : _c.call(slots, slotProps.value), slots.body ? slots.body(slotProps.value) : createVNode(VDataTableRows, mergeProps(attrs, dataTableRowsProps, {
              "items": flatItems.value
            }), slots), (_d = slots["body.append"]) == null ? void 0 : _d.call(slots, slotProps.value)]), (_e = slots.tbody) == null ? void 0 : _e.call(slots, slotProps.value), (_f = slots.tfoot) == null ? void 0 : _f.call(slots, slotProps.value)]);
          },
          bottom: () => slots.bottom ? slots.bottom(slotProps.value) : !props.hideDefaultFooter && createBaseVNode(Fragment, null, [createVNode(VDivider, null, null), createVNode(VDataTableFooter, dataTableFooterProps, {
            prepend: slots["footer.prepend"]
          })])
        });
      });
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VGrid/VContainer.js
  var makeVContainerProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({
    fluid: {
      type: Boolean,
      default: false
    }
  }, makeComponentProps()), makeDimensionProps()), makeTagProps()), "VContainer");
  var VContainer = genericComponent()({
    name: "VContainer",
    props: makeVContainerProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        rtlClasses
      } = useRtl();
      const {
        dimensionStyles
      } = useDimension(props);
      useRender(() => createVNode(props.tag, {
        "class": normalizeClass(["v-container", {
          "v-container--fluid": props.fluid
        }, rtlClasses.value, props.class]),
        "style": normalizeStyle([dimensionStyles.value, props.style])
      }, slots));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VGrid/VCol.js
  var breakpointProps = (() => {
    return breakpoints.reduce((props, val) => {
      props[val] = {
        type: [Boolean, String, Number],
        default: false
      };
      return props;
    }, {});
  })();
  var offsetProps = (() => {
    return breakpoints.reduce((props, val) => {
      const offsetKey = "offset" + capitalize(val);
      props[offsetKey] = {
        type: [String, Number],
        default: null
      };
      return props;
    }, {});
  })();
  var orderProps = (() => {
    return breakpoints.reduce((props, val) => {
      const orderKey = "order" + capitalize(val);
      props[orderKey] = {
        type: [String, Number],
        default: null
      };
      return props;
    }, {});
  })();
  var propMap = {
    col: Object.keys(breakpointProps),
    offset: Object.keys(offsetProps),
    order: Object.keys(orderProps)
  };
  function breakpointClass(type, prop, val) {
    let className = type;
    if (val == null || val === false) {
      return void 0;
    }
    if (prop) {
      const breakpoint = prop.replace(type, "");
      className += `-${breakpoint}`;
    }
    if (type === "col") {
      className = "v-" + className;
    }
    if (type === "col" && (val === "" || val === true)) {
      return className.toLowerCase();
    }
    className += `-${val}`;
    return className.toLowerCase();
  }
  var ALIGN_SELF_VALUES = ["auto", "start", "end", "center", "baseline", "stretch"];
  var makeVColProps = propsFactory(__spreadValues(__spreadValues(__spreadProps(__spreadValues(__spreadProps(__spreadValues(__spreadProps(__spreadValues({
    cols: {
      type: [Boolean, String, Number],
      default: false
    }
  }, breakpointProps), {
    offset: {
      type: [String, Number],
      default: null
    }
  }), offsetProps), {
    order: {
      type: [String, Number],
      default: null
    }
  }), orderProps), {
    alignSelf: {
      type: String,
      default: null,
      validator: (str) => ALIGN_SELF_VALUES.includes(str)
    }
  }), makeComponentProps()), makeTagProps()), "VCol");
  var VCol = genericComponent()({
    name: "VCol",
    props: makeVColProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const classes = computed2(() => {
        const classList = [];
        let type;
        for (type in propMap) {
          propMap[type].forEach((prop) => {
            const value = props[prop];
            const className = breakpointClass(type, prop, value);
            if (className)
              classList.push(className);
          });
        }
        const hasColClasses = classList.some((className) => className.startsWith("v-col-"));
        classList.push({
          "v-col": !hasColClasses || !props.cols,
          [`v-col-${props.cols}`]: props.cols,
          [`offset-${props.offset}`]: props.offset,
          [`order-${props.order}`]: props.order,
          [`align-self-${props.alignSelf}`]: props.alignSelf
        });
        return classList;
      });
      return () => {
        var _a3;
        return h(props.tag, {
          class: [classes.value, props.class],
          style: props.style
        }, (_a3 = slots.default) == null ? void 0 : _a3.call(slots));
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VGrid/VRow.js
  var ALIGNMENT = ["start", "end", "center"];
  var SPACE = ["space-between", "space-around", "space-evenly"];
  function makeRowProps(prefix, def2) {
    return breakpoints.reduce((props, val) => {
      const prefixKey = prefix + capitalize(val);
      props[prefixKey] = def2();
      return props;
    }, {});
  }
  var ALIGN_VALUES = [...ALIGNMENT, "baseline", "stretch"];
  var alignValidator = (str) => ALIGN_VALUES.includes(str);
  var alignProps = makeRowProps("align", () => ({
    type: String,
    default: null,
    validator: alignValidator
  }));
  var JUSTIFY_VALUES = [...ALIGNMENT, ...SPACE];
  var justifyValidator = (str) => JUSTIFY_VALUES.includes(str);
  var justifyProps = makeRowProps("justify", () => ({
    type: String,
    default: null,
    validator: justifyValidator
  }));
  var ALIGN_CONTENT_VALUES = [...ALIGNMENT, ...SPACE, "stretch"];
  var alignContentValidator = (str) => ALIGN_CONTENT_VALUES.includes(str);
  var alignContentProps = makeRowProps("alignContent", () => ({
    type: String,
    default: null,
    validator: alignContentValidator
  }));
  var propMap2 = {
    align: Object.keys(alignProps),
    justify: Object.keys(justifyProps),
    alignContent: Object.keys(alignContentProps)
  };
  var classMap = {
    align: "align",
    justify: "justify",
    alignContent: "align-content"
  };
  function breakpointClass2(type, prop, val) {
    let className = classMap[type];
    if (val == null) {
      return void 0;
    }
    if (prop) {
      const breakpoint = prop.replace(type, "");
      className += `-${breakpoint}`;
    }
    className += `-${val}`;
    return className.toLowerCase();
  }
  var makeVRowProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadProps(__spreadValues(__spreadProps(__spreadValues({
    dense: Boolean,
    noGutters: Boolean,
    align: {
      type: String,
      default: null,
      validator: alignValidator
    }
  }, alignProps), {
    justify: {
      type: String,
      default: null,
      validator: justifyValidator
    }
  }), justifyProps), {
    alignContent: {
      type: String,
      default: null,
      validator: alignContentValidator
    }
  }), alignContentProps), makeComponentProps()), makeTagProps()), "VRow");
  var VRow = genericComponent()({
    name: "VRow",
    props: makeVRowProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const classes = computed2(() => {
        const classList = [];
        let type;
        for (type in propMap2) {
          propMap2[type].forEach((prop) => {
            const value = props[prop];
            const className = breakpointClass2(type, prop, value);
            if (className)
              classList.push(className);
          });
        }
        classList.push({
          "v-row--no-gutters": props.noGutters,
          "v-row--dense": props.dense,
          [`align-${props.align}`]: props.align,
          [`justify-${props.justify}`]: props.justify,
          [`align-content-${props.alignContent}`]: props.alignContent
        });
        return classList;
      });
      return () => {
        var _a3;
        return h(props.tag, {
          class: ["v-row", classes.value, props.class],
          style: props.style
        }, (_a3 = slots.default) == null ? void 0 : _a3.call(slots));
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VGrid/VSpacer.js
  var VSpacer = createSimpleFunctional("v-spacer", "div", "VSpacer");

  // ../posawesome/node_modules/vuetify/lib/components/VDatePicker/VDatePickerControls.js
  var makeVDatePickerControlsProps = propsFactory({
    active: {
      type: [String, Array],
      default: void 0
    },
    controlHeight: [Number, String],
    disabled: {
      type: [Boolean, String, Array],
      default: null
    },
    nextIcon: {
      type: IconValue,
      default: "$next"
    },
    prevIcon: {
      type: IconValue,
      default: "$prev"
    },
    modeIcon: {
      type: IconValue,
      default: "$subgroup"
    },
    text: String,
    viewMode: {
      type: String,
      default: "month"
    }
  }, "VDatePickerControls");
  var VDatePickerControls = genericComponent()({
    name: "VDatePickerControls",
    props: makeVDatePickerControlsProps(),
    emits: {
      "click:year": () => true,
      "click:month": () => true,
      "click:prev": () => true,
      "click:next": () => true,
      "click:text": () => true
    },
    setup(props, _ref) {
      let {
        emit: emit2
      } = _ref;
      const disableMonth = computed2(() => {
        return Array.isArray(props.disabled) ? props.disabled.includes("text") : !!props.disabled;
      });
      const disableYear = computed2(() => {
        return Array.isArray(props.disabled) ? props.disabled.includes("mode") : !!props.disabled;
      });
      const disablePrev = computed2(() => {
        return Array.isArray(props.disabled) ? props.disabled.includes("prev") : !!props.disabled;
      });
      const disableNext = computed2(() => {
        return Array.isArray(props.disabled) ? props.disabled.includes("next") : !!props.disabled;
      });
      function onClickPrev() {
        emit2("click:prev");
      }
      function onClickNext() {
        emit2("click:next");
      }
      function onClickYear() {
        emit2("click:year");
      }
      function onClickMonth() {
        emit2("click:month");
      }
      useRender(() => {
        return createBaseVNode("div", {
          "class": normalizeClass(["v-date-picker-controls"]),
          "style": {
            "--v-date-picker-controls-height": convertToUnit(props.controlHeight)
          }
        }, [createVNode(VBtn, {
          "class": "v-date-picker-controls__month-btn",
          "data-testid": "month-btn",
          "disabled": disableMonth.value,
          "text": props.text,
          "variant": "text",
          "rounded": true,
          "onClick": onClickMonth
        }, null), createVNode(VBtn, {
          "class": "v-date-picker-controls__mode-btn",
          "data-testid": "year-btn",
          "disabled": disableYear.value,
          "density": "comfortable",
          "icon": props.modeIcon,
          "variant": "text",
          "onClick": onClickYear
        }, null), createVNode(VSpacer, null, null), createBaseVNode("div", {
          "class": "v-date-picker-controls__month"
        }, [createVNode(VBtn, {
          "data-testid": "prev-month",
          "disabled": disablePrev.value,
          "density": "comfortable",
          "icon": props.prevIcon,
          "variant": "text",
          "onClick": onClickPrev
        }, null), createVNode(VBtn, {
          "data-testid": "next-month",
          "disabled": disableNext.value,
          "icon": props.nextIcon,
          "density": "comfortable",
          "variant": "text",
          "onClick": onClickNext
        }, null)])]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VDatePicker/VDatePickerHeader.js
  var makeVDatePickerHeaderProps = propsFactory({
    appendIcon: IconValue,
    color: String,
    header: String,
    transition: String,
    onClick: EventProp()
  }, "VDatePickerHeader");
  var VDatePickerHeader = genericComponent()({
    name: "VDatePickerHeader",
    props: makeVDatePickerHeaderProps(),
    emits: {
      click: () => true,
      "click:append": () => true
    },
    setup(props, _ref) {
      let {
        emit: emit2,
        slots
      } = _ref;
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(() => props.color);
      function onClick() {
        emit2("click");
      }
      function onClickAppend() {
        emit2("click:append");
      }
      useRender(() => {
        const hasContent = !!(slots.default || props.header);
        const hasAppend = !!(slots.append || props.appendIcon);
        return createBaseVNode("div", {
          "class": normalizeClass(["v-date-picker-header", {
            "v-date-picker-header--clickable": !!props.onClick
          }, backgroundColorClasses.value]),
          "style": normalizeStyle(backgroundColorStyles.value),
          "onClick": onClick
        }, [slots.prepend && createBaseVNode("div", {
          "key": "prepend",
          "class": "v-date-picker-header__prepend"
        }, [slots.prepend()]), hasContent && createVNode(MaybeTransition, {
          "key": "content",
          "name": props.transition
        }, {
          default: () => {
            var _a3, _b;
            return [createBaseVNode("div", {
              "key": props.header,
              "class": "v-date-picker-header__content"
            }, [(_b = (_a3 = slots.default) == null ? void 0 : _a3.call(slots)) != null ? _b : props.header])];
          }
        }), hasAppend && createBaseVNode("div", {
          "class": "v-date-picker-header__append"
        }, [!slots.append ? createVNode(VBtn, {
          "key": "append-btn",
          "icon": props.appendIcon,
          "variant": "text",
          "onClick": onClickAppend
        }, null) : createVNode(VDefaultsProvider, {
          "key": "append-defaults",
          "disabled": !props.appendIcon,
          "defaults": {
            VBtn: {
              icon: props.appendIcon,
              variant: "text"
            }
          }
        }, {
          default: () => {
            var _a3;
            return [(_a3 = slots.append) == null ? void 0 : _a3.call(slots)];
          }
        })])]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/composables/calendar.js
  var makeCalendarProps = propsFactory({
    allowedDates: [Array, Function],
    disabled: {
      type: Boolean,
      default: null
    },
    displayValue: null,
    modelValue: Array,
    month: [Number, String],
    max: null,
    min: null,
    showAdjacentMonths: Boolean,
    year: [Number, String],
    weekdays: {
      type: Array,
      default: () => [0, 1, 2, 3, 4, 5, 6]
    },
    weeksInMonth: {
      type: String,
      default: "dynamic"
    },
    firstDayOfWeek: {
      type: [Number, String],
      default: void 0
    }
  }, "calendar");
  function useCalendar(props) {
    const adapter = useDate();
    const model = useProxiedModel(props, "modelValue", [], (v) => wrapInArray(v).map((i) => adapter.date(i)));
    const displayValue = computed2(() => {
      if (props.displayValue)
        return adapter.date(props.displayValue);
      if (model.value.length > 0)
        return adapter.date(model.value[0]);
      if (props.min)
        return adapter.date(props.min);
      if (Array.isArray(props.allowedDates))
        return adapter.date(props.allowedDates[0]);
      return adapter.date();
    });
    const year = useProxiedModel(props, "year", void 0, (v) => {
      const value = v != null ? Number(v) : adapter.getYear(displayValue.value);
      return adapter.startOfYear(adapter.setYear(adapter.date(), value));
    }, (v) => adapter.getYear(v));
    const month = useProxiedModel(props, "month", void 0, (v) => {
      const value = v != null ? Number(v) : adapter.getMonth(displayValue.value);
      const date2 = adapter.setYear(adapter.startOfMonth(adapter.date()), adapter.getYear(year.value));
      return adapter.setMonth(date2, value);
    }, (v) => adapter.getMonth(v));
    const weekDays = computed2(() => {
      const firstDayOfWeek = adapter.toJsDate(adapter.startOfWeek(adapter.date(), props.firstDayOfWeek)).getDay();
      return [0, 1, 2, 3, 4, 5, 6].map((day) => (day + firstDayOfWeek) % 7);
    });
    const weeksInMonth = computed2(() => {
      const weeks = adapter.getWeekArray(month.value, props.firstDayOfWeek);
      const days = weeks.flat();
      const daysInMonth2 = 6 * 7;
      if (props.weeksInMonth === "static" && days.length < daysInMonth2) {
        const lastDay = days[days.length - 1];
        let week = [];
        for (let day = 1; day <= daysInMonth2 - days.length; day++) {
          week.push(adapter.addDays(lastDay, day));
          if (day % 7 === 0) {
            weeks.push(week);
            week = [];
          }
        }
      }
      return weeks;
    });
    function genDays(days, today) {
      return days.filter((date2) => {
        return weekDays.value.includes(adapter.toJsDate(date2).getDay());
      }).map((date2, index) => {
        const isoDate = adapter.toISO(date2);
        const isAdjacent = !adapter.isSameMonth(date2, month.value);
        const isStart = adapter.isSameDay(date2, adapter.startOfMonth(month.value));
        const isEnd = adapter.isSameDay(date2, adapter.endOfMonth(month.value));
        const isSame = adapter.isSameDay(date2, month.value);
        return {
          date: date2,
          formatted: adapter.format(date2, "keyboardDate"),
          isAdjacent,
          isDisabled: isDisabled(date2),
          isEnd,
          isHidden: isAdjacent && !props.showAdjacentMonths,
          isSame,
          isSelected: model.value.some((value) => adapter.isSameDay(date2, value)),
          isStart,
          isToday: adapter.isSameDay(date2, today),
          isWeekEnd: index % 7 === 6,
          isWeekStart: index % 7 === 0,
          isoDate,
          localized: adapter.format(date2, "dayOfMonth"),
          month: adapter.getMonth(date2),
          year: adapter.getYear(date2)
        };
      });
    }
    const daysInWeek = computed2(() => {
      const lastDay = adapter.startOfWeek(displayValue.value, props.firstDayOfWeek);
      const week = [];
      for (let day = 0; day <= 6; day++) {
        week.push(adapter.addDays(lastDay, day));
      }
      const today = adapter.date();
      return genDays(week, today);
    });
    const daysInMonth = computed2(() => {
      const days = weeksInMonth.value.flat();
      const today = adapter.date();
      return genDays(days, today);
    });
    const weekNumbers = computed2(() => {
      return weeksInMonth.value.map((week) => {
        return week.length ? adapter.getWeek(week[0], props.firstDayOfWeek) : null;
      });
    });
    function isDisabled(value) {
      if (props.disabled)
        return true;
      const date2 = adapter.date(value);
      if (props.min && adapter.isAfter(adapter.date(props.min), date2))
        return true;
      if (props.max && adapter.isAfter(date2, adapter.date(props.max)))
        return true;
      if (Array.isArray(props.allowedDates) && props.allowedDates.length > 0) {
        return !props.allowedDates.some((d) => adapter.isSameDay(adapter.date(d), date2));
      }
      if (typeof props.allowedDates === "function") {
        return !props.allowedDates(date2);
      }
      return !props.weekdays.includes(adapter.toJsDate(date2).getDay());
    }
    return {
      displayValue,
      daysInMonth,
      daysInWeek,
      genDays,
      model,
      weeksInMonth,
      weekDays,
      weekNumbers
    };
  }

  // ../posawesome/node_modules/vuetify/lib/components/VDatePicker/VDatePickerMonth.js
  var makeVDatePickerMonthProps = propsFactory(__spreadValues({
    color: String,
    hideWeekdays: Boolean,
    multiple: [Boolean, Number, String],
    showWeek: Boolean,
    transition: {
      type: String,
      default: "picker-transition"
    },
    reverseTransition: {
      type: String,
      default: "picker-reverse-transition"
    }
  }, omit(makeCalendarProps(), ["displayValue"])), "VDatePickerMonth");
  var VDatePickerMonth = genericComponent()({
    name: "VDatePickerMonth",
    props: makeVDatePickerMonthProps(),
    emits: {
      "update:modelValue": (date2) => true,
      "update:month": (date2) => true,
      "update:year": (date2) => true
    },
    setup(props, _ref) {
      let {
        emit: emit2,
        slots
      } = _ref;
      const daysRef = ref();
      const {
        daysInMonth,
        model,
        weekNumbers
      } = useCalendar(props);
      const adapter = useDate();
      const rangeStart = shallowRef();
      const rangeStop = shallowRef();
      const isReverse = shallowRef(false);
      const transition = toRef(() => {
        return !isReverse.value ? props.transition : props.reverseTransition;
      });
      if (props.multiple === "range" && model.value.length > 0) {
        rangeStart.value = model.value[0];
        if (model.value.length > 1) {
          rangeStop.value = model.value[model.value.length - 1];
        }
      }
      const atMax = computed2(() => {
        const max = ["number", "string"].includes(typeof props.multiple) ? Number(props.multiple) : Infinity;
        return model.value.length >= max;
      });
      watch2(daysInMonth, (val, oldVal) => {
        if (!oldVal)
          return;
        isReverse.value = adapter.isBefore(val[0].date, oldVal[0].date);
      });
      function onRangeClick(value) {
        const _value = adapter.startOfDay(value);
        if (model.value.length === 0) {
          rangeStart.value = void 0;
        } else if (model.value.length === 1) {
          rangeStart.value = model.value[0];
          rangeStop.value = void 0;
        }
        if (!rangeStart.value) {
          rangeStart.value = _value;
          model.value = [rangeStart.value];
        } else if (!rangeStop.value) {
          if (adapter.isSameDay(_value, rangeStart.value)) {
            rangeStart.value = void 0;
            model.value = [];
            return;
          } else if (adapter.isBefore(_value, rangeStart.value)) {
            rangeStop.value = adapter.endOfDay(rangeStart.value);
            rangeStart.value = _value;
          } else {
            rangeStop.value = adapter.endOfDay(_value);
          }
          model.value = createDateRange(adapter, rangeStart.value, rangeStop.value);
        } else {
          rangeStart.value = value;
          rangeStop.value = void 0;
          model.value = [rangeStart.value];
        }
      }
      function onMultipleClick(value) {
        const index = model.value.findIndex((selection) => adapter.isSameDay(selection, value));
        if (index === -1) {
          model.value = [...model.value, value];
        } else {
          const value2 = [...model.value];
          value2.splice(index, 1);
          model.value = value2;
        }
      }
      function onClick(value) {
        if (props.multiple === "range") {
          onRangeClick(value);
        } else if (props.multiple) {
          onMultipleClick(value);
        } else {
          model.value = [value];
        }
      }
      useRender(() => createBaseVNode("div", {
        "class": "v-date-picker-month"
      }, [props.showWeek && createBaseVNode("div", {
        "key": "weeks",
        "class": "v-date-picker-month__weeks"
      }, [!props.hideWeekdays && createBaseVNode("div", {
        "key": "hide-week-days",
        "class": "v-date-picker-month__day"
      }, [createTextVNode("\xA0")]), weekNumbers.value.map((week) => createBaseVNode("div", {
        "class": normalizeClass(["v-date-picker-month__day", "v-date-picker-month__day--adjacent"])
      }, [week]))]), createVNode(MaybeTransition, {
        "name": transition.value
      }, {
        default: () => {
          var _a3;
          return [createBaseVNode("div", {
            "ref": daysRef,
            "key": (_a3 = daysInMonth.value[0].date) == null ? void 0 : _a3.toString(),
            "class": "v-date-picker-month__days"
          }, [!props.hideWeekdays && adapter.getWeekdays(props.firstDayOfWeek).map((weekDay) => createBaseVNode("div", {
            "class": normalizeClass(["v-date-picker-month__day", "v-date-picker-month__weekday"])
          }, [weekDay])), daysInMonth.value.map((item, i) => {
            var _a4, _b;
            const slotProps = {
              props: {
                class: "v-date-picker-month__day-btn",
                color: item.isSelected || item.isToday ? props.color : void 0,
                disabled: item.isDisabled,
                icon: true,
                ripple: false,
                text: item.localized,
                variant: item.isSelected ? "flat" : item.isToday ? "outlined" : "text",
                onClick: () => onClick(item.date)
              },
              item,
              i
            };
            if (atMax.value && !item.isSelected) {
              item.isDisabled = true;
            }
            return createBaseVNode("div", {
              "class": normalizeClass(["v-date-picker-month__day", {
                "v-date-picker-month__day--adjacent": item.isAdjacent,
                "v-date-picker-month__day--hide-adjacent": item.isHidden,
                "v-date-picker-month__day--selected": item.isSelected,
                "v-date-picker-month__day--week-end": item.isWeekEnd,
                "v-date-picker-month__day--week-start": item.isWeekStart
              }]),
              "data-v-date": !item.isDisabled ? item.isoDate : void 0
            }, [(props.showAdjacentMonths || !item.isAdjacent) && ((_b = (_a4 = slots.day) == null ? void 0 : _a4.call(slots, slotProps)) != null ? _b : createVNode(VBtn, slotProps.props, null))]);
          })])];
        }
      })]));
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VDatePicker/VDatePickerMonths.js
  var makeVDatePickerMonthsProps = propsFactory({
    color: String,
    height: [String, Number],
    min: null,
    max: null,
    modelValue: Number,
    year: Number,
    allowedMonths: [Array, Function]
  }, "VDatePickerMonths");
  var VDatePickerMonths = genericComponent()({
    name: "VDatePickerMonths",
    props: makeVDatePickerMonthsProps(),
    emits: {
      "update:modelValue": (date2) => true
    },
    setup(props, _ref) {
      let {
        emit: emit2,
        slots
      } = _ref;
      const adapter = useDate();
      const model = useProxiedModel(props, "modelValue");
      const months = computed2(() => {
        let date2 = adapter.startOfYear(adapter.date());
        if (props.year) {
          date2 = adapter.setYear(date2, props.year);
        }
        return createRange(12).map((i) => {
          const text = adapter.format(date2, "monthShort");
          const isDisabled = !!(!isMonthAllowed(i) || props.min && adapter.isAfter(adapter.startOfMonth(adapter.date(props.min)), date2) || props.max && adapter.isAfter(date2, adapter.startOfMonth(adapter.date(props.max))));
          date2 = adapter.getNextMonth(date2);
          return {
            isDisabled,
            text,
            value: i
          };
        });
      });
      watchEffect(() => {
        var _a3;
        model.value = (_a3 = model.value) != null ? _a3 : adapter.getMonth(adapter.date());
      });
      function isMonthAllowed(month) {
        if (Array.isArray(props.allowedMonths) && props.allowedMonths.length) {
          return props.allowedMonths.includes(month);
        }
        if (typeof props.allowedMonths === "function") {
          return props.allowedMonths(month);
        }
        return true;
      }
      useRender(() => createBaseVNode("div", {
        "class": "v-date-picker-months",
        "style": {
          height: convertToUnit(props.height)
        }
      }, [createBaseVNode("div", {
        "class": "v-date-picker-months__content"
      }, [months.value.map((month, i) => {
        var _a3, _b;
        const btnProps = {
          active: model.value === i,
          color: model.value === i ? props.color : void 0,
          disabled: month.isDisabled,
          rounded: true,
          text: month.text,
          variant: model.value === month.value ? "flat" : "text",
          onClick: () => onClick(i)
        };
        function onClick(i2) {
          if (model.value === i2) {
            emit2("update:modelValue", model.value);
            return;
          }
          model.value = i2;
        }
        return (_b = (_a3 = slots.month) == null ? void 0 : _a3.call(slots, {
          month,
          i,
          props: btnProps
        })) != null ? _b : createVNode(VBtn, mergeProps({
          "key": "month"
        }, btnProps), null);
      })])]));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VDatePicker/VDatePickerYears.js
  var makeVDatePickerYearsProps = propsFactory({
    color: String,
    height: [String, Number],
    min: null,
    max: null,
    modelValue: Number,
    allowedYears: [Array, Function]
  }, "VDatePickerYears");
  var VDatePickerYears = genericComponent()({
    name: "VDatePickerYears",
    props: makeVDatePickerYearsProps(),
    emits: {
      "update:modelValue": (year) => true
    },
    setup(props, _ref) {
      let {
        emit: emit2,
        slots
      } = _ref;
      const adapter = useDate();
      const model = useProxiedModel(props, "modelValue");
      const years = computed2(() => {
        const year = adapter.getYear(adapter.date());
        let min = year - 100;
        let max = year + 52;
        if (props.min) {
          min = adapter.getYear(adapter.date(props.min));
        }
        if (props.max) {
          max = adapter.getYear(adapter.date(props.max));
        }
        let date2 = adapter.startOfYear(adapter.date());
        date2 = adapter.setYear(date2, min);
        return createRange(max - min + 1, min).map((i) => {
          const text = adapter.format(date2, "year");
          date2 = adapter.setYear(date2, adapter.getYear(date2) + 1);
          return {
            text,
            value: i,
            isDisabled: !isYearAllowed(i)
          };
        });
      });
      watchEffect(() => {
        var _a3;
        model.value = (_a3 = model.value) != null ? _a3 : adapter.getYear(adapter.date());
      });
      const yearRef = templateRef();
      onMounted(async () => {
        var _a3;
        await nextTick();
        (_a3 = yearRef.el) == null ? void 0 : _a3.focus();
      });
      function isYearAllowed(year) {
        if (Array.isArray(props.allowedYears) && props.allowedYears.length) {
          return props.allowedYears.includes(year);
        }
        if (typeof props.allowedYears === "function") {
          return props.allowedYears(year);
        }
        return true;
      }
      useRender(() => createBaseVNode("div", {
        "class": "v-date-picker-years",
        "style": {
          height: convertToUnit(props.height)
        }
      }, [createBaseVNode("div", {
        "class": "v-date-picker-years__content"
      }, [years.value.map((year, i) => {
        var _a3, _b;
        const btnProps = {
          ref: model.value === year.value ? yearRef : void 0,
          active: model.value === year.value,
          color: model.value === year.value ? props.color : void 0,
          rounded: true,
          text: year.text,
          disabled: year.isDisabled,
          variant: model.value === year.value ? "flat" : "text",
          onClick: () => {
            if (model.value === year.value) {
              emit2("update:modelValue", model.value);
              return;
            }
            model.value = year.value;
          }
        };
        return (_b = (_a3 = slots.year) == null ? void 0 : _a3.call(slots, {
          year,
          i,
          props: btnProps
        })) != null ? _b : createVNode(VBtn, mergeProps({
          "key": "month"
        }, btnProps), null);
      })])]));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VDatePicker/VDatePicker.js
  var makeVDatePickerProps = propsFactory(__spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    header: {
      type: String,
      default: "$vuetify.datePicker.header"
    },
    headerColor: String
  }, makeVDatePickerControlsProps()), makeVDatePickerMonthProps({
    weeksInMonth: "static"
  })), omit(makeVDatePickerMonthsProps(), ["modelValue"])), omit(makeVDatePickerYearsProps(), ["modelValue"])), makeVPickerProps({
    title: "$vuetify.datePicker.title"
  })), {
    modelValue: null
  }), "VDatePicker");
  var VDatePicker = genericComponent()({
    name: "VDatePicker",
    props: makeVDatePickerProps(),
    emits: {
      "update:modelValue": (date2) => true,
      "update:month": (date2) => true,
      "update:year": (date2) => true,
      "update:viewMode": (date2) => true
    },
    setup(props, _ref) {
      let {
        emit: emit2,
        slots
      } = _ref;
      const adapter = useDate();
      const {
        t
      } = useLocale();
      const {
        rtlClasses
      } = useRtl();
      const model = useProxiedModel(props, "modelValue", void 0, (v) => wrapInArray(v).map((i) => adapter.date(i)), (v) => props.multiple ? v : v[0]);
      const viewMode = useProxiedModel(props, "viewMode");
      const minDate = computed2(() => {
        const date2 = adapter.date(props.min);
        return props.min && adapter.isValid(date2) ? date2 : null;
      });
      const maxDate = computed2(() => {
        const date2 = adapter.date(props.max);
        return props.max && adapter.isValid(date2) ? date2 : null;
      });
      const internal = computed2(() => {
        var _a3;
        const today = adapter.date();
        let value = today;
        if ((_a3 = model.value) == null ? void 0 : _a3[0]) {
          value = adapter.date(model.value[0]);
        } else if (minDate.value && adapter.isBefore(today, minDate.value)) {
          value = minDate.value;
        } else if (maxDate.value && adapter.isAfter(today, maxDate.value)) {
          value = maxDate.value;
        }
        return value && adapter.isValid(value) ? value : today;
      });
      const headerColor = toRef(() => {
        var _a3;
        return (_a3 = props.headerColor) != null ? _a3 : props.color;
      });
      const _month = useProxiedModel(props, "month");
      const month = computed2({
        get: () => {
          var _a3;
          return Number((_a3 = _month.value) != null ? _a3 : adapter.getMonth(adapter.startOfMonth(internal.value)));
        },
        set: (v) => _month.value = v
      });
      const _year = useProxiedModel(props, "year");
      const year = computed2({
        get: () => {
          var _a3;
          return Number((_a3 = _year.value) != null ? _a3 : adapter.getYear(adapter.startOfYear(adapter.setMonth(internal.value, month.value))));
        },
        set: (v) => _year.value = v
      });
      const isReversing = shallowRef(false);
      const header = computed2(() => {
        if (props.multiple && model.value.length > 1) {
          return t("$vuetify.datePicker.itemsSelected", model.value.length);
        }
        return model.value[0] && adapter.isValid(model.value[0]) ? adapter.format(adapter.date(model.value[0]), "normalDateWithWeekday") : t(props.header);
      });
      const text = computed2(() => {
        let date2 = adapter.date();
        date2 = adapter.setDate(date2, 1);
        date2 = adapter.setMonth(date2, month.value);
        date2 = adapter.setYear(date2, year.value);
        return adapter.format(date2, "monthAndYear");
      });
      const headerTransition = toRef(() => `date-picker-header${isReversing.value ? "-reverse" : ""}-transition`);
      const disabled = computed2(() => {
        if (props.disabled)
          return true;
        const targets = [];
        if (viewMode.value !== "month") {
          targets.push(...["prev", "next"]);
        } else {
          let _date = adapter.date();
          _date = adapter.startOfMonth(_date);
          _date = adapter.setMonth(_date, month.value);
          _date = adapter.setYear(_date, year.value);
          if (minDate.value) {
            const date2 = adapter.addDays(adapter.startOfMonth(_date), -1);
            adapter.isAfter(minDate.value, date2) && targets.push("prev");
          }
          if (maxDate.value) {
            const date2 = adapter.addDays(adapter.endOfMonth(_date), 1);
            adapter.isAfter(date2, maxDate.value) && targets.push("next");
          }
        }
        return targets;
      });
      function isAllowedInRange(start, end) {
        const allowedDates = props.allowedDates;
        if (typeof allowedDates !== "function")
          return true;
        const days = adapter.getDiff(end, start, "days");
        for (let i = 0; i < days; i++) {
          if (allowedDates(adapter.addDays(start, i)))
            return true;
        }
        return false;
      }
      function allowedYears(year2) {
        if (typeof props.allowedDates === "function") {
          const startOfYear3 = adapter.parseISO(`${year2}-01-01`);
          return isAllowedInRange(startOfYear3, adapter.endOfYear(startOfYear3));
        }
        if (Array.isArray(props.allowedDates) && props.allowedDates.length) {
          for (const date2 of props.allowedDates) {
            if (adapter.getYear(adapter.date(date2)) === year2)
              return true;
          }
          return false;
        }
        return true;
      }
      function allowedMonths(month2) {
        if (typeof props.allowedDates === "function") {
          const startOfMonth3 = adapter.parseISO(`${year.value}-${month2 + 1}-01`);
          return isAllowedInRange(startOfMonth3, adapter.endOfMonth(startOfMonth3));
        }
        if (Array.isArray(props.allowedDates) && props.allowedDates.length) {
          for (const date2 of props.allowedDates) {
            if (adapter.getYear(adapter.date(date2)) === year.value && adapter.getMonth(adapter.date(date2)) === month2)
              return true;
          }
          return false;
        }
        return true;
      }
      function onClickNext() {
        if (month.value < 11) {
          month.value++;
        } else {
          year.value++;
          month.value = 0;
          onUpdateYear();
        }
        onUpdateMonth();
      }
      function onClickPrev() {
        if (month.value > 0) {
          month.value--;
        } else {
          year.value--;
          month.value = 11;
          onUpdateYear();
        }
        onUpdateMonth();
      }
      function onClickDate() {
        viewMode.value = "month";
      }
      function onClickMonth() {
        viewMode.value = viewMode.value === "months" ? "month" : "months";
      }
      function onClickYear() {
        viewMode.value = viewMode.value === "year" ? "month" : "year";
      }
      function onUpdateMonth() {
        if (viewMode.value === "months")
          onClickMonth();
      }
      function onUpdateYear() {
        if (viewMode.value === "year")
          onClickYear();
      }
      watch2(model, (val, oldVal) => {
        const arrBefore = wrapInArray(oldVal);
        const arrAfter = wrapInArray(val);
        if (!arrAfter.length)
          return;
        const before = adapter.date(arrBefore[arrBefore.length - 1]);
        const after = adapter.date(arrAfter[arrAfter.length - 1]);
        const newMonth = adapter.getMonth(after);
        const newYear = adapter.getYear(after);
        if (newMonth !== month.value) {
          month.value = newMonth;
          onUpdateMonth();
        }
        if (newYear !== year.value) {
          year.value = newYear;
          onUpdateYear();
        }
        isReversing.value = adapter.isBefore(before, after);
      });
      useRender(() => {
        const pickerProps = VPicker.filterProps(props);
        const datePickerControlsProps = VDatePickerControls.filterProps(props);
        const datePickerHeaderProps = VDatePickerHeader.filterProps(props);
        const datePickerMonthProps = VDatePickerMonth.filterProps(props);
        const datePickerMonthsProps = omit(VDatePickerMonths.filterProps(props), ["modelValue"]);
        const datePickerYearsProps = omit(VDatePickerYears.filterProps(props), ["modelValue"]);
        const headerProps = {
          color: headerColor.value,
          header: header.value,
          transition: headerTransition.value
        };
        return createVNode(VPicker, mergeProps(pickerProps, {
          "color": headerColor.value,
          "class": ["v-date-picker", `v-date-picker--${viewMode.value}`, {
            "v-date-picker--show-week": props.showWeek
          }, rtlClasses.value, props.class],
          "style": props.style
        }), {
          title: () => {
            var _a3, _b;
            return (_b = (_a3 = slots.title) == null ? void 0 : _a3.call(slots)) != null ? _b : createBaseVNode("div", {
              "class": "v-date-picker__title"
            }, [t(props.title)]);
          },
          header: () => slots.header ? createVNode(VDefaultsProvider, {
            "defaults": {
              VDatePickerHeader: __spreadValues({}, headerProps)
            }
          }, {
            default: () => {
              var _a3;
              return [(_a3 = slots.header) == null ? void 0 : _a3.call(slots, headerProps)];
            }
          }) : createVNode(VDatePickerHeader, mergeProps({
            "key": "header"
          }, datePickerHeaderProps, headerProps, {
            "onClick": viewMode.value !== "month" ? onClickDate : void 0
          }), __spreadProps(__spreadValues({}, slots), {
            default: void 0
          })),
          default: () => createBaseVNode(Fragment, null, [createVNode(VDatePickerControls, mergeProps(datePickerControlsProps, {
            "disabled": disabled.value,
            "text": text.value,
            "onClick:next": onClickNext,
            "onClick:prev": onClickPrev,
            "onClick:month": onClickMonth,
            "onClick:year": onClickYear
          }), null), createVNode(VFadeTransition, {
            "hideOnLeave": true
          }, {
            default: () => [viewMode.value === "months" ? createVNode(VDatePickerMonths, mergeProps({
              "key": "date-picker-months"
            }, datePickerMonthsProps, {
              "modelValue": month.value,
              "onUpdate:modelValue": [($event) => month.value = $event, onUpdateMonth],
              "min": minDate.value,
              "max": maxDate.value,
              "year": year.value,
              "allowedMonths": allowedMonths
            }), null) : viewMode.value === "year" ? createVNode(VDatePickerYears, mergeProps({
              "key": "date-picker-years"
            }, datePickerYearsProps, {
              "modelValue": year.value,
              "onUpdate:modelValue": [($event) => year.value = $event, onUpdateYear],
              "min": minDate.value,
              "max": maxDate.value,
              "allowedYears": allowedYears
            }), null) : createVNode(VDatePickerMonth, mergeProps({
              "key": "date-picker-month"
            }, datePickerMonthProps, {
              "modelValue": model.value,
              "onUpdate:modelValue": ($event) => model.value = $event,
              "month": month.value,
              "onUpdate:month": [($event) => month.value = $event, onUpdateMonth],
              "year": year.value,
              "onUpdate:year": [($event) => year.value = $event, onUpdateYear],
              "min": minDate.value,
              "max": maxDate.value
            }), null)]
          })]),
          actions: slots.actions
        });
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VEmptyState/VEmptyState.js
  var makeVEmptyStateProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    actionText: String,
    bgColor: String,
    color: String,
    icon: IconValue,
    image: String,
    justify: {
      type: String,
      default: "center"
    },
    headline: String,
    title: String,
    text: String,
    textWidth: {
      type: [Number, String],
      default: 500
    },
    href: String,
    to: String
  }, makeComponentProps()), makeDimensionProps()), makeSizeProps({
    size: void 0
  })), makeThemeProps()), "VEmptyState");
  var VEmptyState = genericComponent()({
    name: "VEmptyState",
    props: makeVEmptyStateProps(),
    emits: {
      "click:action": (e) => true
    },
    setup(props, _ref) {
      let {
        emit: emit2,
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(() => props.bgColor);
      const {
        dimensionStyles
      } = useDimension(props);
      const {
        displayClasses
      } = useDisplay();
      function onClickAction(e) {
        emit2("click:action", e);
      }
      useRender(() => {
        var _a3, _b, _c, _d, _e, _f, _g;
        const hasActions = !!(slots.actions || props.actionText);
        const hasHeadline = !!(slots.headline || props.headline);
        const hasTitle = !!(slots.title || props.title);
        const hasText = !!(slots.text || props.text);
        const hasMedia = !!(slots.media || props.image || props.icon);
        const size = props.size || (props.image ? 200 : 96);
        return createBaseVNode("div", {
          "class": normalizeClass(["v-empty-state", {
            [`v-empty-state--${props.justify}`]: true
          }, themeClasses.value, backgroundColorClasses.value, displayClasses.value, props.class]),
          "style": normalizeStyle([backgroundColorStyles.value, dimensionStyles.value, props.style])
        }, [hasMedia && createBaseVNode("div", {
          "key": "media",
          "class": "v-empty-state__media"
        }, [!slots.media ? createBaseVNode(Fragment, null, [props.image ? createVNode(VImg, {
          "key": "image",
          "src": props.image,
          "height": size
        }, null) : props.icon ? createVNode(VIcon, {
          "key": "icon",
          "color": props.color,
          "size": size,
          "icon": props.icon
        }, null) : void 0]) : createVNode(VDefaultsProvider, {
          "key": "media-defaults",
          "defaults": {
            VImg: {
              src: props.image,
              height: size
            },
            VIcon: {
              size,
              icon: props.icon
            }
          }
        }, {
          default: () => [slots.media()]
        })]), hasHeadline && createBaseVNode("div", {
          "key": "headline",
          "class": "v-empty-state__headline"
        }, [(_b = (_a3 = slots.headline) == null ? void 0 : _a3.call(slots)) != null ? _b : props.headline]), hasTitle && createBaseVNode("div", {
          "key": "title",
          "class": "v-empty-state__title"
        }, [(_d = (_c = slots.title) == null ? void 0 : _c.call(slots)) != null ? _d : props.title]), hasText && createBaseVNode("div", {
          "key": "text",
          "class": "v-empty-state__text",
          "style": {
            maxWidth: convertToUnit(props.textWidth)
          }
        }, [(_f = (_e = slots.text) == null ? void 0 : _e.call(slots)) != null ? _f : props.text]), slots.default && createBaseVNode("div", {
          "key": "content",
          "class": "v-empty-state__content"
        }, [slots.default()]), hasActions && createBaseVNode("div", {
          "key": "actions",
          "class": "v-empty-state__actions"
        }, [createVNode(VDefaultsProvider, {
          "defaults": {
            VBtn: {
              class: "v-empty-state__action-btn",
              color: (_g = props.color) != null ? _g : "surface-variant",
              href: props.href,
              text: props.actionText,
              to: props.to
            }
          }
        }, {
          default: () => {
            var _a4, _b2;
            return [(_b2 = (_a4 = slots.actions) == null ? void 0 : _a4.call(slots, {
              props: {
                onClick: onClickAction
              }
            })) != null ? _b2 : createVNode(VBtn, {
              "onClick": onClickAction
            }, null)];
          }
        })])]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VExpansionPanel/shared.js
  var VExpansionPanelSymbol = Symbol.for("vuetify:v-expansion-panel");

  // ../posawesome/node_modules/vuetify/lib/components/VExpansionPanel/VExpansionPanelText.js
  var makeVExpansionPanelTextProps = propsFactory(__spreadValues(__spreadValues({}, makeComponentProps()), makeLazyProps()), "VExpansionPanelText");
  var VExpansionPanelText = genericComponent()({
    name: "VExpansionPanelText",
    props: makeVExpansionPanelTextProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const expansionPanel = inject(VExpansionPanelSymbol);
      if (!expansionPanel)
        throw new Error("[Vuetify] v-expansion-panel-text needs to be placed inside v-expansion-panel");
      const {
        hasContent,
        onAfterLeave
      } = useLazy(props, expansionPanel.isSelected);
      useRender(() => createVNode(VExpandTransition, {
        "onAfterLeave": onAfterLeave
      }, {
        default: () => {
          var _a3;
          return [withDirectives(createBaseVNode("div", {
            "class": normalizeClass(["v-expansion-panel-text", props.class]),
            "style": normalizeStyle(props.style)
          }, [slots.default && hasContent.value && createBaseVNode("div", {
            "class": "v-expansion-panel-text__wrapper"
          }, [(_a3 = slots.default) == null ? void 0 : _a3.call(slots)])]), [[vShow, expansionPanel.isSelected.value]])];
        }
      }));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VExpansionPanel/VExpansionPanelTitle.js
  var makeVExpansionPanelTitleProps = propsFactory(__spreadValues(__spreadValues({
    color: String,
    expandIcon: {
      type: IconValue,
      default: "$expand"
    },
    collapseIcon: {
      type: IconValue,
      default: "$collapse"
    },
    hideActions: Boolean,
    focusable: Boolean,
    static: Boolean,
    ripple: {
      type: [Boolean, Object],
      default: false
    },
    readonly: Boolean
  }, makeComponentProps()), makeDimensionProps()), "VExpansionPanelTitle");
  var VExpansionPanelTitle = genericComponent()({
    name: "VExpansionPanelTitle",
    directives: {
      vRipple: ripple_default
    },
    props: makeVExpansionPanelTitleProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const expansionPanel = inject(VExpansionPanelSymbol);
      if (!expansionPanel)
        throw new Error("[Vuetify] v-expansion-panel-title needs to be placed inside v-expansion-panel");
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(() => props.color);
      const {
        dimensionStyles
      } = useDimension(props);
      const slotProps = computed2(() => ({
        collapseIcon: props.collapseIcon,
        disabled: expansionPanel.disabled.value,
        expanded: expansionPanel.isSelected.value,
        expandIcon: props.expandIcon,
        readonly: props.readonly
      }));
      const icon = toRef(() => expansionPanel.isSelected.value ? props.collapseIcon : props.expandIcon);
      useRender(() => {
        var _a3;
        return withDirectives(createBaseVNode("button", {
          "class": normalizeClass(["v-expansion-panel-title", {
            "v-expansion-panel-title--active": expansionPanel.isSelected.value,
            "v-expansion-panel-title--focusable": props.focusable,
            "v-expansion-panel-title--static": props.static
          }, backgroundColorClasses.value, props.class]),
          "style": normalizeStyle([backgroundColorStyles.value, dimensionStyles.value, props.style]),
          "type": "button",
          "tabindex": expansionPanel.disabled.value ? -1 : void 0,
          "disabled": expansionPanel.disabled.value,
          "aria-expanded": expansionPanel.isSelected.value,
          "onClick": !props.readonly ? expansionPanel.toggle : void 0
        }, [createBaseVNode("span", {
          "class": "v-expansion-panel-title__overlay"
        }, null), (_a3 = slots.default) == null ? void 0 : _a3.call(slots, slotProps.value), !props.hideActions && createVNode(VDefaultsProvider, {
          "defaults": {
            VIcon: {
              icon: icon.value
            }
          }
        }, {
          default: () => {
            var _a4, _b;
            return [createBaseVNode("span", {
              "class": "v-expansion-panel-title__icon"
            }, [(_b = (_a4 = slots.actions) == null ? void 0 : _a4.call(slots, slotProps.value)) != null ? _b : createVNode(VIcon, null, null)])];
          }
        })]), [[ripple_default, props.ripple]]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VExpansionPanel/VExpansionPanel.js
  var makeVExpansionPanelProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    title: String,
    text: String,
    bgColor: String
  }, makeElevationProps()), makeGroupItemProps()), makeRoundedProps()), makeTagProps()), makeVExpansionPanelTitleProps()), makeVExpansionPanelTextProps()), "VExpansionPanel");
  var VExpansionPanel = genericComponent()({
    name: "VExpansionPanel",
    props: makeVExpansionPanelProps(),
    emits: {
      "group:selected": (val) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const groupItem = useGroupItem(props, VExpansionPanelSymbol);
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(() => props.bgColor);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        roundedClasses
      } = useRounded(props);
      const isDisabled = toRef(() => (groupItem == null ? void 0 : groupItem.disabled.value) || props.disabled);
      const selectedIndices = computed2(() => groupItem.group.items.value.reduce((arr, item, index) => {
        if (groupItem.group.selected.value.includes(item.id))
          arr.push(index);
        return arr;
      }, []));
      const isBeforeSelected = computed2(() => {
        const index = groupItem.group.items.value.findIndex((item) => item.id === groupItem.id);
        return !groupItem.isSelected.value && selectedIndices.value.some((selectedIndex) => selectedIndex - index === 1);
      });
      const isAfterSelected = computed2(() => {
        const index = groupItem.group.items.value.findIndex((item) => item.id === groupItem.id);
        return !groupItem.isSelected.value && selectedIndices.value.some((selectedIndex) => selectedIndex - index === -1);
      });
      provide(VExpansionPanelSymbol, groupItem);
      useRender(() => {
        const hasText = !!(slots.text || props.text);
        const hasTitle = !!(slots.title || props.title);
        const expansionPanelTitleProps = VExpansionPanelTitle.filterProps(props);
        const expansionPanelTextProps = VExpansionPanelText.filterProps(props);
        return createVNode(props.tag, {
          "class": normalizeClass(["v-expansion-panel", {
            "v-expansion-panel--active": groupItem.isSelected.value,
            "v-expansion-panel--before-active": isBeforeSelected.value,
            "v-expansion-panel--after-active": isAfterSelected.value,
            "v-expansion-panel--disabled": isDisabled.value
          }, roundedClasses.value, backgroundColorClasses.value, props.class]),
          "style": normalizeStyle([backgroundColorStyles.value, props.style])
        }, {
          default: () => [createBaseVNode("div", {
            "class": normalizeClass(["v-expansion-panel__shadow", ...elevationClasses.value])
          }, null), createVNode(VDefaultsProvider, {
            "defaults": {
              VExpansionPanelTitle: __spreadValues({}, expansionPanelTitleProps),
              VExpansionPanelText: __spreadValues({}, expansionPanelTextProps)
            }
          }, {
            default: () => {
              var _a3;
              return [hasTitle && createVNode(VExpansionPanelTitle, {
                "key": "title"
              }, {
                default: () => [slots.title ? slots.title() : props.title]
              }), hasText && createVNode(VExpansionPanelText, {
                "key": "text"
              }, {
                default: () => [slots.text ? slots.text() : props.text]
              }), (_a3 = slots.default) == null ? void 0 : _a3.call(slots)];
            }
          })]
        });
      });
      return {
        groupItem
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VExpansionPanel/VExpansionPanels.js
  var allowedVariants3 = ["default", "accordion", "inset", "popout"];
  var makeVExpansionPanelsProps = propsFactory(__spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    flat: Boolean
  }, makeGroupProps()), pick(makeVExpansionPanelProps(), ["bgColor", "collapseIcon", "color", "eager", "elevation", "expandIcon", "focusable", "hideActions", "readonly", "ripple", "rounded", "tile", "static"])), makeThemeProps()), makeComponentProps()), makeTagProps()), {
    variant: {
      type: String,
      default: "default",
      validator: (v) => allowedVariants3.includes(v)
    }
  }), "VExpansionPanels");
  var VExpansionPanels = genericComponent()({
    name: "VExpansionPanels",
    props: makeVExpansionPanelsProps(),
    emits: {
      "update:modelValue": (val) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        next,
        prev
      } = useGroup(props, VExpansionPanelSymbol);
      const {
        themeClasses
      } = provideTheme(props);
      const variantClass = toRef(() => props.variant && `v-expansion-panels--variant-${props.variant}`);
      provideDefaults({
        VExpansionPanel: {
          bgColor: toRef(() => props.bgColor),
          collapseIcon: toRef(() => props.collapseIcon),
          color: toRef(() => props.color),
          eager: toRef(() => props.eager),
          elevation: toRef(() => props.elevation),
          expandIcon: toRef(() => props.expandIcon),
          focusable: toRef(() => props.focusable),
          hideActions: toRef(() => props.hideActions),
          readonly: toRef(() => props.readonly),
          ripple: toRef(() => props.ripple),
          rounded: toRef(() => props.rounded),
          static: toRef(() => props.static)
        }
      });
      useRender(() => createVNode(props.tag, {
        "class": normalizeClass(["v-expansion-panels", {
          "v-expansion-panels--flat": props.flat,
          "v-expansion-panels--tile": props.tile
        }, themeClasses.value, variantClass.value, props.class]),
        "style": normalizeStyle(props.style)
      }, {
        default: () => {
          var _a3;
          return [(_a3 = slots.default) == null ? void 0 : _a3.call(slots, {
            prev,
            next
          })];
        }
      }));
      return {
        next,
        prev
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VFab/VFab.js
  var makeVFabProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    app: Boolean,
    appear: Boolean,
    extended: Boolean,
    layout: Boolean,
    offset: Boolean,
    modelValue: {
      type: Boolean,
      default: true
    }
  }, omit(makeVBtnProps({
    active: true
  }), ["location"])), makeLayoutItemProps()), makeLocationProps()), makeTransitionProps2({
    transition: "fab-transition"
  })), "VFab");
  var VFab = genericComponent()({
    name: "VFab",
    props: makeVFabProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const model = useProxiedModel(props, "modelValue");
      const height = shallowRef(56);
      const layoutItemStyles = ref();
      const {
        resizeRef
      } = useResizeObserver((entries) => {
        if (!entries.length)
          return;
        height.value = entries[0].target.clientHeight;
      });
      const hasPosition = toRef(() => props.app || props.absolute);
      const position = computed2(() => {
        var _a3, _b;
        if (!hasPosition.value)
          return false;
        return (_b = (_a3 = props.location) == null ? void 0 : _a3.split(" ").shift()) != null ? _b : "bottom";
      });
      const orientation = computed2(() => {
        var _a3, _b;
        if (!hasPosition.value)
          return false;
        return (_b = (_a3 = props.location) == null ? void 0 : _a3.split(" ")[1]) != null ? _b : "end";
      });
      useToggleScope(() => props.app, () => {
        const layout = useLayoutItem({
          id: props.name,
          order: computed2(() => parseInt(props.order, 10)),
          position,
          layoutSize: computed2(() => props.layout ? height.value + 24 : 0),
          elementSize: computed2(() => height.value + 24),
          active: computed2(() => props.app && model.value),
          absolute: toRef(() => props.absolute)
        });
        watchEffect(() => {
          layoutItemStyles.value = layout.layoutItemStyles.value;
        });
      });
      const vFabRef = ref();
      useRender(() => {
        const btnProps = VBtn.filterProps(props);
        return createBaseVNode("div", {
          "ref": vFabRef,
          "class": normalizeClass(["v-fab", {
            "v-fab--absolute": props.absolute,
            "v-fab--app": !!props.app,
            "v-fab--extended": props.extended,
            "v-fab--offset": props.offset,
            [`v-fab--${position.value}`]: hasPosition.value,
            [`v-fab--${orientation.value}`]: hasPosition.value
          }, props.class]),
          "style": normalizeStyle([props.app ? __spreadValues({}, layoutItemStyles.value) : {
            height: props.absolute ? "100%" : "inherit"
          }, props.style])
        }, [createBaseVNode("div", {
          "class": "v-fab__container"
        }, [createVNode(MaybeTransition, {
          "appear": props.appear,
          "transition": props.transition
        }, {
          default: () => [withDirectives(createVNode(VBtn, mergeProps({
            "ref": resizeRef
          }, btnProps, {
            "active": void 0,
            "location": void 0
          }), slots), [[vShow, props.active]])]
        })])]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/composables/fileDrop.js
  function useFileDrop() {
    function hasFilesOrFolders(e) {
      var _a3, _b, _c, _d;
      const entries = [...(_b = (_a3 = e.dataTransfer) == null ? void 0 : _a3.items) != null ? _b : []].filter((x) => x.kind === "file").map((x) => x.webkitGetAsEntry()).filter(Boolean);
      return entries.length > 0 || [...(_d = (_c = e.dataTransfer) == null ? void 0 : _c.files) != null ? _d : []].length > 0;
    }
    async function handleDrop(e) {
      var _a3, _b, _c, _d;
      const result = [];
      const entries = [...(_b = (_a3 = e.dataTransfer) == null ? void 0 : _a3.items) != null ? _b : []].filter((x) => x.kind === "file").map((x) => x.webkitGetAsEntry()).filter(Boolean);
      if (entries.length) {
        for (const entry of entries) {
          const files = await traverseFileTree(entry, appendIfDirectory(".", entry));
          result.push(...files.map((x) => x.file));
        }
      } else {
        result.push(...[...(_d = (_c = e.dataTransfer) == null ? void 0 : _c.files) != null ? _d : []]);
      }
      return result;
    }
    return {
      handleDrop,
      hasFilesOrFolders
    };
  }
  function traverseFileTree(item) {
    let path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return new Promise((resolve2, reject) => {
      if (item.isFile) {
        const fileEntry = item;
        fileEntry.file((file) => resolve2([{
          file,
          path
        }]), reject);
      } else if (item.isDirectory) {
        const directoryReader = item.createReader();
        directoryReader.readEntries(async (entries) => {
          const files = [];
          for (const entry of entries) {
            files.push(...await traverseFileTree(entry, appendIfDirectory(path, entry)));
          }
          resolve2(files);
        });
      }
    });
  }
  function appendIfDirectory(path, item) {
    return item.isDirectory ? `${path}/${item.name}` : path;
  }

  // ../posawesome/node_modules/vuetify/lib/components/VFileInput/VFileInput.js
  var makeVFileInputProps = propsFactory(__spreadValues(__spreadProps(__spreadValues({
    chips: Boolean,
    counter: Boolean,
    counterSizeString: {
      type: String,
      default: "$vuetify.fileInput.counterSize"
    },
    counterString: {
      type: String,
      default: "$vuetify.fileInput.counter"
    },
    hideInput: Boolean,
    multiple: Boolean,
    showSize: {
      type: [Boolean, Number, String],
      default: false,
      validator: (v) => {
        return typeof v === "boolean" || [1e3, 1024].includes(Number(v));
      }
    }
  }, makeVInputProps({
    prependIcon: "$file"
  })), {
    modelValue: {
      type: [Array, Object],
      default: (props) => props.multiple ? [] : null,
      validator: (val) => {
        return wrapInArray(val).every((v) => v != null && typeof v === "object");
      }
    }
  }), makeVFieldProps({
    clearable: true
  })), "VFileInput");
  var VFileInput = genericComponent()({
    name: "VFileInput",
    inheritAttrs: false,
    props: makeVFileInputProps(),
    emits: {
      "click:control": (e) => true,
      "mousedown:control": (e) => true,
      "update:focused": (focused) => true,
      "update:modelValue": (files) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        emit: emit2,
        slots
      } = _ref;
      const {
        t
      } = useLocale();
      const model = useProxiedModel(props, "modelValue", props.modelValue, (val) => wrapInArray(val), (val) => !props.multiple && Array.isArray(val) ? val[0] : val);
      const {
        isFocused,
        focus,
        blur
      } = useFocus(props);
      const base = computed2(() => typeof props.showSize !== "boolean" ? props.showSize : void 0);
      const totalBytes = computed2(() => {
        var _a3;
        return ((_a3 = model.value) != null ? _a3 : []).reduce((bytes, _ref2) => {
          let {
            size = 0
          } = _ref2;
          return bytes + size;
        }, 0);
      });
      const totalBytesReadable = computed2(() => humanReadableFileSize(totalBytes.value, base.value));
      const fileNames = computed2(() => {
        var _a3;
        return ((_a3 = model.value) != null ? _a3 : []).map((file) => {
          const {
            name = "",
            size = 0
          } = file;
          return !props.showSize ? name : `${name} (${humanReadableFileSize(size, base.value)})`;
        });
      });
      const counterValue = computed2(() => {
        var _a3, _b;
        const fileCount = (_b = (_a3 = model.value) == null ? void 0 : _a3.length) != null ? _b : 0;
        if (props.showSize)
          return t(props.counterSizeString, fileCount, totalBytesReadable.value);
        else
          return t(props.counterString, fileCount);
      });
      const vInputRef = ref();
      const vFieldRef = ref();
      const inputRef = ref();
      const isActive = toRef(() => isFocused.value || props.active);
      const isPlainOrUnderlined = computed2(() => ["plain", "underlined"].includes(props.variant));
      const isDragging = shallowRef(false);
      const {
        handleDrop,
        hasFilesOrFolders
      } = useFileDrop();
      function onFocus() {
        var _a3;
        if (inputRef.value !== document.activeElement) {
          (_a3 = inputRef.value) == null ? void 0 : _a3.focus();
        }
        if (!isFocused.value)
          focus();
      }
      function onClickPrepend(e) {
        var _a3;
        (_a3 = inputRef.value) == null ? void 0 : _a3.click();
      }
      function onControlMousedown(e) {
        emit2("mousedown:control", e);
      }
      function onControlClick(e) {
        var _a3;
        (_a3 = inputRef.value) == null ? void 0 : _a3.click();
        emit2("click:control", e);
      }
      function onClear(e) {
        e.stopPropagation();
        onFocus();
        nextTick(() => {
          model.value = [];
          callEvent(props["onClick:clear"], e);
        });
      }
      function onDragover(e) {
        e.preventDefault();
        e.stopImmediatePropagation();
        isDragging.value = true;
      }
      function onDragleave(e) {
        e.preventDefault();
        isDragging.value = false;
      }
      async function onDrop(e) {
        e.preventDefault();
        e.stopImmediatePropagation();
        isDragging.value = false;
        if (!inputRef.value || !hasFilesOrFolders(e))
          return;
        const dataTransfer = new DataTransfer();
        for (const file of await handleDrop(e)) {
          dataTransfer.items.add(file);
        }
        inputRef.value.files = dataTransfer.files;
        inputRef.value.dispatchEvent(new Event("change", {
          bubbles: true
        }));
      }
      watch2(model, (newValue) => {
        const hasModelReset = !Array.isArray(newValue) || !newValue.length;
        if (hasModelReset && inputRef.value) {
          inputRef.value.value = "";
        }
      });
      useRender(() => {
        const hasCounter = !!(slots.counter || props.counter);
        const hasDetails = !!(hasCounter || slots.details);
        const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
        const _a3 = VInput.filterProps(props), {
          modelValue: _2
        } = _a3, inputProps = __objRest(_a3, [
          "modelValue"
        ]);
        const fieldProps = VField.filterProps(props);
        return createVNode(VInput, mergeProps({
          "ref": vInputRef,
          "modelValue": props.multiple ? model.value : model.value[0],
          "class": ["v-file-input", {
            "v-file-input--chips": !!props.chips,
            "v-file-input--dragging": isDragging.value,
            "v-file-input--hide": props.hideInput,
            "v-input--plain-underlined": isPlainOrUnderlined.value
          }, props.class],
          "style": props.style,
          "onClick:prepend": onClickPrepend
        }, rootAttrs, inputProps, {
          "centerAffix": !isPlainOrUnderlined.value,
          "focused": isFocused.value
        }), __spreadProps(__spreadValues({}, slots), {
          default: (_ref3) => {
            let {
              id,
              isDisabled,
              isDirty: isDirty2,
              isReadonly: isReadonly2,
              isValid: isValid3
            } = _ref3;
            return createVNode(VField, mergeProps({
              "ref": vFieldRef,
              "prepend-icon": props.prependIcon,
              "onMousedown": onControlMousedown,
              "onClick": onControlClick,
              "onClick:clear": onClear,
              "onClick:prependInner": props["onClick:prependInner"],
              "onClick:appendInner": props["onClick:appendInner"]
            }, fieldProps, {
              "id": id.value,
              "active": isActive.value || isDirty2.value,
              "dirty": isDirty2.value || props.dirty,
              "disabled": isDisabled.value,
              "focused": isFocused.value,
              "error": isValid3.value === false,
              "onDragover": onDragover,
              "onDrop": onDrop
            }), __spreadProps(__spreadValues({}, slots), {
              default: (_ref4) => {
                var _c;
                let {
                  props: _a4
                } = _ref4, _b = _a4, {
                  class: fieldClass
                } = _b, slotProps = __objRest(_b, [
                  "class"
                ]);
                return createBaseVNode(Fragment, null, [createBaseVNode("input", mergeProps({
                  "ref": inputRef,
                  "type": "file",
                  "readonly": isReadonly2.value,
                  "disabled": isDisabled.value,
                  "multiple": props.multiple,
                  "name": props.name,
                  "onClick": (e) => {
                    e.stopPropagation();
                    if (isReadonly2.value)
                      e.preventDefault();
                    onFocus();
                  },
                  "onChange": (e) => {
                    var _a5;
                    if (!e.target)
                      return;
                    const target = e.target;
                    model.value = [...(_a5 = target.files) != null ? _a5 : []];
                  },
                  "onDragleave": onDragleave,
                  "onFocus": onFocus,
                  "onBlur": blur
                }, slotProps, inputAttrs), null), createBaseVNode("div", {
                  "class": normalizeClass(fieldClass)
                }, [!!((_c = model.value) == null ? void 0 : _c.length) && !props.hideInput && (slots.selection ? slots.selection({
                  fileNames: fileNames.value,
                  totalBytes: totalBytes.value,
                  totalBytesReadable: totalBytesReadable.value
                }) : props.chips ? fileNames.value.map((text) => createVNode(VChip, {
                  "key": text,
                  "size": "small",
                  "text": text
                }, null)) : fileNames.value.join(", "))])]);
              }
            }));
          },
          details: hasDetails ? (slotProps) => {
            var _a4, _b;
            return createBaseVNode(Fragment, null, [(_a4 = slots.details) == null ? void 0 : _a4.call(slots, slotProps), hasCounter && createBaseVNode(Fragment, null, [createBaseVNode("span", null, null), createVNode(VCounter, {
              "active": !!((_b = model.value) == null ? void 0 : _b.length),
              "value": counterValue.value,
              "disabled": props.disabled
            }, slots.counter)])]);
          } : void 0
        }));
      });
      return forwardRefs({}, vInputRef, vFieldRef, inputRef);
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VFooter/VFooter.js
  var makeVFooterProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    app: Boolean,
    color: String,
    height: {
      type: [Number, String],
      default: "auto"
    }
  }, makeBorderProps()), makeComponentProps()), makeElevationProps()), makeLayoutItemProps()), makeRoundedProps()), makeTagProps({
    tag: "footer"
  })), makeThemeProps()), "VFooter");
  var VFooter = genericComponent()({
    name: "VFooter",
    props: makeVFooterProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const layoutItemStyles = ref();
      const {
        themeClasses
      } = provideTheme(props);
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(() => props.color);
      const {
        borderClasses
      } = useBorder(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        roundedClasses
      } = useRounded(props);
      const autoHeight = shallowRef(32);
      const {
        resizeRef
      } = useResizeObserver((entries) => {
        if (!entries.length)
          return;
        autoHeight.value = entries[0].target.clientHeight;
      });
      const height = computed2(() => props.height === "auto" ? autoHeight.value : parseInt(props.height, 10));
      useToggleScope(() => props.app, () => {
        const layout = useLayoutItem({
          id: props.name,
          order: computed2(() => parseInt(props.order, 10)),
          position: toRef(() => "bottom"),
          layoutSize: height,
          elementSize: computed2(() => props.height === "auto" ? void 0 : height.value),
          active: toRef(() => props.app),
          absolute: toRef(() => props.absolute)
        });
        watchEffect(() => {
          layoutItemStyles.value = layout.layoutItemStyles.value;
        });
      });
      useRender(() => createVNode(props.tag, {
        "ref": resizeRef,
        "class": normalizeClass(["v-footer", themeClasses.value, backgroundColorClasses.value, borderClasses.value, elevationClasses.value, roundedClasses.value, props.class]),
        "style": normalizeStyle([backgroundColorStyles.value, props.app ? layoutItemStyles.value : {
          height: convertToUnit(props.height)
        }, props.style])
      }, slots));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VForm/VForm.js
  var makeVFormProps = propsFactory(__spreadValues(__spreadValues({}, makeComponentProps()), makeFormProps()), "VForm");
  var VForm = genericComponent()({
    name: "VForm",
    props: makeVFormProps(),
    emits: {
      "update:modelValue": (val) => true,
      submit: (e) => true
    },
    setup(props, _ref) {
      let {
        slots,
        emit: emit2
      } = _ref;
      const form = createForm(props);
      const formRef = ref();
      function onReset(e) {
        e.preventDefault();
        form.reset();
      }
      function onSubmit(_e) {
        const e = _e;
        const ready = form.validate();
        e.then = ready.then.bind(ready);
        e.catch = ready.catch.bind(ready);
        e.finally = ready.finally.bind(ready);
        emit2("submit", e);
        if (!e.defaultPrevented) {
          ready.then((_ref2) => {
            var _a3;
            let {
              valid
            } = _ref2;
            if (valid) {
              (_a3 = formRef.value) == null ? void 0 : _a3.submit();
            }
          });
        }
        e.preventDefault();
      }
      useRender(() => {
        var _a3;
        return createBaseVNode("form", {
          "ref": formRef,
          "class": normalizeClass(["v-form", props.class]),
          "style": normalizeStyle(props.style),
          "novalidate": true,
          "onReset": onReset,
          "onSubmit": onSubmit
        }, [(_a3 = slots.default) == null ? void 0 : _a3.call(slots, form)]);
      });
      return forwardRefs(form, formRef);
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VHover/VHover.js
  var makeVHoverProps = propsFactory(__spreadValues({
    disabled: Boolean,
    modelValue: {
      type: Boolean,
      default: null
    }
  }, makeDelayProps()), "VHover");
  var VHover = genericComponent()({
    name: "VHover",
    props: makeVHoverProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const isHovering = useProxiedModel(props, "modelValue");
      const {
        runOpenDelay,
        runCloseDelay
      } = useDelay(props, (value) => !props.disabled && (isHovering.value = value));
      return () => {
        var _a3;
        return (_a3 = slots.default) == null ? void 0 : _a3.call(slots, {
          isHovering: isHovering.value,
          props: {
            onMouseenter: runOpenDelay,
            onMouseleave: runCloseDelay
          }
        });
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VInfiniteScroll/VInfiniteScroll.js
  var makeVInfiniteScrollProps = propsFactory(__spreadValues(__spreadValues({
    color: String,
    direction: {
      type: String,
      default: "vertical",
      validator: (v) => ["vertical", "horizontal"].includes(v)
    },
    side: {
      type: String,
      default: "end",
      validator: (v) => ["start", "end", "both"].includes(v)
    },
    mode: {
      type: String,
      default: "intersect",
      validator: (v) => ["intersect", "manual"].includes(v)
    },
    margin: [Number, String],
    loadMoreText: {
      type: String,
      default: "$vuetify.infiniteScroll.loadMore"
    },
    emptyText: {
      type: String,
      default: "$vuetify.infiniteScroll.empty"
    }
  }, makeDimensionProps()), makeTagProps()), "VInfiniteScroll");
  var VInfiniteScrollIntersect = defineComponent2({
    name: "VInfiniteScrollIntersect",
    props: {
      side: {
        type: String,
        required: true
      },
      rootMargin: String
    },
    emits: {
      intersect: (side, isIntersecting) => true
    },
    setup(props, _ref) {
      let {
        emit: emit2
      } = _ref;
      const {
        intersectionRef,
        isIntersecting
      } = useIntersectionObserver();
      watch2(isIntersecting, async (val) => {
        emit2("intersect", props.side, val);
      });
      useRender(() => createBaseVNode("div", {
        "class": "v-infinite-scroll-intersect",
        "style": {
          "--v-infinite-margin-size": props.rootMargin
        },
        "ref": intersectionRef
      }, [createTextVNode("\xA0")]));
      return {};
    }
  });
  var VInfiniteScroll = genericComponent()({
    name: "VInfiniteScroll",
    props: makeVInfiniteScrollProps(),
    emits: {
      load: (options) => true
    },
    setup(props, _ref2) {
      let {
        slots,
        emit: emit2
      } = _ref2;
      const rootEl = ref();
      const startStatus = shallowRef("ok");
      const endStatus = shallowRef("ok");
      const margin = computed2(() => convertToUnit(props.margin));
      const isIntersecting = shallowRef(false);
      function setScrollAmount(amount) {
        if (!rootEl.value)
          return;
        const property = props.direction === "vertical" ? "scrollTop" : "scrollLeft";
        rootEl.value[property] = amount;
      }
      function getScrollAmount() {
        if (!rootEl.value)
          return 0;
        const property = props.direction === "vertical" ? "scrollTop" : "scrollLeft";
        return rootEl.value[property];
      }
      function getScrollSize2() {
        if (!rootEl.value)
          return 0;
        const property = props.direction === "vertical" ? "scrollHeight" : "scrollWidth";
        return rootEl.value[property];
      }
      function getContainerSize() {
        if (!rootEl.value)
          return 0;
        const property = props.direction === "vertical" ? "clientHeight" : "clientWidth";
        return rootEl.value[property];
      }
      onMounted(() => {
        if (!rootEl.value)
          return;
        if (props.side === "start") {
          setScrollAmount(getScrollSize2());
        } else if (props.side === "both") {
          setScrollAmount(getScrollSize2() / 2 - getContainerSize() / 2);
        }
      });
      function setStatus(side, status) {
        if (side === "start") {
          startStatus.value = status;
        } else if (side === "end") {
          endStatus.value = status;
        }
      }
      function getStatus(side) {
        return side === "start" ? startStatus.value : endStatus.value;
      }
      let previousScrollSize = 0;
      function handleIntersect(side, _isIntersecting) {
        isIntersecting.value = _isIntersecting;
        if (isIntersecting.value) {
          intersecting(side);
        }
      }
      function intersecting(side) {
        if (props.mode !== "manual" && !isIntersecting.value)
          return;
        const status = getStatus(side);
        if (!rootEl.value || ["empty", "loading"].includes(status))
          return;
        previousScrollSize = getScrollSize2();
        setStatus(side, "loading");
        function done(status2) {
          setStatus(side, status2);
          nextTick(() => {
            if (status2 === "empty" || status2 === "error")
              return;
            if (status2 === "ok" && side === "start") {
              setScrollAmount(getScrollSize2() - previousScrollSize + getScrollAmount());
            }
            if (props.mode !== "manual") {
              nextTick(() => {
                window.requestAnimationFrame(() => {
                  window.requestAnimationFrame(() => {
                    window.requestAnimationFrame(() => {
                      intersecting(side);
                    });
                  });
                });
              });
            }
          });
        }
        emit2("load", {
          side,
          done
        });
      }
      const {
        t
      } = useLocale();
      function renderSide(side, status) {
        var _a3, _b, _c, _d, _e, _f, _g, _h, _i2;
        if (props.side !== side && props.side !== "both")
          return;
        const onClick = () => intersecting(side);
        const slotProps = {
          side,
          props: {
            onClick,
            color: props.color
          }
        };
        if (status === "error")
          return (_a3 = slots.error) == null ? void 0 : _a3.call(slots, slotProps);
        if (status === "empty")
          return (_c = (_b = slots.empty) == null ? void 0 : _b.call(slots, slotProps)) != null ? _c : createBaseVNode("div", null, [t(props.emptyText)]);
        if (props.mode === "manual") {
          if (status === "loading") {
            return (_e = (_d = slots.loading) == null ? void 0 : _d.call(slots, slotProps)) != null ? _e : createVNode(VProgressCircular, {
              "indeterminate": true,
              "color": props.color
            }, null);
          }
          return (_g = (_f = slots["load-more"]) == null ? void 0 : _f.call(slots, slotProps)) != null ? _g : createVNode(VBtn, {
            "variant": "outlined",
            "color": props.color,
            "onClick": onClick
          }, {
            default: () => [t(props.loadMoreText)]
          });
        }
        return (_i2 = (_h = slots.loading) == null ? void 0 : _h.call(slots, slotProps)) != null ? _i2 : createVNode(VProgressCircular, {
          "indeterminate": true,
          "color": props.color
        }, null);
      }
      const {
        dimensionStyles
      } = useDimension(props);
      useRender(() => {
        const Tag = props.tag;
        const hasStartIntersect = props.side === "start" || props.side === "both";
        const hasEndIntersect = props.side === "end" || props.side === "both";
        const intersectMode = props.mode === "intersect";
        return createVNode(Tag, {
          "ref": rootEl,
          "class": normalizeClass(["v-infinite-scroll", `v-infinite-scroll--${props.direction}`, {
            "v-infinite-scroll--start": hasStartIntersect,
            "v-infinite-scroll--end": hasEndIntersect
          }]),
          "style": normalizeStyle(dimensionStyles.value)
        }, {
          default: () => {
            var _a3;
            return [createBaseVNode("div", {
              "class": "v-infinite-scroll__side"
            }, [renderSide("start", startStatus.value)]), hasStartIntersect && intersectMode && createVNode(VInfiniteScrollIntersect, {
              "key": "start",
              "side": "start",
              "onIntersect": handleIntersect,
              "rootMargin": margin.value
            }, null), (_a3 = slots.default) == null ? void 0 : _a3.call(slots), hasEndIntersect && intersectMode && createVNode(VInfiniteScrollIntersect, {
              "key": "end",
              "side": "end",
              "onIntersect": handleIntersect,
              "rootMargin": margin.value
            }, null), createBaseVNode("div", {
              "class": "v-infinite-scroll__side"
            }, [renderSide("end", endStatus.value)])];
          }
        });
      });
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VItemGroup/VItemGroup.js
  var VItemGroupSymbol = Symbol.for("vuetify:v-item-group");
  var makeVItemGroupProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, makeComponentProps()), makeGroupProps({
    selectedClass: "v-item--selected"
  })), makeTagProps()), makeThemeProps()), "VItemGroup");
  var VItemGroup = genericComponent()({
    name: "VItemGroup",
    props: makeVItemGroupProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        isSelected,
        select,
        next,
        prev,
        selected
      } = useGroup(props, VItemGroupSymbol);
      return () => createVNode(props.tag, {
        "class": normalizeClass(["v-item-group", themeClasses.value, props.class]),
        "style": normalizeStyle(props.style)
      }, {
        default: () => {
          var _a3;
          return [(_a3 = slots.default) == null ? void 0 : _a3.call(slots, {
            isSelected,
            select,
            next,
            prev,
            selected: selected.value
          })];
        }
      });
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VItemGroup/VItem.js
  var VItem = genericComponent()({
    name: "VItem",
    props: makeGroupItemProps(),
    emits: {
      "group:selected": (val) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        isSelected,
        select,
        toggle,
        selectedClass,
        value,
        disabled
      } = useGroupItem(props, VItemGroupSymbol);
      return () => {
        var _a3;
        return (_a3 = slots.default) == null ? void 0 : _a3.call(slots, {
          isSelected: isSelected.value,
          selectedClass: selectedClass.value,
          select,
          toggle,
          value: value.value,
          disabled: disabled.value
        });
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VKbd/index.js
  var VKbd = createSimpleFunctional("v-kbd", "kbd");

  // ../posawesome/node_modules/vuetify/lib/components/VLayout/VLayout.js
  var makeVLayoutProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({}, makeComponentProps()), makeDimensionProps()), makeLayoutProps()), "VLayout");
  var VLayout = genericComponent()({
    name: "VLayout",
    props: makeVLayoutProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        layoutClasses,
        layoutStyles,
        getLayoutItem,
        items,
        layoutRef
      } = createLayout(props);
      const {
        dimensionStyles
      } = useDimension(props);
      useRender(() => {
        var _a3;
        return createBaseVNode("div", {
          "ref": layoutRef,
          "class": normalizeClass([layoutClasses.value, props.class]),
          "style": normalizeStyle([dimensionStyles.value, layoutStyles.value, props.style])
        }, [(_a3 = slots.default) == null ? void 0 : _a3.call(slots)]);
      });
      return {
        getLayoutItem,
        items
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VLayout/VLayoutItem.js
  var makeVLayoutItemProps = propsFactory(__spreadValues(__spreadValues({
    position: {
      type: String,
      required: true
    },
    size: {
      type: [Number, String],
      default: 300
    },
    modelValue: Boolean
  }, makeComponentProps()), makeLayoutItemProps()), "VLayoutItem");
  var VLayoutItem = genericComponent()({
    name: "VLayoutItem",
    props: makeVLayoutItemProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        layoutItemStyles
      } = useLayoutItem({
        id: props.name,
        order: computed2(() => parseInt(props.order, 10)),
        position: toRef(() => props.position),
        elementSize: toRef(() => props.size),
        layoutSize: toRef(() => props.size),
        active: toRef(() => props.modelValue),
        absolute: toRef(() => props.absolute)
      });
      return () => {
        var _a3;
        return createBaseVNode("div", {
          "class": normalizeClass(["v-layout-item", props.class]),
          "style": normalizeStyle([layoutItemStyles.value, props.style])
        }, [(_a3 = slots.default) == null ? void 0 : _a3.call(slots)]);
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VLazy/VLazy.js
  var makeVLazyProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    modelValue: Boolean,
    options: {
      type: Object,
      default: () => ({
        root: void 0,
        rootMargin: void 0,
        threshold: void 0
      })
    }
  }, makeComponentProps()), makeDimensionProps()), makeTagProps()), makeTransitionProps2({
    transition: "fade-transition"
  })), "VLazy");
  var VLazy = genericComponent()({
    name: "VLazy",
    directives: {
      vIntersect: intersect_default
    },
    props: makeVLazyProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        dimensionStyles
      } = useDimension(props);
      const isActive = useProxiedModel(props, "modelValue");
      function onIntersect(isIntersecting) {
        if (isActive.value)
          return;
        isActive.value = isIntersecting;
      }
      useRender(() => withDirectives(createVNode(props.tag, {
        "class": normalizeClass(["v-lazy", props.class]),
        "style": normalizeStyle([dimensionStyles.value, props.style])
      }, {
        default: () => [isActive.value && createVNode(MaybeTransition, {
          "transition": props.transition,
          "appear": true
        }, {
          default: () => {
            var _a3;
            return [(_a3 = slots.default) == null ? void 0 : _a3.call(slots)];
          }
        })]
      }), [[intersect_default, {
        handler: onIntersect,
        options: props.options
      }, null]]));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VLocaleProvider/VLocaleProvider.js
  var makeVLocaleProviderProps = propsFactory(__spreadValues({
    locale: String,
    fallbackLocale: String,
    messages: Object,
    rtl: {
      type: Boolean,
      default: void 0
    }
  }, makeComponentProps()), "VLocaleProvider");
  var VLocaleProvider = genericComponent()({
    name: "VLocaleProvider",
    props: makeVLocaleProviderProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        rtlClasses
      } = provideLocale(props);
      useRender(() => {
        var _a3;
        return createBaseVNode("div", {
          "class": normalizeClass(["v-locale-provider", rtlClasses.value, props.class]),
          "style": normalizeStyle(props.style)
        }, [(_a3 = slots.default) == null ? void 0 : _a3.call(slots)]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VMain/VMain.js
  var makeVMainProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({
    scrollable: Boolean
  }, makeComponentProps()), makeDimensionProps()), makeTagProps({
    tag: "main"
  })), "VMain");
  var VMain = genericComponent()({
    name: "VMain",
    props: makeVMainProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        dimensionStyles
      } = useDimension(props);
      const {
        mainStyles
      } = useLayout();
      const {
        ssrBootStyles
      } = useSsrBoot();
      useRender(() => createVNode(props.tag, {
        "class": normalizeClass(["v-main", {
          "v-main--scrollable": props.scrollable
        }, props.class]),
        "style": normalizeStyle([mainStyles.value, ssrBootStyles.value, dimensionStyles.value, props.style])
      }, {
        default: () => {
          var _a3, _b;
          return [props.scrollable ? createBaseVNode("div", {
            "class": "v-main__scroller"
          }, [(_a3 = slots.default) == null ? void 0 : _a3.call(slots)]) : (_b = slots.default) == null ? void 0 : _b.call(slots)];
        }
      }));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VNavigationDrawer/sticky.js
  function useSticky(_ref) {
    let {
      rootEl,
      isSticky,
      layoutItemStyles
    } = _ref;
    const isStuck = shallowRef(false);
    const stuckPosition = shallowRef(0);
    const stickyStyles = computed2(() => {
      const side = typeof isStuck.value === "boolean" ? "top" : isStuck.value;
      return [isSticky.value ? {
        top: "auto",
        bottom: "auto",
        height: void 0
      } : void 0, isStuck.value ? {
        [side]: convertToUnit(stuckPosition.value)
      } : {
        top: layoutItemStyles.value.top
      }];
    });
    onMounted(() => {
      watch2(isSticky, (val) => {
        if (val) {
          window.addEventListener("scroll", onScroll, {
            passive: true
          });
        } else {
          window.removeEventListener("scroll", onScroll);
        }
      }, {
        immediate: true
      });
    });
    onBeforeUnmount(() => {
      window.removeEventListener("scroll", onScroll);
    });
    let lastScrollTop = 0;
    function onScroll() {
      var _a3;
      const direction = lastScrollTop > window.scrollY ? "up" : "down";
      const rect = rootEl.value.getBoundingClientRect();
      const layoutTop = parseFloat((_a3 = layoutItemStyles.value.top) != null ? _a3 : 0);
      const top = window.scrollY - Math.max(0, stuckPosition.value - layoutTop);
      const bottom = rect.height + Math.max(stuckPosition.value, layoutTop) - window.scrollY - window.innerHeight;
      const bodyScroll = parseFloat(getComputedStyle(rootEl.value).getPropertyValue("--v-body-scroll-y")) || 0;
      if (rect.height < window.innerHeight - layoutTop) {
        isStuck.value = "top";
        stuckPosition.value = layoutTop;
      } else if (direction === "up" && isStuck.value === "bottom" || direction === "down" && isStuck.value === "top") {
        stuckPosition.value = window.scrollY + rect.top - bodyScroll;
        isStuck.value = true;
      } else if (direction === "down" && bottom <= 0) {
        stuckPosition.value = 0;
        isStuck.value = "bottom";
      } else if (direction === "up" && top <= 0) {
        if (!bodyScroll) {
          stuckPosition.value = rect.top + top;
          isStuck.value = "top";
        } else if (isStuck.value !== "top") {
          stuckPosition.value = -top + bodyScroll + layoutTop;
          isStuck.value = "top";
        }
      }
      lastScrollTop = window.scrollY;
    }
    return {
      isStuck,
      stickyStyles
    };
  }

  // ../posawesome/node_modules/vuetify/lib/composables/touch.js
  var HORIZON = 100;
  var HISTORY = 20;
  function kineticEnergyToVelocity(work) {
    const sqrt2 = 1.41421356237;
    return (work < 0 ? -1 : 1) * Math.sqrt(Math.abs(work)) * sqrt2;
  }
  function calculateImpulseVelocity(samples) {
    if (samples.length < 2) {
      return 0;
    }
    if (samples.length === 2) {
      if (samples[1].t === samples[0].t) {
        return 0;
      }
      return (samples[1].d - samples[0].d) / (samples[1].t - samples[0].t);
    }
    let work = 0;
    for (let i = samples.length - 1; i > 0; i--) {
      if (samples[i].t === samples[i - 1].t) {
        continue;
      }
      const vprev = kineticEnergyToVelocity(work);
      const vcurr = (samples[i].d - samples[i - 1].d) / (samples[i].t - samples[i - 1].t);
      work += (vcurr - vprev) * Math.abs(vcurr);
      if (i === samples.length - 1) {
        work *= 0.5;
      }
    }
    return kineticEnergyToVelocity(work) * 1e3;
  }
  function useVelocity() {
    const touches = {};
    function addMovement(e) {
      Array.from(e.changedTouches).forEach((touch) => {
        var _a3;
        const samples = (_a3 = touches[touch.identifier]) != null ? _a3 : touches[touch.identifier] = new CircularBuffer(HISTORY);
        samples.push([e.timeStamp, touch]);
      });
    }
    function endTouch(e) {
      Array.from(e.changedTouches).forEach((touch) => {
        delete touches[touch.identifier];
      });
    }
    function getVelocity(id) {
      var _a3;
      const samples = (_a3 = touches[id]) == null ? void 0 : _a3.values().reverse();
      if (!samples) {
        throw new Error(`No samples for touch id ${id}`);
      }
      const newest = samples[0];
      const x = [];
      const y = [];
      for (const val of samples) {
        if (newest[0] - val[0] > HORIZON)
          break;
        x.push({
          t: val[0],
          d: val[1].clientX
        });
        y.push({
          t: val[0],
          d: val[1].clientY
        });
      }
      return {
        x: calculateImpulseVelocity(x),
        y: calculateImpulseVelocity(y),
        get direction() {
          const {
            x: x2,
            y: y2
          } = this;
          const [absX, absY] = [Math.abs(x2), Math.abs(y2)];
          return absX > absY && x2 >= 0 ? "right" : absX > absY && x2 <= 0 ? "left" : absY > absX && y2 >= 0 ? "down" : absY > absX && y2 <= 0 ? "up" : oops();
        }
      };
    }
    return {
      addMovement,
      endTouch,
      getVelocity
    };
  }
  function oops() {
    throw new Error();
  }

  // ../posawesome/node_modules/vuetify/lib/components/VNavigationDrawer/touch.js
  function useTouch(_ref) {
    let {
      el,
      isActive,
      isTemporary,
      width,
      touchless,
      position
    } = _ref;
    onMounted(() => {
      window.addEventListener("touchstart", onTouchstart, {
        passive: true
      });
      window.addEventListener("touchmove", onTouchmove, {
        passive: false
      });
      window.addEventListener("touchend", onTouchend, {
        passive: true
      });
    });
    onBeforeUnmount(() => {
      window.removeEventListener("touchstart", onTouchstart);
      window.removeEventListener("touchmove", onTouchmove);
      window.removeEventListener("touchend", onTouchend);
    });
    const isHorizontal = computed2(() => ["left", "right"].includes(position.value));
    const {
      addMovement,
      endTouch,
      getVelocity
    } = useVelocity();
    let maybeDragging = false;
    const isDragging = shallowRef(false);
    const dragProgress = shallowRef(0);
    const offset = shallowRef(0);
    let start;
    function getOffset4(pos, active) {
      return (position.value === "left" ? pos : position.value === "right" ? document.documentElement.clientWidth - pos : position.value === "top" ? pos : position.value === "bottom" ? document.documentElement.clientHeight - pos : oops2()) - (active ? width.value : 0);
    }
    function getProgress(pos) {
      let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      const progress = position.value === "left" ? (pos - offset.value) / width.value : position.value === "right" ? (document.documentElement.clientWidth - pos - offset.value) / width.value : position.value === "top" ? (pos - offset.value) / width.value : position.value === "bottom" ? (document.documentElement.clientHeight - pos - offset.value) / width.value : oops2();
      return limit ? clamp(progress) : progress;
    }
    function onTouchstart(e) {
      if (touchless.value)
        return;
      const touchX = e.changedTouches[0].clientX;
      const touchY = e.changedTouches[0].clientY;
      const touchZone = 25;
      const inTouchZone = position.value === "left" ? touchX < touchZone : position.value === "right" ? touchX > document.documentElement.clientWidth - touchZone : position.value === "top" ? touchY < touchZone : position.value === "bottom" ? touchY > document.documentElement.clientHeight - touchZone : oops2();
      const inElement = isActive.value && (position.value === "left" ? touchX < width.value : position.value === "right" ? touchX > document.documentElement.clientWidth - width.value : position.value === "top" ? touchY < width.value : position.value === "bottom" ? touchY > document.documentElement.clientHeight - width.value : oops2());
      if (inTouchZone || inElement || isActive.value && isTemporary.value) {
        start = [touchX, touchY];
        offset.value = getOffset4(isHorizontal.value ? touchX : touchY, isActive.value);
        dragProgress.value = getProgress(isHorizontal.value ? touchX : touchY);
        maybeDragging = offset.value > -20 && offset.value < 80;
        endTouch(e);
        addMovement(e);
      }
    }
    function onTouchmove(e) {
      const touchX = e.changedTouches[0].clientX;
      const touchY = e.changedTouches[0].clientY;
      if (maybeDragging) {
        if (!e.cancelable) {
          maybeDragging = false;
          return;
        }
        const dx = Math.abs(touchX - start[0]);
        const dy = Math.abs(touchY - start[1]);
        const thresholdMet = isHorizontal.value ? dx > dy && dx > 3 : dy > dx && dy > 3;
        if (thresholdMet) {
          isDragging.value = true;
          maybeDragging = false;
        } else if ((isHorizontal.value ? dy : dx) > 3) {
          maybeDragging = false;
        }
      }
      if (!isDragging.value)
        return;
      e.preventDefault();
      addMovement(e);
      const progress = getProgress(isHorizontal.value ? touchX : touchY, false);
      dragProgress.value = Math.max(0, Math.min(1, progress));
      if (progress > 1) {
        offset.value = getOffset4(isHorizontal.value ? touchX : touchY, true);
      } else if (progress < 0) {
        offset.value = getOffset4(isHorizontal.value ? touchX : touchY, false);
      }
    }
    function onTouchend(e) {
      maybeDragging = false;
      if (!isDragging.value)
        return;
      addMovement(e);
      isDragging.value = false;
      const velocity = getVelocity(e.changedTouches[0].identifier);
      const vx = Math.abs(velocity.x);
      const vy = Math.abs(velocity.y);
      const thresholdMet = isHorizontal.value ? vx > vy && vx > 400 : vy > vx && vy > 3;
      if (thresholdMet) {
        isActive.value = velocity.direction === ({
          left: "right",
          right: "left",
          top: "down",
          bottom: "up"
        }[position.value] || oops2());
      } else {
        isActive.value = dragProgress.value > 0.5;
      }
    }
    const dragStyles = computed2(() => {
      return isDragging.value ? {
        transform: position.value === "left" ? `translateX(calc(-100% + ${dragProgress.value * width.value}px))` : position.value === "right" ? `translateX(calc(100% - ${dragProgress.value * width.value}px))` : position.value === "top" ? `translateY(calc(-100% + ${dragProgress.value * width.value}px))` : position.value === "bottom" ? `translateY(calc(100% - ${dragProgress.value * width.value}px))` : oops2(),
        transition: "none"
      } : void 0;
    });
    useToggleScope(isDragging, () => {
      var _a3, _b, _c, _d;
      const transform2 = (_b = (_a3 = el.value) == null ? void 0 : _a3.style.transform) != null ? _b : null;
      const transition = (_d = (_c = el.value) == null ? void 0 : _c.style.transition) != null ? _d : null;
      watchEffect(() => {
        var _a4, _b2, _c2, _d2;
        (_b2 = el.value) == null ? void 0 : _b2.style.setProperty("transform", ((_a4 = dragStyles.value) == null ? void 0 : _a4.transform) || "none");
        (_d2 = el.value) == null ? void 0 : _d2.style.setProperty("transition", ((_c2 = dragStyles.value) == null ? void 0 : _c2.transition) || null);
      });
      onScopeDispose(() => {
        var _a4, _b2;
        (_a4 = el.value) == null ? void 0 : _a4.style.setProperty("transform", transform2);
        (_b2 = el.value) == null ? void 0 : _b2.style.setProperty("transition", transition);
      });
    });
    return {
      isDragging,
      dragProgress,
      dragStyles
    };
  }
  function oops2() {
    throw new Error();
  }

  // ../posawesome/node_modules/vuetify/lib/components/VNavigationDrawer/VNavigationDrawer.js
  var locations = ["start", "end", "left", "right", "top", "bottom"];
  var makeVNavigationDrawerProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    color: String,
    disableResizeWatcher: Boolean,
    disableRouteWatcher: Boolean,
    expandOnHover: Boolean,
    floating: Boolean,
    modelValue: {
      type: Boolean,
      default: null
    },
    permanent: Boolean,
    rail: {
      type: Boolean,
      default: null
    },
    railWidth: {
      type: [Number, String],
      default: 56
    },
    scrim: {
      type: [Boolean, String],
      default: true
    },
    image: String,
    temporary: Boolean,
    persistent: Boolean,
    touchless: Boolean,
    width: {
      type: [Number, String],
      default: 256
    },
    location: {
      type: String,
      default: "start",
      validator: (value) => locations.includes(value)
    },
    sticky: Boolean
  }, makeBorderProps()), makeComponentProps()), makeDelayProps()), makeDisplayProps({
    mobile: null
  })), makeElevationProps()), makeLayoutItemProps()), makeRoundedProps()), makeTagProps({
    tag: "nav"
  })), makeThemeProps()), "VNavigationDrawer");
  var VNavigationDrawer = genericComponent()({
    name: "VNavigationDrawer",
    props: makeVNavigationDrawerProps(),
    emits: {
      "update:modelValue": (val) => true,
      "update:rail": (val) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        emit: emit2,
        slots
      } = _ref;
      const {
        isRtl
      } = useRtl();
      const {
        themeClasses
      } = provideTheme(props);
      const {
        borderClasses
      } = useBorder(props);
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(() => props.color);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        displayClasses,
        mobile
      } = useDisplay(props);
      const {
        roundedClasses
      } = useRounded(props);
      const router = useRouter();
      const isActive = useProxiedModel(props, "modelValue", null, (v) => !!v);
      const {
        ssrBootStyles
      } = useSsrBoot();
      const {
        scopeId
      } = useScopeId();
      const rootEl = ref();
      const isHovering = shallowRef(false);
      const {
        runOpenDelay,
        runCloseDelay
      } = useDelay(props, (value) => {
        isHovering.value = value;
      });
      const width = computed2(() => {
        return props.rail && props.expandOnHover && isHovering.value ? Number(props.width) : Number(props.rail ? props.railWidth : props.width);
      });
      const location2 = computed2(() => {
        return toPhysical(props.location, isRtl.value);
      });
      const isPersistent = toRef(() => props.persistent);
      const isTemporary = computed2(() => !props.permanent && (mobile.value || props.temporary));
      const isSticky = computed2(() => props.sticky && !isTemporary.value && location2.value !== "bottom");
      useToggleScope(() => props.expandOnHover && props.rail != null, () => {
        watch2(isHovering, (val) => emit2("update:rail", !val));
      });
      useToggleScope(() => !props.disableResizeWatcher, () => {
        watch2(isTemporary, (val) => !props.permanent && nextTick(() => isActive.value = !val));
      });
      useToggleScope(() => !props.disableRouteWatcher && !!router, () => {
        watch2(router.currentRoute, () => isTemporary.value && (isActive.value = false));
      });
      watch2(() => props.permanent, (val) => {
        if (val)
          isActive.value = true;
      });
      if (props.modelValue == null && !isTemporary.value) {
        isActive.value = props.permanent || !mobile.value;
      }
      const {
        isDragging,
        dragProgress
      } = useTouch({
        el: rootEl,
        isActive,
        isTemporary,
        width,
        touchless: toRef(() => props.touchless),
        position: location2
      });
      const layoutSize = computed2(() => {
        const size = isTemporary.value ? 0 : props.rail && props.expandOnHover ? Number(props.railWidth) : width.value;
        return isDragging.value ? size * dragProgress.value : size;
      });
      const {
        layoutItemStyles,
        layoutItemScrimStyles
      } = useLayoutItem({
        id: props.name,
        order: computed2(() => parseInt(props.order, 10)),
        position: location2,
        layoutSize,
        elementSize: width,
        active: readonly(isActive),
        disableTransitions: toRef(() => isDragging.value),
        absolute: computed2(() => props.absolute || isSticky.value && typeof isStuck.value !== "string")
      });
      const {
        isStuck,
        stickyStyles
      } = useSticky({
        rootEl,
        isSticky,
        layoutItemStyles
      });
      const scrimColor = useBackgroundColor(() => {
        return typeof props.scrim === "string" ? props.scrim : null;
      });
      const scrimStyles = computed2(() => __spreadValues(__spreadValues({}, isDragging.value ? {
        opacity: dragProgress.value * 0.2,
        transition: "none"
      } : void 0), layoutItemScrimStyles.value));
      provideDefaults({
        VList: {
          bgColor: "transparent"
        }
      });
      useRender(() => {
        const hasImage = slots.image || props.image;
        return createBaseVNode(Fragment, null, [createVNode(props.tag, mergeProps({
          "ref": rootEl,
          "onMouseenter": runOpenDelay,
          "onMouseleave": runCloseDelay,
          "class": ["v-navigation-drawer", `v-navigation-drawer--${location2.value}`, {
            "v-navigation-drawer--expand-on-hover": props.expandOnHover,
            "v-navigation-drawer--floating": props.floating,
            "v-navigation-drawer--is-hovering": isHovering.value,
            "v-navigation-drawer--rail": props.rail,
            "v-navigation-drawer--temporary": isTemporary.value,
            "v-navigation-drawer--persistent": isPersistent.value,
            "v-navigation-drawer--active": isActive.value,
            "v-navigation-drawer--sticky": isSticky.value
          }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, displayClasses.value, elevationClasses.value, roundedClasses.value, props.class],
          "style": [backgroundColorStyles.value, layoutItemStyles.value, ssrBootStyles.value, stickyStyles.value, props.style]
        }, scopeId, attrs), {
          default: () => {
            var _a3, _b, _c;
            return [hasImage && createBaseVNode("div", {
              "key": "image",
              "class": "v-navigation-drawer__img"
            }, [!slots.image ? createVNode(VImg, {
              "key": "image-img",
              "alt": "",
              "cover": true,
              "height": "inherit",
              "src": props.image
            }, null) : createVNode(VDefaultsProvider, {
              "key": "image-defaults",
              "disabled": !props.image,
              "defaults": {
                VImg: {
                  alt: "",
                  cover: true,
                  height: "inherit",
                  src: props.image
                }
              }
            }, slots.image)]), slots.prepend && createBaseVNode("div", {
              "class": "v-navigation-drawer__prepend"
            }, [(_a3 = slots.prepend) == null ? void 0 : _a3.call(slots)]), createBaseVNode("div", {
              "class": "v-navigation-drawer__content"
            }, [(_b = slots.default) == null ? void 0 : _b.call(slots)]), slots.append && createBaseVNode("div", {
              "class": "v-navigation-drawer__append"
            }, [(_c = slots.append) == null ? void 0 : _c.call(slots)])];
          }
        }), createVNode(Transition, {
          "name": "fade-transition"
        }, {
          default: () => [isTemporary.value && (isDragging.value || isActive.value) && !!props.scrim && createBaseVNode("div", mergeProps({
            "class": ["v-navigation-drawer__scrim", scrimColor.backgroundColorClasses.value],
            "style": [scrimStyles.value, scrimColor.backgroundColorStyles.value],
            "onClick": () => {
              if (isPersistent.value)
                return;
              isActive.value = false;
            }
          }, scopeId), null)]
        })]);
      });
      return {
        isStuck
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VNoSsr/VNoSsr.js
  var VNoSsr = defineComponent2({
    name: "VNoSsr",
    setup(_2, _ref) {
      let {
        slots
      } = _ref;
      const show = useHydration();
      return () => {
        var _a3;
        return show.value && ((_a3 = slots.default) == null ? void 0 : _a3.call(slots));
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VNumberInput/hold.js
  var HOLD_REPEAT = 50;
  var HOLD_DELAY = 500;
  function useHold(_ref) {
    let {
      toggleUpDown
    } = _ref;
    let timeout = -1;
    let interval = -1;
    onScopeDispose(holdStop);
    function holdStart(value) {
      holdStop();
      tick(value);
      timeout = window.setTimeout(() => {
        interval = window.setInterval(() => tick(value), HOLD_REPEAT);
      }, HOLD_DELAY);
    }
    function holdStop() {
      window.clearTimeout(timeout);
      window.clearInterval(interval);
    }
    function tick(value) {
      toggleUpDown(value === "up");
    }
    return {
      holdStart,
      holdStop
    };
  }

  // ../posawesome/node_modules/vuetify/lib/components/VNumberInput/VNumberInput.js
  var makeVNumberInputProps = propsFactory(__spreadValues({
    controlVariant: {
      type: String,
      default: "default"
    },
    inset: Boolean,
    hideInput: Boolean,
    modelValue: {
      type: Number,
      default: null
    },
    min: {
      type: Number,
      default: Number.MIN_SAFE_INTEGER
    },
    max: {
      type: Number,
      default: Number.MAX_SAFE_INTEGER
    },
    step: {
      type: Number,
      default: 1
    },
    precision: {
      type: Number,
      default: 0
    }
  }, omit(makeVTextFieldProps(), ["modelValue", "validationValue"])), "VNumberInput");
  var VNumberInput = genericComponent()({
    name: "VNumberInput",
    props: __spreadValues({}, makeVNumberInputProps()),
    emits: {
      "update:focused": (val) => true,
      "update:modelValue": (val) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const vTextFieldRef = ref();
      const {
        holdStart,
        holdStop
      } = useHold({
        toggleUpDown
      });
      const form = useForm(props);
      const controlsDisabled = computed2(() => form.isDisabled.value || form.isReadonly.value);
      const isFocused = shallowRef(props.focused);
      function correctPrecision(val) {
        let precision = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : props.precision;
        const fixed = precision == null ? String(val) : val.toFixed(precision);
        return isFocused.value ? Number(fixed).toString() : fixed;
      }
      const model = useProxiedModel(props, "modelValue", null, (val) => val != null ? val : null, (val) => val == null ? val != null ? val : null : clamp(Number(val), props.min, props.max));
      const _inputText = shallowRef(null);
      watchEffect(() => {
        if (isFocused.value && !controlsDisabled.value) {
        } else if (model.value == null) {
          _inputText.value = null;
        } else if (!isNaN(model.value)) {
          _inputText.value = correctPrecision(model.value);
        }
      });
      const inputText = computed2({
        get: () => _inputText.value,
        set(val) {
          if (val === null || val === "") {
            model.value = null;
            _inputText.value = null;
          } else if (!isNaN(Number(val)) && Number(val) <= props.max && Number(val) >= props.min) {
            model.value = Number(val);
            _inputText.value = val;
          }
        }
      });
      const canIncrease = computed2(() => {
        var _a3;
        if (controlsDisabled.value)
          return false;
        return ((_a3 = model.value) != null ? _a3 : 0) + props.step <= props.max;
      });
      const canDecrease = computed2(() => {
        var _a3;
        if (controlsDisabled.value)
          return false;
        return ((_a3 = model.value) != null ? _a3 : 0) - props.step >= props.min;
      });
      const controlVariant = computed2(() => {
        return props.hideInput ? "stacked" : props.controlVariant;
      });
      const incrementIcon = toRef(() => controlVariant.value === "split" ? "$plus" : "$collapse");
      const decrementIcon = toRef(() => controlVariant.value === "split" ? "$minus" : "$expand");
      const controlNodeSize = toRef(() => controlVariant.value === "split" ? "default" : "small");
      const controlNodeDefaultHeight = toRef(() => controlVariant.value === "stacked" ? "auto" : "100%");
      const incrementSlotProps = {
        props: {
          onClick: onControlClick,
          onPointerup: onControlMouseup,
          onPointerdown: onUpControlMousedown,
          onPointercancel: onControlPointerCancel
        }
      };
      const decrementSlotProps = {
        props: {
          onClick: onControlClick,
          onPointerup: onControlMouseup,
          onPointerdown: onDownControlMousedown,
          onPointercancel: onControlPointerCancel
        }
      };
      watch2(() => props.precision, () => formatInputValue());
      onMounted(() => {
        clampModel();
      });
      function inferPrecision(value) {
        if (value == null)
          return 0;
        const str = value.toString();
        const idx = str.indexOf(".");
        return ~idx ? str.length - idx : 0;
      }
      function toggleUpDown() {
        let increment = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        if (controlsDisabled.value)
          return;
        if (model.value == null) {
          inputText.value = correctPrecision(clamp(0, props.min, props.max));
          return;
        }
        let inferredPrecision = Math.max(inferPrecision(model.value), inferPrecision(props.step));
        if (props.precision != null)
          inferredPrecision = Math.max(inferredPrecision, props.precision);
        if (increment) {
          if (canIncrease.value)
            inputText.value = correctPrecision(model.value + props.step, inferredPrecision);
        } else {
          if (canDecrease.value)
            inputText.value = correctPrecision(model.value - props.step, inferredPrecision);
        }
      }
      function onBeforeinput(e) {
        var _a3;
        if (!e.data)
          return;
        const inputElement = e.target;
        const {
          value: existingTxt,
          selectionStart,
          selectionEnd
        } = inputElement != null ? inputElement : {};
        const potentialNewInputVal = existingTxt ? existingTxt.slice(0, selectionStart) + e.data + existingTxt.slice(selectionEnd) : e.data;
        const potentialNewNumber = extractNumber(potentialNewInputVal, props.precision);
        if (!/^-?(\d+(\.\d*)?|(\.\d+)|\d*|\.)$/.test(potentialNewInputVal)) {
          e.preventDefault();
          inputElement.value = potentialNewNumber;
        }
        if (props.precision == null)
          return;
        if (((_a3 = potentialNewInputVal.split(".")[1]) == null ? void 0 : _a3.length) > props.precision) {
          e.preventDefault();
          inputElement.value = potentialNewNumber;
        }
        if (props.precision === 0 && potentialNewInputVal.includes(".")) {
          e.preventDefault();
          inputElement.value = potentialNewNumber;
        }
      }
      async function onKeydown(e) {
        if (["Enter", "ArrowLeft", "ArrowRight", "Backspace", "Delete", "Tab"].includes(e.key) || e.ctrlKey)
          return;
        if (["ArrowDown", "ArrowUp"].includes(e.key)) {
          e.preventDefault();
          clampModel();
          await nextTick();
          if (e.key === "ArrowDown") {
            toggleUpDown(false);
          } else {
            toggleUpDown();
          }
        }
      }
      function onControlClick(e) {
        e.stopPropagation();
      }
      function onControlMouseup(e) {
        const el = e.currentTarget;
        el == null ? void 0 : el.releasePointerCapture(e.pointerId);
        e.preventDefault();
        e.stopPropagation();
        holdStop();
      }
      function onUpControlMousedown(e) {
        const el = e.currentTarget;
        el == null ? void 0 : el.setPointerCapture(e.pointerId);
        e.preventDefault();
        e.stopPropagation();
        holdStart("up");
      }
      function onDownControlMousedown(e) {
        const el = e.currentTarget;
        el == null ? void 0 : el.setPointerCapture(e.pointerId);
        e.preventDefault();
        e.stopPropagation();
        holdStart("down");
      }
      function onControlPointerCancel(e) {
        const el = e.currentTarget;
        el == null ? void 0 : el.releasePointerCapture(e.pointerId);
        holdStop();
      }
      function clampModel() {
        if (controlsDisabled.value)
          return;
        if (!vTextFieldRef.value)
          return;
        const actualText = vTextFieldRef.value.value;
        if (actualText && !isNaN(Number(actualText))) {
          inputText.value = correctPrecision(clamp(Number(actualText), props.min, props.max));
        } else {
          inputText.value = null;
        }
      }
      function formatInputValue() {
        if (controlsDisabled.value)
          return;
        if (model.value === null || isNaN(model.value)) {
          inputText.value = null;
          return;
        }
        inputText.value = props.precision == null ? String(model.value) : model.value.toFixed(props.precision);
      }
      function trimDecimalZeros() {
        if (controlsDisabled.value)
          return;
        if (model.value === null || isNaN(model.value)) {
          inputText.value = null;
          return;
        }
        inputText.value = model.value.toString();
      }
      function onFocus() {
        trimDecimalZeros();
      }
      function onBlur() {
        clampModel();
      }
      useRender(() => {
        const _a3 = VTextField.filterProps(props), {
          modelValue: _2
        } = _a3, textFieldProps = __objRest(_a3, [
          "modelValue"
        ]);
        function incrementControlNode() {
          return !slots.increment ? createVNode(VBtn, {
            "aria-hidden": "true",
            "data-testid": "increment",
            "disabled": !canIncrease.value,
            "flat": true,
            "height": controlNodeDefaultHeight.value,
            "icon": incrementIcon.value,
            "key": "increment-btn",
            "onClick": onControlClick,
            "onPointerdown": onUpControlMousedown,
            "onPointerup": onControlMouseup,
            "onPointercancel": onControlPointerCancel,
            "size": controlNodeSize.value,
            "tabindex": "-1"
          }, null) : createVNode(VDefaultsProvider, {
            "key": "increment-defaults",
            "defaults": {
              VBtn: {
                disabled: !canIncrease.value,
                flat: true,
                height: controlNodeDefaultHeight.value,
                size: controlNodeSize.value,
                icon: incrementIcon.value
              }
            }
          }, {
            default: () => [slots.increment(incrementSlotProps)]
          });
        }
        function decrementControlNode() {
          return !slots.decrement ? createVNode(VBtn, {
            "aria-hidden": "true",
            "data-testid": "decrement",
            "disabled": !canDecrease.value,
            "flat": true,
            "height": controlNodeDefaultHeight.value,
            "icon": decrementIcon.value,
            "key": "decrement-btn",
            "onClick": onControlClick,
            "onPointerdown": onDownControlMousedown,
            "onPointerup": onControlMouseup,
            "onPointercancel": onControlPointerCancel,
            "size": controlNodeSize.value,
            "tabindex": "-1"
          }, null) : createVNode(VDefaultsProvider, {
            "key": "decrement-defaults",
            "defaults": {
              VBtn: {
                disabled: !canDecrease.value,
                flat: true,
                height: controlNodeDefaultHeight.value,
                size: controlNodeSize.value,
                icon: decrementIcon.value
              }
            }
          }, {
            default: () => [slots.decrement(decrementSlotProps)]
          });
        }
        function controlNode() {
          return createBaseVNode("div", {
            "class": "v-number-input__control"
          }, [decrementControlNode(), createVNode(VDivider, {
            "vertical": controlVariant.value !== "stacked"
          }, null), incrementControlNode()]);
        }
        function dividerNode() {
          return !props.hideInput && !props.inset ? createVNode(VDivider, {
            "vertical": true
          }, null) : void 0;
        }
        const appendInnerControl = controlVariant.value === "split" ? createBaseVNode("div", {
          "class": "v-number-input__control"
        }, [createVNode(VDivider, {
          "vertical": true
        }, null), incrementControlNode()]) : props.reverse || controlVariant.value === "hidden" ? void 0 : createBaseVNode(Fragment, null, [dividerNode(), controlNode()]);
        const hasAppendInner = slots["append-inner"] || appendInnerControl;
        const prependInnerControl = controlVariant.value === "split" ? createBaseVNode("div", {
          "class": "v-number-input__control"
        }, [decrementControlNode(), createVNode(VDivider, {
          "vertical": true
        }, null)]) : props.reverse && controlVariant.value !== "hidden" ? createBaseVNode(Fragment, null, [controlNode(), dividerNode()]) : void 0;
        const hasPrependInner = slots["prepend-inner"] || prependInnerControl;
        return createVNode(VTextField, mergeProps({
          "ref": vTextFieldRef
        }, textFieldProps, {
          "modelValue": inputText.value,
          "onUpdate:modelValue": ($event) => inputText.value = $event,
          "focused": isFocused.value,
          "onUpdate:focused": ($event) => isFocused.value = $event,
          "validationValue": model.value,
          "onBeforeinput": onBeforeinput,
          "onFocus": onFocus,
          "onBlur": onBlur,
          "onKeydown": onKeydown,
          "class": ["v-number-input", {
            "v-number-input--default": controlVariant.value === "default",
            "v-number-input--hide-input": props.hideInput,
            "v-number-input--inset": props.inset,
            "v-number-input--reverse": props.reverse,
            "v-number-input--split": controlVariant.value === "split",
            "v-number-input--stacked": controlVariant.value === "stacked"
          }, props.class],
          "style": props.style,
          "inputmode": "decimal"
        }), __spreadProps(__spreadValues({}, slots), {
          "append-inner": hasAppendInner ? function() {
            var _a4;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return createBaseVNode(Fragment, null, [(_a4 = slots["append-inner"]) == null ? void 0 : _a4.call(slots, ...args), appendInnerControl]);
          } : void 0,
          "prepend-inner": hasPrependInner ? function() {
            var _a4;
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }
            return createBaseVNode(Fragment, null, [prependInnerControl, (_a4 = slots["prepend-inner"]) == null ? void 0 : _a4.call(slots, ...args)]);
          } : void 0
        }));
      });
      return forwardRefs({}, vTextFieldRef);
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VOtpInput/VOtpInput.js
  var makeVOtpInputProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({
    autofocus: Boolean,
    divider: String,
    focusAll: Boolean,
    label: {
      type: String,
      default: "$vuetify.input.otp"
    },
    length: {
      type: [Number, String],
      default: 6
    },
    modelValue: {
      type: [Number, String],
      default: void 0
    },
    placeholder: String,
    type: {
      type: String,
      default: "number"
    }
  }, makeDimensionProps()), makeFocusProps()), pick(makeVFieldProps({
    variant: "outlined"
  }), ["baseColor", "bgColor", "class", "color", "disabled", "error", "loading", "rounded", "style", "theme", "variant"])), "VOtpInput");
  var VOtpInput = genericComponent()({
    name: "VOtpInput",
    props: makeVOtpInputProps(),
    emits: {
      finish: (val) => true,
      "update:focused": (val) => true,
      "update:modelValue": (val) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        emit: emit2,
        slots
      } = _ref;
      const {
        dimensionStyles
      } = useDimension(props);
      const {
        isFocused,
        focus,
        blur
      } = useFocus(props);
      const model = useProxiedModel(props, "modelValue", "", (val) => val == null ? [] : String(val).split(""), (val) => val.join(""));
      const {
        t
      } = useLocale();
      const length = computed2(() => Number(props.length));
      const fields = computed2(() => Array(length.value).fill(0));
      const focusIndex = ref(-1);
      const contentRef = ref();
      const inputRef = ref([]);
      const current = computed2(() => inputRef.value[focusIndex.value]);
      const intersectScope = effectScope();
      intersectScope.run(() => {
        const {
          intersectionRef,
          isIntersecting
        } = useIntersectionObserver();
        watch2(isIntersecting, (v) => {
          var _a3;
          if (!v)
            return;
          (_a3 = intersectionRef.value) == null ? void 0 : _a3.focus();
          intersectScope.stop();
        });
        watchEffect(() => {
          intersectionRef.value = inputRef.value[0];
        });
      });
      function onInput() {
        if (isValidNumber(current.value.value)) {
          current.value.value = "";
          return;
        }
        const array = model.value.slice();
        const value = current.value.value;
        array[focusIndex.value] = value;
        let target = null;
        if (focusIndex.value > model.value.length) {
          target = model.value.length + 1;
        } else if (focusIndex.value + 1 !== length.value) {
          target = "next";
        }
        model.value = array;
        if (target)
          focusChild(contentRef.value, target);
      }
      function onKeydown(e) {
        const array = model.value.slice();
        const index = focusIndex.value;
        let target = null;
        if (!["ArrowLeft", "ArrowRight", "Backspace", "Delete"].includes(e.key))
          return;
        e.preventDefault();
        if (e.key === "ArrowLeft") {
          target = "prev";
        } else if (e.key === "ArrowRight") {
          target = "next";
        } else if (["Backspace", "Delete"].includes(e.key)) {
          array[focusIndex.value] = "";
          model.value = array;
          if (focusIndex.value > 0 && e.key === "Backspace") {
            target = "prev";
          } else {
            requestAnimationFrame(() => {
              var _a3;
              (_a3 = inputRef.value[index]) == null ? void 0 : _a3.select();
            });
          }
        }
        requestAnimationFrame(() => {
          if (target != null) {
            focusChild(contentRef.value, target);
          }
        });
      }
      function onPaste(index, e) {
        var _a3, _b, _c;
        e.preventDefault();
        e.stopPropagation();
        const clipboardText = (_b = (_a3 = e == null ? void 0 : e.clipboardData) == null ? void 0 : _a3.getData("Text").trim().slice(0, length.value)) != null ? _b : "";
        if (isValidNumber(clipboardText))
          return;
        model.value = clipboardText.split("");
        (_c = inputRef.value) == null ? void 0 : _c[index].blur();
      }
      function reset() {
        model.value = [];
      }
      function onFocus(e, index) {
        focus();
        focusIndex.value = index;
      }
      function onBlur() {
        blur();
        focusIndex.value = -1;
      }
      function isValidNumber(value) {
        return props.type === "number" && /[^0-9]/g.test(value);
      }
      provideDefaults({
        VField: {
          color: toRef(() => props.color),
          bgColor: toRef(() => props.color),
          baseColor: toRef(() => props.baseColor),
          disabled: toRef(() => props.disabled),
          error: toRef(() => props.error),
          variant: toRef(() => props.variant)
        }
      }, {
        scoped: true
      });
      watch2(model, (val) => {
        if (val.length === length.value) {
          focusIndex.value = length.value - 1;
          emit2("finish", val.join(""));
        }
      }, {
        deep: true
      });
      watch2(focusIndex, (val) => {
        if (val < 0)
          return;
        nextTick(() => {
          var _a3;
          (_a3 = inputRef.value[val]) == null ? void 0 : _a3.select();
        });
      });
      useRender(() => {
        var _a3;
        const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
        return createBaseVNode("div", mergeProps({
          "class": ["v-otp-input", {
            "v-otp-input--divided": !!props.divider
          }, props.class],
          "style": [props.style]
        }, rootAttrs), [createBaseVNode("div", {
          "ref": contentRef,
          "class": "v-otp-input__content",
          "style": normalizeStyle([dimensionStyles.value])
        }, [fields.value.map((_2, i) => createBaseVNode(Fragment, null, [props.divider && i !== 0 && createBaseVNode("span", {
          "class": "v-otp-input__divider"
        }, [props.divider]), createVNode(VField, {
          "focused": isFocused.value && props.focusAll || focusIndex.value === i,
          "key": i
        }, __spreadProps(__spreadValues({}, slots), {
          loader: void 0,
          default: () => {
            return createBaseVNode("input", {
              "ref": (val) => inputRef.value[i] = val,
              "aria-label": t(props.label, i + 1),
              "autofocus": i === 0 && props.autofocus,
              "autocomplete": "one-time-code",
              "class": normalizeClass(["v-otp-input__field"]),
              "disabled": props.disabled,
              "inputmode": props.type === "number" ? "numeric" : "text",
              "min": props.type === "number" ? 0 : void 0,
              "maxlength": i === 0 ? length.value : "1",
              "placeholder": props.placeholder,
              "type": props.type === "number" ? "text" : props.type,
              "value": model.value[i],
              "onInput": onInput,
              "onFocus": (e) => onFocus(e, i),
              "onBlur": onBlur,
              "onKeydown": onKeydown,
              "onPaste": (event2) => onPaste(i, event2)
            }, null);
          }
        }))])), createBaseVNode("input", mergeProps({
          "class": "v-otp-input-input",
          "type": "hidden"
        }, inputAttrs, {
          "value": model.value.join("")
        }), null), createVNode(VOverlay, {
          "contained": true,
          "content-class": "v-otp-input__loader",
          "model-value": !!props.loading,
          "persistent": true
        }, {
          default: () => {
            var _a4, _b;
            return [(_b = (_a4 = slots.loader) == null ? void 0 : _a4.call(slots)) != null ? _b : createVNode(VProgressCircular, {
              "color": typeof props.loading === "boolean" ? void 0 : props.loading,
              "indeterminate": true,
              "size": "24",
              "width": "2"
            }, null)];
          }
        }), (_a3 = slots.default) == null ? void 0 : _a3.call(slots)])]);
      });
      return {
        blur: () => {
          var _a3;
          (_a3 = inputRef.value) == null ? void 0 : _a3.some((input) => input.blur());
        },
        focus: () => {
          var _a3;
          (_a3 = inputRef.value) == null ? void 0 : _a3[0].focus();
        },
        reset,
        isFocused
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VParallax/VParallax.js
  function floor(val) {
    return Math.floor(Math.abs(val)) * Math.sign(val);
  }
  var makeVParallaxProps = propsFactory(__spreadValues({
    scale: {
      type: [Number, String],
      default: 0.5
    }
  }, makeComponentProps()), "VParallax");
  var VParallax = genericComponent()({
    name: "VParallax",
    props: makeVParallaxProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        intersectionRef,
        isIntersecting
      } = useIntersectionObserver();
      const {
        resizeRef,
        contentRect
      } = useResizeObserver();
      const {
        height: displayHeight
      } = useDisplay();
      const root = ref();
      watchEffect(() => {
        var _a3;
        intersectionRef.value = resizeRef.value = (_a3 = root.value) == null ? void 0 : _a3.$el;
      });
      let scrollParent;
      watch2(isIntersecting, (val) => {
        if (val) {
          scrollParent = getScrollParent(intersectionRef.value);
          scrollParent = scrollParent === document.scrollingElement ? document : scrollParent;
          scrollParent.addEventListener("scroll", onScroll, {
            passive: true
          });
          onScroll();
        } else {
          scrollParent.removeEventListener("scroll", onScroll);
        }
      });
      onBeforeUnmount(() => {
        scrollParent == null ? void 0 : scrollParent.removeEventListener("scroll", onScroll);
      });
      watch2(displayHeight, onScroll);
      watch2(() => {
        var _a3;
        return (_a3 = contentRect.value) == null ? void 0 : _a3.height;
      }, onScroll);
      const scale = computed2(() => {
        return 1 - clamp(Number(props.scale));
      });
      let frame = -1;
      function onScroll() {
        if (!isIntersecting.value)
          return;
        cancelAnimationFrame(frame);
        frame = requestAnimationFrame(() => {
          var _a3;
          const el = ((_a3 = root.value) == null ? void 0 : _a3.$el).querySelector(".v-img__img");
          if (!el)
            return;
          const scrollHeight = scrollParent instanceof Document ? document.documentElement.clientHeight : scrollParent.clientHeight;
          const scrollPos = scrollParent instanceof Document ? window.scrollY : scrollParent.scrollTop;
          const top = intersectionRef.value.getBoundingClientRect().top + scrollPos;
          const height = contentRect.value.height;
          const center = top + (height - scrollHeight) / 2;
          const translate = floor((scrollPos - center) * scale.value);
          const sizeScale = Math.max(1, (scale.value * (scrollHeight - height) + height) / height);
          el.style.setProperty("transform", `translateY(${translate}px) scale(${sizeScale})`);
        });
      }
      useRender(() => createVNode(VImg, {
        "class": normalizeClass(["v-parallax", {
          "v-parallax--active": isIntersecting.value
        }, props.class]),
        "style": normalizeStyle(props.style),
        "ref": root,
        "cover": true,
        "onLoadstart": onScroll,
        "onLoad": onScroll
      }, slots));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VRadio/VRadio.js
  var makeVRadioProps = propsFactory(__spreadValues({}, makeVSelectionControlProps({
    falseIcon: "$radioOff",
    trueIcon: "$radioOn"
  })), "VRadio");
  var VRadio = genericComponent()({
    name: "VRadio",
    props: makeVRadioProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => {
        const controlProps = VSelectionControl.filterProps(props);
        return createVNode(VSelectionControl, mergeProps(controlProps, {
          "class": ["v-radio", props.class],
          "style": props.style,
          "type": "radio"
        }), slots);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VRadioGroup/VRadioGroup.js
  var makeVRadioGroupProps = propsFactory(__spreadProps(__spreadValues(__spreadValues({
    height: {
      type: [Number, String],
      default: "auto"
    }
  }, makeVInputProps()), omit(makeSelectionControlGroupProps(), ["multiple"])), {
    trueIcon: {
      type: IconValue,
      default: "$radioOn"
    },
    falseIcon: {
      type: IconValue,
      default: "$radioOff"
    },
    type: {
      type: String,
      default: "radio"
    }
  }), "VRadioGroup");
  var VRadioGroup = genericComponent()({
    name: "VRadioGroup",
    inheritAttrs: false,
    props: makeVRadioGroupProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const uid2 = useId();
      const id = computed2(() => props.id || `radio-group-${uid2}`);
      const model = useProxiedModel(props, "modelValue");
      useRender(() => {
        const [rootAttrs, controlAttrs] = filterInputAttrs(attrs);
        const inputProps = VInput.filterProps(props);
        const controlProps = VSelectionControl.filterProps(props);
        const label = slots.label ? slots.label({
          label: props.label,
          props: {
            for: id.value
          }
        }) : props.label;
        return createVNode(VInput, mergeProps({
          "class": ["v-radio-group", props.class],
          "style": props.style
        }, rootAttrs, inputProps, {
          "modelValue": model.value,
          "onUpdate:modelValue": ($event) => model.value = $event,
          "id": id.value
        }), __spreadProps(__spreadValues({}, slots), {
          default: (_ref2) => {
            let {
              id: id2,
              messagesId,
              isDisabled,
              isReadonly: isReadonly2
            } = _ref2;
            return createBaseVNode(Fragment, null, [label && createVNode(VLabel, {
              "id": id2.value
            }, {
              default: () => [label]
            }), createVNode(VSelectionControlGroup, mergeProps(controlProps, {
              "id": id2.value,
              "aria-describedby": messagesId.value,
              "defaultsTarget": "VRadio",
              "trueIcon": props.trueIcon,
              "falseIcon": props.falseIcon,
              "type": props.type,
              "disabled": isDisabled.value,
              "readonly": isReadonly2.value,
              "aria-labelledby": label ? id2.value : void 0,
              "multiple": false
            }, controlAttrs, {
              "modelValue": model.value,
              "onUpdate:modelValue": ($event) => model.value = $event
            }), slots)]);
          }
        }));
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VRangeSlider/VRangeSlider.js
  var makeVRangeSliderProps = propsFactory(__spreadProps(__spreadValues(__spreadValues(__spreadValues({}, makeFocusProps()), makeVInputProps()), makeSliderProps()), {
    strict: Boolean,
    modelValue: {
      type: Array,
      default: () => [0, 0]
    }
  }), "VRangeSlider");
  var VRangeSlider = genericComponent()({
    name: "VRangeSlider",
    props: makeVRangeSliderProps(),
    emits: {
      "update:focused": (value) => true,
      "update:modelValue": (value) => true,
      end: (value) => true,
      start: (value) => true
    },
    setup(props, _ref) {
      let {
        slots,
        emit: emit2
      } = _ref;
      const startThumbRef = ref();
      const stopThumbRef = ref();
      const inputRef = ref();
      const {
        rtlClasses
      } = useRtl();
      function getActiveThumb(e) {
        if (!startThumbRef.value || !stopThumbRef.value)
          return;
        const startOffset = getOffset3(e, startThumbRef.value.$el, props.direction);
        const stopOffset = getOffset3(e, stopThumbRef.value.$el, props.direction);
        const a = Math.abs(startOffset);
        const b = Math.abs(stopOffset);
        return a < b || a === b && startOffset < 0 ? startThumbRef.value.$el : stopThumbRef.value.$el;
      }
      const steps = useSteps(props);
      const model = useProxiedModel(props, "modelValue", void 0, (arr) => {
        if (!(arr == null ? void 0 : arr.length))
          return [0, 0];
        return arr.map((value) => steps.roundValue(value));
      });
      const {
        activeThumbRef,
        hasLabels,
        max,
        min,
        mousePressed,
        onSliderMousedown,
        onSliderTouchstart,
        position,
        trackContainerRef,
        readonly: readonly2
      } = useSlider({
        props,
        steps,
        onSliderStart: () => {
          emit2("start", model.value);
        },
        onSliderEnd: (_ref2) => {
          var _a3;
          let {
            value
          } = _ref2;
          const newValue = activeThumbRef.value === ((_a3 = startThumbRef.value) == null ? void 0 : _a3.$el) ? [value, model.value[1]] : [model.value[0], value];
          if (!props.strict && newValue[0] < newValue[1]) {
            model.value = newValue;
          }
          emit2("end", model.value);
        },
        onSliderMove: (_ref3) => {
          var _a3, _b, _c, _d;
          let {
            value
          } = _ref3;
          const [start, stop2] = model.value;
          if (!props.strict && start === stop2 && start !== min.value) {
            activeThumbRef.value = value > start ? (_a3 = stopThumbRef.value) == null ? void 0 : _a3.$el : (_b = startThumbRef.value) == null ? void 0 : _b.$el;
            (_c = activeThumbRef.value) == null ? void 0 : _c.focus();
          }
          if (activeThumbRef.value === ((_d = startThumbRef.value) == null ? void 0 : _d.$el)) {
            model.value = [Math.min(value, stop2), stop2];
          } else {
            model.value = [start, Math.max(start, value)];
          }
        },
        getActiveThumb
      });
      const {
        isFocused,
        focus,
        blur
      } = useFocus(props);
      const trackStart = computed2(() => position(model.value[0]));
      const trackStop = computed2(() => position(model.value[1]));
      useRender(() => {
        const inputProps = VInput.filterProps(props);
        const hasPrepend = !!(props.label || slots.label || slots.prepend);
        return createVNode(VInput, mergeProps({
          "class": ["v-slider", "v-range-slider", {
            "v-slider--has-labels": !!slots["tick-label"] || hasLabels.value,
            "v-slider--focused": isFocused.value,
            "v-slider--pressed": mousePressed.value,
            "v-slider--disabled": props.disabled
          }, rtlClasses.value, props.class],
          "style": props.style,
          "ref": inputRef
        }, inputProps, {
          "focused": isFocused.value
        }), __spreadProps(__spreadValues({}, slots), {
          prepend: hasPrepend ? (slotProps) => {
            var _a3, _b, _c;
            return createBaseVNode(Fragment, null, [(_b = (_a3 = slots.label) == null ? void 0 : _a3.call(slots, slotProps)) != null ? _b : props.label ? createVNode(VLabel, {
              "class": "v-slider__label",
              "text": props.label
            }, null) : void 0, (_c = slots.prepend) == null ? void 0 : _c.call(slots, slotProps)]);
          } : void 0,
          default: (_ref4) => {
            var _a3, _b;
            let {
              id,
              messagesId
            } = _ref4;
            return createBaseVNode("div", {
              "class": "v-slider__container",
              "onMousedown": !readonly2.value ? onSliderMousedown : void 0,
              "onTouchstartPassive": !readonly2.value ? onSliderTouchstart : void 0
            }, [createBaseVNode("input", {
              "id": `${id.value}_start`,
              "name": props.name || id.value,
              "disabled": !!props.disabled,
              "readonly": !!props.readonly,
              "tabindex": "-1",
              "value": model.value[0]
            }, null), createBaseVNode("input", {
              "id": `${id.value}_stop`,
              "name": props.name || id.value,
              "disabled": !!props.disabled,
              "readonly": !!props.readonly,
              "tabindex": "-1",
              "value": model.value[1]
            }, null), createVNode(VSliderTrack, {
              "ref": trackContainerRef,
              "start": trackStart.value,
              "stop": trackStop.value
            }, {
              "tick-label": slots["tick-label"]
            }), createVNode(VSliderThumb, {
              "ref": startThumbRef,
              "aria-describedby": messagesId.value,
              "focused": isFocused && activeThumbRef.value === ((_a3 = startThumbRef.value) == null ? void 0 : _a3.$el),
              "modelValue": model.value[0],
              "onUpdate:modelValue": (v) => model.value = [v, model.value[1]],
              "onFocus": (e) => {
                var _a4, _b2, _c, _d;
                focus();
                activeThumbRef.value = (_a4 = startThumbRef.value) == null ? void 0 : _a4.$el;
                if (max.value !== min.value && model.value[0] === model.value[1] && model.value[1] === min.value && e.relatedTarget !== ((_b2 = stopThumbRef.value) == null ? void 0 : _b2.$el)) {
                  (_c = startThumbRef.value) == null ? void 0 : _c.$el.blur();
                  (_d = stopThumbRef.value) == null ? void 0 : _d.$el.focus();
                }
              },
              "onBlur": () => {
                blur();
                activeThumbRef.value = void 0;
              },
              "min": min.value,
              "max": model.value[1],
              "position": trackStart.value,
              "ripple": props.ripple
            }, {
              "thumb-label": slots["thumb-label"]
            }), createVNode(VSliderThumb, {
              "ref": stopThumbRef,
              "aria-describedby": messagesId.value,
              "focused": isFocused && activeThumbRef.value === ((_b = stopThumbRef.value) == null ? void 0 : _b.$el),
              "modelValue": model.value[1],
              "onUpdate:modelValue": (v) => model.value = [model.value[0], v],
              "onFocus": (e) => {
                var _a4, _b2, _c, _d;
                focus();
                activeThumbRef.value = (_a4 = stopThumbRef.value) == null ? void 0 : _a4.$el;
                if (max.value !== min.value && model.value[0] === model.value[1] && model.value[0] === max.value && e.relatedTarget !== ((_b2 = startThumbRef.value) == null ? void 0 : _b2.$el)) {
                  (_c = stopThumbRef.value) == null ? void 0 : _c.$el.blur();
                  (_d = startThumbRef.value) == null ? void 0 : _d.$el.focus();
                }
              },
              "onBlur": () => {
                blur();
                activeThumbRef.value = void 0;
              },
              "min": model.value[0],
              "max": max.value,
              "position": trackStop.value,
              "ripple": props.ripple
            }, {
              "thumb-label": slots["thumb-label"]
            })]);
          }
        }));
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VRating/VRating.js
  var makeVRatingProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    name: String,
    itemAriaLabel: {
      type: String,
      default: "$vuetify.rating.ariaLabel.item"
    },
    activeColor: String,
    color: String,
    clearable: Boolean,
    disabled: Boolean,
    emptyIcon: {
      type: IconValue,
      default: "$ratingEmpty"
    },
    fullIcon: {
      type: IconValue,
      default: "$ratingFull"
    },
    halfIncrements: Boolean,
    hover: Boolean,
    length: {
      type: [Number, String],
      default: 5
    },
    readonly: Boolean,
    modelValue: {
      type: [Number, String],
      default: 0
    },
    itemLabels: Array,
    itemLabelPosition: {
      type: String,
      default: "top",
      validator: (v) => ["top", "bottom"].includes(v)
    },
    ripple: Boolean
  }, makeComponentProps()), makeDensityProps()), makeSizeProps()), makeTagProps()), makeThemeProps()), "VRating");
  var VRating = genericComponent()({
    name: "VRating",
    props: makeVRatingProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        t
      } = useLocale();
      const {
        themeClasses
      } = provideTheme(props);
      const rating = useProxiedModel(props, "modelValue");
      const normalizedValue = computed2(() => clamp(parseFloat(rating.value), 0, Number(props.length)));
      const range = computed2(() => createRange(Number(props.length), 1));
      const increments = computed2(() => range.value.flatMap((v) => props.halfIncrements ? [v - 0.5, v] : [v]));
      const hoverIndex = shallowRef(-1);
      const itemState = computed2(() => increments.value.map((value) => {
        var _a3;
        const isHovering = props.hover && hoverIndex.value > -1;
        const isFilled = normalizedValue.value >= value;
        const isHovered = hoverIndex.value >= value;
        const isFullIcon = isHovering ? isHovered : isFilled;
        const icon = isFullIcon ? props.fullIcon : props.emptyIcon;
        const activeColor = (_a3 = props.activeColor) != null ? _a3 : props.color;
        const color = isFilled || isHovered ? activeColor : props.color;
        return {
          isFilled,
          isHovered,
          icon,
          color
        };
      }));
      const eventState = computed2(() => [0, ...increments.value].map((value) => {
        function onMouseenter() {
          hoverIndex.value = value;
        }
        function onMouseleave() {
          hoverIndex.value = -1;
        }
        function onClick() {
          if (props.disabled || props.readonly)
            return;
          rating.value = normalizedValue.value === value && props.clearable ? 0 : value;
        }
        return {
          onMouseenter: props.hover ? onMouseenter : void 0,
          onMouseleave: props.hover ? onMouseleave : void 0,
          onClick
        };
      }));
      const uid2 = useId();
      const name = computed2(() => {
        var _a3;
        return (_a3 = props.name) != null ? _a3 : `v-rating-${uid2}`;
      });
      function VRatingItem(_ref2) {
        var _a3, _b;
        let {
          value,
          index,
          showStar = true
        } = _ref2;
        const {
          onMouseenter,
          onMouseleave,
          onClick
        } = eventState.value[index + 1];
        const id = `${name.value}-${String(value).replace(".", "-")}`;
        const btnProps = {
          color: (_a3 = itemState.value[index]) == null ? void 0 : _a3.color,
          density: props.density,
          disabled: props.disabled,
          icon: (_b = itemState.value[index]) == null ? void 0 : _b.icon,
          ripple: props.ripple,
          size: props.size,
          variant: "plain"
        };
        return createBaseVNode(Fragment, null, [createBaseVNode("label", {
          "for": id,
          "class": normalizeClass({
            "v-rating__item--half": props.halfIncrements && value % 1 > 0,
            "v-rating__item--full": props.halfIncrements && value % 1 === 0
          }),
          "onMouseenter": onMouseenter,
          "onMouseleave": onMouseleave,
          "onClick": onClick
        }, [createBaseVNode("span", {
          "class": "v-rating__hidden"
        }, [t(props.itemAriaLabel, value, props.length)]), !showStar ? void 0 : slots.item ? slots.item(__spreadProps(__spreadValues({}, itemState.value[index]), {
          props: btnProps,
          value,
          index,
          rating: normalizedValue.value
        })) : createVNode(VBtn, mergeProps({
          "aria-label": t(props.itemAriaLabel, value, props.length)
        }, btnProps), null)]), createBaseVNode("input", {
          "class": "v-rating__hidden",
          "name": name.value,
          "id": id,
          "type": "radio",
          "value": value,
          "checked": normalizedValue.value === value,
          "tabindex": -1,
          "readonly": props.readonly,
          "disabled": props.disabled
        }, null)]);
      }
      function createLabel(labelProps) {
        if (slots["item-label"])
          return slots["item-label"](labelProps);
        if (labelProps.label)
          return createBaseVNode("span", null, [labelProps.label]);
        return createBaseVNode("span", null, [createTextVNode("\xA0")]);
      }
      useRender(() => {
        var _a3;
        const hasLabels = !!((_a3 = props.itemLabels) == null ? void 0 : _a3.length) || slots["item-label"];
        return createVNode(props.tag, {
          "class": normalizeClass(["v-rating", {
            "v-rating--hover": props.hover,
            "v-rating--readonly": props.readonly
          }, themeClasses.value, props.class]),
          "style": normalizeStyle(props.style)
        }, {
          default: () => [createVNode(VRatingItem, {
            "value": 0,
            "index": -1,
            "showStar": false
          }, null), range.value.map((value, i) => {
            var _a4, _b;
            return createBaseVNode("div", {
              "class": "v-rating__wrapper"
            }, [hasLabels && props.itemLabelPosition === "top" ? createLabel({
              value,
              index: i,
              label: (_a4 = props.itemLabels) == null ? void 0 : _a4[i]
            }) : void 0, createBaseVNode("div", {
              "class": "v-rating__item"
            }, [props.halfIncrements ? createBaseVNode(Fragment, null, [createVNode(VRatingItem, {
              "value": value - 0.5,
              "index": i * 2
            }, null), createVNode(VRatingItem, {
              "value": value,
              "index": i * 2 + 1
            }, null)]) : createVNode(VRatingItem, {
              "value": value,
              "index": i
            }, null)]), hasLabels && props.itemLabelPosition === "bottom" ? createLabel({
              value,
              index: i,
              label: (_b = props.itemLabels) == null ? void 0 : _b[i]
            }) : void 0]);
          })]
        });
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VSkeletonLoader/VSkeletonLoader.js
  var rootTypes = {
    actions: "button@2",
    article: "heading, paragraph",
    avatar: "avatar",
    button: "button",
    card: "image, heading",
    "card-avatar": "image, list-item-avatar",
    chip: "chip",
    "date-picker": "list-item, heading, divider, date-picker-options, date-picker-days, actions",
    "date-picker-options": "text, avatar@2",
    "date-picker-days": "avatar@28",
    divider: "divider",
    heading: "heading",
    image: "image",
    "list-item": "text",
    "list-item-avatar": "avatar, text",
    "list-item-two-line": "sentences",
    "list-item-avatar-two-line": "avatar, sentences",
    "list-item-three-line": "paragraph",
    "list-item-avatar-three-line": "avatar, paragraph",
    ossein: "ossein",
    paragraph: "text@3",
    sentences: "text@2",
    subtitle: "text",
    table: "table-heading, table-thead, table-tbody, table-tfoot",
    "table-heading": "chip, text",
    "table-thead": "heading@6",
    "table-tbody": "table-row-divider@6",
    "table-row-divider": "table-row, divider",
    "table-row": "text@6",
    "table-tfoot": "text@2, avatar@2",
    text: "text"
  };
  function genBone(type) {
    let children = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return createBaseVNode("div", {
      "class": normalizeClass(["v-skeleton-loader__bone", `v-skeleton-loader__${type}`])
    }, [children]);
  }
  function genBones(bone) {
    const [type, length] = bone.split("@");
    return Array.from({
      length
    }).map(() => genStructure(type));
  }
  function genStructure(type) {
    let children = [];
    if (!type)
      return children;
    const bone = rootTypes[type];
    if (type === bone) {
    } else if (type.includes(","))
      return mapBones(type);
    else if (type.includes("@"))
      return genBones(type);
    else if (bone.includes(","))
      children = mapBones(bone);
    else if (bone.includes("@"))
      children = genBones(bone);
    else if (bone)
      children.push(genStructure(bone));
    return [genBone(type, children)];
  }
  function mapBones(bones) {
    return bones.replace(/\s/g, "").split(",").map(genStructure);
  }
  var makeVSkeletonLoaderProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({
    boilerplate: Boolean,
    color: String,
    loading: Boolean,
    loadingText: {
      type: String,
      default: "$vuetify.loading"
    },
    type: {
      type: [String, Array],
      default: "ossein"
    }
  }, makeDimensionProps()), makeElevationProps()), makeThemeProps()), "VSkeletonLoader");
  var VSkeletonLoader = genericComponent()({
    name: "VSkeletonLoader",
    props: makeVSkeletonLoaderProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(() => props.color);
      const {
        dimensionStyles
      } = useDimension(props);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        themeClasses
      } = provideTheme(props);
      const {
        t
      } = useLocale();
      const items = computed2(() => genStructure(wrapInArray(props.type).join(",")));
      useRender(() => {
        var _a3;
        const isLoading = !slots.default || props.loading;
        const loadingProps = props.boilerplate || !isLoading ? {} : {
          ariaLive: "polite",
          ariaLabel: t(props.loadingText),
          role: "alert"
        };
        return createBaseVNode("div", mergeProps({
          "class": ["v-skeleton-loader", {
            "v-skeleton-loader--boilerplate": props.boilerplate
          }, themeClasses.value, backgroundColorClasses.value, elevationClasses.value],
          "style": [backgroundColorStyles.value, isLoading ? dimensionStyles.value : {}]
        }, loadingProps), [isLoading ? items.value : (_a3 = slots.default) == null ? void 0 : _a3.call(slots)]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VSlideGroup/VSlideGroupItem.js
  var VSlideGroupItem = genericComponent()({
    name: "VSlideGroupItem",
    props: makeGroupItemProps(),
    emits: {
      "group:selected": (val) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const slideGroupItem = useGroupItem(props, VSlideGroupSymbol);
      return () => {
        var _a3;
        return (_a3 = slots.default) == null ? void 0 : _a3.call(slots, {
          isSelected: slideGroupItem.isSelected.value,
          select: slideGroupItem.select,
          toggle: slideGroupItem.toggle,
          selectedClass: slideGroupItem.selectedClass.value
        });
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VSnackbar/VSnackbar.js
  function useCountdown(milliseconds) {
    const time = shallowRef(milliseconds());
    let timer = -1;
    function clear() {
      clearInterval(timer);
    }
    function reset() {
      clear();
      nextTick(() => time.value = milliseconds());
    }
    function start(el) {
      const style = el ? getComputedStyle(el) : {
        transitionDuration: 0.2
      };
      const interval = parseFloat(style.transitionDuration) * 1e3 || 200;
      clear();
      if (time.value <= 0)
        return;
      const startTime = performance.now();
      timer = window.setInterval(() => {
        const elapsed = performance.now() - startTime + interval;
        time.value = Math.max(milliseconds() - elapsed, 0);
        if (time.value <= 0)
          clear();
      }, interval);
    }
    onScopeDispose(clear);
    return {
      clear,
      time,
      start,
      reset
    };
  }
  var makeVSnackbarProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    multiLine: Boolean,
    text: String,
    timer: [Boolean, String],
    timeout: {
      type: [Number, String],
      default: 5e3
    },
    vertical: Boolean
  }, makeLocationProps({
    location: "bottom"
  })), makePositionProps()), makeRoundedProps()), makeVariantProps()), makeThemeProps()), omit(makeVOverlayProps({
    transition: "v-snackbar-transition"
  }), ["persistent", "noClickAnimation", "scrim", "scrollStrategy"])), "VSnackbar");
  var VSnackbar = genericComponent()({
    name: "VSnackbar",
    props: makeVSnackbarProps(),
    emits: {
      "update:modelValue": (v) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const isActive = useProxiedModel(props, "modelValue");
      const {
        positionClasses
      } = usePosition(props);
      const {
        scopeId
      } = useScopeId();
      const {
        themeClasses
      } = provideTheme(props);
      const {
        colorClasses,
        colorStyles,
        variantClasses
      } = useVariant(props);
      const {
        roundedClasses
      } = useRounded(props);
      const countdown = useCountdown(() => Number(props.timeout));
      const overlay = ref();
      const timerRef = ref();
      const isHovering = shallowRef(false);
      const startY = shallowRef(0);
      const mainStyles = ref();
      const hasLayout = inject(VuetifyLayoutKey, void 0);
      useToggleScope(() => !!hasLayout, () => {
        const layout = useLayout();
        watchEffect(() => {
          mainStyles.value = layout.mainStyles.value;
        });
      });
      watch2(isActive, startTimeout);
      watch2(() => props.timeout, startTimeout);
      onMounted(() => {
        if (isActive.value)
          startTimeout();
      });
      let activeTimeout = -1;
      function startTimeout() {
        countdown.reset();
        window.clearTimeout(activeTimeout);
        const timeout = Number(props.timeout);
        if (!isActive.value || timeout === -1)
          return;
        const element = refElement(timerRef.value);
        countdown.start(element);
        activeTimeout = window.setTimeout(() => {
          isActive.value = false;
        }, timeout);
      }
      function clearTimeout2() {
        countdown.reset();
        window.clearTimeout(activeTimeout);
      }
      function onPointerenter() {
        isHovering.value = true;
        clearTimeout2();
      }
      function onPointerleave() {
        isHovering.value = false;
        startTimeout();
      }
      function onTouchstart(event2) {
        startY.value = event2.touches[0].clientY;
      }
      function onTouchend(event2) {
        if (Math.abs(startY.value - event2.changedTouches[0].clientY) > 50) {
          isActive.value = false;
        }
      }
      function onAfterLeave() {
        if (isHovering.value)
          onPointerleave();
      }
      const locationClasses = computed2(() => {
        return props.location.split(" ").reduce((acc, loc) => {
          acc[`v-snackbar--${loc}`] = true;
          return acc;
        }, {});
      });
      useRender(() => {
        const overlayProps = VOverlay.filterProps(props);
        const hasContent = !!(slots.default || slots.text || props.text);
        return createVNode(VOverlay, mergeProps({
          "ref": overlay,
          "class": ["v-snackbar", {
            "v-snackbar--active": isActive.value,
            "v-snackbar--multi-line": props.multiLine && !props.vertical,
            "v-snackbar--timer": !!props.timer,
            "v-snackbar--vertical": props.vertical
          }, locationClasses.value, positionClasses.value, props.class],
          "style": [mainStyles.value, props.style]
        }, overlayProps, {
          "modelValue": isActive.value,
          "onUpdate:modelValue": ($event) => isActive.value = $event,
          "contentProps": mergeProps({
            class: ["v-snackbar__wrapper", themeClasses.value, colorClasses.value, roundedClasses.value, variantClasses.value],
            style: [colorStyles.value],
            onPointerenter,
            onPointerleave
          }, overlayProps.contentProps),
          "persistent": true,
          "noClickAnimation": true,
          "scrim": false,
          "scrollStrategy": "none",
          "_disableGlobalStack": true,
          "onTouchstartPassive": onTouchstart,
          "onTouchend": onTouchend,
          "onAfterLeave": onAfterLeave
        }, scopeId), {
          default: () => {
            var _a3, _b, _c;
            return [genOverlays(false, "v-snackbar"), props.timer && !isHovering.value && createBaseVNode("div", {
              "key": "timer",
              "class": "v-snackbar__timer"
            }, [createVNode(VProgressLinear, {
              "ref": timerRef,
              "color": typeof props.timer === "string" ? props.timer : "info",
              "max": props.timeout,
              "model-value": countdown.time.value
            }, null)]), hasContent && createBaseVNode("div", {
              "key": "content",
              "class": "v-snackbar__content",
              "role": "status",
              "aria-live": "polite"
            }, [(_b = (_a3 = slots.text) == null ? void 0 : _a3.call(slots)) != null ? _b : props.text, (_c = slots.default) == null ? void 0 : _c.call(slots)]), slots.actions && createVNode(VDefaultsProvider, {
              "defaults": {
                VBtn: {
                  variant: "text",
                  ripple: false,
                  slim: true
                }
              }
            }, {
              default: () => [createBaseVNode("div", {
                "class": "v-snackbar__actions"
              }, [slots.actions({
                isActive
              })])]
            })];
          },
          activator: slots.activator
        });
      });
      return forwardRefs({}, overlay);
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VSnackbarQueue/VSnackbarQueue.js
  var makeVSnackbarQueueProps = propsFactory(__spreadValues({
    closable: [Boolean, String],
    closeText: {
      type: String,
      default: "$vuetify.dismiss"
    },
    modelValue: {
      type: Array,
      default: () => []
    }
  }, omit(makeVSnackbarProps(), ["modelValue"])), "VSnackbarQueue");
  var VSnackbarQueue = genericComponent()({
    name: "VSnackbarQueue",
    props: makeVSnackbarQueueProps(),
    emits: {
      "update:modelValue": (val) => true
    },
    setup(props, _ref) {
      let {
        emit: emit2,
        slots
      } = _ref;
      const {
        t
      } = useLocale();
      const isActive = shallowRef(false);
      const isVisible = shallowRef(false);
      const current = shallowRef();
      watch2(() => props.modelValue.length, (val, oldVal) => {
        if (!isVisible.value && val > oldVal) {
          showNext();
        }
      });
      watch2(isActive, (val) => {
        if (val)
          isVisible.value = true;
      });
      function onAfterLeave() {
        if (props.modelValue.length) {
          showNext();
        } else {
          current.value = void 0;
          isVisible.value = false;
        }
      }
      function showNext() {
        const [next, ...rest] = props.modelValue;
        emit2("update:modelValue", rest);
        current.value = typeof next === "string" ? {
          text: next
        } : next;
        nextTick(() => {
          isActive.value = true;
        });
      }
      function onClickClose() {
        isActive.value = false;
      }
      const btnProps = computed2(() => ({
        color: typeof props.closable === "string" ? props.closable : void 0,
        text: t(props.closeText)
      }));
      useRender(() => {
        const hasActions = !!(props.closable || slots.actions);
        const _a3 = VSnackbar.filterProps(props), {
          modelValue: _2
        } = _a3, snackbarProps = __objRest(_a3, [
          "modelValue"
        ]);
        return createBaseVNode(Fragment, null, [isVisible.value && !!current.value && (slots.default ? createVNode(VDefaultsProvider, {
          "defaults": {
            VSnackbar: current.value
          }
        }, {
          default: () => [slots.default({
            item: current.value
          })]
        }) : createVNode(VSnackbar, mergeProps(snackbarProps, current.value, {
          "modelValue": isActive.value,
          "onUpdate:modelValue": ($event) => isActive.value = $event,
          "onAfterLeave": onAfterLeave
        }), {
          text: slots.text ? () => {
            var _a4;
            return (_a4 = slots.text) == null ? void 0 : _a4.call(slots, {
              item: current.value
            });
          } : void 0,
          actions: hasActions ? () => createBaseVNode(Fragment, null, [!slots.actions ? createVNode(VBtn, mergeProps(btnProps.value, {
            "onClick": onClickClose
          }), null) : createVNode(VDefaultsProvider, {
            "defaults": {
              VBtn: btnProps.value
            }
          }, {
            default: () => [slots.actions({
              item: current.value,
              props: {
                onClick: onClickClose
              }
            })]
          })]) : void 0
        }))]);
      });
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VSparkline/util/line.js
  var makeLineProps = propsFactory({
    autoDraw: Boolean,
    autoDrawDuration: [Number, String],
    autoDrawEasing: {
      type: String,
      default: "ease"
    },
    color: String,
    gradient: {
      type: Array,
      default: () => []
    },
    gradientDirection: {
      type: String,
      validator: (val) => ["top", "bottom", "left", "right"].includes(val),
      default: "top"
    },
    height: {
      type: [String, Number],
      default: 75
    },
    labels: {
      type: Array,
      default: () => []
    },
    labelSize: {
      type: [Number, String],
      default: 7
    },
    lineWidth: {
      type: [String, Number],
      default: 4
    },
    id: String,
    itemValue: {
      type: String,
      default: "value"
    },
    modelValue: {
      type: Array,
      default: () => []
    },
    min: [String, Number],
    max: [String, Number],
    padding: {
      type: [String, Number],
      default: 8
    },
    showLabels: Boolean,
    smooth: [Boolean, String, Number],
    width: {
      type: [Number, String],
      default: 300
    }
  }, "Line");

  // ../posawesome/node_modules/vuetify/lib/components/VSparkline/VBarline.js
  var makeVBarlineProps = propsFactory(__spreadValues({
    autoLineWidth: Boolean
  }, makeLineProps()), "VBarline");
  var VBarline = genericComponent()({
    name: "VBarline",
    props: makeVBarlineProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const uid2 = useId();
      const id = computed2(() => props.id || `barline-${uid2}`);
      const autoDrawDuration = computed2(() => Number(props.autoDrawDuration) || 500);
      const hasLabels = computed2(() => {
        return Boolean(props.showLabels || props.labels.length > 0 || !!(slots == null ? void 0 : slots.label));
      });
      const lineWidth = computed2(() => parseFloat(props.lineWidth) || 4);
      const totalWidth = computed2(() => Math.max(props.modelValue.length * lineWidth.value, Number(props.width)));
      const boundary = computed2(() => {
        return {
          minX: 0,
          maxX: totalWidth.value,
          minY: 0,
          maxY: parseInt(props.height, 10)
        };
      });
      const items = computed2(() => props.modelValue.map((item) => getPropertyFromItem(item, props.itemValue, item)));
      function genBars(values, boundary2) {
        const {
          minX,
          maxX,
          minY,
          maxY
        } = boundary2;
        const totalValues = values.length;
        let maxValue = props.max != null ? Number(props.max) : Math.max(...values);
        let minValue = props.min != null ? Number(props.min) : Math.min(...values);
        if (minValue > 0 && props.min == null)
          minValue = 0;
        if (maxValue < 0 && props.max == null)
          maxValue = 0;
        const gridX = maxX / totalValues;
        const gridY = (maxY - minY) / (maxValue - minValue || 1);
        const horizonY = maxY - Math.abs(minValue * gridY);
        return values.map((value, index) => {
          const height = Math.abs(gridY * value);
          return {
            x: minX + index * gridX,
            y: horizonY - height + Number(value < 0) * height,
            height,
            value
          };
        });
      }
      const parsedLabels = computed2(() => {
        const labels = [];
        const points = genBars(items.value, boundary.value);
        const len = points.length;
        for (let i = 0; labels.length < len; i++) {
          const item = points[i];
          let value = props.labels[i];
          if (!value) {
            value = typeof item === "object" ? item.value : item;
          }
          labels.push({
            x: item.x,
            value: String(value)
          });
        }
        return labels;
      });
      const bars = computed2(() => genBars(items.value, boundary.value));
      const offsetX = computed2(() => (Math.abs(bars.value[0].x - bars.value[1].x) - lineWidth.value) / 2);
      const smooth = computed2(() => typeof props.smooth === "boolean" ? props.smooth ? 2 : 0 : Number(props.smooth));
      useRender(() => {
        const gradientData = !props.gradient.slice().length ? [""] : props.gradient.slice().reverse();
        return createBaseVNode("svg", {
          "display": "block"
        }, [createBaseVNode("defs", null, [createBaseVNode("linearGradient", {
          "id": id.value,
          "gradientUnits": "userSpaceOnUse",
          "x1": props.gradientDirection === "left" ? "100%" : "0",
          "y1": props.gradientDirection === "top" ? "100%" : "0",
          "x2": props.gradientDirection === "right" ? "100%" : "0",
          "y2": props.gradientDirection === "bottom" ? "100%" : "0"
        }, [gradientData.map((color, index) => createBaseVNode("stop", {
          "offset": index / Math.max(gradientData.length - 1, 1),
          "stop-color": color || "currentColor"
        }, null))])]), createBaseVNode("clipPath", {
          "id": `${id.value}-clip`
        }, [bars.value.map((item) => createBaseVNode("rect", {
          "x": item.x + offsetX.value,
          "y": item.y,
          "width": lineWidth.value,
          "height": item.height,
          "rx": smooth.value,
          "ry": smooth.value
        }, [props.autoDraw && createBaseVNode(Fragment, null, [createBaseVNode("animate", {
          "attributeName": "y",
          "from": item.y + item.height,
          "to": item.y,
          "dur": `${autoDrawDuration.value}ms`,
          "fill": "freeze"
        }, null), createBaseVNode("animate", {
          "attributeName": "height",
          "from": "0",
          "to": item.height,
          "dur": `${autoDrawDuration.value}ms`,
          "fill": "freeze"
        }, null)])]))]), hasLabels.value && createBaseVNode("g", {
          "key": "labels",
          "style": {
            textAnchor: "middle",
            dominantBaseline: "mathematical",
            fill: "currentColor"
          }
        }, [parsedLabels.value.map((item, i) => {
          var _a3, _b;
          return createBaseVNode("text", {
            "x": item.x + offsetX.value + lineWidth.value / 2,
            "y": parseInt(props.height, 10) - 2 + (parseInt(props.labelSize, 10) || 7 * 0.75),
            "font-size": Number(props.labelSize) || 7
          }, [(_b = (_a3 = slots.label) == null ? void 0 : _a3.call(slots, {
            index: i,
            value: item.value
          })) != null ? _b : item.value]);
        })]), createBaseVNode("g", {
          "clip-path": `url(#${id.value}-clip)`,
          "fill": `url(#${id.value})`
        }, [createBaseVNode("rect", {
          "x": 0,
          "y": 0,
          "width": Math.max(props.modelValue.length * lineWidth.value, Number(props.width)),
          "height": props.height
        }, null)])]);
      });
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VSparkline/util/path.js
  function genPath(points, radius) {
    let fill = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    let height = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 75;
    if (points.length === 0)
      return "";
    const start = points.shift();
    const end = points[points.length - 1];
    return (fill ? `M${start.x} ${height - start.x + 2} L${start.x} ${start.y}` : `M${start.x} ${start.y}`) + points.map((point, index) => {
      const next = points[index + 1];
      const prev = points[index - 1] || start;
      const isCollinear = next && checkCollinear(next, point, prev);
      if (!next || isCollinear) {
        return `L${point.x} ${point.y}`;
      }
      const threshold = Math.min(getDistance(prev, point), getDistance(next, point));
      const isTooCloseForRadius = threshold / 2 < radius;
      const radiusForPoint = isTooCloseForRadius ? threshold / 2 : radius;
      const before = moveTo(prev, point, radiusForPoint);
      const after = moveTo(next, point, radiusForPoint);
      return `L${before.x} ${before.y}S${point.x} ${point.y} ${after.x} ${after.y}`;
    }).join("") + (fill ? `L${end.x} ${height - start.x + 2} Z` : "");
  }
  function int(value) {
    return parseInt(value, 10);
  }
  function checkCollinear(p0, p1, p2) {
    return int(p0.x + p2.x) === int(2 * p1.x) && int(p0.y + p2.y) === int(2 * p1.y);
  }
  function getDistance(p1, p2) {
    return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
  }
  function moveTo(to2, from, radius) {
    const vector = {
      x: to2.x - from.x,
      y: to2.y - from.y
    };
    const length = Math.sqrt(vector.x * vector.x + vector.y * vector.y);
    const unitVector = {
      x: vector.x / length,
      y: vector.y / length
    };
    return {
      x: from.x + unitVector.x * radius,
      y: from.y + unitVector.y * radius
    };
  }

  // ../posawesome/node_modules/vuetify/lib/components/VSparkline/VTrendline.js
  var makeVTrendlineProps = propsFactory(__spreadValues({
    fill: Boolean
  }, makeLineProps()), "VTrendline");
  var VTrendline = genericComponent()({
    name: "VTrendline",
    props: makeVTrendlineProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const uid2 = useId();
      const id = computed2(() => props.id || `trendline-${uid2}`);
      const autoDrawDuration = computed2(() => Number(props.autoDrawDuration) || (props.fill ? 500 : 2e3));
      const lastLength = ref(0);
      const path = ref(null);
      function genPoints(values, boundary2) {
        const {
          minX,
          maxX,
          minY,
          maxY
        } = boundary2;
        const totalValues = values.length;
        const maxValue = props.max != null ? Number(props.max) : Math.max(...values);
        const minValue = props.min != null ? Number(props.min) : Math.min(...values);
        const gridX = (maxX - minX) / (totalValues - 1);
        const gridY = (maxY - minY) / (maxValue - minValue || 1);
        return values.map((value, index) => {
          return {
            x: minX + index * gridX,
            y: maxY - (value - minValue) * gridY,
            value
          };
        });
      }
      const hasLabels = computed2(() => {
        return Boolean(props.showLabels || props.labels.length > 0 || !!(slots == null ? void 0 : slots.label));
      });
      const lineWidth = computed2(() => {
        return parseFloat(props.lineWidth) || 4;
      });
      const totalWidth = computed2(() => Number(props.width));
      const boundary = computed2(() => {
        const padding = Number(props.padding);
        return {
          minX: padding,
          maxX: totalWidth.value - padding,
          minY: padding,
          maxY: parseInt(props.height, 10) - padding
        };
      });
      const items = computed2(() => props.modelValue.map((item) => getPropertyFromItem(item, props.itemValue, item)));
      const parsedLabels = computed2(() => {
        const labels = [];
        const points = genPoints(items.value, boundary.value);
        const len = points.length;
        for (let i = 0; labels.length < len; i++) {
          const item = points[i];
          let value = props.labels[i];
          if (!value) {
            value = typeof item === "object" ? item.value : item;
          }
          labels.push({
            x: item.x,
            value: String(value)
          });
        }
        return labels;
      });
      watch2(() => props.modelValue, async () => {
        await nextTick();
        if (!props.autoDraw || !path.value)
          return;
        const pathRef = path.value;
        const length = pathRef.getTotalLength();
        if (!props.fill) {
          pathRef.style.strokeDasharray = `${length}`;
          pathRef.style.strokeDashoffset = `${length}`;
          pathRef.getBoundingClientRect();
          pathRef.style.transition = `stroke-dashoffset ${autoDrawDuration.value}ms ${props.autoDrawEasing}`;
          pathRef.style.strokeDashoffset = "0";
        } else {
          pathRef.style.transformOrigin = "bottom center";
          pathRef.style.transition = "none";
          pathRef.style.transform = `scaleY(0)`;
          pathRef.getBoundingClientRect();
          pathRef.style.transition = `transform ${autoDrawDuration.value}ms ${props.autoDrawEasing}`;
          pathRef.style.transform = `scaleY(1)`;
        }
        lastLength.value = length;
      }, {
        immediate: true
      });
      function genPath2(fill) {
        const smoothValue = typeof props.smooth === "boolean" ? props.smooth ? 8 : 0 : Number(props.smooth);
        return genPath(genPoints(items.value, boundary.value), smoothValue, fill, parseInt(props.height, 10));
      }
      useRender(() => {
        var _a3, _b, _c;
        const gradientData = !props.gradient.slice().length ? [""] : props.gradient.slice().reverse();
        return createBaseVNode("svg", {
          "display": "block",
          "stroke-width": (_a3 = parseFloat(props.lineWidth)) != null ? _a3 : 4
        }, [createBaseVNode("defs", null, [createBaseVNode("linearGradient", {
          "id": id.value,
          "gradientUnits": "userSpaceOnUse",
          "x1": props.gradientDirection === "left" ? "100%" : "0",
          "y1": props.gradientDirection === "top" ? "100%" : "0",
          "x2": props.gradientDirection === "right" ? "100%" : "0",
          "y2": props.gradientDirection === "bottom" ? "100%" : "0"
        }, [gradientData.map((color, index) => createBaseVNode("stop", {
          "offset": index / Math.max(gradientData.length - 1, 1),
          "stop-color": color || "currentColor"
        }, null))])]), hasLabels.value && createBaseVNode("g", {
          "key": "labels",
          "style": {
            textAnchor: "middle",
            dominantBaseline: "mathematical",
            fill: "currentColor"
          }
        }, [parsedLabels.value.map((item, i) => {
          var _a4, _b2;
          return createBaseVNode("text", {
            "x": item.x + lineWidth.value / 2 + lineWidth.value / 2,
            "y": parseInt(props.height, 10) - 4 + (parseInt(props.labelSize, 10) || 7 * 0.75),
            "font-size": Number(props.labelSize) || 7
          }, [(_b2 = (_a4 = slots.label) == null ? void 0 : _a4.call(slots, {
            index: i,
            value: item.value
          })) != null ? _b2 : item.value]);
        })]), createBaseVNode("path", {
          "ref": path,
          "d": genPath2(props.fill),
          "fill": props.fill ? `url(#${id.value})` : "none",
          "stroke": props.fill ? "none" : `url(#${id.value})`
        }, null), props.fill && createBaseVNode("path", {
          "d": genPath2(false),
          "fill": "none",
          "stroke": (_c = props.color) != null ? _c : (_b = props.gradient) == null ? void 0 : _b[0]
        }, null)]);
      });
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VSparkline/VSparkline.js
  var makeVSparklineProps = propsFactory(__spreadValues(__spreadValues({
    type: {
      type: String,
      default: "trend"
    }
  }, makeVBarlineProps()), makeVTrendlineProps()), "VSparkline");
  var VSparkline = genericComponent()({
    name: "VSparkline",
    props: makeVSparklineProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(() => props.color);
      const hasLabels = computed2(() => {
        return Boolean(props.showLabels || props.labels.length > 0 || !!(slots == null ? void 0 : slots.label));
      });
      const totalHeight = computed2(() => {
        let height = parseInt(props.height, 10);
        if (hasLabels.value)
          height += parseInt(props.labelSize, 10) * 1.5;
        return height;
      });
      useRender(() => {
        const Tag = props.type === "trend" ? VTrendline : VBarline;
        const lineProps = props.type === "trend" ? VTrendline.filterProps(props) : VBarline.filterProps(props);
        return createVNode(Tag, mergeProps({
          "key": props.type,
          "class": textColorClasses.value,
          "style": textColorStyles.value,
          "viewBox": `0 0 ${props.width} ${parseInt(totalHeight.value, 10)}`
        }, lineProps), slots);
      });
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VSpeedDial/VSpeedDial.js
  var makeVSpeedDialProps = propsFactory(__spreadValues(__spreadValues({}, makeComponentProps()), makeVMenuProps({
    offset: 8,
    minWidth: 0,
    openDelay: 0,
    closeDelay: 100,
    location: "top center",
    transition: "scale-transition"
  })), "VSpeedDial");
  var VSpeedDial = genericComponent()({
    name: "VSpeedDial",
    props: makeVSpeedDialProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const model = useProxiedModel(props, "modelValue");
      const menuRef = ref();
      const location2 = computed2(() => {
        var _a3, _b;
        const [y, x = "center"] = (_b = (_a3 = props.location) == null ? void 0 : _a3.split(" ")) != null ? _b : [];
        return `${y} ${x}`;
      });
      const locationClasses = computed2(() => ({
        [`v-speed-dial__content--${location2.value.replace(" ", "-")}`]: true
      }));
      useRender(() => {
        const menuProps = VMenu.filterProps(props);
        return createVNode(VMenu, mergeProps(menuProps, {
          "modelValue": model.value,
          "onUpdate:modelValue": ($event) => model.value = $event,
          "class": props.class,
          "style": props.style,
          "contentClass": ["v-speed-dial__content", locationClasses.value, props.contentClass],
          "location": location2.value,
          "ref": menuRef,
          "transition": "fade-transition"
        }), __spreadProps(__spreadValues({}, slots), {
          default: (slotProps) => createVNode(VDefaultsProvider, {
            "defaults": {
              VBtn: {
                size: "small"
              }
            }
          }, {
            default: () => [createVNode(MaybeTransition, {
              "appear": true,
              "group": true,
              "transition": props.transition
            }, {
              default: () => {
                var _a3;
                return [(_a3 = slots.default) == null ? void 0 : _a3.call(slots, slotProps)];
              }
            })]
          })
        }));
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VStepper/shared.js
  var VStepperSymbol = Symbol.for("vuetify:v-stepper");

  // ../posawesome/node_modules/vuetify/lib/components/VStepper/VStepperActions.js
  var makeVStepperActionsProps = propsFactory({
    color: String,
    disabled: {
      type: [Boolean, String],
      default: false
    },
    prevText: {
      type: String,
      default: "$vuetify.stepper.prev"
    },
    nextText: {
      type: String,
      default: "$vuetify.stepper.next"
    }
  }, "VStepperActions");
  var VStepperActions = genericComponent()({
    name: "VStepperActions",
    props: makeVStepperActionsProps(),
    emits: {
      "click:prev": () => true,
      "click:next": () => true
    },
    setup(props, _ref) {
      let {
        emit: emit2,
        slots
      } = _ref;
      const {
        t
      } = useLocale();
      function onClickPrev() {
        emit2("click:prev");
      }
      function onClickNext() {
        emit2("click:next");
      }
      useRender(() => {
        const prevSlotProps = {
          onClick: onClickPrev
        };
        const nextSlotProps = {
          onClick: onClickNext
        };
        return createBaseVNode("div", {
          "class": "v-stepper-actions"
        }, [createVNode(VDefaultsProvider, {
          "defaults": {
            VBtn: {
              disabled: ["prev", true].includes(props.disabled),
              text: t(props.prevText),
              variant: "text"
            }
          }
        }, {
          default: () => {
            var _a3, _b;
            return [(_b = (_a3 = slots.prev) == null ? void 0 : _a3.call(slots, {
              props: prevSlotProps
            })) != null ? _b : createVNode(VBtn, prevSlotProps, null)];
          }
        }), createVNode(VDefaultsProvider, {
          "defaults": {
            VBtn: {
              color: props.color,
              disabled: ["next", true].includes(props.disabled),
              text: t(props.nextText),
              variant: "tonal"
            }
          }
        }, {
          default: () => {
            var _a3, _b;
            return [(_b = (_a3 = slots.next) == null ? void 0 : _a3.call(slots, {
              props: nextSlotProps
            })) != null ? _b : createVNode(VBtn, nextSlotProps, null)];
          }
        })]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VStepper/VStepperHeader.js
  var VStepperHeader = createSimpleFunctional("v-stepper-header");

  // ../posawesome/node_modules/vuetify/lib/components/VStepper/VStepperItem.js
  var makeStepperItemProps = propsFactory({
    color: String,
    title: String,
    subtitle: String,
    complete: Boolean,
    completeIcon: {
      type: IconValue,
      default: "$complete"
    },
    editable: Boolean,
    editIcon: {
      type: IconValue,
      default: "$edit"
    },
    error: Boolean,
    errorIcon: {
      type: IconValue,
      default: "$error"
    },
    icon: IconValue,
    ripple: {
      type: [Boolean, Object],
      default: true
    },
    rules: {
      type: Array,
      default: () => []
    }
  }, "StepperItem");
  var makeVStepperItemProps = propsFactory(__spreadValues(__spreadValues({}, makeStepperItemProps()), makeGroupItemProps()), "VStepperItem");
  var VStepperItem = genericComponent()({
    name: "VStepperItem",
    directives: {
      vRipple: ripple_default
    },
    props: makeVStepperItemProps(),
    emits: {
      "group:selected": (val) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const group = useGroupItem(props, VStepperSymbol, true);
      const step = computed2(() => {
        var _a3;
        return (_a3 = group == null ? void 0 : group.value.value) != null ? _a3 : props.value;
      });
      const isValid3 = computed2(() => props.rules.every((handler) => handler() === true));
      const isClickable = computed2(() => !props.disabled && props.editable);
      const canEdit = computed2(() => !props.disabled && props.editable);
      const hasError = computed2(() => props.error || !isValid3.value);
      const hasCompleted = computed2(() => props.complete || props.rules.length > 0 && isValid3.value);
      const icon = computed2(() => {
        if (hasError.value)
          return props.errorIcon;
        if (hasCompleted.value)
          return props.completeIcon;
        if (group.isSelected.value && props.editable)
          return props.editIcon;
        return props.icon;
      });
      const slotProps = computed2(() => ({
        canEdit: canEdit.value,
        hasError: hasError.value,
        hasCompleted: hasCompleted.value,
        title: props.title,
        subtitle: props.subtitle,
        step: step.value,
        value: props.value
      }));
      useRender(() => {
        var _a3, _b, _c, _d, _e;
        const hasColor = (!group || group.isSelected.value || hasCompleted.value || canEdit.value) && !hasError.value && !props.disabled;
        const hasTitle = !!(props.title != null || slots.title);
        const hasSubtitle = !!(props.subtitle != null || slots.subtitle);
        function onClick() {
          group == null ? void 0 : group.toggle();
        }
        return withDirectives(createBaseVNode("button", {
          "class": normalizeClass(["v-stepper-item", {
            "v-stepper-item--complete": hasCompleted.value,
            "v-stepper-item--disabled": props.disabled,
            "v-stepper-item--error": hasError.value
          }, group == null ? void 0 : group.selectedClass.value]),
          "disabled": !props.editable,
          "type": "button",
          "onClick": onClick
        }, [isClickable.value && genOverlays(true, "v-stepper-item"), createVNode(VAvatar, {
          "key": "stepper-avatar",
          "class": "v-stepper-item__avatar",
          "color": hasColor ? props.color : void 0,
          "size": 24
        }, {
          default: () => {
            var _a4, _b2;
            return [(_b2 = (_a4 = slots.icon) == null ? void 0 : _a4.call(slots, slotProps.value)) != null ? _b2 : icon.value ? createVNode(VIcon, {
              "icon": icon.value
            }, null) : step.value];
          }
        }), createBaseVNode("div", {
          "class": "v-stepper-item__content"
        }, [hasTitle && createBaseVNode("div", {
          "key": "title",
          "class": "v-stepper-item__title"
        }, [(_b = (_a3 = slots.title) == null ? void 0 : _a3.call(slots, slotProps.value)) != null ? _b : props.title]), hasSubtitle && createBaseVNode("div", {
          "key": "subtitle",
          "class": "v-stepper-item__subtitle"
        }, [(_d = (_c = slots.subtitle) == null ? void 0 : _c.call(slots, slotProps.value)) != null ? _d : props.subtitle]), (_e = slots.default) == null ? void 0 : _e.call(slots, slotProps.value)])]), [[ripple_default, props.ripple && props.editable, null]]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VStepper/VStepperWindow.js
  var makeVStepperWindowProps = propsFactory(__spreadValues({}, omit(makeVWindowProps(), ["continuous", "nextIcon", "prevIcon", "showArrows", "touch", "mandatory"])), "VStepperWindow");
  var VStepperWindow = genericComponent()({
    name: "VStepperWindow",
    props: makeVStepperWindowProps(),
    emits: {
      "update:modelValue": (v) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const group = inject(VStepperSymbol, null);
      const _model = useProxiedModel(props, "modelValue");
      const model = computed2({
        get() {
          var _a3;
          if (_model.value != null || !group)
            return _model.value;
          return (_a3 = group.items.value.find((item) => group.selected.value.includes(item.id))) == null ? void 0 : _a3.value;
        },
        set(val) {
          _model.value = val;
        }
      });
      useRender(() => {
        const windowProps = VWindow.filterProps(props);
        return createVNode(VWindow, mergeProps({
          "_as": "VStepperWindow"
        }, windowProps, {
          "modelValue": model.value,
          "onUpdate:modelValue": ($event) => model.value = $event,
          "class": ["v-stepper-window", props.class],
          "style": props.style,
          "mandatory": false,
          "touch": false
        }), slots);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VStepper/VStepperWindowItem.js
  var makeVStepperWindowItemProps = propsFactory(__spreadValues({}, makeVWindowItemProps()), "VStepperWindowItem");
  var VStepperWindowItem = genericComponent()({
    name: "VStepperWindowItem",
    props: makeVStepperWindowItemProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => {
        const windowItemProps = VWindowItem.filterProps(props);
        return createVNode(VWindowItem, mergeProps({
          "_as": "VStepperWindowItem"
        }, windowItemProps, {
          "class": ["v-stepper-window-item", props.class],
          "style": props.style
        }), slots);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VStepper/VStepper.js
  var makeStepperProps = propsFactory(__spreadValues({
    altLabels: Boolean,
    bgColor: String,
    completeIcon: IconValue,
    editIcon: IconValue,
    editable: Boolean,
    errorIcon: IconValue,
    hideActions: Boolean,
    items: {
      type: Array,
      default: () => []
    },
    itemTitle: {
      type: String,
      default: "title"
    },
    itemValue: {
      type: String,
      default: "value"
    },
    nonLinear: Boolean,
    flat: Boolean
  }, makeDisplayProps()), "Stepper");
  var makeVStepperProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, makeStepperProps()), makeGroupProps({
    mandatory: "force",
    selectedClass: "v-stepper-item--selected"
  })), makeVSheetProps()), pick(makeVStepperActionsProps(), ["prevText", "nextText"])), "VStepper");
  var VStepper = genericComponent()({
    name: "VStepper",
    props: makeVStepperProps(),
    emits: {
      "update:modelValue": (v) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        items: _items,
        next,
        prev,
        selected
      } = useGroup(props, VStepperSymbol);
      const {
        displayClasses,
        mobile
      } = useDisplay(props);
      const {
        completeIcon,
        editIcon,
        errorIcon,
        color,
        editable,
        prevText,
        nextText
      } = toRefs(props);
      const items = computed2(() => props.items.map((item, index) => {
        const title = getPropertyFromItem(item, props.itemTitle, item);
        const value = getPropertyFromItem(item, props.itemValue, index + 1);
        return {
          title,
          value,
          raw: item
        };
      }));
      const activeIndex = computed2(() => {
        return _items.value.findIndex((item) => selected.value.includes(item.id));
      });
      const disabled = computed2(() => {
        if (props.disabled)
          return props.disabled;
        if (activeIndex.value === 0)
          return "prev";
        if (activeIndex.value === _items.value.length - 1)
          return "next";
        return false;
      });
      provideDefaults({
        VStepperItem: {
          editable,
          errorIcon,
          completeIcon,
          editIcon,
          prevText,
          nextText
        },
        VStepperActions: {
          color,
          disabled,
          prevText,
          nextText
        }
      });
      useRender(() => {
        const sheetProps = VSheet.filterProps(props);
        const hasHeader = !!(slots.header || props.items.length);
        const hasWindow = props.items.length > 0;
        const hasActions = !props.hideActions && !!(hasWindow || slots.actions);
        return createVNode(VSheet, mergeProps(sheetProps, {
          "color": props.bgColor,
          "class": ["v-stepper", {
            "v-stepper--alt-labels": props.altLabels,
            "v-stepper--flat": props.flat,
            "v-stepper--non-linear": props.nonLinear,
            "v-stepper--mobile": mobile.value
          }, displayClasses.value, props.class],
          "style": props.style
        }), {
          default: () => {
            var _a3, _b, _c;
            return [hasHeader && createVNode(VStepperHeader, {
              "key": "stepper-header"
            }, {
              default: () => [items.value.map((_ref2, index) => {
                var _b2;
                let _a4 = _ref2, {
                  raw
                } = _a4, item = __objRest(_a4, [
                  "raw"
                ]);
                return createBaseVNode(Fragment, null, [!!index && createVNode(VDivider, null, null), createVNode(VStepperItem, item, {
                  default: (_b2 = slots[`header-item.${item.value}`]) != null ? _b2 : slots.header,
                  icon: slots.icon,
                  title: slots.title,
                  subtitle: slots.subtitle
                })]);
              })]
            }), hasWindow && createVNode(VStepperWindow, {
              "key": "stepper-window"
            }, {
              default: () => [items.value.map((item) => createVNode(VStepperWindowItem, {
                "value": item.value
              }, {
                default: () => {
                  var _a4, _b2, _c2;
                  return (_c2 = (_a4 = slots[`item.${item.value}`]) == null ? void 0 : _a4.call(slots, item)) != null ? _c2 : (_b2 = slots.item) == null ? void 0 : _b2.call(slots, item);
                }
              }))]
            }), (_a3 = slots.default) == null ? void 0 : _a3.call(slots, {
              prev,
              next
            }), hasActions && ((_c = (_b = slots.actions) == null ? void 0 : _b.call(slots, {
              next,
              prev
            })) != null ? _c : createVNode(VStepperActions, {
              "key": "stepper-actions",
              "onClick:prev": prev,
              "onClick:next": next
            }, slots))];
          }
        });
      });
      return {
        prev,
        next
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VSwitch/VSwitch.js
  var makeVSwitchProps = propsFactory(__spreadValues(__spreadValues({
    indeterminate: Boolean,
    inset: Boolean,
    flat: Boolean,
    loading: {
      type: [Boolean, String],
      default: false
    }
  }, makeVInputProps()), makeVSelectionControlProps()), "VSwitch");
  var VSwitch = genericComponent()({
    name: "VSwitch",
    inheritAttrs: false,
    props: makeVSwitchProps(),
    emits: {
      "update:focused": (focused) => true,
      "update:modelValue": (value) => true,
      "update:indeterminate": (value) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const indeterminate = useProxiedModel(props, "indeterminate");
      const model = useProxiedModel(props, "modelValue");
      const {
        loaderClasses
      } = useLoader(props);
      const {
        isFocused,
        focus,
        blur
      } = useFocus(props);
      const control = ref();
      const isForcedColorsModeActive = IN_BROWSER && window.matchMedia("(forced-colors: active)").matches;
      const loaderColor = toRef(() => {
        return typeof props.loading === "string" && props.loading !== "" ? props.loading : props.color;
      });
      const uid2 = useId();
      const id = toRef(() => props.id || `switch-${uid2}`);
      function onChange() {
        if (indeterminate.value) {
          indeterminate.value = false;
        }
      }
      function onTrackClick(e) {
        var _a3, _b;
        e.stopPropagation();
        e.preventDefault();
        (_b = (_a3 = control.value) == null ? void 0 : _a3.input) == null ? void 0 : _b.click();
      }
      useRender(() => {
        const [rootAttrs, controlAttrs] = filterInputAttrs(attrs);
        const inputProps = VInput.filterProps(props);
        const controlProps = VSelectionControl.filterProps(props);
        return createVNode(VInput, mergeProps({
          "class": ["v-switch", {
            "v-switch--flat": props.flat
          }, {
            "v-switch--inset": props.inset
          }, {
            "v-switch--indeterminate": indeterminate.value
          }, loaderClasses.value, props.class]
        }, rootAttrs, inputProps, {
          "modelValue": model.value,
          "onUpdate:modelValue": ($event) => model.value = $event,
          "id": id.value,
          "focused": isFocused.value,
          "style": props.style
        }), __spreadProps(__spreadValues({}, slots), {
          default: (_ref2) => {
            let {
              id: id2,
              messagesId,
              isDisabled,
              isReadonly: isReadonly2,
              isValid: isValid3
            } = _ref2;
            const slotProps = {
              model,
              isValid: isValid3
            };
            return createVNode(VSelectionControl, mergeProps({
              "ref": control
            }, controlProps, {
              "modelValue": model.value,
              "onUpdate:modelValue": [($event) => model.value = $event, onChange],
              "id": id2.value,
              "aria-describedby": messagesId.value,
              "type": "checkbox",
              "aria-checked": indeterminate.value ? "mixed" : void 0,
              "disabled": isDisabled.value,
              "readonly": isReadonly2.value,
              "onFocus": focus,
              "onBlur": blur
            }, controlAttrs), __spreadProps(__spreadValues({}, slots), {
              default: (_ref3) => {
                let {
                  backgroundColorClasses,
                  backgroundColorStyles
                } = _ref3;
                return createBaseVNode("div", {
                  "class": normalizeClass(["v-switch__track", !isForcedColorsModeActive ? backgroundColorClasses.value : void 0]),
                  "style": normalizeStyle(backgroundColorStyles.value),
                  "onClick": onTrackClick
                }, [slots["track-true"] && createBaseVNode("div", {
                  "key": "prepend",
                  "class": "v-switch__track-true"
                }, [slots["track-true"](slotProps)]), slots["track-false"] && createBaseVNode("div", {
                  "key": "append",
                  "class": "v-switch__track-false"
                }, [slots["track-false"](slotProps)])]);
              },
              input: (_ref4) => {
                let {
                  inputNode,
                  icon,
                  backgroundColorClasses,
                  backgroundColorStyles
                } = _ref4;
                return createBaseVNode(Fragment, null, [inputNode, createBaseVNode("div", {
                  "class": normalizeClass(["v-switch__thumb", {
                    "v-switch__thumb--filled": icon || props.loading
                  }, props.inset || isForcedColorsModeActive ? void 0 : backgroundColorClasses.value]),
                  "style": normalizeStyle(props.inset ? void 0 : backgroundColorStyles.value)
                }, [slots.thumb ? createVNode(VDefaultsProvider, {
                  "defaults": {
                    VIcon: {
                      icon,
                      size: "x-small"
                    }
                  }
                }, {
                  default: () => [slots.thumb(__spreadProps(__spreadValues({}, slotProps), {
                    icon
                  }))]
                }) : createVNode(VScaleTransition, null, {
                  default: () => [!props.loading ? icon && createVNode(VIcon, {
                    "key": String(icon),
                    "icon": icon,
                    "size": "x-small"
                  }, null) : createVNode(LoaderSlot, {
                    "name": "v-switch",
                    "active": true,
                    "color": isValid3.value === false ? void 0 : loaderColor.value
                  }, {
                    default: (slotProps2) => slots.loader ? slots.loader(slotProps2) : createVNode(VProgressCircular, {
                      "active": slotProps2.isActive,
                      "color": slotProps2.color,
                      "indeterminate": true,
                      "size": "16",
                      "width": "2"
                    }, null)
                  })]
                })])]);
              }
            }));
          }
        }));
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VSystemBar/VSystemBar.js
  var makeVSystemBarProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    color: String,
    height: [Number, String],
    window: Boolean
  }, makeComponentProps()), makeElevationProps()), makeLayoutItemProps()), makeRoundedProps()), makeTagProps()), makeThemeProps()), "VSystemBar");
  var VSystemBar = genericComponent()({
    name: "VSystemBar",
    props: makeVSystemBarProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(() => props.color);
      const {
        elevationClasses
      } = useElevation(props);
      const {
        roundedClasses
      } = useRounded(props);
      const {
        ssrBootStyles
      } = useSsrBoot();
      const height = computed2(() => {
        var _a3;
        return (_a3 = props.height) != null ? _a3 : props.window ? 32 : 24;
      });
      const {
        layoutItemStyles
      } = useLayoutItem({
        id: props.name,
        order: computed2(() => parseInt(props.order, 10)),
        position: shallowRef("top"),
        layoutSize: height,
        elementSize: height,
        active: computed2(() => true),
        absolute: toRef(() => props.absolute)
      });
      useRender(() => createVNode(props.tag, {
        "class": normalizeClass(["v-system-bar", {
          "v-system-bar--window": props.window
        }, themeClasses.value, backgroundColorClasses.value, elevationClasses.value, roundedClasses.value, props.class]),
        "style": normalizeStyle([backgroundColorStyles.value, layoutItemStyles.value, ssrBootStyles.value, props.style])
      }, slots));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VTabs/shared.js
  var VTabsSymbol = Symbol.for("vuetify:v-tabs");

  // ../posawesome/node_modules/vuetify/lib/components/VTabs/VTab.js
  var makeVTabProps = propsFactory(__spreadValues({
    fixed: Boolean,
    sliderColor: String,
    hideSlider: Boolean,
    direction: {
      type: String,
      default: "horizontal"
    }
  }, omit(makeVBtnProps({
    selectedClass: "v-tab--selected",
    variant: "text"
  }), ["active", "block", "flat", "location", "position", "symbol"])), "VTab");
  var VTab = genericComponent()({
    name: "VTab",
    props: makeVTabProps(),
    setup(props, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      const {
        textColorClasses: sliderColorClasses,
        textColorStyles: sliderColorStyles
      } = useTextColor(() => props.sliderColor);
      const rootEl = ref();
      const sliderEl = ref();
      const isHorizontal = computed2(() => props.direction === "horizontal");
      const isSelected = computed2(() => {
        var _a3, _b, _c;
        return (_c = (_b = (_a3 = rootEl.value) == null ? void 0 : _a3.group) == null ? void 0 : _b.isSelected.value) != null ? _c : false;
      });
      function updateSlider(_ref2) {
        var _a3, _b;
        let {
          value
        } = _ref2;
        if (value) {
          const prevEl = (_b = (_a3 = rootEl.value) == null ? void 0 : _a3.$el.parentElement) == null ? void 0 : _b.querySelector(".v-tab--selected .v-tab__slider");
          const nextEl = sliderEl.value;
          if (!prevEl || !nextEl)
            return;
          const color = getComputedStyle(prevEl).color;
          const prevBox = prevEl.getBoundingClientRect();
          const nextBox = nextEl.getBoundingClientRect();
          const xy = isHorizontal.value ? "x" : "y";
          const XY = isHorizontal.value ? "X" : "Y";
          const rightBottom = isHorizontal.value ? "right" : "bottom";
          const widthHeight = isHorizontal.value ? "width" : "height";
          const prevPos = prevBox[xy];
          const nextPos = nextBox[xy];
          const delta2 = prevPos > nextPos ? prevBox[rightBottom] - nextBox[rightBottom] : prevBox[xy] - nextBox[xy];
          const origin = Math.sign(delta2) > 0 ? isHorizontal.value ? "right" : "bottom" : Math.sign(delta2) < 0 ? isHorizontal.value ? "left" : "top" : "center";
          const size = Math.abs(delta2) + (Math.sign(delta2) < 0 ? prevBox[widthHeight] : nextBox[widthHeight]);
          const scale = size / Math.max(prevBox[widthHeight], nextBox[widthHeight]) || 0;
          const initialScale = prevBox[widthHeight] / nextBox[widthHeight] || 0;
          const sigma = 1.5;
          animate(nextEl, {
            backgroundColor: [color, "currentcolor"],
            transform: [`translate${XY}(${delta2}px) scale${XY}(${initialScale})`, `translate${XY}(${delta2 / sigma}px) scale${XY}(${(scale - 1) / sigma + 1})`, "none"],
            transformOrigin: Array(3).fill(origin)
          }, {
            duration: 225,
            easing: standardEasing
          });
        }
      }
      useRender(() => {
        const btnProps = VBtn.filterProps(props);
        return createVNode(VBtn, mergeProps({
          "symbol": VTabsSymbol,
          "ref": rootEl,
          "class": ["v-tab", props.class],
          "style": props.style,
          "tabindex": isSelected.value ? 0 : -1,
          "role": "tab",
          "aria-selected": String(isSelected.value),
          "active": false
        }, btnProps, attrs, {
          "block": props.fixed,
          "maxWidth": props.fixed ? 300 : void 0,
          "onGroup:selected": updateSlider
        }), __spreadProps(__spreadValues({}, slots), {
          default: () => {
            var _a3, _b;
            return createBaseVNode(Fragment, null, [(_b = (_a3 = slots.default) == null ? void 0 : _a3.call(slots)) != null ? _b : props.text, !props.hideSlider && createBaseVNode("div", {
              "ref": sliderEl,
              "class": normalizeClass(["v-tab__slider", sliderColorClasses.value]),
              "style": normalizeStyle(sliderColorStyles.value)
            }, null)]);
          }
        }));
      });
      return forwardRefs({}, rootEl);
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VTabs/VTabsWindow.js
  var makeVTabsWindowProps = propsFactory(__spreadValues({}, omit(makeVWindowProps(), ["continuous", "nextIcon", "prevIcon", "showArrows", "touch", "mandatory"])), "VTabsWindow");
  var VTabsWindow = genericComponent()({
    name: "VTabsWindow",
    props: makeVTabsWindowProps(),
    emits: {
      "update:modelValue": (v) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const group = inject(VTabsSymbol, null);
      const _model = useProxiedModel(props, "modelValue");
      const model = computed2({
        get() {
          var _a3;
          if (_model.value != null || !group)
            return _model.value;
          return (_a3 = group.items.value.find((item) => group.selected.value.includes(item.id))) == null ? void 0 : _a3.value;
        },
        set(val) {
          _model.value = val;
        }
      });
      useRender(() => {
        const windowProps = VWindow.filterProps(props);
        return createVNode(VWindow, mergeProps({
          "_as": "VTabsWindow"
        }, windowProps, {
          "modelValue": model.value,
          "onUpdate:modelValue": ($event) => model.value = $event,
          "class": ["v-tabs-window", props.class],
          "style": props.style,
          "mandatory": false,
          "touch": false
        }), slots);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VTabs/VTabsWindowItem.js
  var makeVTabsWindowItemProps = propsFactory(__spreadValues({}, makeVWindowItemProps()), "VTabsWindowItem");
  var VTabsWindowItem = genericComponent()({
    name: "VTabsWindowItem",
    props: makeVTabsWindowItemProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useRender(() => {
        const windowItemProps = VWindowItem.filterProps(props);
        return createVNode(VWindowItem, mergeProps({
          "_as": "VTabsWindowItem"
        }, windowItemProps, {
          "class": ["v-tabs-window-item", props.class],
          "style": props.style
        }), slots);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VTabs/VTabs.js
  function parseItems(items) {
    if (!items)
      return [];
    return items.map((item) => {
      if (!isObject2(item))
        return {
          text: item,
          value: item
        };
      return item;
    });
  }
  var makeVTabsProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({
    alignTabs: {
      type: String,
      default: "start"
    },
    color: String,
    fixedTabs: Boolean,
    items: {
      type: Array,
      default: () => []
    },
    stacked: Boolean,
    bgColor: String,
    grow: Boolean,
    height: {
      type: [Number, String],
      default: void 0
    },
    hideSlider: Boolean,
    sliderColor: String
  }, makeVSlideGroupProps({
    mandatory: "force",
    selectedClass: "v-tab-item--selected"
  })), makeDensityProps()), makeTagProps()), "VTabs");
  var VTabs = genericComponent()({
    name: "VTabs",
    props: makeVTabsProps(),
    emits: {
      "update:modelValue": (v) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const model = useProxiedModel(props, "modelValue");
      const items = computed2(() => parseItems(props.items));
      const {
        densityClasses
      } = useDensity(props);
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(() => props.bgColor);
      const {
        scopeId
      } = useScopeId();
      provideDefaults({
        VTab: {
          color: toRef(() => props.color),
          direction: toRef(() => props.direction),
          stacked: toRef(() => props.stacked),
          fixed: toRef(() => props.fixedTabs),
          sliderColor: toRef(() => props.sliderColor),
          hideSlider: toRef(() => props.hideSlider)
        }
      });
      useRender(() => {
        const slideGroupProps = VSlideGroup.filterProps(props);
        const hasWindow = !!(slots.window || props.items.length > 0);
        return createBaseVNode(Fragment, null, [createVNode(VSlideGroup, mergeProps(slideGroupProps, {
          "modelValue": model.value,
          "onUpdate:modelValue": ($event) => model.value = $event,
          "class": ["v-tabs", `v-tabs--${props.direction}`, `v-tabs--align-tabs-${props.alignTabs}`, {
            "v-tabs--fixed-tabs": props.fixedTabs,
            "v-tabs--grow": props.grow,
            "v-tabs--stacked": props.stacked
          }, densityClasses.value, backgroundColorClasses.value, props.class],
          "style": [{
            "--v-tabs-height": convertToUnit(props.height)
          }, backgroundColorStyles.value, props.style],
          "role": "tablist",
          "symbol": VTabsSymbol
        }, scopeId, attrs), {
          default: () => {
            var _a3, _b;
            return [(_b = (_a3 = slots.default) == null ? void 0 : _a3.call(slots)) != null ? _b : items.value.map((item) => {
              var _a4, _b2;
              return (_b2 = (_a4 = slots.tab) == null ? void 0 : _a4.call(slots, {
                item
              })) != null ? _b2 : createVNode(VTab, mergeProps(item, {
                "key": item.text,
                "value": item.value
              }), {
                default: slots[`tab.${item.value}`] ? () => {
                  var _a5;
                  return (_a5 = slots[`tab.${item.value}`]) == null ? void 0 : _a5.call(slots, {
                    item
                  });
                } : void 0
              });
            })];
          }
        }), hasWindow && createVNode(VTabsWindow, mergeProps({
          "modelValue": model.value,
          "onUpdate:modelValue": ($event) => model.value = $event,
          "key": "tabs-window"
        }, scopeId), {
          default: () => {
            var _a3;
            return [items.value.map((item) => {
              var _a4, _b;
              return (_b = (_a4 = slots.item) == null ? void 0 : _a4.call(slots, {
                item
              })) != null ? _b : createVNode(VTabsWindowItem, {
                "value": item.value
              }, {
                default: () => {
                  var _a5;
                  return (_a5 = slots[`item.${item.value}`]) == null ? void 0 : _a5.call(slots, {
                    item
                  });
                }
              });
            }), (_a3 = slots.window) == null ? void 0 : _a3.call(slots)];
          }
        })]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VTextarea/VTextarea.js
  var makeVTextareaProps = propsFactory(__spreadValues(__spreadValues({
    autoGrow: Boolean,
    autofocus: Boolean,
    counter: [Boolean, Number, String],
    counterValue: Function,
    prefix: String,
    placeholder: String,
    persistentPlaceholder: Boolean,
    persistentCounter: Boolean,
    noResize: Boolean,
    rows: {
      type: [Number, String],
      default: 5,
      validator: (v) => !isNaN(parseFloat(v))
    },
    maxRows: {
      type: [Number, String],
      validator: (v) => !isNaN(parseFloat(v))
    },
    suffix: String,
    modelModifiers: Object
  }, makeVInputProps()), makeVFieldProps()), "VTextarea");
  var VTextarea = genericComponent()({
    name: "VTextarea",
    directives: {
      vIntersect: intersect_default
    },
    inheritAttrs: false,
    props: makeVTextareaProps(),
    emits: {
      "click:control": (e) => true,
      "mousedown:control": (e) => true,
      "update:focused": (focused) => true,
      "update:modelValue": (val) => true
    },
    setup(props, _ref) {
      let {
        attrs,
        emit: emit2,
        slots
      } = _ref;
      const model = useProxiedModel(props, "modelValue");
      const {
        isFocused,
        focus,
        blur
      } = useFocus(props);
      const {
        onIntersect
      } = useAutofocus(props);
      const counterValue = computed2(() => {
        return typeof props.counterValue === "function" ? props.counterValue(model.value) : (model.value || "").toString().length;
      });
      const max = computed2(() => {
        if (attrs.maxlength)
          return attrs.maxlength;
        if (!props.counter || typeof props.counter !== "number" && typeof props.counter !== "string")
          return void 0;
        return props.counter;
      });
      const vInputRef = ref();
      const vFieldRef = ref();
      const controlHeight = shallowRef("");
      const textareaRef = ref();
      const isActive = computed2(() => props.persistentPlaceholder || isFocused.value || props.active);
      function onFocus() {
        var _a3;
        if (textareaRef.value !== document.activeElement) {
          (_a3 = textareaRef.value) == null ? void 0 : _a3.focus();
        }
        if (!isFocused.value)
          focus();
      }
      function onControlClick(e) {
        onFocus();
        emit2("click:control", e);
      }
      function onControlMousedown(e) {
        emit2("mousedown:control", e);
      }
      function onClear(e) {
        e.stopPropagation();
        onFocus();
        nextTick(() => {
          model.value = "";
          callEvent(props["onClick:clear"], e);
        });
      }
      function onInput(e) {
        var _a3;
        const el = e.target;
        model.value = el.value;
        if ((_a3 = props.modelModifiers) == null ? void 0 : _a3.trim) {
          const caretPosition = [el.selectionStart, el.selectionEnd];
          nextTick(() => {
            el.selectionStart = caretPosition[0];
            el.selectionEnd = caretPosition[1];
          });
        }
      }
      const sizerRef = ref();
      const rows = ref(Number(props.rows));
      const isPlainOrUnderlined = computed2(() => ["plain", "underlined"].includes(props.variant));
      watchEffect(() => {
        if (!props.autoGrow)
          rows.value = Number(props.rows);
      });
      function calculateInputHeight() {
        if (!props.autoGrow)
          return;
        nextTick(() => {
          if (!sizerRef.value || !vFieldRef.value)
            return;
          const style = getComputedStyle(sizerRef.value);
          const fieldStyle = getComputedStyle(vFieldRef.value.$el);
          const padding = parseFloat(style.getPropertyValue("--v-field-padding-top")) + parseFloat(style.getPropertyValue("--v-input-padding-top")) + parseFloat(style.getPropertyValue("--v-field-padding-bottom"));
          const height = sizerRef.value.scrollHeight;
          const lineHeight = parseFloat(style.lineHeight);
          const minHeight = Math.max(parseFloat(props.rows) * lineHeight + padding, parseFloat(fieldStyle.getPropertyValue("--v-input-control-height")));
          const maxHeight = parseFloat(props.maxRows) * lineHeight + padding || Infinity;
          const newHeight = clamp(height != null ? height : 0, minHeight, maxHeight);
          rows.value = Math.floor((newHeight - padding) / lineHeight);
          controlHeight.value = convertToUnit(newHeight);
        });
      }
      onMounted(calculateInputHeight);
      watch2(model, calculateInputHeight);
      watch2(() => props.rows, calculateInputHeight);
      watch2(() => props.maxRows, calculateInputHeight);
      watch2(() => props.density, calculateInputHeight);
      let observer;
      watch2(sizerRef, (val) => {
        if (val) {
          observer = new ResizeObserver(calculateInputHeight);
          observer.observe(sizerRef.value);
        } else {
          observer == null ? void 0 : observer.disconnect();
        }
      });
      onBeforeUnmount(() => {
        observer == null ? void 0 : observer.disconnect();
      });
      useRender(() => {
        const hasCounter = !!(slots.counter || props.counter || props.counterValue);
        const hasDetails = !!(hasCounter || slots.details);
        const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
        const _a3 = VInput.filterProps(props), {
          modelValue: _2
        } = _a3, inputProps = __objRest(_a3, [
          "modelValue"
        ]);
        const fieldProps = VField.filterProps(props);
        return createVNode(VInput, mergeProps({
          "ref": vInputRef,
          "modelValue": model.value,
          "onUpdate:modelValue": ($event) => model.value = $event,
          "class": ["v-textarea v-text-field", {
            "v-textarea--prefixed": props.prefix,
            "v-textarea--suffixed": props.suffix,
            "v-text-field--prefixed": props.prefix,
            "v-text-field--suffixed": props.suffix,
            "v-textarea--auto-grow": props.autoGrow,
            "v-textarea--no-resize": props.noResize || props.autoGrow,
            "v-input--plain-underlined": isPlainOrUnderlined.value
          }, props.class],
          "style": props.style
        }, rootAttrs, inputProps, {
          "centerAffix": rows.value === 1 && !isPlainOrUnderlined.value,
          "focused": isFocused.value
        }), __spreadProps(__spreadValues({}, slots), {
          default: (_ref2) => {
            let {
              id,
              isDisabled,
              isDirty: isDirty2,
              isReadonly: isReadonly2,
              isValid: isValid3
            } = _ref2;
            return createVNode(VField, mergeProps({
              "ref": vFieldRef,
              "style": {
                "--v-textarea-control-height": controlHeight.value
              },
              "onClick": onControlClick,
              "onMousedown": onControlMousedown,
              "onClick:clear": onClear,
              "onClick:prependInner": props["onClick:prependInner"],
              "onClick:appendInner": props["onClick:appendInner"]
            }, fieldProps, {
              "id": id.value,
              "active": isActive.value || isDirty2.value,
              "centerAffix": rows.value === 1 && !isPlainOrUnderlined.value,
              "dirty": isDirty2.value || props.dirty,
              "disabled": isDisabled.value,
              "focused": isFocused.value,
              "error": isValid3.value === false
            }), __spreadProps(__spreadValues({}, slots), {
              default: (_ref3) => {
                let {
                  props: _a4
                } = _ref3, _b = _a4, {
                  class: fieldClass
                } = _b, slotProps = __objRest(_b, [
                  "class"
                ]);
                return createBaseVNode(Fragment, null, [props.prefix && createBaseVNode("span", {
                  "class": "v-text-field__prefix"
                }, [props.prefix]), withDirectives(createBaseVNode("textarea", mergeProps({
                  "ref": textareaRef,
                  "class": fieldClass,
                  "value": model.value,
                  "onInput": onInput,
                  "autofocus": props.autofocus,
                  "readonly": isReadonly2.value,
                  "disabled": isDisabled.value,
                  "placeholder": props.placeholder,
                  "rows": props.rows,
                  "name": props.name,
                  "onFocus": onFocus,
                  "onBlur": blur
                }, slotProps, inputAttrs), null), [[intersect_default, {
                  handler: onIntersect
                }, null, {
                  once: true
                }]]), props.autoGrow && withDirectives(createBaseVNode("textarea", {
                  "class": normalizeClass([fieldClass, "v-textarea__sizer"]),
                  "id": `${slotProps.id}-sizer`,
                  "onUpdate:modelValue": ($event) => model.value = $event,
                  "ref": sizerRef,
                  "readonly": true,
                  "aria-hidden": "true"
                }, null), [[vModelText, model.value]]), props.suffix && createBaseVNode("span", {
                  "class": "v-text-field__suffix"
                }, [props.suffix])]);
              }
            }));
          },
          details: hasDetails ? (slotProps) => {
            var _a4;
            return createBaseVNode(Fragment, null, [(_a4 = slots.details) == null ? void 0 : _a4.call(slots, slotProps), hasCounter && createBaseVNode(Fragment, null, [createBaseVNode("span", null, null), createVNode(VCounter, {
              "active": props.persistentCounter || isFocused.value,
              "value": counterValue.value,
              "max": max.value,
              "disabled": props.disabled
            }, slots.counter)])]);
          } : void 0
        }));
      });
      return forwardRefs({}, vInputRef, vFieldRef, textareaRef);
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VThemeProvider/VThemeProvider.js
  var makeVThemeProviderProps = propsFactory(__spreadValues(__spreadValues(__spreadValues({
    withBackground: Boolean
  }, makeComponentProps()), makeThemeProps()), makeTagProps()), "VThemeProvider");
  var VThemeProvider = genericComponent()({
    name: "VThemeProvider",
    props: makeVThemeProviderProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      return () => {
        var _a3;
        if (!props.withBackground)
          return (_a3 = slots.default) == null ? void 0 : _a3.call(slots);
        return createVNode(props.tag, {
          "class": normalizeClass(["v-theme-provider", themeClasses.value, props.class]),
          "style": normalizeStyle(props.style)
        }, {
          default: () => {
            var _a4;
            return [(_a4 = slots.default) == null ? void 0 : _a4.call(slots)];
          }
        });
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VTimeline/VTimelineDivider.js
  var makeVTimelineDividerProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    dotColor: String,
    fillDot: Boolean,
    hideDot: Boolean,
    icon: IconValue,
    iconColor: String,
    lineColor: String
  }, makeComponentProps()), makeRoundedProps()), makeSizeProps()), makeElevationProps()), "VTimelineDivider");
  var VTimelineDivider = genericComponent()({
    name: "VTimelineDivider",
    props: makeVTimelineDividerProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        sizeClasses,
        sizeStyles
      } = useSize(props, "v-timeline-divider__dot");
      const {
        backgroundColorStyles,
        backgroundColorClasses
      } = useBackgroundColor(() => props.dotColor);
      const {
        roundedClasses
      } = useRounded(props, "v-timeline-divider__dot");
      const {
        elevationClasses
      } = useElevation(props);
      const {
        backgroundColorClasses: lineColorClasses,
        backgroundColorStyles: lineColorStyles
      } = useBackgroundColor(() => props.lineColor);
      useRender(() => createBaseVNode("div", {
        "class": normalizeClass(["v-timeline-divider", {
          "v-timeline-divider--fill-dot": props.fillDot
        }, props.class]),
        "style": normalizeStyle(props.style)
      }, [createBaseVNode("div", {
        "class": normalizeClass(["v-timeline-divider__before", lineColorClasses.value]),
        "style": normalizeStyle(lineColorStyles.value)
      }, null), !props.hideDot && createBaseVNode("div", {
        "key": "dot",
        "class": normalizeClass(["v-timeline-divider__dot", elevationClasses.value, roundedClasses.value, sizeClasses.value]),
        "style": normalizeStyle(sizeStyles.value)
      }, [createBaseVNode("div", {
        "class": normalizeClass(["v-timeline-divider__inner-dot", backgroundColorClasses.value, roundedClasses.value]),
        "style": normalizeStyle(backgroundColorStyles.value)
      }, [!slots.default ? createVNode(VIcon, {
        "key": "icon",
        "color": props.iconColor,
        "icon": props.icon,
        "size": props.size
      }, null) : createVNode(VDefaultsProvider, {
        "key": "icon-defaults",
        "disabled": !props.icon,
        "defaults": {
          VIcon: {
            color: props.iconColor,
            icon: props.icon,
            size: props.size
          }
        }
      }, slots.default)])]), createBaseVNode("div", {
        "class": normalizeClass(["v-timeline-divider__after", lineColorClasses.value]),
        "style": normalizeStyle(lineColorStyles.value)
      }, null)]));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VTimeline/VTimelineItem.js
  var makeVTimelineItemProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    density: String,
    dotColor: String,
    fillDot: Boolean,
    hideDot: Boolean,
    hideOpposite: {
      type: Boolean,
      default: void 0
    },
    icon: IconValue,
    iconColor: String,
    lineInset: [Number, String],
    side: {
      type: String,
      validator: (v) => v == null || ["start", "end"].includes(v)
    }
  }, makeComponentProps()), makeDimensionProps()), makeElevationProps()), makeRoundedProps()), makeSizeProps()), makeTagProps()), "VTimelineItem");
  var VTimelineItem = genericComponent()({
    name: "VTimelineItem",
    props: makeVTimelineItemProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        dimensionStyles
      } = useDimension(props);
      const dotSize = shallowRef(0);
      const dotRef = ref();
      watch2(dotRef, (newValue) => {
        var _a3, _b;
        if (!newValue)
          return;
        dotSize.value = (_b = (_a3 = newValue.$el.querySelector(".v-timeline-divider__dot")) == null ? void 0 : _a3.getBoundingClientRect().width) != null ? _b : 0;
      }, {
        flush: "post"
      });
      useRender(() => {
        var _a3, _b;
        return createBaseVNode("div", {
          "class": normalizeClass(["v-timeline-item", {
            "v-timeline-item--fill-dot": props.fillDot,
            "v-timeline-item--side-start": props.side === "start",
            "v-timeline-item--side-end": props.side === "end"
          }, props.class]),
          "style": normalizeStyle([{
            "--v-timeline-dot-size": convertToUnit(dotSize.value),
            "--v-timeline-line-inset": props.lineInset ? `calc(var(--v-timeline-dot-size) / 2 + ${convertToUnit(props.lineInset)})` : convertToUnit(0)
          }, props.style])
        }, [createBaseVNode("div", {
          "class": "v-timeline-item__body",
          "style": normalizeStyle(dimensionStyles.value)
        }, [(_a3 = slots.default) == null ? void 0 : _a3.call(slots)]), createVNode(VTimelineDivider, {
          "ref": dotRef,
          "hideDot": props.hideDot,
          "icon": props.icon,
          "iconColor": props.iconColor,
          "size": props.size,
          "elevation": props.elevation,
          "dotColor": props.dotColor,
          "fillDot": props.fillDot,
          "rounded": props.rounded
        }, {
          default: slots.icon
        }), props.density !== "compact" && createBaseVNode("div", {
          "class": "v-timeline-item__opposite"
        }, [!props.hideOpposite && ((_b = slots.opposite) == null ? void 0 : _b.call(slots))])]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VTimeline/VTimeline.js
  var makeVTimelineProps = propsFactory(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    align: {
      type: String,
      default: "center",
      validator: (v) => ["center", "start"].includes(v)
    },
    direction: {
      type: String,
      default: "vertical",
      validator: (v) => ["vertical", "horizontal"].includes(v)
    },
    justify: {
      type: String,
      default: "auto",
      validator: (v) => ["auto", "center"].includes(v)
    },
    side: {
      type: String,
      validator: (v) => v == null || ["start", "end"].includes(v)
    },
    lineThickness: {
      type: [String, Number],
      default: 2
    },
    lineColor: String,
    truncateLine: {
      type: String,
      validator: (v) => ["start", "end", "both"].includes(v)
    }
  }, pick(makeVTimelineItemProps({
    lineInset: 0
  }), ["dotColor", "fillDot", "hideOpposite", "iconColor", "lineInset", "size"])), makeComponentProps()), makeDensityProps()), makeTagProps()), makeThemeProps()), "VTimeline");
  var VTimeline = genericComponent()({
    name: "VTimeline",
    props: makeVTimelineProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        themeClasses
      } = provideTheme(props);
      const {
        densityClasses
      } = useDensity(props);
      const {
        rtlClasses
      } = useRtl();
      provideDefaults({
        VTimelineDivider: {
          lineColor: toRef(() => props.lineColor)
        },
        VTimelineItem: {
          density: toRef(() => props.density),
          dotColor: toRef(() => props.dotColor),
          fillDot: toRef(() => props.fillDot),
          hideOpposite: toRef(() => props.hideOpposite),
          iconColor: toRef(() => props.iconColor),
          lineColor: toRef(() => props.lineColor),
          lineInset: toRef(() => props.lineInset),
          size: toRef(() => props.size)
        }
      });
      const sideClasses = computed2(() => {
        const side = props.side ? props.side : props.density !== "default" ? "end" : null;
        return side && `v-timeline--side-${side}`;
      });
      const truncateClasses = computed2(() => {
        const classes = ["v-timeline--truncate-line-start", "v-timeline--truncate-line-end"];
        switch (props.truncateLine) {
          case "both":
            return classes;
          case "start":
            return classes[0];
          case "end":
            return classes[1];
          default:
            return null;
        }
      });
      useRender(() => createVNode(props.tag, {
        "class": normalizeClass(["v-timeline", `v-timeline--${props.direction}`, `v-timeline--align-${props.align}`, `v-timeline--justify-${props.justify}`, truncateClasses.value, {
          "v-timeline--inset-line": !!props.lineInset
        }, themeClasses.value, densityClasses.value, sideClasses.value, rtlClasses.value, props.class]),
        "style": normalizeStyle([{
          "--v-timeline-line-thickness": convertToUnit(props.lineThickness)
        }, props.style])
      }, slots));
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VToolbar/VToolbarItems.js
  var makeVToolbarItemsProps = propsFactory(__spreadValues(__spreadValues({}, makeComponentProps()), makeVariantProps({
    variant: "text"
  })), "VToolbarItems");
  var VToolbarItems = genericComponent()({
    name: "VToolbarItems",
    props: makeVToolbarItemsProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      provideDefaults({
        VBtn: {
          color: toRef(() => props.color),
          height: "inherit",
          variant: toRef(() => props.variant)
        }
      });
      useRender(() => {
        var _a3;
        return createBaseVNode("div", {
          "class": normalizeClass(["v-toolbar-items", props.class]),
          "style": normalizeStyle(props.style)
        }, [(_a3 = slots.default) == null ? void 0 : _a3.call(slots)]);
      });
      return {};
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VTooltip/VTooltip.js
  var makeVTooltipProps = propsFactory(__spreadValues({
    id: String,
    interactive: Boolean,
    text: String
  }, omit(makeVOverlayProps({
    closeOnBack: false,
    location: "end",
    locationStrategy: "connected",
    eager: true,
    minWidth: 0,
    offset: 10,
    openOnClick: false,
    openOnHover: true,
    origin: "auto",
    scrim: false,
    scrollStrategy: "reposition",
    transition: null
  }), ["absolute", "persistent"])), "VTooltip");
  var VTooltip = genericComponent()({
    name: "VTooltip",
    props: makeVTooltipProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const isActive = useProxiedModel(props, "modelValue");
      const {
        scopeId
      } = useScopeId();
      const uid2 = useId();
      const id = toRef(() => props.id || `v-tooltip-${uid2}`);
      const overlay = ref();
      const location2 = computed2(() => {
        return props.location.split(" ").length > 1 ? props.location : props.location + " center";
      });
      const origin = computed2(() => {
        return props.origin === "auto" || props.origin === "overlap" || props.origin.split(" ").length > 1 || props.location.split(" ").length > 1 ? props.origin : props.origin + " center";
      });
      const transition = toRef(() => {
        if (props.transition != null)
          return props.transition;
        return isActive.value ? "scale-transition" : "fade-transition";
      });
      const activatorProps = computed2(() => mergeProps({
        "aria-describedby": id.value
      }, props.activatorProps));
      useRender(() => {
        const overlayProps = VOverlay.filterProps(props);
        return createVNode(VOverlay, mergeProps({
          "ref": overlay,
          "class": ["v-tooltip", {
            "v-tooltip--interactive": props.interactive
          }, props.class],
          "style": props.style,
          "id": id.value
        }, overlayProps, {
          "modelValue": isActive.value,
          "onUpdate:modelValue": ($event) => isActive.value = $event,
          "transition": transition.value,
          "absolute": true,
          "location": location2.value,
          "origin": origin.value,
          "persistent": true,
          "role": "tooltip",
          "activatorProps": activatorProps.value,
          "_disableGlobalStack": true
        }, scopeId), {
          activator: slots.activator,
          default: function() {
            var _a3, _b;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return (_b = (_a3 = slots.default) == null ? void 0 : _a3.call(slots, ...args)) != null ? _b : props.text;
          }
        });
      });
      return forwardRefs({}, overlay);
    }
  });

  // ../posawesome/node_modules/vuetify/lib/components/VValidation/VValidation.js
  var VValidation = genericComponent()({
    name: "VValidation",
    props: makeValidationProps(),
    emits: {
      "update:modelValue": (value) => true
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const validation = useValidation(props, "validation");
      return () => {
        var _a3;
        return (_a3 = slots.default) == null ? void 0 : _a3.call(slots, validation);
      };
    }
  });

  // ../posawesome/node_modules/vuetify/lib/directives/index.js
  var directives_exports = {};
  __export(directives_exports, {
    ClickOutside: () => ClickOutside,
    Intersect: () => Intersect,
    Mutate: () => Mutate,
    Resize: () => Resize,
    Ripple: () => Ripple,
    Scroll: () => Scroll,
    Tooltip: () => Tooltip,
    Touch: () => Touch
  });

  // ../posawesome/node_modules/vuetify/lib/directives/mutate/index.js
  function mounted4(el, binding) {
    var _b, _c, _d, _e;
    const modifiers = binding.modifiers || {};
    const value = binding.value;
    const _a3 = modifiers, {
      once,
      immediate
    } = _a3, modifierKeys = __objRest(_a3, [
      "once",
      "immediate"
    ]);
    const defaultValue = !Object.keys(modifierKeys).length;
    const {
      handler,
      options
    } = typeof value === "object" ? value : {
      handler: value,
      options: {
        attributes: (_b = modifierKeys == null ? void 0 : modifierKeys.attr) != null ? _b : defaultValue,
        characterData: (_c = modifierKeys == null ? void 0 : modifierKeys.char) != null ? _c : defaultValue,
        childList: (_d = modifierKeys == null ? void 0 : modifierKeys.child) != null ? _d : defaultValue,
        subtree: (_e = modifierKeys == null ? void 0 : modifierKeys.sub) != null ? _e : defaultValue
      }
    };
    const observer = new MutationObserver(function() {
      let mutations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      let observer2 = arguments.length > 1 ? arguments[1] : void 0;
      handler == null ? void 0 : handler(mutations, observer2);
      if (once)
        unmounted4(el, binding);
    });
    if (immediate)
      handler == null ? void 0 : handler([], observer);
    el._mutate = Object(el._mutate);
    el._mutate[binding.instance.$.uid] = {
      observer
    };
    observer.observe(el, options);
  }
  function unmounted4(el, binding) {
    var _a3;
    if (!((_a3 = el._mutate) == null ? void 0 : _a3[binding.instance.$.uid]))
      return;
    el._mutate[binding.instance.$.uid].observer.disconnect();
    delete el._mutate[binding.instance.$.uid];
  }
  var Mutate = {
    mounted: mounted4,
    unmounted: unmounted4
  };

  // ../posawesome/node_modules/vuetify/lib/directives/resize/index.js
  function mounted5(el, binding) {
    var _a3, _b;
    const handler = binding.value;
    const options = {
      passive: !((_a3 = binding.modifiers) == null ? void 0 : _a3.active)
    };
    window.addEventListener("resize", handler, options);
    el._onResize = Object(el._onResize);
    el._onResize[binding.instance.$.uid] = {
      handler,
      options
    };
    if (!((_b = binding.modifiers) == null ? void 0 : _b.quiet)) {
      handler();
    }
  }
  function unmounted5(el, binding) {
    var _a3;
    if (!((_a3 = el._onResize) == null ? void 0 : _a3[binding.instance.$.uid]))
      return;
    const {
      handler,
      options
    } = el._onResize[binding.instance.$.uid];
    window.removeEventListener("resize", handler, options);
    delete el._onResize[binding.instance.$.uid];
  }
  var Resize = {
    mounted: mounted5,
    unmounted: unmounted5
  };

  // ../posawesome/node_modules/vuetify/lib/directives/scroll/index.js
  function mounted6(el, binding) {
    var _a3;
    const {
      self: self2 = false
    } = (_a3 = binding.modifiers) != null ? _a3 : {};
    const value = binding.value;
    const options = typeof value === "object" && value.options || {
      passive: true
    };
    const handler = typeof value === "function" || "handleEvent" in value ? value : value.handler;
    const target = self2 ? el : binding.arg ? document.querySelector(binding.arg) : window;
    if (!target)
      return;
    target.addEventListener("scroll", handler, options);
    el._onScroll = Object(el._onScroll);
    el._onScroll[binding.instance.$.uid] = {
      handler,
      options,
      target: self2 ? void 0 : target
    };
  }
  function unmounted6(el, binding) {
    var _a3;
    if (!((_a3 = el._onScroll) == null ? void 0 : _a3[binding.instance.$.uid]))
      return;
    const {
      handler,
      options,
      target = el
    } = el._onScroll[binding.instance.$.uid];
    target.removeEventListener("scroll", handler, options);
    delete el._onScroll[binding.instance.$.uid];
  }
  function updated2(el, binding) {
    if (binding.value === binding.oldValue)
      return;
    unmounted6(el, binding);
    mounted6(el, binding);
  }
  var Scroll = {
    mounted: mounted6,
    unmounted: unmounted6,
    updated: updated2
  };

  // ../posawesome/node_modules/vuetify/lib/composables/directiveComponent.js
  function useDirectiveComponent(component, props) {
    const concreteComponent = typeof component === "string" ? resolveComponent(component) : component;
    const hook = mountComponent(concreteComponent, props);
    return {
      mounted: hook,
      updated: hook,
      unmounted(el) {
        render(null, el);
      }
    };
  }
  function mountComponent(component, props) {
    return function(el, binding, vnode) {
      var _a3, _b, _c, _d, _e, _f;
      const _props = typeof props === "function" ? props(binding) : props;
      const text = (_c = (_b = (_a3 = binding.value) == null ? void 0 : _a3.text) != null ? _b : binding.value) != null ? _c : _props == null ? void 0 : _props.text;
      const value = isObject2(binding.value) ? binding.value : {};
      const children = () => text != null ? text : el.textContent;
      const provides = (_f = vnode.ctx === binding.instance.$ ? (_d = findComponentParent(vnode, binding.instance.$)) == null ? void 0 : _d.provides : (_e = vnode.ctx) == null ? void 0 : _e.provides) != null ? _f : binding.instance.$.provides;
      const node = h(component, mergeProps(_props, value), children);
      node.appContext = Object.assign(/* @__PURE__ */ Object.create(null), binding.instance.$.appContext, {
        provides
      });
      render(node, el);
    };
  }
  function findComponentParent(vnode, root) {
    const stack2 = /* @__PURE__ */ new Set();
    const walk = (children) => {
      var _a3, _b;
      for (const child of children) {
        if (!child)
          continue;
        if (child === vnode || child.el && vnode.el && child.el === vnode.el) {
          return true;
        }
        stack2.add(child);
        let result2;
        if (child.suspense) {
          result2 = walk([child.ssContent]);
        } else if (Array.isArray(child.children)) {
          result2 = walk(child.children);
        } else if ((_a3 = child.component) == null ? void 0 : _a3.vnode) {
          result2 = walk([(_b = child.component) == null ? void 0 : _b.subTree]);
        }
        if (result2) {
          return result2;
        }
        stack2.delete(child);
      }
      return false;
    };
    if (!walk([root.subTree])) {
      consoleError("Could not find original vnode, component will not inherit provides");
      return root;
    }
    const result = Array.from(stack2).reverse();
    for (const child of result) {
      if (child.component) {
        return child.component;
      }
    }
    return root;
  }

  // ../posawesome/node_modules/vuetify/lib/directives/tooltip/index.js
  var Tooltip = useDirectiveComponent(VTooltip, (binding) => {
    var _a3;
    return {
      activator: "parent",
      location: (_a3 = binding.arg) == null ? void 0 : _a3.replace("-", " "),
      text: typeof binding.value === "boolean" ? void 0 : binding.value
    };
  });

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/navbar/NavbarAppBar.vue?type=script
  var NavbarAppBar_default = {
    name: "NavbarAppBar",
    props: {
      posProfile: {
        type: Object,
        default: () => ({})
      },
      pendingInvoices: {
        type: Number,
        default: 0
      },
      isDark: Boolean
    },
    computed: {
      appBarColor() {
        return this.isDark ? this.$vuetify.theme.themes.dark.colors.surface : "white";
      },
      displayName() {
        if (this.posProfile && this.posProfile.name) {
          return this.posProfile.name;
        }
        if (frappe.session && frappe.session.user_fullname) {
          return frappe.session.user_fullname;
        }
        if (frappe.session && frappe.session.user) {
          return frappe.session.user;
        }
        return "User";
      }
    },
    emits: ["nav-click", "go-desk", "show-offline-invoices"]
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/navbar/NavbarAppBar.vue?type=template
  var _withScopeId = (n) => (pushScopeId("data-v-559a00f1"), n = n(), popScopeId(), n);
  var _hoisted_1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "font-weight-light" }, "POS", -1));
  var _hoisted_2 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", null, "Awesome", -1));
  var _hoisted_3 = { class: "profile-section mx-1" };
  function render2(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_app_bar_nav_icon = resolveComponent("v-app-bar-nav-icon");
    const _component_v_img = resolveComponent("v-img");
    const _component_v_toolbar_title = resolveComponent("v-toolbar-title");
    const _component_v_spacer = resolveComponent("v-spacer");
    const _component_v_icon = resolveComponent("v-icon");
    const _component_v_chip = resolveComponent("v-chip");
    const _component_v_badge = resolveComponent("v-badge");
    const _component_v_tooltip = resolveComponent("v-tooltip");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_app_bar = resolveComponent("v-app-bar");
    return openBlock(), createBlock(_component_v_app_bar, {
      app: "",
      flat: "",
      height: "56",
      color: $options.appBarColor,
      theme: $props.isDark ? "dark" : "light",
      class: "navbar-enhanced elevation-2 px-2 pb-1"
    }, {
      default: withCtx(() => [
        createVNode(_component_v_app_bar_nav_icon, {
          ref: "navIcon",
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("nav-click")),
          class: "text-secondary nav-icon"
        }, null, 512),
        createVNode(_component_v_img, {
          src: "/assets/posawesome/js/posapp/components/pos/pos.png",
          alt: "POS Awesome",
          "max-width": "32",
          class: "mx-2"
        }),
        createVNode(_component_v_toolbar_title, {
          onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("go-desk")),
          class: "text-h6 font-weight-bold text-primary navbar-title",
          style: { "cursor": "pointer", "text-decoration": "none" }
        }, {
          default: withCtx(() => [
            _hoisted_1,
            _hoisted_2
          ]),
          _: 1
        }),
        createVNode(_component_v_spacer),
        createCommentVNode(" Enhanced connectivity status indicator - Always visible "),
        renderSlot(_ctx.$slots, "status-indicator", {}, void 0, true),
        createCommentVNode(" Cache Usage Meter "),
        renderSlot(_ctx.$slots, "cache-usage-meter", {}, void 0, true),
        createBaseVNode("div", _hoisted_3, [
          createVNode(_component_v_chip, {
            color: "primary",
            variant: "outlined",
            class: "profile-chip"
          }, {
            default: withCtx(() => [
              createVNode(_component_v_icon, { start: "" }, {
                default: withCtx(() => [
                  createTextVNode("mdi-account-circle")
                ]),
                _: 1
              }),
              createTextVNode(" " + toDisplayString($options.displayName), 1)
            ]),
            _: 1
          })
        ]),
        createVNode(_component_v_btn, {
          icon: "",
          color: "primary",
          class: normalizeClass(["mx-1 offline-invoices-btn", { "has-pending": $props.pendingInvoices > 0 }]),
          onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("show-offline-invoices"))
        }, {
          default: withCtx(() => [
            $props.pendingInvoices > 0 ? (openBlock(), createBlock(_component_v_badge, {
              key: 0,
              content: $props.pendingInvoices,
              color: "error",
              overlap: ""
            }, {
              default: withCtx(() => [
                createVNode(_component_v_icon, null, {
                  default: withCtx(() => [
                    createTextVNode("mdi-file-document-multiple-outline")
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["content"])) : (openBlock(), createBlock(_component_v_icon, { key: 1 }, {
              default: withCtx(() => [
                createTextVNode("mdi-file-document-multiple-outline")
              ]),
              _: 1
            })),
            createVNode(_component_v_tooltip, {
              activator: "parent",
              location: "bottom"
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.__("Offline Invoices")) + " (" + toDisplayString($props.pendingInvoices) + ") ", 1)
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["class"]),
        createCommentVNode(" Menu component slot "),
        renderSlot(_ctx.$slots, "menu", {}, void 0, true)
      ]),
      _: 3
    }, 8, ["color", "theme"]);
  }

  // ../posawesome/posawesome/public/js/posapp/components/navbar/NavbarAppBar.vue
  NavbarAppBar_default.render = render2;
  NavbarAppBar_default.__file = "../posawesome/posawesome/public/js/posapp/components/navbar/NavbarAppBar.vue";
  NavbarAppBar_default.__scopeId = "data-v-559a00f1";
  var NavbarAppBar_default2 = NavbarAppBar_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/navbar/NavbarDrawer.vue?type=script
  var NavbarDrawer_default = {
    name: "NavbarDrawer",
    props: {
      drawer: Boolean,
      company: String,
      companyImg: String,
      items: Array,
      item: Number,
      isDark: Boolean
    },
    data() {
      return {
        mini: false,
        drawerOpen: this.drawer,
        activeItem: this.item
      };
    },
    watch: {
      drawer(val) {
        console.log("Drawer prop changed to:", val);
        this.drawerOpen = val;
        if (val) {
          this.mini = false;
        }
      },
      drawerOpen(val) {
        console.log("DrawerOpen changed to:", val);
        this.$emit("update:drawer", val);
      },
      item(val) {
        this.activeItem = val;
      },
      activeItem(val) {
        this.$emit("update:item", val);
      }
    },
    mounted() {
      console.log("NavbarDrawer mounted with:");
      console.log("- Drawer:", this.drawer);
      console.log("- Company:", this.company);
      console.log("- Items:", this.items);
      console.log("- Company Image:", this.companyImg);
    },
    methods: {
      handleMouseLeave() {
        if (!this.drawerOpen)
          return;
        clearTimeout(this._closeTimeout);
        this._closeTimeout = setTimeout(() => {
          this.drawerOpen = false;
          this.mini = true;
        }, 250);
      },
      changePage(key) {
        console.log("Changing page to:", key);
        this.$emit("change-page", key);
        if (window.innerWidth < 1024) {
          this.closeDrawer();
        }
      },
      closeDrawer() {
        this.drawerOpen = false;
        this.mini = true;
      }
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/navbar/NavbarDrawer.vue?type=template
  var _hoisted_12 = {
    key: 0,
    class: "drawer-header"
  };
  var _hoisted_22 = { class: "drawer-company" };
  var _hoisted_32 = {
    key: 1,
    class: "drawer-header-mini"
  };
  function render3(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_img = resolveComponent("v-img");
    const _component_v_avatar = resolveComponent("v-avatar");
    const _component_v_divider = resolveComponent("v-divider");
    const _component_v_icon = resolveComponent("v-icon");
    const _component_v_list_item_title = resolveComponent("v-list-item-title");
    const _component_v_list_item = resolveComponent("v-list-item");
    const _component_v_list_item_group = resolveComponent("v-list-item-group");
    const _component_v_list = resolveComponent("v-list");
    const _component_v_navigation_drawer = resolveComponent("v-navigation-drawer");
    return openBlock(), createBlock(_component_v_navigation_drawer, {
      modelValue: $data.drawerOpen,
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.drawerOpen = $event),
      "mini-variant": $data.mini,
      "expand-on-hover": "",
      width: "220",
      class: "drawer-custom",
      onMouseleave: $options.handleMouseLeave,
      temporary: "",
      location: "left",
      scrim: true
    }, {
      default: withCtx(() => [
        !$data.mini ? (openBlock(), createElementBlock("div", _hoisted_12, [
          createVNode(_component_v_avatar, { size: "40" }, {
            default: withCtx(() => [
              createVNode(_component_v_img, {
                src: $props.companyImg,
                alt: "Company logo"
              }, null, 8, ["src"])
            ]),
            _: 1
          }),
          createBaseVNode("span", _hoisted_22, toDisplayString($props.company), 1)
        ])) : (openBlock(), createElementBlock("div", _hoisted_32, [
          createVNode(_component_v_avatar, { size: "40" }, {
            default: withCtx(() => [
              createVNode(_component_v_img, {
                src: $props.companyImg,
                alt: "Company logo"
              }, null, 8, ["src"])
            ]),
            _: 1
          })
        ])),
        createVNode(_component_v_divider),
        createVNode(_component_v_list, {
          dense: "",
          nav: ""
        }, {
          default: withCtx(() => [
            createVNode(_component_v_list_item_group, {
              modelValue: $data.activeItem,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.activeItem = $event),
              "active-class": "active-item"
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList($props.items, (item, index) => {
                  return openBlock(), createBlock(_component_v_list_item, {
                    key: item.text,
                    onClick: ($event) => $options.changePage(item.text),
                    class: "drawer-item"
                  }, {
                    prepend: withCtx(() => [
                      createVNode(_component_v_icon, { class: "drawer-icon" }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(item.icon), 1)
                        ]),
                        _: 2
                      }, 1024)
                    ]),
                    default: withCtx(() => [
                      createVNode(_component_v_list_item_title, { class: "drawer-item-title" }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(item.text), 1)
                        ]),
                        _: 2
                      }, 1024)
                    ]),
                    _: 2
                  }, 1032, ["onClick"]);
                }), 128))
              ]),
              _: 1
            }, 8, ["modelValue"])
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["modelValue", "mini-variant", "onMouseleave"]);
  }

  // ../posawesome/posawesome/public/js/posapp/components/navbar/NavbarDrawer.vue
  NavbarDrawer_default.render = render3;
  NavbarDrawer_default.__file = "../posawesome/posawesome/public/js/posapp/components/navbar/NavbarDrawer.vue";
  NavbarDrawer_default.__scopeId = "data-v-5ea7027e";
  var NavbarDrawer_default2 = NavbarDrawer_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/navbar/NavbarMenu.vue?type=script
  var NavbarMenu_default = {
    name: "NavbarMenu",
    props: {
      posProfile: {
        type: Object,
        default: () => ({})
      },
      lastInvoiceId: String,
      manualOffline: Boolean,
      isDark: Boolean
    },
    emits: [
      "close-shift",
      "print-last-invoice",
      "sync-invoices",
      "toggle-offline",
      "clear-cache",
      "show-about",
      "toggle-theme",
      "logout"
    ]
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/navbar/NavbarMenu.vue?type=template
  var _hoisted_13 = { class: "menu-header-compact" };
  var _hoisted_23 = { class: "menu-header-text-compact" };
  var _hoisted_33 = { class: "menu-icon-wrapper-compact primary-icon" };
  var _hoisted_4 = { class: "menu-content-compact" };
  var _hoisted_5 = { class: "menu-icon-wrapper-compact secondary-icon" };
  var _hoisted_6 = { class: "menu-content-compact" };
  var _hoisted_7 = { class: "menu-icon-wrapper-compact info-icon" };
  var _hoisted_8 = { class: "menu-content-compact" };
  var _hoisted_9 = { class: "menu-icon-wrapper-compact warning-icon" };
  var _hoisted_10 = { class: "menu-content-compact" };
  var _hoisted_11 = { class: "menu-icon-wrapper-compact neutral-icon" };
  var _hoisted_122 = { class: "menu-content-compact" };
  var _hoisted_132 = { class: "menu-icon-wrapper-compact neutral-icon" };
  var _hoisted_14 = { class: "menu-content-compact" };
  var _hoisted_15 = { class: "menu-icon-wrapper-compact info-icon" };
  var _hoisted_16 = { class: "menu-content-compact" };
  var _hoisted_17 = { class: "menu-icon-wrapper-compact danger-icon" };
  var _hoisted_18 = { class: "menu-content-compact" };
  function render4(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_icon = resolveComponent("v-icon");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_list_item_title = resolveComponent("v-list-item-title");
    const _component_v_list_item_subtitle = resolveComponent("v-list-item-subtitle");
    const _component_v_list_item = resolveComponent("v-list-item");
    const _component_v_divider = resolveComponent("v-divider");
    const _component_v_list = resolveComponent("v-list");
    const _component_v_card = resolveComponent("v-card");
    const _component_v_menu = resolveComponent("v-menu");
    return openBlock(), createBlock(_component_v_menu, {
      "offset-y": "",
      "min-width": 240,
      "close-on-content-click": false,
      location: "bottom end",
      offset: [0, 4]
    }, {
      activator: withCtx(({ props }) => [
        createVNode(_component_v_btn, mergeProps(props, {
          color: "primary",
          variant: "elevated",
          class: "menu-btn-compact"
        }), {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.__("Menu")) + " ", 1),
            createVNode(_component_v_icon, {
              right: "",
              size: "16",
              class: "ml-1"
            }, {
              default: withCtx(() => [
                createTextVNode("mdi-menu-down")
              ]),
              _: 1
            })
          ]),
          _: 2
        }, 1040)
      ]),
      default: withCtx(() => [
        createVNode(_component_v_card, {
          class: "menu-card-compact",
          elevation: "12"
        }, {
          default: withCtx(() => [
            createBaseVNode("div", _hoisted_13, [
              createVNode(_component_v_icon, {
                color: "primary",
                size: "20"
              }, {
                default: withCtx(() => [
                  createTextVNode("mdi-menu")
                ]),
                _: 1
              }),
              createBaseVNode("span", _hoisted_23, toDisplayString(_ctx.__("Actions")), 1)
            ]),
            createVNode(_component_v_list, {
              density: "compact",
              class: "menu-list-compact"
            }, {
              default: withCtx(() => [
                !$props.posProfile.posa_hide_closing_shift ? (openBlock(), createBlock(_component_v_list_item, {
                  key: 0,
                  onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close-shift")),
                  class: "menu-item-compact primary-action"
                }, {
                  prepend: withCtx(() => [
                    createBaseVNode("div", _hoisted_33, [
                      createVNode(_component_v_icon, {
                        color: "white",
                        size: "16"
                      }, {
                        default: withCtx(() => [
                          createTextVNode("mdi-content-save-move-outline")
                        ]),
                        _: 1
                      })
                    ])
                  ]),
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_4, [
                      createVNode(_component_v_list_item_title, { class: "menu-item-title-compact" }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.__("Close Shift")), 1)
                        ]),
                        _: 1
                      }),
                      createVNode(_component_v_list_item_subtitle, { class: "menu-item-subtitle-compact" }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.__("End current session")), 1)
                        ]),
                        _: 1
                      })
                    ])
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true),
                $props.posProfile.posa_allow_print_last_invoice && $props.lastInvoiceId ? (openBlock(), createBlock(_component_v_list_item, {
                  key: 1,
                  onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("print-last-invoice")),
                  class: "menu-item-compact secondary-action"
                }, {
                  prepend: withCtx(() => [
                    createBaseVNode("div", _hoisted_5, [
                      createVNode(_component_v_icon, {
                        color: "white",
                        size: "16"
                      }, {
                        default: withCtx(() => [
                          createTextVNode("mdi-printer")
                        ]),
                        _: 1
                      })
                    ])
                  ]),
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_6, [
                      createVNode(_component_v_list_item_title, { class: "menu-item-title-compact" }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.__("Print Last Invoice")), 1)
                        ]),
                        _: 1
                      }),
                      createVNode(_component_v_list_item_subtitle, { class: "menu-item-subtitle-compact" }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.__("Reprint previous transaction")), 1)
                        ]),
                        _: 1
                      })
                    ])
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true),
                createVNode(_component_v_list_item, {
                  onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("sync-invoices")),
                  class: "menu-item-compact info-action"
                }, {
                  prepend: withCtx(() => [
                    createBaseVNode("div", _hoisted_7, [
                      createVNode(_component_v_icon, {
                        color: "white",
                        size: "16"
                      }, {
                        default: withCtx(() => [
                          createTextVNode("mdi-sync")
                        ]),
                        _: 1
                      })
                    ])
                  ]),
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_8, [
                      createVNode(_component_v_list_item_title, { class: "menu-item-title-compact" }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.__("Sync Offline Invoices")), 1)
                        ]),
                        _: 1
                      }),
                      createVNode(_component_v_list_item_subtitle, { class: "menu-item-subtitle-compact" }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.__("Upload pending transactions")), 1)
                        ]),
                        _: 1
                      })
                    ])
                  ]),
                  _: 1
                }),
                createVNode(_component_v_list_item, {
                  onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("toggle-offline")),
                  class: "menu-item-compact warning-action"
                }, {
                  prepend: withCtx(() => [
                    createBaseVNode("div", _hoisted_9, [
                      createVNode(_component_v_icon, {
                        color: "white",
                        size: "16"
                      }, {
                        default: withCtx(() => [
                          createTextVNode("mdi-wifi-off")
                        ]),
                        _: 1
                      })
                    ])
                  ]),
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_10, [
                      createVNode(_component_v_list_item_title, { class: "menu-item-title-compact" }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString($props.manualOffline ? _ctx.__("Go Online") : _ctx.__("Go Offline")), 1)
                        ]),
                        _: 1
                      }),
                      createVNode(_component_v_list_item_subtitle, { class: "menu-item-subtitle-compact" }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString($props.manualOffline ? _ctx.__("Disable offline mode") : _ctx.__("Work without server connection")), 1)
                        ]),
                        _: 1
                      })
                    ])
                  ]),
                  _: 1
                }),
                createVNode(_component_v_list_item, {
                  onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("clear-cache")),
                  class: "menu-item-compact neutral-action"
                }, {
                  prepend: withCtx(() => [
                    createBaseVNode("div", _hoisted_11, [
                      createVNode(_component_v_icon, {
                        color: "white",
                        size: "16"
                      }, {
                        default: withCtx(() => [
                          createTextVNode("mdi-delete-sweep-outline")
                        ]),
                        _: 1
                      })
                    ])
                  ]),
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_122, [
                      createVNode(_component_v_list_item_title, { class: "menu-item-title-compact" }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.__("Clear Cache")), 1)
                        ]),
                        _: 1
                      }),
                      createVNode(_component_v_list_item_subtitle, { class: "menu-item-subtitle-compact" }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.__("Remove local data and refresh")), 1)
                        ]),
                        _: 1
                      })
                    ])
                  ]),
                  _: 1
                }),
                createVNode(_component_v_divider, { class: "menu-section-divider-compact" }),
                createVNode(_component_v_list_item, {
                  onClick: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("show-about")),
                  class: "menu-item-compact neutral-action"
                }, {
                  prepend: withCtx(() => [
                    createBaseVNode("div", _hoisted_132, [
                      createVNode(_component_v_icon, {
                        color: "white",
                        size: "16"
                      }, {
                        default: withCtx(() => [
                          createTextVNode("mdi-information-outline")
                        ]),
                        _: 1
                      })
                    ])
                  ]),
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_14, [
                      createVNode(_component_v_list_item_title, { class: "menu-item-title-compact" }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.__("About")), 1)
                        ]),
                        _: 1
                      }),
                      createVNode(_component_v_list_item_subtitle, { class: "menu-item-subtitle-compact" }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.__("App information")), 1)
                        ]),
                        _: 1
                      })
                    ])
                  ]),
                  _: 1
                }),
                createCommentVNode(" Theme toggle menu item "),
                createVNode(_component_v_list_item, {
                  onClick: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("toggle-theme")),
                  class: "menu-item-compact info-action"
                }, {
                  prepend: withCtx(() => [
                    createBaseVNode("div", _hoisted_15, [
                      createVNode(_component_v_icon, {
                        color: "white",
                        size: "16"
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString($props.isDark ? "mdi-white-balance-sunny" : "mdi-moon-waning-crescent"), 1)
                        ]),
                        _: 1
                      })
                    ])
                  ]),
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_16, [
                      createVNode(_component_v_list_item_title, { class: "menu-item-title-compact" }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString($props.isDark ? _ctx.__("Light Mode") : _ctx.__("Dark Mode")), 1)
                        ]),
                        _: 1
                      }),
                      createVNode(_component_v_list_item_subtitle, { class: "menu-item-subtitle-compact" }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.__("Switch theme appearance")), 1)
                        ]),
                        _: 1
                      })
                    ])
                  ]),
                  _: 1
                }),
                createVNode(_component_v_list_item, {
                  onClick: _cache[7] || (_cache[7] = ($event) => _ctx.$emit("logout")),
                  class: "menu-item-compact danger-action"
                }, {
                  prepend: withCtx(() => [
                    createBaseVNode("div", _hoisted_17, [
                      createVNode(_component_v_icon, {
                        color: "white",
                        size: "16"
                      }, {
                        default: withCtx(() => [
                          createTextVNode("mdi-logout")
                        ]),
                        _: 1
                      })
                    ])
                  ]),
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_18, [
                      createVNode(_component_v_list_item_title, { class: "menu-item-title-compact" }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.__("Logout")), 1)
                        ]),
                        _: 1
                      }),
                      createVNode(_component_v_list_item_subtitle, { class: "menu-item-subtitle-compact" }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.__("Sign out of session")), 1)
                        ]),
                        _: 1
                      })
                    ])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    });
  }

  // ../posawesome/posawesome/public/js/posapp/components/navbar/NavbarMenu.vue
  NavbarMenu_default.render = render4;
  NavbarMenu_default.__file = "../posawesome/posawesome/public/js/posapp/components/navbar/NavbarMenu.vue";
  NavbarMenu_default.__scopeId = "data-v-9128e291";
  var NavbarMenu_default2 = NavbarMenu_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/navbar/StatusIndicator.vue?type=script
  var StatusIndicator_default = {
    name: "StatusIndicator",
    props: {
      networkOnline: Boolean,
      serverOnline: Boolean,
      serverConnecting: Boolean,
      isIpHost: Boolean,
      syncTotals: Object
    },
    computed: {
      statusColor() {
        console.log("StatusIndicator - Network:", this.networkOnline, "Server:", this.serverOnline, "Connecting:", this.serverConnecting, "IP Host:", this.isIpHost, "Host:", window.location.hostname);
        if (this.serverConnecting) {
          return "orange";
        }
        if (this.isIpHost) {
          return this.networkOnline ? "green" : "red";
        }
        if (this.networkOnline && this.serverOnline) {
          return "green";
        }
        if (this.networkOnline && !this.serverOnline) {
          return "orange";
        }
        return "red";
      },
      statusIcon() {
        console.log("StatusIndicator - Determining icon for network:", this.networkOnline, "server:", this.serverOnline, "connecting:", this.serverConnecting);
        if (this.serverConnecting) {
          return "mdi-wifi-sync";
        }
        if (this.isIpHost) {
          return this.networkOnline ? "mdi-wifi" : "mdi-wifi-off";
        }
        if (this.networkOnline && this.serverOnline) {
          return "mdi-wifi";
        }
        if (this.networkOnline && !this.serverOnline) {
          return "mdi-wifi-strength-alert-outline";
        }
        return "mdi-wifi-off";
      },
      statusText() {
        const hostname = window.location.hostname;
        const hostType = this.isIpHost ? "Local/IP Host" : "Domain Host";
        if (this.serverConnecting) {
          return this.__(`Connecting to server... (${hostType}: ${hostname})`);
        }
        if (!this.networkOnline) {
          return this.__(`No Internet Connection (${hostType}: ${hostname})`);
        }
        if (this.isIpHost) {
          return this.__(`Connected to ${hostname}`);
        }
        if (this.serverOnline) {
          return this.__(`Connected to Server (${hostname})`);
        }
        return this.__(`Server Offline (${hostname})`);
      },
      syncInfoText() {
        const { pending, synced, drafted } = this.syncTotals;
        const pendingCount = pending || 0;
        const syncedCount = synced || 0;
        const draftedCount = drafted || 0;
        if (!this.networkOnline) {
          if (pendingCount > 0 || syncedCount > 0 || draftedCount > 0) {
            return `Pending: ${pendingCount} | Synced: ${syncedCount} | Draft: ${draftedCount}`;
          } else {
            return "Offline Mode";
          }
        }
        return `To Sync: ${pendingCount} | Synced: ${syncedCount} | Draft: ${draftedCount}`;
      }
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/navbar/StatusIndicator.vue?type=template
  var _hoisted_19 = { class: "status-section-enhanced mx-1" };
  var _hoisted_24 = { class: "status-info-always-visible" };
  var _hoisted_34 = { class: "status-detail-inline" };
  function render5(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_icon = resolveComponent("v-icon");
    const _component_v_btn = resolveComponent("v-btn");
    return openBlock(), createElementBlock("div", _hoisted_19, [
      createVNode(_component_v_btn, {
        icon: "",
        title: $options.statusText,
        class: "status-btn-enhanced",
        color: $options.statusColor
      }, {
        default: withCtx(() => [
          createVNode(_component_v_icon, { color: $options.statusColor }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString($options.statusIcon), 1)
            ]),
            _: 1
          }, 8, ["color"])
        ]),
        _: 1
      }, 8, ["title", "color"]),
      createBaseVNode("div", _hoisted_24, [
        createBaseVNode("div", {
          class: normalizeClass(["status-title-inline", { "status-connected": $options.statusColor === "green", "status-offline": $options.statusColor === "red" }])
        }, toDisplayString($options.statusText), 3),
        createBaseVNode("div", _hoisted_34, toDisplayString($options.syncInfoText), 1)
      ])
    ]);
  }

  // ../posawesome/posawesome/public/js/posapp/components/navbar/StatusIndicator.vue
  StatusIndicator_default.render = render5;
  StatusIndicator_default.__file = "../posawesome/posawesome/public/js/posapp/components/navbar/StatusIndicator.vue";
  StatusIndicator_default.__scopeId = "data-v-fe826534";
  var StatusIndicator_default2 = StatusIndicator_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/navbar/CacheUsageMeter.vue?type=script
  var CacheUsageMeter_default = {
    name: "CacheUsageMeter",
    props: {
      cacheUsage: {
        type: Number,
        default: 0
      },
      cacheUsageLoading: {
        type: Boolean,
        default: false
      },
      cacheUsageDetails: {
        type: Object,
        default: () => ({
          total: 0,
          indexedDB: 0,
          localStorage: 0
        })
      }
    },
    computed: {
      cacheUsageColor() {
        if (this.cacheUsage < 50)
          return "success";
        if (this.cacheUsage < 80)
          return "warning";
        return "error";
      }
    },
    methods: {
      refreshCacheUsage() {
        this.$emit("refresh");
      },
      formatBytes(bytes) {
        if (bytes === 0)
          return "0 Bytes";
        const k = 1024;
        const sizes = ["Bytes", "KB", "MB", "GB"];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
      }
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/navbar/CacheUsageMeter.vue?type=template
  var _hoisted_110 = { class: "cache-usage-section mx-1" };
  var _hoisted_25 = { class: "cache-tooltip-content" };
  var _hoisted_35 = { class: "cache-tooltip-title" };
  var _hoisted_42 = {
    key: 0,
    class: "cache-tooltip-detail"
  };
  var _hoisted_52 = {
    key: 1,
    class: "cache-tooltip-detail"
  };
  var _hoisted_62 = { class: "cache-tooltip-action" };
  function render6(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_icon = resolveComponent("v-icon");
    const _component_v_progress_circular = resolveComponent("v-progress-circular");
    const _component_v_tooltip = resolveComponent("v-tooltip");
    return openBlock(), createElementBlock("div", _hoisted_110, [
      createVNode(_component_v_tooltip, { location: "bottom" }, {
        activator: withCtx(({ props }) => [
          createBaseVNode("div", mergeProps(props, {
            class: "cache-meter-container",
            onClick: _cache[0] || (_cache[0] = (...args) => $options.refreshCacheUsage && $options.refreshCacheUsage(...args))
          }), [
            createVNode(_component_v_progress_circular, {
              "model-value": $props.cacheUsage,
              color: $options.cacheUsageColor,
              size: 32,
              width: 3,
              class: "cache-meter"
            }, {
              default: withCtx(() => [
                createVNode(_component_v_icon, { size: "16" }, {
                  default: withCtx(() => [
                    createTextVNode("mdi-database")
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["model-value", "color"])
          ], 16)
        ]),
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_25, [
            createBaseVNode("div", _hoisted_35, toDisplayString(_ctx.__("Cache Usage")), 1),
            !$props.cacheUsageLoading ? (openBlock(), createElementBlock("div", _hoisted_42, [
              createBaseVNode("div", null, toDisplayString(_ctx.__("Total Size")) + ": " + toDisplayString($options.formatBytes($props.cacheUsageDetails.total)), 1),
              createBaseVNode("div", null, toDisplayString(_ctx.__("IndexedDB")) + ": " + toDisplayString($options.formatBytes($props.cacheUsageDetails.indexedDB)), 1),
              createBaseVNode("div", null, toDisplayString(_ctx.__("localStorage")) + ": " + toDisplayString($options.formatBytes($props.cacheUsageDetails.localStorage)), 1)
            ])) : (openBlock(), createElementBlock("div", _hoisted_52, toDisplayString(_ctx.__("Calculating...")), 1)),
            createBaseVNode("div", _hoisted_62, [
              createVNode(_component_v_icon, {
                size: "14",
                class: "mr-1"
              }, {
                default: withCtx(() => [
                  createTextVNode("mdi-refresh")
                ]),
                _: 1
              }),
              createTextVNode(" " + toDisplayString(_ctx.__("Click to refresh")), 1)
            ])
          ])
        ]),
        _: 1
      })
    ]);
  }

  // ../posawesome/posawesome/public/js/posapp/components/navbar/CacheUsageMeter.vue
  CacheUsageMeter_default.render = render6;
  CacheUsageMeter_default.__file = "../posawesome/posawesome/public/js/posapp/components/navbar/CacheUsageMeter.vue";
  CacheUsageMeter_default.__scopeId = "data-v-d47ae9a3";
  var CacheUsageMeter_default2 = CacheUsageMeter_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/navbar/AboutDialog.vue?type=script
  var AboutDialog_default = {
    name: "AboutDialog",
    props: {
      modelValue: Boolean
    },
    data() {
      return {
        dialogOpen: this.modelValue,
        loadingAppInfo: false,
        appInfoError: false,
        appInfo: []
      };
    },
    watch: {
      modelValue(val) {
        this.dialogOpen = val;
        if (val) {
          this.loadAppInfo();
        }
      },
      dialogOpen(val) {
        this.$emit("update:modelValue", val);
      }
    },
    methods: {
      close() {
        this.dialogOpen = false;
      },
      loadAppInfo() {
        this.loadingAppInfo = true;
        this.appInfoError = false;
        frappe.call({
          method: "posawesome.posawesome.api.utilities.get_app_info",
          callback: (r) => {
            this.loadingAppInfo = false;
            if (Array.isArray(r.message.apps)) {
              this.appInfo = r.message.apps;
            } else {
              this.appInfoError = true;
            }
          },
          error: () => {
            this.loadingAppInfo = false;
            this.appInfoError = true;
          }
        });
      }
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/navbar/AboutDialog.vue?type=template
  var _hoisted_111 = { class: "header-content-improved" };
  var _hoisted_26 = { class: "header-icon-wrapper-improved" };
  var _hoisted_36 = { class: "header-text-improved" };
  var _hoisted_43 = { class: "header-title-improved" };
  var _hoisted_53 = { class: "header-subtitle-improved" };
  var _hoisted_63 = {
    key: 0,
    class: "header-stats-improved"
  };
  var _hoisted_72 = { class: "content-container-improved" };
  var _hoisted_82 = {
    key: 0,
    class: "empty-state-improved text-center"
  };
  var _hoisted_92 = { class: "text-body-2 mt-3 mb-0" };
  var _hoisted_102 = { class: "empty-state-improved text-center" };
  var _hoisted_112 = { class: "text-body-2 mb-3" };
  var _hoisted_123 = { class: "apps-list-improved" };
  var _hoisted_133 = { class: "apps-header-improved" };
  var _hoisted_142 = { class: "text-h6 mb-2" };
  var _hoisted_152 = { class: "apps-grid-improved" };
  var _hoisted_162 = { class: "app-icon-improved" };
  var _hoisted_172 = { class: "app-details-improved" };
  var _hoisted_182 = { class: "app-name-improved" };
  var _hoisted_192 = { class: "app-version-improved" };
  var _hoisted_20 = { class: "footer-info-improved" };
  var _hoisted_21 = { class: "footer-text-improved" };
  function render7(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_icon = resolveComponent("v-icon");
    const _component_v_chip = resolveComponent("v-chip");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_card_title = resolveComponent("v-card-title");
    const _component_v_progress_circular = resolveComponent("v-progress-circular");
    const _component_v_card_text = resolveComponent("v-card-text");
    const _component_v_spacer = resolveComponent("v-spacer");
    const _component_v_card_actions = resolveComponent("v-card-actions");
    const _component_v_card = resolveComponent("v-card");
    const _component_v_dialog = resolveComponent("v-dialog");
    return openBlock(), createBlock(_component_v_dialog, {
      modelValue: $data.dialogOpen,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.dialogOpen = $event),
      "max-width": "650",
      persistent: ""
    }, {
      default: withCtx(() => [
        createVNode(_component_v_card, { class: "about-dialog-card-improved" }, {
          default: withCtx(() => [
            createVNode(_component_v_card_title, { class: "about-header-improved pa-5" }, {
              default: withCtx(() => [
                createBaseVNode("div", _hoisted_111, [
                  createBaseVNode("div", _hoisted_26, [
                    createVNode(_component_v_icon, {
                      size: "22",
                      class: "header-icon"
                    }, {
                      default: withCtx(() => [
                        createTextVNode("mdi-information-outline")
                      ]),
                      _: 1
                    })
                  ]),
                  createBaseVNode("div", _hoisted_36, [
                    createBaseVNode("h3", _hoisted_43, toDisplayString(_ctx.__("About")), 1),
                    createBaseVNode("p", _hoisted_53, toDisplayString(_ctx.__("System Information")), 1)
                  ]),
                  !$data.loadingAppInfo && !$data.appInfoError ? (openBlock(), createElementBlock("div", _hoisted_63, [
                    createVNode(_component_v_chip, {
                      size: "small",
                      color: "primary",
                      variant: "tonal",
                      class: "status-chip-improved"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_v_icon, {
                          start: "",
                          size: "14"
                        }, {
                          default: withCtx(() => [
                            createTextVNode("mdi-application-outline")
                          ]),
                          _: 1
                        }),
                        createTextVNode(" " + toDisplayString($data.appInfo.length) + " " + toDisplayString(_ctx.__("Apps")), 1)
                      ]),
                      _: 1
                    })
                  ])) : createCommentVNode("v-if", true)
                ]),
                createVNode(_component_v_btn, {
                  icon: "mdi-close",
                  variant: "text",
                  size: "default",
                  onClick: $options.close,
                  class: "close-btn-improved"
                }, null, 8, ["onClick"])
              ]),
              _: 1
            }),
            createVNode(_component_v_card_text, { class: "pa-0 white-background" }, {
              default: withCtx(() => [
                createBaseVNode("div", _hoisted_72, [
                  createCommentVNode(" Loading State "),
                  $data.loadingAppInfo ? (openBlock(), createElementBlock("div", _hoisted_82, [
                    createVNode(_component_v_progress_circular, {
                      indeterminate: "",
                      color: "primary",
                      size: "50"
                    }),
                    createBaseVNode("p", _hoisted_92, toDisplayString(_ctx.__("Loading...")), 1)
                  ])) : $data.appInfoError ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createCommentVNode(" Error State "),
                    createBaseVNode("div", _hoisted_102, [
                      createVNode(_component_v_icon, {
                        size: "50",
                        color: "error",
                        class: "mb-3"
                      }, {
                        default: withCtx(() => [
                          createTextVNode("mdi-alert-circle-outline")
                        ]),
                        _: 1
                      }),
                      createBaseVNode("p", _hoisted_112, toDisplayString(_ctx.__("Error Loading Data")), 1),
                      createVNode(_component_v_btn, {
                        color: "primary",
                        variant: "outlined",
                        size: "default",
                        onClick: $options.loadAppInfo
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_v_icon, {
                            start: "",
                            size: "18"
                          }, {
                            default: withCtx(() => [
                              createTextVNode("mdi-refresh")
                            ]),
                            _: 1
                          }),
                          createTextVNode(" " + toDisplayString(_ctx.__("Retry")), 1)
                        ]),
                        _: 1
                      }, 8, ["onClick"])
                    ])
                  ], 2112)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                    createCommentVNode(" Applications List - Improved "),
                    createBaseVNode("div", _hoisted_123, [
                      createBaseVNode("div", _hoisted_133, [
                        createBaseVNode("h4", _hoisted_142, toDisplayString(_ctx.__("Installed Applications")), 1)
                      ]),
                      createBaseVNode("div", _hoisted_152, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList($data.appInfo, (app) => {
                          return openBlock(), createElementBlock("div", {
                            key: app.app_name,
                            class: "app-item-improved"
                          }, [
                            createBaseVNode("div", _hoisted_162, [
                              createVNode(_component_v_icon, {
                                size: "18",
                                color: "white"
                              }, {
                                default: withCtx(() => [
                                  createTextVNode("mdi-application-outline")
                                ]),
                                _: 1
                              })
                            ]),
                            createBaseVNode("div", _hoisted_172, [
                              createBaseVNode("div", _hoisted_182, toDisplayString(app.app_name), 1),
                              createBaseVNode("div", _hoisted_192, "v" + toDisplayString(app.installed_version), 1)
                            ])
                          ]);
                        }), 128))
                      ])
                    ])
                  ], 2112))
                ])
              ]),
              _: 1
            }),
            createVNode(_component_v_card_actions, { class: "dialog-actions-improved pa-4" }, {
              default: withCtx(() => [
                createBaseVNode("div", _hoisted_20, [
                  createBaseVNode("span", _hoisted_21, [
                    createVNode(_component_v_icon, {
                      start: "",
                      size: "16",
                      color: "error"
                    }, {
                      default: withCtx(() => [
                        createTextVNode("mdi-heart")
                      ]),
                      _: 1
                    }),
                    createTextVNode(" " + toDisplayString(_ctx.__("Built with Frappe")), 1)
                  ])
                ]),
                createVNode(_component_v_spacer),
                createVNode(_component_v_btn, {
                  color: "primary",
                  onClick: $options.close,
                  class: "close-btn-action-improved"
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.__("Close")), 1)
                  ]),
                  _: 1
                }, 8, ["onClick"])
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["modelValue"]);
  }

  // ../posawesome/posawesome/public/js/posapp/components/navbar/AboutDialog.vue
  AboutDialog_default.render = render7;
  AboutDialog_default.__file = "../posawesome/posawesome/public/js/posapp/components/navbar/AboutDialog.vue";
  AboutDialog_default.__scopeId = "data-v-a26a8d71";
  var AboutDialog_default2 = AboutDialog_default;

  // ../posawesome/posawesome/public/js/posapp/format.js
  var format_default = {
    data() {
      return {
        float_precision: 2,
        currency_precision: 2
      };
    },
    methods: {
      flt(value, precision, number_format, rounding_method) {
        if (!precision && precision != 0) {
          precision = this.currency_precision || 2;
        }
        if (!rounding_method) {
          rounding_method = "Banker's Rounding (legacy)";
        }
        return flt(value, precision, number_format, rounding_method);
      },
      formatCurrency(value, precision) {
        if (value === null || value === void 0) {
          value = 0;
        }
        let number = Number(String(value).replace(/,/g, ""));
        if (isNaN(number))
          number = 0;
        let prec = precision != null ? Number(precision) : Number(this.currency_precision) || 2;
        if (!Number.isInteger(prec) || prec < 0 || prec > 20) {
          prec = Math.min(Math.max(parseInt(prec) || 2, 0), 20);
        }
        return number.toLocaleString("en-US", {
          minimumFractionDigits: prec,
          maximumFractionDigits: prec
        });
      },
      formatFloat(value, precision) {
        if (value === null || value === void 0) {
          value = 0;
        }
        let number = Number(String(value).replace(/,/g, ""));
        if (isNaN(number))
          number = 0;
        let prec = precision != null ? Number(precision) : Number(this.float_precision) || 2;
        if (!Number.isInteger(prec) || prec < 0 || prec > 20) {
          prec = Math.min(Math.max(parseInt(prec) || 2, 0), 20);
        }
        return number.toLocaleString("en-US", {
          minimumFractionDigits: prec,
          maximumFractionDigits: prec
        });
      },
      setFormatedCurrency(el, field_name, precision, no_negative = false, $event) {
        let input_val = $event && $event.target ? $event.target.value : $event;
        if (typeof input_val === "string") {
          input_val = input_val.replace(/,/g, "");
        }
        let value = parseFloat(input_val);
        if (isNaN(value)) {
          value = 0;
        } else if (no_negative && value < 0) {
          value = Math.abs(value);
        }
        if (typeof el === "object") {
          el[field_name] = value;
        } else {
          this[field_name] = value;
        }
        return this.formatCurrency(value, precision);
      },
      setFormatedFloat(el, field_name, precision, no_negative = false, $event) {
        let input_val = $event && $event.target ? $event.target.value : $event;
        if (typeof input_val === "string") {
          input_val = input_val.replace(/,/g, "");
        }
        let value = parseFloat(input_val);
        if (isNaN(value)) {
          value = 0;
        } else if (no_negative && value < 0) {
          value = Math.abs(value);
        }
        if (typeof el === "object") {
          el[field_name] = value;
        } else {
          this[field_name] = value;
        }
        return this.formatFloat(value, precision);
      },
      currencySymbol(currency) {
        return get_currency_symbol(currency);
      },
      isNumber(value) {
        const pattern = /^-?(\d+|\d{1,3}(\.\d{3})*)(,\d+)?$/;
        return pattern.test(value) || "invalid number";
      }
    },
    mounted() {
      this.float_precision = frappe.defaults.get_default("float_precision") || 2;
      this.currency_precision = frappe.defaults.get_default("currency_precision") || 2;
      const updatePrecision = (data) => {
        const profile = data.pos_profile || data;
        const prec = parseInt(profile.posa_decimal_precision);
        if (!isNaN(prec)) {
          this.float_precision = prec;
          this.currency_precision = prec;
        }
      };
      if (this.eventBus && this.eventBus.on) {
        this.eventBus.on("register_pos_profile", updatePrecision);
        this.eventBus.on("payments_register_pos_profile", updatePrecision);
      }
    }
  };

  // ../posawesome/node_modules/dexie/import-wrapper.mjs
  var import_dexie = __toESM(require_dexie(), 1);
  var DexieSymbol = Symbol.for("Dexie");
  var Dexie2 = globalThis[DexieSymbol] || (globalThis[DexieSymbol] = import_dexie.default);
  if (import_dexie.default.semVer !== Dexie2.semVer) {
    throw new Error(`Two different versions of Dexie loaded in the same app: ${import_dexie.default.semVer} and ${Dexie2.semVer}`);
  }
  var {
    liveQuery,
    mergeRanges,
    rangesOverlap,
    RangeSet,
    cmp,
    Entity,
    PropModification,
    replacePrefix,
    add: add2,
    remove: remove2
  } = Dexie2;
  var import_wrapper_default = Dexie2;

  // ../posawesome/posawesome/public/js/offline/core.js
  var db = new import_wrapper_default("posawesome_offline");
  db.version(1).stores({ keyval: "&key" });
  var persistWorker = null;
  if (typeof Worker !== "undefined") {
    try {
      const workerUrl = "/assets/posawesome/js/posapp/workers/itemWorker.js";
      persistWorker = new Worker(workerUrl, { type: "classic" });
    } catch (e) {
      console.error("Failed to init persist worker", e);
      persistWorker = null;
    }
  }
  function persist(key, value) {
    if (persistWorker) {
      let cleanValue = value;
      try {
        cleanValue = JSON.parse(JSON.stringify(value));
      } catch (e) {
        console.error("Failed to serialize", key, e);
      }
      try {
        persistWorker.postMessage({ type: "persist", key, value: cleanValue });
      } catch (e) {
        console.error(`Failed to postMessage for ${key}`, e);
      }
      return;
    }
    db.table("keyval").put({ key, value }).catch((e) => console.error(`Failed to persist ${key}`, e));
    if (typeof localStorage !== "undefined" && key !== "price_list_cache") {
      try {
        localStorage.setItem(`posa_${key}`, JSON.stringify(value));
      } catch (err) {
        console.error("Failed to persist", key, "to localStorage", err);
      }
    }
  }
  var initPromise = new Promise((resolve2) => {
    const init = async () => {
      try {
        await db.open();
        resolve2();
      } catch (e) {
        console.error("Failed to initialize offline DB", e);
        resolve2();
      }
    };
    if (typeof requestIdleCallback === "function") {
      requestIdleCallback(init);
    } else {
      setTimeout(init, 0);
    }
  });

  // ../posawesome/posawesome/public/js/offline/cache.js
  var memory = {
    offline_invoices: [],
    offline_customers: [],
    offline_payments: [],
    pos_last_sync_totals: { pending: 0, synced: 0, drafted: 0 },
    uom_cache: {},
    offers_cache: [],
    customer_balance_cache: {},
    local_stock_cache: {},
    stock_cache_ready: false,
    items_storage: [],
    customer_storage: [],
    pos_opening_storage: null,
    opening_dialog_storage: null,
    sales_persons_storage: [],
    price_list_cache: {},
    item_details_cache: {},
    manual_offline: false
  };
  (async () => {
    try {
      for (const key of Object.keys(memory)) {
        const stored = await db.table("keyval").get(key);
        if (stored && stored.value !== void 0) {
          memory[key] = stored.value;
          continue;
        }
        if (typeof localStorage !== "undefined") {
          const ls = localStorage.getItem(`posa_${key}`);
          if (ls) {
            try {
              memory[key] = JSON.parse(ls);
              continue;
            } catch (err) {
              console.error("Failed to parse localStorage for", key, err);
            }
          }
        }
      }
    } catch (e) {
      console.error("Failed to initialize memory from DB", e);
    }
  })();
  function resetOfflineState() {
    memory.offline_invoices = [];
    memory.offline_customers = [];
    memory.offline_payments = [];
    memory.pos_last_sync_totals = { pending: 0, synced: 0, drafted: 0 };
    persist("offline_invoices", memory.offline_invoices);
    persist("offline_customers", memory.offline_customers);
    persist("offline_payments", memory.offline_payments);
    persist("pos_last_sync_totals", memory.pos_last_sync_totals);
  }
  function getItemsStorage() {
    return memory.items_storage || [];
  }
  function setItemsStorage(items) {
    try {
      memory.items_storage = JSON.parse(JSON.stringify(items));
    } catch (e) {
      console.error("Failed to serialize items for storage", e);
      memory.items_storage = [];
    }
    persist("items_storage", memory.items_storage);
  }
  function getCustomerStorage() {
    return memory.customer_storage || [];
  }
  function setCustomerStorage(customers) {
    memory.customer_storage = customers;
    persist("customer_storage", memory.customer_storage);
  }
  function getSalesPersonsStorage() {
    return memory.sales_persons_storage || [];
  }
  function setSalesPersonsStorage(data) {
    try {
      memory.sales_persons_storage = JSON.parse(JSON.stringify(data));
      persist("sales_persons_storage", memory.sales_persons_storage);
    } catch (e) {
      console.error("Failed to set sales persons storage", e);
    }
  }
  function getOpeningStorage() {
    return memory.pos_opening_storage || null;
  }
  function setOpeningStorage(data) {
    try {
      memory.pos_opening_storage = JSON.parse(JSON.stringify(data));
      persist("pos_opening_storage", memory.pos_opening_storage);
    } catch (e) {
      console.error("Failed to set opening storage", e);
    }
  }
  function clearOpeningStorage() {
    try {
      memory.pos_opening_storage = null;
      persist("pos_opening_storage", memory.pos_opening_storage);
    } catch (e) {
      console.error("Failed to clear opening storage", e);
    }
  }
  function getOpeningDialogStorage() {
    return memory.opening_dialog_storage || null;
  }
  function setOpeningDialogStorage(data) {
    try {
      memory.opening_dialog_storage = JSON.parse(JSON.stringify(data));
      persist("opening_dialog_storage", memory.opening_dialog_storage);
    } catch (e) {
      console.error("Failed to set opening dialog storage", e);
    }
  }
  function setLastSyncTotals(totals) {
    memory.pos_last_sync_totals = totals;
    persist("pos_last_sync_totals", memory.pos_last_sync_totals);
  }
  async function clearAllCache() {
    try {
      if (db.isOpen()) {
        await db.close();
      }
      await Dexie.delete("posawesome_offline");
      await db.open();
    } catch (e) {
      console.error("Failed to clear IndexedDB cache", e);
    }
    if (typeof localStorage !== "undefined") {
      Object.keys(localStorage).forEach((key) => {
        if (key.startsWith("posa_")) {
          localStorage.removeItem(key);
        }
      });
    }
    memory.offline_invoices = [];
    memory.offline_customers = [];
    memory.offline_payments = [];
    memory.pos_last_sync_totals = { pending: 0, synced: 0, drafted: 0 };
    memory.uom_cache = {};
    memory.offers_cache = [];
    memory.customer_balance_cache = {};
    memory.local_stock_cache = {};
    memory.stock_cache_ready = false;
    memory.items_storage = [];
    memory.customer_storage = [];
    memory.pos_opening_storage = null;
    memory.opening_dialog_storage = null;
    memory.sales_persons_storage = [];
    memory.price_list_cache = {};
    memory.item_details_cache = {};
    memory.manual_offline = false;
  }
  async function getCacheUsageEstimate() {
    try {
      let localStorageSize = 0;
      if (typeof localStorage !== "undefined") {
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && key.startsWith("posa_")) {
            const value = localStorage.getItem(key) || "";
            localStorageSize += (key.length + value.length) * 2;
          }
        }
      }
      let indexedDBSize = 0;
      try {
        if (db.isOpen()) {
          const allItems = await db.table("keyval").toArray();
          indexedDBSize = allItems.reduce((size, item) => {
            const itemSize = JSON.stringify(item).length * 2;
            return size + itemSize;
          }, 0);
        }
      } catch (e) {
        console.error("Failed to calculate IndexedDB size", e);
      }
      const totalSize = localStorageSize + indexedDBSize;
      const maxSize = 10 * 1024 * 1024;
      const usagePercentage = Math.min(100, Math.round(totalSize / maxSize * 100));
      return {
        total: totalSize,
        localStorage: localStorageSize,
        indexedDB: indexedDBSize,
        percentage: usagePercentage
      };
    } catch (e) {
      console.error("Failed to estimate cache usage", e);
      return {
        total: 0,
        localStorage: 0,
        indexedDB: 0,
        percentage: 0
      };
    }
  }

  // ../posawesome/posawesome/public/js/offline/stock.js
  async function initializeStockCache(items, pos_profile) {
    try {
      if (memory.stock_cache_ready && Object.keys(memory.local_stock_cache || {}).length > 0) {
        console.debug("Stock cache already initialized, skipping");
        return true;
      }
      console.info("Initializing stock cache for", items.length, "items");
      const updatedItems = await fetchItemStockQuantities(items, pos_profile);
      if (updatedItems && updatedItems.length > 0) {
        const stockCache = {};
        updatedItems.forEach((item) => {
          if (item.actual_qty !== void 0) {
            stockCache[item.item_code] = {
              actual_qty: item.actual_qty,
              last_updated: new Date().toISOString()
            };
          }
        });
        memory.local_stock_cache = stockCache;
        memory.stock_cache_ready = true;
        persist("local_stock_cache", memory.local_stock_cache);
        persist("stock_cache_ready", memory.stock_cache_ready);
        console.info("Stock cache initialized with", Object.keys(stockCache).length, "items");
        return true;
      }
      return false;
    } catch (error) {
      console.error("Failed to initialize stock cache:", error);
      return false;
    }
  }
  function isStockCacheReady() {
    return memory.stock_cache_ready || false;
  }
  function updateLocalStock(items) {
    try {
      const stockCache = memory.local_stock_cache || {};
      items.forEach((item) => {
        const key = item.item_code;
        if (stockCache[key]) {
          const soldQty = Math.abs(item.qty || 0);
          stockCache[key].actual_qty = Math.max(0, stockCache[key].actual_qty - soldQty);
          stockCache[key].last_updated = new Date().toISOString();
        }
      });
      memory.local_stock_cache = stockCache;
      persist("local_stock_cache", memory.local_stock_cache);
    } catch (e) {
      console.error("Failed to update local stock", e);
    }
  }
  function getLocalStock(itemCode) {
    var _a3;
    try {
      const stockCache = memory.local_stock_cache || {};
      return ((_a3 = stockCache[itemCode]) == null ? void 0 : _a3.actual_qty) || null;
    } catch (e) {
      return null;
    }
  }
  function updateLocalStockCache(items) {
    try {
      const stockCache = memory.local_stock_cache || {};
      items.forEach((item) => {
        if (!item || !item.item_code)
          return;
        if (item.actual_qty !== void 0) {
          stockCache[item.item_code] = {
            actual_qty: item.actual_qty,
            last_updated: new Date().toISOString()
          };
        }
      });
      memory.local_stock_cache = stockCache;
      persist("local_stock_cache", memory.local_stock_cache);
    } catch (e) {
      console.error("Failed to refresh local stock cache", e);
    }
  }
  async function fetchItemStockQuantities(items, pos_profile, chunkSize = 100) {
    const allItems = [];
    try {
      for (let i = 0; i < items.length; i += chunkSize) {
        const chunk2 = items.slice(i, i + chunkSize);
        const response = await new Promise((resolve2, reject) => {
          frappe.call({
            method: "posawesome.posawesome.api.posapp.get_items_details",
            args: {
              pos_profile: JSON.stringify(pos_profile),
              items_data: JSON.stringify(chunk2)
            },
            freeze: false,
            callback: function(r) {
              if (r.message) {
                resolve2(r.message);
              } else {
                reject(new Error("No response from server"));
              }
            },
            error: function(err) {
              reject(err);
            }
          });
        });
        if (response) {
          allItems.push(...response);
        }
      }
      return allItems;
    } catch (error) {
      console.error("Failed to fetch item stock quantities:", error);
      return null;
    }
  }

  // ../posawesome/posawesome/public/js/offline/sync.js
  function saveOfflineInvoice(entry) {
    if (!entry.invoice || !Array.isArray(entry.invoice.items) || !entry.invoice.items.length) {
      throw new Error("Cart is empty. Add items before saving.");
    }
    const key = "offline_invoices";
    const entries = memory.offline_invoices;
    let cleanEntry;
    try {
      cleanEntry = JSON.parse(JSON.stringify(entry));
    } catch (e) {
      console.error("Failed to serialize offline invoice", e);
      throw e;
    }
    entries.push(cleanEntry);
    memory.offline_invoices = entries;
    persist(key, memory.offline_invoices);
    if (entry.invoice && entry.invoice.items) {
      updateLocalStock(entry.invoice.items);
    }
  }
  function isOffline() {
    if (typeof window === "undefined") {
      return memory.manual_offline || false;
    }
    const { protocol, hostname, navigator: navigator2 } = window;
    const online = navigator2.onLine;
    const serverOnline = typeof window.serverOnline === "boolean" ? window.serverOnline : true;
    const isIpAddress = /^(?:\d{1,3}\.){3}\d{1,3}$/.test(hostname);
    const isLocalhost = hostname === "localhost" || hostname === "127.0.0.1";
    const isDnsName = !isIpAddress && !isLocalhost;
    if (memory.manual_offline) {
      return true;
    }
    if (protocol === "https:" && isDnsName) {
      return !online || !serverOnline;
    }
    return !online || !serverOnline;
  }
  function getOfflineInvoices() {
    return memory.offline_invoices;
  }
  function clearOfflineInvoices() {
    memory.offline_invoices = [];
    persist("offline_invoices", memory.offline_invoices);
  }
  function deleteOfflineInvoice(index) {
    if (Array.isArray(memory.offline_invoices) && index >= 0 && index < memory.offline_invoices.length) {
      memory.offline_invoices.splice(index, 1);
      persist("offline_invoices", memory.offline_invoices);
    }
  }
  function getPendingOfflineInvoiceCount() {
    return memory.offline_invoices.length;
  }
  function saveOfflinePayment(entry) {
    var _a3, _b;
    const key = "offline_payments";
    const entries = memory.offline_payments;
    if ((_b = (_a3 = entry == null ? void 0 : entry.args) == null ? void 0 : _a3.payload) == null ? void 0 : _b.pos_profile) {
      const profile = entry.args.payload.pos_profile;
      entry.args.payload.pos_profile = {
        posa_use_pos_awesome_payments: profile.posa_use_pos_awesome_payments,
        posa_allow_make_new_payments: profile.posa_allow_make_new_payments,
        posa_allow_reconcile_payments: profile.posa_allow_reconcile_payments,
        posa_allow_mpesa_reconcile_payments: profile.posa_allow_mpesa_reconcile_payments,
        cost_center: profile.cost_center,
        posa_cash_mode_of_payment: profile.posa_cash_mode_of_payment,
        name: profile.name
      };
    }
    let cleanEntry;
    try {
      cleanEntry = JSON.parse(JSON.stringify(entry));
    } catch (e) {
      console.error("Failed to serialize offline payment", e);
      throw e;
    }
    entries.push(cleanEntry);
    memory.offline_payments = entries;
    persist(key, memory.offline_payments);
  }
  function getOfflinePayments() {
    return memory.offline_payments;
  }
  function clearOfflinePayments() {
    memory.offline_payments = [];
    persist("offline_payments", memory.offline_payments);
  }
  function getPendingOfflinePaymentCount() {
    return memory.offline_payments.length;
  }
  function saveOfflineCustomer(entry) {
    const key = "offline_customers";
    const entries = memory.offline_customers;
    let cleanEntry;
    try {
      cleanEntry = JSON.parse(JSON.stringify(entry));
    } catch (e) {
      console.error("Failed to serialize offline customer", e);
      throw e;
    }
    entries.push(cleanEntry);
    memory.offline_customers = entries;
    persist(key, memory.offline_customers);
  }
  function updateOfflineInvoicesCustomer(oldName, newName) {
    let updated3 = false;
    const invoices = memory.offline_invoices || [];
    invoices.forEach((inv) => {
      if (inv.invoice && inv.invoice.customer === oldName) {
        inv.invoice.customer = newName;
        if (inv.invoice.customer_name) {
          inv.invoice.customer_name = newName;
        }
        updated3 = true;
      }
    });
    if (updated3) {
      memory.offline_invoices = invoices;
      persist("offline_invoices", memory.offline_invoices);
    }
  }
  function getOfflineCustomers() {
    return memory.offline_customers;
  }
  function clearOfflineCustomers() {
    memory.offline_customers = [];
    persist("offline_customers", memory.offline_customers);
  }
  async function syncOfflineInvoices() {
    await syncOfflineCustomers();
    const invoices = getOfflineInvoices();
    if (!invoices.length) {
      const totals2 = { pending: 0, synced: 0, drafted: 0 };
      setLastSyncTotals(totals2);
      return totals2;
    }
    if (isOffline()) {
      return { pending: invoices.length, synced: 0, drafted: 0 };
    }
    const failures = [];
    let synced = 0;
    let drafted = 0;
    for (const inv of invoices) {
      try {
        await frappe.call({
          method: "posawesome.posawesome.api.invoices.submit_invoice",
          args: {
            invoice: inv.invoice,
            data: inv.data
          }
        });
        synced++;
      } catch (error) {
        console.error("Failed to submit invoice, saving as draft", error);
        try {
          await frappe.call({
            method: "posawesome.posawesome.api.invoices.update_invoice",
            args: { data: inv.invoice }
          });
          drafted += 1;
        } catch (draftErr) {
          console.error("Failed to save invoice as draft", draftErr);
          failures.push(inv);
        }
      }
    }
    if (synced > 0) {
      resetOfflineState();
    }
    const pendingLeft = failures.length;
    if (pendingLeft) {
      memory.offline_invoices = failures;
      persist("offline_invoices", memory.offline_invoices);
    } else {
      clearOfflineInvoices();
    }
    const totals = { pending: pendingLeft, synced, drafted };
    if (pendingLeft || drafted) {
      setLastSyncTotals(totals);
    } else {
      setLastSyncTotals({ pending: 0, synced: 0, drafted: 0 });
    }
    return totals;
  }
  async function syncOfflineCustomers() {
    const customers = getOfflineCustomers();
    if (!customers.length) {
      return { pending: 0, synced: 0 };
    }
    if (isOffline()) {
      return { pending: customers.length, synced: 0 };
    }
    const failures = [];
    let synced = 0;
    for (const cust of customers) {
      try {
        const result = await frappe.call({
          method: "posawesome.posawesome.api.customer.create_customer",
          args: cust.args
        });
        synced++;
        if (result && result.message && result.message.name && result.message.name !== cust.args.customer_name) {
          updateOfflineInvoicesCustomer(cust.args.customer_name, result.message.name);
        }
      } catch (error) {
        console.error("Failed to create customer", error);
        failures.push(cust);
      }
    }
    if (failures.length) {
      memory.offline_customers = failures;
      persist("offline_customers", memory.offline_customers);
    } else {
      clearOfflineCustomers();
    }
    return { pending: failures.length, synced };
  }
  async function syncOfflinePayments() {
    await syncOfflineCustomers();
    const payments = getOfflinePayments();
    if (!payments.length) {
      return { pending: 0, synced: 0 };
    }
    if (isOffline()) {
      return { pending: payments.length, synced: 0 };
    }
    const failures = [];
    let synced = 0;
    for (const pay of payments) {
      try {
        await frappe.call({
          method: "posawesome.posawesome.api.payment_entry.process_pos_payment",
          args: pay.args
        });
        synced++;
      } catch (error) {
        console.error("Failed to submit payment", error);
        failures.push(pay);
      }
    }
    if (failures.length) {
      memory.offline_payments = failures;
      persist("offline_payments", memory.offline_payments);
    } else {
      clearOfflinePayments();
    }
    return { pending: failures.length, synced };
  }

  // ../posawesome/posawesome/public/js/offline/items.js
  function saveItemUOMs(itemCode, uoms) {
    try {
      const cache = memory.uom_cache;
      const cleanUoms = JSON.parse(JSON.stringify(uoms));
      cache[itemCode] = cleanUoms;
      memory.uom_cache = cache;
      persist("uom_cache", memory.uom_cache);
    } catch (e) {
      console.error("Failed to cache UOMs", e);
    }
  }
  function getItemUOMs2(itemCode) {
    try {
      const cache = memory.uom_cache || {};
      return cache[itemCode] || [];
    } catch (e) {
      return [];
    }
  }
  function saveOffers(offers) {
    try {
      memory.offers_cache = offers;
      persist("offers_cache", memory.offers_cache);
    } catch (e) {
      console.error("Failed to cache offers", e);
    }
  }
  function getCachedOffers() {
    try {
      return memory.offers_cache || [];
    } catch (e) {
      return [];
    }
  }
  function savePriceListItems(priceList, items) {
    try {
      const cache = memory.price_list_cache || {};
      let cleanItems;
      try {
        cleanItems = JSON.parse(JSON.stringify(items));
      } catch (err) {
        console.error("Failed to serialize price list items", err);
        cleanItems = [];
      }
      cache[priceList] = {
        items: cleanItems,
        timestamp: Date.now()
      };
      memory.price_list_cache = cache;
      persist("price_list_cache", memory.price_list_cache);
    } catch (e) {
      console.error("Failed to cache price list items", e);
    }
  }
  function getCachedPriceListItems(priceList) {
    try {
      const cache = memory.price_list_cache || {};
      const cachedData = cache[priceList];
      if (cachedData) {
        const isValid3 = Date.now() - cachedData.timestamp < 24 * 60 * 60 * 1e3;
        return isValid3 ? cachedData.items : null;
      }
      return null;
    } catch (e) {
      console.error("Failed to get cached price list items", e);
      return null;
    }
  }
  function clearPriceListCache() {
    try {
      memory.price_list_cache = {};
      persist("price_list_cache", memory.price_list_cache);
    } catch (e) {
      console.error("Failed to clear price list cache", e);
    }
  }
  function saveItemDetailsCache(profileName, priceList, items) {
    try {
      const cache = memory.item_details_cache || {};
      const profileCache = cache[profileName] || {};
      const priceCache = profileCache[priceList] || {};
      let cleanItems;
      try {
        cleanItems = JSON.parse(JSON.stringify(items));
      } catch (err) {
        console.error("Failed to serialize item details", err);
        cleanItems = [];
      }
      cleanItems.forEach((item) => {
        priceCache[item.item_code] = {
          data: item,
          timestamp: Date.now()
        };
      });
      profileCache[priceList] = priceCache;
      cache[profileName] = profileCache;
      memory.item_details_cache = cache;
      persist("item_details_cache", memory.item_details_cache);
    } catch (e) {
      console.error("Failed to cache item details", e);
    }
  }
  function getCachedItemDetails(profileName, priceList, itemCodes, ttl = 15 * 60 * 1e3) {
    var _a3;
    try {
      const cache = memory.item_details_cache || {};
      const priceCache = ((_a3 = cache[profileName]) == null ? void 0 : _a3[priceList]) || {};
      const now = Date.now();
      const cached = [];
      const missing = [];
      itemCodes.forEach((code) => {
        const entry = priceCache[code];
        if (entry && now - entry.timestamp < ttl) {
          cached.push(entry.data);
        } else {
          missing.push(code);
        }
      });
      return { cached, missing };
    } catch (e) {
      console.error("Failed to get cached item details", e);
      return { cached: [], missing: itemCodes };
    }
  }

  // ../posawesome/posawesome/public/js/offline/customers.js
  function saveCustomerBalance(customer, balance) {
    try {
      const cache = memory.customer_balance_cache;
      cache[customer] = {
        balance,
        timestamp: Date.now()
      };
      memory.customer_balance_cache = cache;
      persist("customer_balance_cache", memory.customer_balance_cache);
    } catch (e) {
      console.error("Failed to cache customer balance", e);
    }
  }
  function getCachedCustomerBalance(customer) {
    try {
      const cache = memory.customer_balance_cache || {};
      const cachedData = cache[customer];
      if (cachedData) {
        const isValid3 = Date.now() - cachedData.timestamp < 24 * 60 * 60 * 1e3;
        return isValid3 ? cachedData.balance : null;
      }
      return null;
    } catch (e) {
      console.error("Failed to get cached customer balance", e);
      return null;
    }
  }
  function clearExpiredCustomerBalances() {
    try {
      const cache = memory.customer_balance_cache || {};
      const now = Date.now();
      const validCache = {};
      Object.keys(cache).forEach((customer) => {
        const cachedData = cache[customer];
        if (cachedData && now - cachedData.timestamp < 24 * 60 * 60 * 1e3) {
          validCache[customer] = cachedData;
        }
      });
      memory.customer_balance_cache = validCache;
      persist("customer_balance_cache", memory.customer_balance_cache);
    } catch (e) {
      console.error("Failed to clear expired customer balances", e);
    }
  }

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/OfflineInvoices.vue?type=script
  var OfflineInvoices_default = {
    name: "OfflineInvoicesDialog",
    mixins: [format_default],
    props: {
      modelValue: Boolean,
      posProfile: {
        type: Object,
        default: () => ({})
      }
    },
    emits: ["update:modelValue", "deleted", "sync-all"],
    data() {
      return {
        dialog: this.modelValue,
        invoices: [],
        headers: [
          {
            title: this.__("Customer"),
            value: "customer",
            align: "start",
            width: "35%"
          },
          {
            title: this.__("Date"),
            value: "posting_date",
            align: "center",
            width: "20%"
          },
          {
            title: this.__("Amount"),
            value: "grand_total",
            align: "end",
            width: "25%"
          },
          {
            title: this.__("Actions"),
            value: "actions",
            align: "center",
            width: "20%",
            sortable: false
          }
        ]
      };
    },
    watch: {
      modelValue(val) {
        this.dialog = val;
        if (val) {
          this.loadInvoices();
        }
      },
      dialog(val) {
        this.$emit("update:modelValue", val);
      }
    },
    methods: {
      loadInvoices() {
        this.invoices = getOfflineInvoices();
      },
      removeInvoice(index) {
        if (!this.posProfile.posa_allow_delete_offline_invoice) {
          return;
        }
        deleteOfflineInvoice(index);
        this.loadInvoices();
        this.$emit("deleted", getPendingOfflineInvoiceCount());
      }
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/OfflineInvoices.vue?type=template
  var _hoisted_113 = { class: "header-content" };
  var _hoisted_27 = { class: "header-icon-wrapper" };
  var _hoisted_37 = { class: "header-text" };
  var _hoisted_44 = { class: "header-title" };
  var _hoisted_54 = { class: "header-subtitle" };
  var _hoisted_64 = { class: "header-stats" };
  var _hoisted_73 = {
    key: 0,
    class: "empty-state text-center py-12"
  };
  var _hoisted_83 = { class: "empty-icon-wrapper mb-4" };
  var _hoisted_93 = { class: "text-h5 mb-3 text-grey-darken-2 font-weight-medium" };
  var _hoisted_103 = { class: "text-body-1 text-grey-darken-1 mb-0" };
  var _hoisted_114 = { class: "table-container" };
  var _hoisted_124 = { class: "table-header mb-4" };
  var _hoisted_134 = { class: "text-h6 text-grey-darken-2 mb-1" };
  var _hoisted_143 = { class: "text-body-2 text-grey" };
  var _hoisted_153 = { class: "customer-cell" };
  var _hoisted_163 = { class: "font-weight-medium text-grey-darken-2" };
  var _hoisted_173 = { class: "text-caption text-grey" };
  var _hoisted_183 = { class: "amount-cell text-right" };
  var _hoisted_193 = { class: "text-h6 font-weight-bold text-success" };
  var _hoisted_202 = { class: "text-caption text-grey" };
  function render8(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_icon = resolveComponent("v-icon");
    const _component_v_chip = resolveComponent("v-chip");
    const _component_v_spacer = resolveComponent("v-spacer");
    const _component_v_card_title = resolveComponent("v-card-title");
    const _component_v_divider = resolveComponent("v-divider");
    const _component_v_avatar = resolveComponent("v-avatar");
    const _component_v_tooltip = resolveComponent("v-tooltip");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_data_table = resolveComponent("v-data-table");
    const _component_v_container = resolveComponent("v-container");
    const _component_v_card_text = resolveComponent("v-card-text");
    const _component_v_card_actions = resolveComponent("v-card-actions");
    const _component_v_card = resolveComponent("v-card");
    const _component_v_dialog = resolveComponent("v-dialog");
    const _component_v_row = resolveComponent("v-row");
    return openBlock(), createBlock(_component_v_row, { justify: "center" }, {
      default: withCtx(() => [
        createVNode(_component_v_dialog, {
          modelValue: $data.dialog,
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.dialog = $event),
          "max-width": "1000px",
          persistent: ""
        }, {
          default: withCtx(() => [
            createVNode(_component_v_card, { class: "offline-invoices-card" }, {
              default: withCtx(() => [
                createCommentVNode(" Enhanced White Header "),
                createVNode(_component_v_card_title, { class: "offline-header pa-6" }, {
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_113, [
                      createBaseVNode("div", _hoisted_27, [
                        createVNode(_component_v_icon, {
                          class: "header-icon",
                          size: "40"
                        }, {
                          default: withCtx(() => [
                            createTextVNode("mdi-file-document-multiple")
                          ]),
                          _: 1
                        })
                      ]),
                      createBaseVNode("div", _hoisted_37, [
                        createBaseVNode("h3", _hoisted_44, toDisplayString(_ctx.__("Offline Invoices")), 1),
                        createBaseVNode("p", _hoisted_54, toDisplayString(_ctx.__("Manage your offline transactions")), 1),
                        createBaseVNode("div", _hoisted_64, [
                          $data.invoices.length > 0 ? (openBlock(), createBlock(_component_v_chip, {
                            key: 0,
                            color: "primary",
                            variant: "flat",
                            size: "small",
                            class: "status-chip mr-2"
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_v_icon, {
                                start: "",
                                size: "14"
                              }, {
                                default: withCtx(() => [
                                  createTextVNode("mdi-clock-outline")
                                ]),
                                _: 1
                              }),
                              createTextVNode(" " + toDisplayString($data.invoices.length) + " " + toDisplayString(_ctx.__("Pending")), 1)
                            ]),
                            _: 1
                          })) : (openBlock(), createBlock(_component_v_chip, {
                            key: 1,
                            color: "success",
                            variant: "flat",
                            size: "small",
                            class: "status-chip"
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_v_icon, {
                                start: "",
                                size: "14"
                              }, {
                                default: withCtx(() => [
                                  createTextVNode("mdi-check-circle")
                                ]),
                                _: 1
                              }),
                              createTextVNode(" " + toDisplayString(_ctx.__("All Synced")), 1)
                            ]),
                            _: 1
                          }))
                        ])
                      ])
                    ]),
                    createVNode(_component_v_spacer),
                    createCommentVNode(" Removed the header-actions div with the Sync All button ")
                  ]),
                  _: 1
                }),
                createVNode(_component_v_divider, { class: "header-divider" }),
                createVNode(_component_v_card_text, { class: "pa-0 white-background" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_container, {
                      fluid: "",
                      class: "pa-6"
                    }, {
                      default: withCtx(() => [
                        createCommentVNode(" Enhanced Empty State "),
                        !$data.invoices.length ? (openBlock(), createElementBlock("div", _hoisted_73, [
                          createBaseVNode("div", _hoisted_83, [
                            createVNode(_component_v_icon, {
                              size: "80",
                              color: "success",
                              class: "empty-icon"
                            }, {
                              default: withCtx(() => [
                                createTextVNode("mdi-check-circle-outline")
                              ]),
                              _: 1
                            })
                          ]),
                          createBaseVNode("h3", _hoisted_93, toDisplayString(_ctx.__("All Caught Up!")), 1),
                          createBaseVNode("p", _hoisted_103, toDisplayString(_ctx.__("No offline invoices pending synchronization")), 1)
                        ])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                          createCommentVNode(" Enhanced Invoices Table "),
                          createBaseVNode("div", _hoisted_114, [
                            createBaseVNode("div", _hoisted_124, [
                              createBaseVNode("h4", _hoisted_134, toDisplayString(_ctx.__("Pending Invoices")), 1),
                              createBaseVNode("p", _hoisted_143, toDisplayString(_ctx.__("These invoices will be synced when connection is restored")), 1)
                            ]),
                            createVNode(_component_v_data_table, {
                              headers: $data.headers,
                              items: $data.invoices,
                              class: "elevation-0 rounded-lg white-table",
                              "items-per-page": 15,
                              "items-per-page-options": [15, 25, 50]
                            }, {
                              "item.customer": withCtx(({ item }) => [
                                createBaseVNode("div", _hoisted_153, [
                                  createVNode(_component_v_avatar, {
                                    size: "32",
                                    color: "primary",
                                    class: "mr-3"
                                  }, {
                                    default: withCtx(() => [
                                      createVNode(_component_v_icon, {
                                        size: "18",
                                        color: "white"
                                      }, {
                                        default: withCtx(() => [
                                          createTextVNode("mdi-account")
                                        ]),
                                        _: 1
                                      })
                                    ]),
                                    _: 1
                                  }),
                                  createBaseVNode("div", null, [
                                    createBaseVNode("div", _hoisted_163, toDisplayString(item.invoice.customer_name || item.invoice.customer), 1),
                                    createBaseVNode("div", _hoisted_173, toDisplayString(_ctx.__("Customer")), 1)
                                  ])
                                ])
                              ]),
                              "item.posting_date": withCtx(({ item }) => [
                                createVNode(_component_v_chip, {
                                  size: "small",
                                  color: "info",
                                  variant: "tonal",
                                  class: "date-chip"
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_v_icon, {
                                      start: "",
                                      size: "14"
                                    }, {
                                      default: withCtx(() => [
                                        createTextVNode("mdi-calendar")
                                      ]),
                                      _: 1
                                    }),
                                    createTextVNode(" " + toDisplayString(item.invoice.posting_date), 1)
                                  ]),
                                  _: 2
                                }, 1024)
                              ]),
                              "item.grand_total": withCtx(({ item }) => [
                                createBaseVNode("div", _hoisted_183, [
                                  createBaseVNode("div", _hoisted_193, toDisplayString(_ctx.currencySymbol(item.invoice.currency)) + " " + toDisplayString(_ctx.formatCurrency(item.invoice.grand_total || item.invoice.rounded_total)), 1),
                                  createBaseVNode("div", _hoisted_202, toDisplayString(_ctx.__("Total Amount")), 1)
                                ])
                              ]),
                              "item.actions": withCtx(({ index }) => [
                                $props.posProfile.posa_allow_delete_offline_invoice ? (openBlock(), createBlock(_component_v_btn, {
                                  key: 0,
                                  icon: "",
                                  color: "error",
                                  size: "small",
                                  variant: "text",
                                  onClick: ($event) => $options.removeInvoice(index),
                                  class: "delete-btn"
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_v_icon, { size: "18" }, {
                                      default: withCtx(() => [
                                        createTextVNode("mdi-delete-outline")
                                      ]),
                                      _: 1
                                    }),
                                    createVNode(_component_v_tooltip, {
                                      activator: "parent",
                                      location: "top"
                                    }, {
                                      default: withCtx(() => [
                                        createTextVNode(toDisplayString(_ctx.__("Delete Invoice")), 1)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])) : createCommentVNode("v-if", true)
                              ]),
                              _: 1
                            }, 8, ["headers", "items"])
                          ])
                        ], 2112))
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                createCommentVNode(" Enhanced Footer "),
                createVNode(_component_v_divider),
                createVNode(_component_v_card_actions, { class: "dialog-actions-container" }, {
                  default: withCtx(() => [
                    $data.invoices.length > 0 ? (openBlock(), createBlock(_component_v_btn, {
                      key: 0,
                      theme: "dark",
                      variant: "elevated",
                      "prepend-icon": "mdi-sync",
                      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("sync-all")),
                      class: "pos-action-btn sync-action-btn",
                      size: "large",
                      elevation: "2"
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.__("Sync All")), 1)
                      ]),
                      _: 1
                    })) : createCommentVNode("v-if", true),
                    createVNode(_component_v_spacer),
                    createVNode(_component_v_btn, {
                      theme: "dark",
                      onClick: _cache[1] || (_cache[1] = ($event) => $data.dialog = false),
                      class: "pos-action-btn cancel-action-btn",
                      size: "large",
                      elevation: "2"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_v_icon, { start: "" }, {
                          default: withCtx(() => [
                            createTextVNode("mdi-close-circle-outline")
                          ]),
                          _: 1
                        }),
                        createBaseVNode("span", null, toDisplayString(_ctx.__("Close")), 1)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]),
      _: 1
    });
  }

  // ../posawesome/posawesome/public/js/posapp/components/OfflineInvoices.vue
  OfflineInvoices_default.render = render8;
  OfflineInvoices_default.__file = "../posawesome/posawesome/public/js/posapp/components/OfflineInvoices.vue";
  var OfflineInvoices_default2 = OfflineInvoices_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/Navbar.vue?type=script
  var Navbar_default = {
    name: "NavBar",
    components: {
      NavbarAppBar: NavbarAppBar_default2,
      NavbarDrawer: NavbarDrawer_default2,
      NavbarMenu: NavbarMenu_default2,
      StatusIndicator: StatusIndicator_default2,
      CacheUsageMeter: CacheUsageMeter_default2,
      AboutDialog: AboutDialog_default2,
      OfflineInvoicesDialog: OfflineInvoices_default2
    },
    props: {
      posProfile: {
        type: Object,
        default: () => ({})
      },
      pendingInvoices: {
        type: Number,
        default: 0
      },
      lastInvoiceId: String,
      networkOnline: Boolean,
      serverOnline: Boolean,
      serverConnecting: Boolean,
      isIpHost: Boolean,
      syncTotals: {
        type: Object,
        default: () => ({ pending: 0, synced: 0, drafted: 0 })
      },
      manualOffline: Boolean,
      isDark: Boolean,
      cacheUsage: {
        type: Number,
        default: 0
      },
      cacheUsageLoading: {
        type: Boolean,
        default: false
      },
      cacheUsageDetails: {
        type: Object,
        default: () => ({ total: 0, indexedDB: 0, localStorage: 0 })
      }
    },
    data() {
      return {
        drawer: false,
        mini: true,
        item: 0,
        items: [
          { text: "POS", icon: "mdi-network-pos" },
          { text: "Payments", icon: "mdi-credit-card" }
        ],
        company: "POS Awesome",
        companyImg: "/assets/posawesome/js/posapp/components/pos/pos.png",
        showAboutDialog: false,
        showOfflineInvoices: false,
        freeze: false,
        freezeTitle: "",
        freezeMsg: "",
        snack: false,
        snackText: "",
        snackColor: "success",
        snackTimeout: 3e3
      };
    },
    computed: {
      appBarColor() {
        return this.isDark ? this.$vuetify.theme.themes.dark.colors.surface : "white";
      }
    },
    mounted() {
      this.initializeNavbar();
      console.log("Navbar mounted with:");
      console.log("- Company:", this.company);
      console.log("- Company Image:", this.companyImg);
      console.log("- Items:", this.items);
      console.log("- Drawer state:", this.drawer);
    },
    methods: {
      initializeNavbar() {
        if (frappe.boot && frappe.boot.sysdefaults && frappe.boot.sysdefaults.company) {
          this.company = frappe.boot.sysdefaults.company;
        }
        if (frappe.boot && frappe.boot.website_settings && frappe.boot.website_settings.app_logo) {
          this.companyImg = frappe.boot.website_settings.app_logo;
        } else if (frappe.boot && frappe.boot.website_settings && frappe.boot.website_settings.banner_image) {
          this.companyImg = frappe.boot.website_settings.banner_image;
        }
        console.log("Company:", this.company);
        console.log("Company Image:", this.companyImg);
        console.log("Frappe boot data:", frappe.boot);
        this.$forceUpdate();
      },
      handleNavClick() {
        console.log("Nav icon clicked, current drawer state:", this.drawer);
        this.drawer = !this.drawer;
        console.log("New drawer state:", this.drawer);
        this.$emit("nav-click");
      },
      goDesk() {
        window.location.href = "/app";
      },
      changePage(page) {
        this.$emit("change-page", page);
      },
      openCloseShift() {
        this.$emit("close-shift");
      },
      printLastInvoice() {
        this.$emit("print-last-invoice");
      },
      syncPendingInvoices() {
        this.$emit("sync-invoices");
      },
      toggleManualOffline() {
        this.$emit("toggle-offline");
      },
      async clearCache() {
        try {
          await clearAllCache();
          this.showMessage({ color: "success", title: this.__("Cache cleared successfully") });
        } catch (e) {
          console.error("Failed to clear cache", e);
          this.showMessage({ color: "error", title: this.__("Failed to clear cache") });
        } finally {
          setTimeout(() => location.reload(), 1e3);
        }
      },
      toggleTheme() {
        this.$emit("toggle-theme");
      },
      logOut() {
        this.$emit("logout");
      },
      refreshCacheUsage() {
        this.$emit("refresh-cache-usage");
      },
      updateAfterDelete() {
        this.$emit("update-after-delete");
      },
      showMessage(data) {
        this.snackText = data.title;
        this.snackColor = data.color || "success";
        this.snack = true;
      },
      handleMouseLeave() {
        if (!this.drawer)
          return;
        clearTimeout(this._closeTimeout);
        this._closeTimeout = setTimeout(() => {
          this.drawer = false;
          this.mini = true;
        }, 250);
      }
    },
    emits: [
      "nav-click",
      "change-page",
      "close-shift",
      "print-last-invoice",
      "sync-invoices",
      "toggle-offline",
      "toggle-theme",
      "logout",
      "refresh-cache-usage",
      "update-after-delete"
    ]
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/Navbar.vue?type=template
  function render9(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_StatusIndicator = resolveComponent("StatusIndicator");
    const _component_CacheUsageMeter = resolveComponent("CacheUsageMeter");
    const _component_NavbarMenu = resolveComponent("NavbarMenu");
    const _component_NavbarAppBar = resolveComponent("NavbarAppBar");
    const _component_NavbarDrawer = resolveComponent("NavbarDrawer");
    const _component_AboutDialog = resolveComponent("AboutDialog");
    const _component_v_card_title = resolveComponent("v-card-title");
    const _component_v_card_text = resolveComponent("v-card-text");
    const _component_v_card = resolveComponent("v-card");
    const _component_v_dialog = resolveComponent("v-dialog");
    const _component_OfflineInvoicesDialog = resolveComponent("OfflineInvoicesDialog");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_snackbar = resolveComponent("v-snackbar");
    return openBlock(), createElementBlock("nav", null, [
      createCommentVNode(" Use the modular NavbarAppBar component "),
      createVNode(_component_NavbarAppBar, {
        "pos-profile": $props.posProfile,
        "pending-invoices": $props.pendingInvoices,
        "is-dark": $props.isDark,
        onNavClick: $options.handleNavClick,
        onGoDesk: $options.goDesk,
        onShowOfflineInvoices: _cache[1] || (_cache[1] = ($event) => $data.showOfflineInvoices = true)
      }, {
        "status-indicator": withCtx(() => [
          createVNode(_component_StatusIndicator, {
            "network-online": $props.networkOnline,
            "server-online": $props.serverOnline,
            "server-connecting": $props.serverConnecting,
            "is-ip-host": $props.isIpHost,
            "sync-totals": $props.syncTotals
          }, null, 8, ["network-online", "server-online", "server-connecting", "is-ip-host", "sync-totals"])
        ]),
        "cache-usage-meter": withCtx(() => [
          createVNode(_component_CacheUsageMeter, {
            "cache-usage": $props.cacheUsage,
            "cache-usage-loading": $props.cacheUsageLoading,
            "cache-usage-details": $props.cacheUsageDetails,
            onRefresh: $options.refreshCacheUsage
          }, null, 8, ["cache-usage", "cache-usage-loading", "cache-usage-details", "onRefresh"])
        ]),
        menu: withCtx(() => [
          createVNode(_component_NavbarMenu, {
            "pos-profile": $props.posProfile,
            "last-invoice-id": $props.lastInvoiceId,
            "manual-offline": $props.manualOffline,
            "is-dark": $props.isDark,
            onCloseShift: $options.openCloseShift,
            onPrintLastInvoice: $options.printLastInvoice,
            onSyncInvoices: $options.syncPendingInvoices,
            onToggleOffline: $options.toggleManualOffline,
            onClearCache: $options.clearCache,
            onShowAbout: _cache[0] || (_cache[0] = ($event) => $data.showAboutDialog = true),
            onToggleTheme: $options.toggleTheme,
            onLogout: $options.logOut
          }, null, 8, ["pos-profile", "last-invoice-id", "manual-offline", "is-dark", "onCloseShift", "onPrintLastInvoice", "onSyncInvoices", "onToggleOffline", "onClearCache", "onToggleTheme", "onLogout"])
        ]),
        _: 1
      }, 8, ["pos-profile", "pending-invoices", "is-dark", "onNavClick", "onGoDesk"]),
      createCommentVNode(" Use the modular NavbarDrawer component "),
      createVNode(_component_NavbarDrawer, {
        drawer: $data.drawer,
        "onUpdate:drawer": _cache[2] || (_cache[2] = ($event) => $data.drawer = $event),
        item: $data.item,
        "onUpdate:item": _cache[3] || (_cache[3] = ($event) => $data.item = $event),
        company: $data.company,
        "company-img": $data.companyImg,
        items: $data.items,
        "is-dark": $props.isDark,
        onChangePage: $options.changePage
      }, null, 8, ["drawer", "item", "company", "company-img", "items", "is-dark", "onChangePage"]),
      createCommentVNode(" Use the modular AboutDialog component "),
      createVNode(_component_AboutDialog, {
        modelValue: $data.showAboutDialog,
        "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $data.showAboutDialog = $event)
      }, null, 8, ["modelValue"]),
      createCommentVNode(" Keep existing dialogs "),
      createVNode(_component_v_dialog, {
        modelValue: $data.freeze,
        "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => $data.freeze = $event),
        persistent: "",
        "max-width": "290"
      }, {
        default: withCtx(() => [
          createVNode(_component_v_card, null, {
            default: withCtx(() => [
              createVNode(_component_v_card_title, { class: "text-h5" }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString($data.freezeTitle), 1)
                ]),
                _: 1
              }),
              createVNode(_component_v_card_text, null, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString($data.freezeMsg), 1)
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["modelValue"]),
      createVNode(_component_OfflineInvoicesDialog, {
        modelValue: $data.showOfflineInvoices,
        "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $data.showOfflineInvoices = $event),
        "pos-profile": $props.posProfile,
        onDeleted: $options.updateAfterDelete
      }, null, 8, ["modelValue", "pos-profile", "onDeleted"]),
      createCommentVNode(" Snackbar for notifications "),
      createVNode(_component_v_snackbar, {
        modelValue: $data.snack,
        "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => $data.snack = $event),
        timeout: $data.snackTimeout,
        color: $data.snackColor,
        location: "top right"
      }, {
        actions: withCtx(() => [
          createVNode(_component_v_btn, {
            color: "white",
            variant: "text",
            onClick: _cache[7] || (_cache[7] = ($event) => $data.snack = false)
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.__("Close")), 1)
            ]),
            _: 1
          })
        ]),
        default: withCtx(() => [
          createTextVNode(toDisplayString($data.snackText) + " ", 1)
        ]),
        _: 1
      }, 8, ["modelValue", "timeout", "color"])
    ]);
  }

  // ../posawesome/posawesome/public/js/posapp/components/Navbar.vue
  Navbar_default.render = render9;
  Navbar_default.__file = "../posawesome/posawesome/public/js/posapp/components/Navbar.vue";
  Navbar_default.__scopeId = "data-v-8763b898";
  var Navbar_default2 = Navbar_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/ItemsSelector.vue?type=script
  var import_lodash = __toESM(require_lodash());

  // ../posawesome/node_modules/vue-qrcode-reader/dist/vue-qrcode-reader.js
  var Dr2 = (r, o, i) => {
    if (!o.has(r))
      throw TypeError("Cannot " + i);
  };
  var br2 = (r, o, i) => (Dr2(r, o, "read from private field"), i ? i.call(r) : o.get(r));
  var Co = (r, o, i) => {
    if (o.has(r))
      throw TypeError("Cannot add the same private member more than once");
    o instanceof WeakSet ? o.add(r) : o.set(r, i);
  };
  var $o2 = (r, o, i, c) => (Dr2(r, o, "write to private field"), o.set(r, i), i);
  var Ar2 = [
    ["aztec", "Aztec"],
    ["code_128", "Code128"],
    ["code_39", "Code39"],
    ["code_93", "Code93"],
    ["codabar", "Codabar"],
    ["databar", "DataBar"],
    ["databar_expanded", "DataBarExpanded"],
    ["data_matrix", "DataMatrix"],
    ["dx_film_edge", "DXFilmEdge"],
    ["ean_13", "EAN-13"],
    ["ean_8", "EAN-8"],
    ["itf", "ITF"],
    ["maxi_code", "MaxiCode"],
    ["micro_qr_code", "MicroQRCode"],
    ["pdf417", "PDF417"],
    ["qr_code", "QRCode"],
    ["rm_qr_code", "rMQRCode"],
    ["upc_a", "UPC-A"],
    ["upc_e", "UPC-E"],
    ["linear_codes", "Linear-Codes"],
    ["matrix_codes", "Matrix-Codes"]
  ];
  var _o = [...Ar2, ["unknown"]].map((r) => r[0]);
  var ct2 = new Map(
    Ar2
  );
  function So(r) {
    for (const [o, i] of ct2)
      if (r === i)
        return o;
    return "unknown";
  }
  function Po(r) {
    if (xr2(r))
      return {
        width: r.naturalWidth,
        height: r.naturalHeight
      };
    if (Rr2(r))
      return {
        width: r.width.baseVal.value,
        height: r.height.baseVal.value
      };
    if (kr2(r))
      return {
        width: r.videoWidth,
        height: r.videoHeight
      };
    if (Fr2(r))
      return {
        width: r.width,
        height: r.height
      };
    if (Wr2(r))
      return {
        width: r.displayWidth,
        height: r.displayHeight
      };
    if (Ir2(r))
      return {
        width: r.width,
        height: r.height
      };
    if (Ur2(r))
      return {
        width: r.width,
        height: r.height
      };
    throw new TypeError(
      "The provided value is not of type '(Blob or HTMLCanvasElement or HTMLImageElement or HTMLVideoElement or ImageBitmap or ImageData or OffscreenCanvas or SVGImageElement or VideoFrame)'."
    );
  }
  function xr2(r) {
    try {
      return r instanceof HTMLImageElement;
    } catch (o) {
      return false;
    }
  }
  function Rr2(r) {
    try {
      return r instanceof SVGImageElement;
    } catch (o) {
      return false;
    }
  }
  function kr2(r) {
    try {
      return r instanceof HTMLVideoElement;
    } catch (o) {
      return false;
    }
  }
  function Ir2(r) {
    try {
      return r instanceof HTMLCanvasElement;
    } catch (o) {
      return false;
    }
  }
  function Fr2(r) {
    try {
      return r instanceof ImageBitmap;
    } catch (o) {
      return false;
    }
  }
  function Ur2(r) {
    try {
      return r instanceof OffscreenCanvas;
    } catch (o) {
      return false;
    }
  }
  function Wr2(r) {
    try {
      return r instanceof VideoFrame;
    } catch (o) {
      return false;
    }
  }
  function Lr2(r) {
    try {
      return r instanceof Blob;
    } catch (o) {
      return false;
    }
  }
  function To2(r) {
    try {
      return r instanceof ImageData;
    } catch (o) {
      return false;
    }
  }
  function Eo(r, o) {
    try {
      const i = new OffscreenCanvas(r, o);
      if (i.getContext("2d") instanceof OffscreenCanvasRenderingContext2D)
        return i;
      throw void 0;
    } catch (i) {
      const c = document.createElement("canvas");
      return c.width = r, c.height = o, c;
    }
  }
  async function jr2(r) {
    if (xr2(r) && !await Ao2(r))
      throw new DOMException(
        "Failed to load or decode HTMLImageElement.",
        "InvalidStateError"
      );
    if (Rr2(r) && !await xo(r))
      throw new DOMException(
        "Failed to load or decode SVGImageElement.",
        "InvalidStateError"
      );
    if (Wr2(r) && Ro(r))
      throw new DOMException("VideoFrame is closed.", "InvalidStateError");
    if (kr2(r) && (r.readyState === 0 || r.readyState === 1))
      throw new DOMException("Invalid element or state.", "InvalidStateError");
    if (Fr2(r) && Io(r))
      throw new DOMException(
        "The image source is detached.",
        "InvalidStateError"
      );
    const { width: o, height: i } = Po(r);
    if (o === 0 || i === 0)
      return null;
    const c = Eo(o, i).getContext("2d");
    c.drawImage(r, 0, 0);
    try {
      return c.getImageData(0, 0, o, i);
    } catch (l) {
      throw new DOMException("Source would taint origin.", "SecurityError");
    }
  }
  async function Oo(r) {
    let o;
    try {
      if (globalThis.createImageBitmap)
        o = await createImageBitmap(r);
      else if (globalThis.Image) {
        o = new Image();
        let i = "";
        try {
          i = URL.createObjectURL(r), o.src = i, await o.decode();
        } finally {
          URL.revokeObjectURL(i);
        }
      } else
        return r;
    } catch (i) {
      throw new DOMException(
        "Failed to load or decode Blob.",
        "InvalidStateError"
      );
    }
    return await jr2(o);
  }
  function Mo2(r) {
    const { width: o, height: i } = r;
    if (o === 0 || i === 0)
      return null;
    const c = r.getContext("2d");
    try {
      return c.getImageData(0, 0, o, i);
    } catch (l) {
      throw new DOMException("Source would taint origin.", "SecurityError");
    }
  }
  async function Do2(r) {
    if (Lr2(r))
      return await Oo(r);
    if (To2(r)) {
      if (ko2(r))
        throw new DOMException(
          "The image data has been detached.",
          "InvalidStateError"
        );
      return r;
    }
    return Ir2(r) || Ur2(r) ? Mo2(r) : await jr2(r);
  }
  async function Ao2(r) {
    try {
      return await r.decode(), true;
    } catch (o) {
      return false;
    }
  }
  async function xo(r) {
    var o;
    try {
      return await ((o = r.decode) == null ? void 0 : o.call(r)), true;
    } catch (i) {
      return false;
    }
  }
  function Ro(r) {
    return r.format === null;
  }
  function ko2(r) {
    return r.data.buffer.byteLength === 0;
  }
  function Io(r) {
    return r.width === 0 && r.height === 0;
  }
  function Cr2(r, o) {
    return r instanceof DOMException ? new DOMException(`${o}: ${r.message}`, r.name) : r instanceof Error ? new r.constructor(`${o}: ${r.message}`) : new Error(`${o}: ${r}`);
  }
  var $r2 = [
    "Aztec",
    "Codabar",
    "Code128",
    "Code39",
    "Code93",
    "DataBar",
    "DataBarExpanded",
    "DataMatrix",
    "DXFilmEdge",
    "EAN-13",
    "EAN-8",
    "ITF",
    "Linear-Codes",
    "Matrix-Codes",
    "MaxiCode",
    "MicroQRCode",
    "None",
    "PDF417",
    "QRCode",
    "rMQRCode",
    "UPC-A",
    "UPC-E"
  ];
  function Fo(r) {
    return r.join("|");
  }
  function Uo(r) {
    const o = _r2(r);
    let i = 0, c = $r2.length - 1;
    for (; i <= c; ) {
      const l = Math.floor((i + c) / 2), h2 = $r2[l], v = _r2(h2);
      if (v === o)
        return h2;
      v < o ? i = l + 1 : c = l - 1;
    }
    return "None";
  }
  function _r2(r) {
    return r.toLowerCase().replace(/_-\[\]/g, "");
  }
  function Wo(r, o) {
    return r.Binarizer[o];
  }
  function Lo(r, o) {
    return r.CharacterSet[o];
  }
  var jo = [
    "Text",
    "Binary",
    "Mixed",
    "GS1",
    "ISO15434",
    "UnknownECI"
  ];
  function Ho(r) {
    return jo[r.value];
  }
  function Bo(r, o) {
    return r.EanAddOnSymbol[o];
  }
  function Vo(r, o) {
    return r.TextMode[o];
  }
  var Ee = {
    formats: [],
    tryHarder: true,
    tryRotate: true,
    tryInvert: true,
    tryDownscale: true,
    binarizer: "LocalAverage",
    isPure: false,
    downscaleFactor: 3,
    downscaleThreshold: 500,
    minLineCount: 2,
    maxNumberOfSymbols: 255,
    tryCode39ExtendedMode: false,
    validateCode39CheckSum: false,
    validateITFCheckSum: false,
    returnCodabarStartEnd: false,
    returnErrors: false,
    eanAddOnSymbol: "Read",
    textMode: "Plain",
    characterSet: "Unknown"
  };
  function Hr2(r, o) {
    return __spreadProps(__spreadValues({}, o), {
      formats: Fo(o.formats),
      binarizer: Wo(r, o.binarizer),
      eanAddOnSymbol: Bo(
        r,
        o.eanAddOnSymbol
      ),
      textMode: Vo(r, o.textMode),
      characterSet: Lo(
        r,
        o.characterSet
      )
    });
  }
  function Br2(r) {
    return __spreadProps(__spreadValues({}, r), {
      format: Uo(r.format),
      eccLevel: r.eccLevel,
      contentType: Ho(r.contentType)
    });
  }
  var qo = {
    locateFile: (r, o) => {
      const i = r.match(/_(.+?)\.wasm$/);
      return i ? `https://fastly.jsdelivr.net/npm/zxing-wasm@1.1.3/dist/${i[1]}/${r}` : o + r;
    }
  };
  var Wt2 = /* @__PURE__ */ new WeakMap();
  function Bt(r, o) {
    var i;
    const c = Wt2.get(r);
    if (c != null && c.modulePromise && o === void 0)
      return c.modulePromise;
    const l = (i = c == null ? void 0 : c.moduleOverrides) != null ? i : qo, h2 = r(__spreadValues({}, l));
    return Wt2.set(r, {
      moduleOverrides: l,
      modulePromise: h2
    }), h2;
  }
  async function zo(r, o, i = Ee) {
    const c = __spreadValues(__spreadValues({}, Ee), i), l = await Bt(r), { size: h2 } = o, v = new Uint8Array(await o.arrayBuffer()), g = l._malloc(h2);
    l.HEAPU8.set(v, g);
    const b = l.readBarcodesFromImage(
      g,
      h2,
      Hr2(l, c)
    );
    l._free(g);
    const p2 = [];
    for (let C = 0; C < b.size(); ++C)
      p2.push(
        Br2(b.get(C))
      );
    return p2;
  }
  async function Go(r, o, i = Ee) {
    const c = __spreadValues(__spreadValues({}, Ee), i), l = await Bt(r), {
      data: h2,
      width: v,
      height: g,
      data: { byteLength: b }
    } = o, p2 = l._malloc(b);
    l.HEAPU8.set(h2, p2);
    const C = l.readBarcodesFromPixmap(
      p2,
      v,
      g,
      Hr2(l, c)
    );
    l._free(p2);
    const S = [];
    for (let $2 = 0; $2 < C.size(); ++$2)
      S.push(
        Br2(C.get($2))
      );
    return S;
  }
  __spreadProps(__spreadValues({}, Ee), {
    formats: [...Ee.formats]
  });
  var dt2 = (() => {
    var r = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0;
    return function(o = {}) {
      var i = o, c, l;
      i.ready = new Promise((e, t) => {
        c = e, l = t;
      });
      var h2 = Object.assign({}, i), v = "./this.program", g = typeof window == "object", b = typeof importScripts == "function";
      typeof process == "object" && typeof process.versions == "object" && process.versions.node;
      var p2 = "";
      function C(e) {
        return i.locateFile ? i.locateFile(e, p2) : p2 + e;
      }
      var S;
      (g || b) && (b ? p2 = self.location.href : typeof document < "u" && document.currentScript && (p2 = document.currentScript.src), r && (p2 = r), p2.indexOf("blob:") !== 0 ? p2 = p2.substr(0, p2.replace(/[?#].*/, "").lastIndexOf("/") + 1) : p2 = "", b && (S = (e) => {
        var t = new XMLHttpRequest();
        return t.open("GET", e, false), t.responseType = "arraybuffer", t.send(null), new Uint8Array(t.response);
      })), i.print || console.log.bind(console);
      var $2 = i.printErr || console.error.bind(console);
      Object.assign(i, h2), h2 = null, i.arguments && i.arguments, i.thisProgram && (v = i.thisProgram), i.quit && i.quit;
      var F;
      i.wasmBinary && (F = i.wasmBinary), typeof WebAssembly != "object" && Z("no native wasm support detected");
      var U, W = false, R, A, X, k, M, D, le, ie;
      function be() {
        var e = U.buffer;
        i.HEAP8 = R = new Int8Array(e), i.HEAP16 = X = new Int16Array(e), i.HEAPU8 = A = new Uint8Array(e), i.HEAPU16 = k = new Uint16Array(e), i.HEAP32 = M = new Int32Array(e), i.HEAPU32 = D = new Uint32Array(e), i.HEAPF32 = le = new Float32Array(e), i.HEAPF64 = ie = new Float64Array(e);
      }
      var Ce2 = [], Oe2 = [], Me = [];
      function He2() {
        if (i.preRun)
          for (typeof i.preRun == "function" && (i.preRun = [i.preRun]); i.preRun.length; )
            pt(i.preRun.shift());
        gt2(Ce2);
      }
      function ft() {
        gt2(Oe2);
      }
      function ht2() {
        if (i.postRun)
          for (typeof i.postRun == "function" && (i.postRun = [i.postRun]); i.postRun.length; )
            De(i.postRun.shift());
        gt2(Me);
      }
      function pt(e) {
        Ce2.unshift(e);
      }
      function mt(e) {
        Oe2.unshift(e);
      }
      function De(e) {
        Me.unshift(e);
      }
      var te = 0, ve = null;
      function Be(e) {
        var t;
        te++, (t = i.monitorRunDependencies) === null || t === void 0 || t.call(i, te);
      }
      function de(e) {
        var t;
        if (te--, (t = i.monitorRunDependencies) === null || t === void 0 || t.call(i, te), te == 0 && ve) {
          var n = ve;
          ve = null, n();
        }
      }
      function Z(e) {
        var t;
        (t = i.onAbort) === null || t === void 0 || t.call(i, e), e = "Aborted(" + e + ")", $2(e), W = true, e += ". Build with -sASSERTIONS for more info.";
        var n = new WebAssembly.RuntimeError(e);
        throw l(n), n;
      }
      var vt = "data:application/octet-stream;base64,", Ve = (e) => e.startsWith(vt), fe;
      fe = "zxing_reader.wasm", Ve(fe) || (fe = C(fe));
      function qe2(e) {
        if (e == fe && F)
          return new Uint8Array(F);
        if (S)
          return S(e);
        throw "both async and sync fetching of the wasm failed";
      }
      function yt(e) {
        return !F && (g || b) && typeof fetch == "function" ? fetch(e, {
          credentials: "same-origin"
        }).then((t) => {
          if (!t.ok)
            throw "failed to load wasm binary file at '" + e + "'";
          return t.arrayBuffer();
        }).catch(() => qe2(e)) : Promise.resolve().then(() => qe2(e));
      }
      function Ne2(e, t, n) {
        return yt(e).then((a) => WebAssembly.instantiate(a, t)).then((a) => a).then(n, (a) => {
          $2(`failed to asynchronously prepare wasm: ${a}`), Z(a);
        });
      }
      function an(e, t, n, a) {
        return !e && typeof WebAssembly.instantiateStreaming == "function" && !Ve(t) && typeof fetch == "function" ? fetch(t, {
          credentials: "same-origin"
        }).then((s) => {
          var u = WebAssembly.instantiateStreaming(s, n);
          return u.then(a, function(d) {
            return $2(`wasm streaming compile failed: ${d}`), $2("falling back to ArrayBuffer instantiation"), Ne2(t, n, a);
          });
        }) : Ne2(t, n, a);
      }
      function on() {
        var e = {
          a: Ga2
        };
        function t(a, s) {
          return z = a.exports, U = z.ia, be(), Kt = z.ma, mt(z.ja), de(), z;
        }
        Be();
        function n(a) {
          t(a.instance);
        }
        if (i.instantiateWasm)
          try {
            return i.instantiateWasm(e, t);
          } catch (a) {
            $2(`Module.instantiateWasm callback failed with error: ${a}`), l(a);
          }
        return an(F, fe, e, n).catch(l), {};
      }
      var gt2 = (e) => {
        for (; e.length > 0; )
          e.shift()(i);
      };
      i.noExitRuntime;
      var ze2 = [], Ge = 0, sn2 = (e) => {
        var t = new wt2(e);
        return t.get_caught() || (t.set_caught(true), Ge--), t.set_rethrown(false), ze2.push(t), hr2(t.excPtr), t.get_exception_ptr();
      }, se = 0, cn2 = () => {
        L(0, 0);
        var e = ze2.pop();
        fr2(e.excPtr), se = 0;
      };
      function wt2(e) {
        this.excPtr = e, this.ptr = e - 24, this.set_type = function(t) {
          D[this.ptr + 4 >> 2] = t;
        }, this.get_type = function() {
          return D[this.ptr + 4 >> 2];
        }, this.set_destructor = function(t) {
          D[this.ptr + 8 >> 2] = t;
        }, this.get_destructor = function() {
          return D[this.ptr + 8 >> 2];
        }, this.set_caught = function(t) {
          t = t ? 1 : 0, R[this.ptr + 12 >> 0] = t;
        }, this.get_caught = function() {
          return R[this.ptr + 12 >> 0] != 0;
        }, this.set_rethrown = function(t) {
          t = t ? 1 : 0, R[this.ptr + 13 >> 0] = t;
        }, this.get_rethrown = function() {
          return R[this.ptr + 13 >> 0] != 0;
        }, this.init = function(t, n) {
          this.set_adjusted_ptr(0), this.set_type(t), this.set_destructor(n);
        }, this.set_adjusted_ptr = function(t) {
          D[this.ptr + 16 >> 2] = t;
        }, this.get_adjusted_ptr = function() {
          return D[this.ptr + 16 >> 2];
        }, this.get_exception_ptr = function() {
          var t = mr2(this.get_type());
          if (t)
            return D[this.excPtr >> 2];
          var n = this.get_adjusted_ptr();
          return n !== 0 ? n : this.excPtr;
        };
      }
      var un2 = (e) => {
        throw se || (se = e), se;
      }, bt = (e) => {
        var t = se;
        if (!t)
          return Ue(0), 0;
        var n = new wt2(t);
        n.set_adjusted_ptr(t);
        var a = n.get_type();
        if (!a)
          return Ue(0), t;
        for (var s in e) {
          var u = e[s];
          if (u === 0 || u === a)
            break;
          var d = n.ptr + 16;
          if (pr2(u, a, d))
            return Ue(u), t;
        }
        return Ue(a), t;
      }, ln = () => bt([]), dn2 = (e) => bt([e]), fn2 = (e, t) => bt([e, t]), hn = () => {
        var e = ze2.pop();
        e || Z("no exception to throw");
        var t = e.excPtr;
        throw e.get_rethrown() || (ze2.push(e), e.set_rethrown(true), e.set_caught(false), Ge++), se = t, se;
      }, pn2 = (e, t, n) => {
        var a = new wt2(e);
        throw a.init(t, n), se = e, Ge++, se;
      }, mn2 = () => Ge, Ye2 = {}, Ct = (e) => {
        for (; e.length; ) {
          var t = e.pop(), n = e.pop();
          n(t);
        }
      };
      function $t2(e) {
        return this.fromWireType(M[e >> 2]);
      }
      var $e = {}, ye = {}, Je = {}, qt2, Qe2 = (e) => {
        throw new qt2(e);
      }, ge = (e, t, n) => {
        e.forEach(function(f) {
          Je[f] = t;
        });
        function a(f) {
          var m = n(f);
          m.length !== e.length && Qe2("Mismatched type converter count");
          for (var w = 0; w < e.length; ++w)
            re(e[w], m[w]);
        }
        var s = new Array(t.length), u = [], d = 0;
        t.forEach((f, m) => {
          ye.hasOwnProperty(f) ? s[m] = ye[f] : (u.push(f), $e.hasOwnProperty(f) || ($e[f] = []), $e[f].push(() => {
            s[m] = ye[f], ++d, d === u.length && a(s);
          }));
        }), u.length === 0 && a(s);
      }, vn2 = (e) => {
        var t = Ye2[e];
        delete Ye2[e];
        var n = t.rawConstructor, a = t.rawDestructor, s = t.fields, u = s.map((d) => d.getterReturnType).concat(s.map((d) => d.setterArgumentType));
        ge([e], u, (d) => {
          var f = {};
          return s.forEach((m, w) => {
            var _2 = m.fieldName, T = d[w], E = m.getter, O = m.getterContext, j = d[w + s.length], q = m.setter, I = m.setterContext;
            f[_2] = {
              read: (J) => T.fromWireType(E(O, J)),
              write: (J, y) => {
                var P = [];
                q(I, J, j.toWireType(P, y)), Ct(P);
              }
            };
          }), [{
            name: t.name,
            fromWireType: (m) => {
              var w = {};
              for (var _2 in f)
                w[_2] = f[_2].read(m);
              return a(m), w;
            },
            toWireType: (m, w) => {
              for (var _2 in f)
                if (!(_2 in w))
                  throw new TypeError(`Missing field: "${_2}"`);
              var T = n();
              for (_2 in f)
                f[_2].write(T, w[_2]);
              return m !== null && m.push(a, T), T;
            },
            argPackAdvance: ne,
            readValueFromPointer: $t2,
            destructorFunction: a
          }];
        });
      }, yn2 = (e, t, n, a, s) => {
      }, gn2 = () => {
        for (var e = new Array(256), t = 0; t < 256; ++t)
          e[t] = String.fromCharCode(t);
        Nt2 = e;
      }, Nt2, Y = (e) => {
        for (var t = "", n = e; A[n]; )
          t += Nt2[A[n++]];
        return t;
      }, _e, x = (e) => {
        throw new _e(e);
      };
      function wn(e, t) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var a = t.name;
        if (e || x(`type "${a}" must have a positive integer typeid pointer`), ye.hasOwnProperty(e)) {
          if (n.ignoreDuplicateRegistrations)
            return;
          x(`Cannot register type '${a}' twice`);
        }
        if (ye[e] = t, delete Je[e], $e.hasOwnProperty(e)) {
          var s = $e[e];
          delete $e[e], s.forEach((u) => u());
        }
      }
      function re(e, t) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (!("argPackAdvance" in t))
          throw new TypeError("registerType registeredInstance requires argPackAdvance");
        return wn(e, t, n);
      }
      var ne = 8, bn = (e, t, n, a) => {
        t = Y(t), re(e, {
          name: t,
          fromWireType: function(s) {
            return !!s;
          },
          toWireType: function(s, u) {
            return u ? n : a;
          },
          argPackAdvance: ne,
          readValueFromPointer: function(s) {
            return this.fromWireType(A[s]);
          },
          destructorFunction: null
        });
      }, Cn2 = (e) => ({
        count: e.count,
        deleteScheduled: e.deleteScheduled,
        preservePointerOnDelete: e.preservePointerOnDelete,
        ptr: e.ptr,
        ptrType: e.ptrType,
        smartPtr: e.smartPtr,
        smartPtrType: e.smartPtrType
      }), _t2 = (e) => {
        function t(n) {
          return n.$$.ptrType.registeredClass.name;
        }
        x(t(e) + " instance already deleted");
      }, St2 = false, zt2 = (e) => {
      }, $n = (e) => {
        e.smartPtr ? e.smartPtrType.rawDestructor(e.smartPtr) : e.ptrType.registeredClass.rawDestructor(e.ptr);
      }, Gt2 = (e) => {
        e.count.value -= 1;
        var t = e.count.value === 0;
        t && $n(e);
      }, Yt2 = (e, t, n) => {
        if (t === n)
          return e;
        if (n.baseClass === void 0)
          return null;
        var a = Yt2(e, t, n.baseClass);
        return a === null ? null : n.downcast(a);
      }, Jt = {}, _n2 = () => Object.keys(Re).length, Sn2 = () => {
        var e = [];
        for (var t in Re)
          Re.hasOwnProperty(t) && e.push(Re[t]);
        return e;
      }, Ae = [], Pt2 = () => {
        for (; Ae.length; ) {
          var e = Ae.pop();
          e.$$.deleteScheduled = false, e.delete();
        }
      }, xe2, Pn2 = (e) => {
        xe2 = e, Ae.length && xe2 && xe2(Pt2);
      }, Tn2 = () => {
        i.getInheritedInstanceCount = _n2, i.getLiveInheritedInstances = Sn2, i.flushPendingDeletes = Pt2, i.setDelayFunction = Pn2;
      }, Re = {}, En2 = (e, t) => {
        for (t === void 0 && x("ptr should not be undefined"); e.baseClass; )
          t = e.upcast(t), e = e.baseClass;
        return t;
      }, On2 = (e, t) => (t = En2(e, t), Re[t]), Xe = (e, t) => {
        (!t.ptrType || !t.ptr) && Qe2("makeClassHandle requires ptr and ptrType");
        var n = !!t.smartPtrType, a = !!t.smartPtr;
        return n !== a && Qe2("Both smartPtrType and smartPtr must be specified"), t.count = {
          value: 1
        }, ke(Object.create(e, {
          $$: {
            value: t,
            writable: true
          }
        }));
      };
      function Mn(e) {
        var t = this.getPointee(e);
        if (!t)
          return this.destructor(e), null;
        var n = On2(this.registeredClass, t);
        if (n !== void 0) {
          if (n.$$.count.value === 0)
            return n.$$.ptr = t, n.$$.smartPtr = e, n.clone();
          var a = n.clone();
          return this.destructor(e), a;
        }
        function s() {
          return this.isSmartPointer ? Xe(this.registeredClass.instancePrototype, {
            ptrType: this.pointeeType,
            ptr: t,
            smartPtrType: this,
            smartPtr: e
          }) : Xe(this.registeredClass.instancePrototype, {
            ptrType: this,
            ptr: e
          });
        }
        var u = this.registeredClass.getActualType(t), d = Jt[u];
        if (!d)
          return s.call(this);
        var f;
        this.isConst ? f = d.constPointerType : f = d.pointerType;
        var m = Yt2(t, this.registeredClass, f.registeredClass);
        return m === null ? s.call(this) : this.isSmartPointer ? Xe(f.registeredClass.instancePrototype, {
          ptrType: f,
          ptr: m,
          smartPtrType: this,
          smartPtr: e
        }) : Xe(f.registeredClass.instancePrototype, {
          ptrType: f,
          ptr: m
        });
      }
      var ke = (e) => typeof FinalizationRegistry > "u" ? (ke = (t) => t, e) : (St2 = new FinalizationRegistry((t) => {
        Gt2(t.$$);
      }), ke = (t) => {
        var n = t.$$, a = !!n.smartPtr;
        if (a) {
          var s = {
            $$: n
          };
          St2.register(t, s, t);
        }
        return t;
      }, zt2 = (t) => St2.unregister(t), ke(e)), Dn = () => {
        Object.assign(Ze2.prototype, {
          isAliasOf(e) {
            if (!(this instanceof Ze2) || !(e instanceof Ze2))
              return false;
            var t = this.$$.ptrType.registeredClass, n = this.$$.ptr;
            e.$$ = e.$$;
            for (var a = e.$$.ptrType.registeredClass, s = e.$$.ptr; t.baseClass; )
              n = t.upcast(n), t = t.baseClass;
            for (; a.baseClass; )
              s = a.upcast(s), a = a.baseClass;
            return t === a && n === s;
          },
          clone() {
            if (this.$$.ptr || _t2(this), this.$$.preservePointerOnDelete)
              return this.$$.count.value += 1, this;
            var e = ke(Object.create(Object.getPrototypeOf(this), {
              $$: {
                value: Cn2(this.$$)
              }
            }));
            return e.$$.count.value += 1, e.$$.deleteScheduled = false, e;
          },
          delete() {
            this.$$.ptr || _t2(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && x("Object already scheduled for deletion"), zt2(this), Gt2(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0);
          },
          isDeleted() {
            return !this.$$.ptr;
          },
          deleteLater() {
            return this.$$.ptr || _t2(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && x("Object already scheduled for deletion"), Ae.push(this), Ae.length === 1 && xe2 && xe2(Pt2), this.$$.deleteScheduled = true, this;
          }
        });
      };
      function Ze2() {
      }
      var Ie = (e, t) => Object.defineProperty(t, "name", {
        value: e
      }), Qt2 = (e, t, n) => {
        if (e[t].overloadTable === void 0) {
          var a = e[t];
          e[t] = function() {
            return e[t].overloadTable.hasOwnProperty(arguments.length) || x(`Function '${n}' called with an invalid number of arguments (${arguments.length}) - expects one of (${e[t].overloadTable})!`), e[t].overloadTable[arguments.length].apply(this, arguments);
          }, e[t].overloadTable = [], e[t].overloadTable[a.argCount] = a;
        }
      }, Tt = (e, t, n) => {
        i.hasOwnProperty(e) ? ((n === void 0 || i[e].overloadTable !== void 0 && i[e].overloadTable[n] !== void 0) && x(`Cannot register public name '${e}' twice`), Qt2(i, e, e), i.hasOwnProperty(n) && x(`Cannot register multiple overloads of a function with the same number of arguments (${n})!`), i[e].overloadTable[n] = t) : (i[e] = t, n !== void 0 && (i[e].numArguments = n));
      }, An = 48, xn = 57, Rn2 = (e) => {
        if (e === void 0)
          return "_unknown";
        e = e.replace(/[^a-zA-Z0-9_]/g, "$");
        var t = e.charCodeAt(0);
        return t >= An && t <= xn ? `_${e}` : e;
      };
      function kn(e, t, n, a, s, u, d, f) {
        this.name = e, this.constructor = t, this.instancePrototype = n, this.rawDestructor = a, this.baseClass = s, this.getActualType = u, this.upcast = d, this.downcast = f, this.pureVirtualFunctions = [];
      }
      var Et = (e, t, n) => {
        for (; t !== n; )
          t.upcast || x(`Expected null or instance of ${n.name}, got an instance of ${t.name}`), e = t.upcast(e), t = t.baseClass;
        return e;
      };
      function In2(e, t) {
        if (t === null)
          return this.isReference && x(`null is not a valid ${this.name}`), 0;
        t.$$ || x(`Cannot pass "${xt2(t)}" as a ${this.name}`), t.$$.ptr || x(`Cannot pass deleted object as a pointer of type ${this.name}`);
        var n = t.$$.ptrType.registeredClass, a = Et(t.$$.ptr, n, this.registeredClass);
        return a;
      }
      function Fn2(e, t) {
        var n;
        if (t === null)
          return this.isReference && x(`null is not a valid ${this.name}`), this.isSmartPointer ? (n = this.rawConstructor(), e !== null && e.push(this.rawDestructor, n), n) : 0;
        (!t || !t.$$) && x(`Cannot pass "${xt2(t)}" as a ${this.name}`), t.$$.ptr || x(`Cannot pass deleted object as a pointer of type ${this.name}`), !this.isConst && t.$$.ptrType.isConst && x(`Cannot convert argument of type ${t.$$.smartPtrType ? t.$$.smartPtrType.name : t.$$.ptrType.name} to parameter type ${this.name}`);
        var a = t.$$.ptrType.registeredClass;
        if (n = Et(t.$$.ptr, a, this.registeredClass), this.isSmartPointer)
          switch (t.$$.smartPtr === void 0 && x("Passing raw pointer to smart pointer is illegal"), this.sharingPolicy) {
            case 0:
              t.$$.smartPtrType === this ? n = t.$$.smartPtr : x(`Cannot convert argument of type ${t.$$.smartPtrType ? t.$$.smartPtrType.name : t.$$.ptrType.name} to parameter type ${this.name}`);
              break;
            case 1:
              n = t.$$.smartPtr;
              break;
            case 2:
              if (t.$$.smartPtrType === this)
                n = t.$$.smartPtr;
              else {
                var s = t.clone();
                n = this.rawShare(n, ce.toHandle(() => s.delete())), e !== null && e.push(this.rawDestructor, n);
              }
              break;
            default:
              x("Unsupporting sharing policy");
          }
        return n;
      }
      function Un2(e, t) {
        if (t === null)
          return this.isReference && x(`null is not a valid ${this.name}`), 0;
        t.$$ || x(`Cannot pass "${xt2(t)}" as a ${this.name}`), t.$$.ptr || x(`Cannot pass deleted object as a pointer of type ${this.name}`), t.$$.ptrType.isConst && x(`Cannot convert argument of type ${t.$$.ptrType.name} to parameter type ${this.name}`);
        var n = t.$$.ptrType.registeredClass, a = Et(t.$$.ptr, n, this.registeredClass);
        return a;
      }
      function Xt(e) {
        return this.fromWireType(D[e >> 2]);
      }
      var Wn2 = () => {
        Object.assign(Ke.prototype, {
          getPointee(e) {
            return this.rawGetPointee && (e = this.rawGetPointee(e)), e;
          },
          destructor(e) {
            var t;
            (t = this.rawDestructor) === null || t === void 0 || t.call(this, e);
          },
          argPackAdvance: ne,
          readValueFromPointer: Xt,
          deleteObject(e) {
            e !== null && e.delete();
          },
          fromWireType: Mn
        });
      };
      function Ke(e, t, n, a, s, u, d, f, m, w, _2) {
        this.name = e, this.registeredClass = t, this.isReference = n, this.isConst = a, this.isSmartPointer = s, this.pointeeType = u, this.sharingPolicy = d, this.rawGetPointee = f, this.rawConstructor = m, this.rawShare = w, this.rawDestructor = _2, !s && t.baseClass === void 0 ? a ? (this.toWireType = In2, this.destructorFunction = null) : (this.toWireType = Un2, this.destructorFunction = null) : this.toWireType = Fn2;
      }
      var Zt = (e, t, n) => {
        i.hasOwnProperty(e) || Qe2("Replacing nonexistant public symbol"), i[e].overloadTable !== void 0 && n !== void 0 ? i[e].overloadTable[n] = t : (i[e] = t, i[e].argCount = n);
      }, Ln2 = (e, t, n) => {
        var a = i["dynCall_" + e];
        return n && n.length ? a.apply(null, [t].concat(n)) : a.call(null, t);
      }, et = [], Kt, H = (e) => {
        var t = et[e];
        return t || (e >= et.length && (et.length = e + 1), et[e] = t = Kt.get(e)), t;
      }, jn2 = (e, t, n) => {
        if (e.includes("j"))
          return Ln2(e, t, n);
        var a = H(t).apply(null, n);
        return a;
      }, Hn2 = (e, t) => {
        var n = [];
        return function() {
          return n.length = 0, Object.assign(n, arguments), jn2(e, t, n);
        };
      }, ee = (e, t) => {
        e = Y(e);
        function n() {
          return e.includes("j") ? Hn2(e, t) : H(t);
        }
        var a = n();
        return typeof a != "function" && x(`unknown function pointer with signature ${e}: ${t}`), a;
      }, Bn2 = (e, t) => {
        var n = Ie(t, function(a) {
          this.name = t, this.message = a;
          var s = new Error(a).stack;
          s !== void 0 && (this.stack = this.toString() + `
` + s.replace(/^Error(:[^\n]*)?\n/, ""));
        });
        return n.prototype = Object.create(e.prototype), n.prototype.constructor = n, n.prototype.toString = function() {
          return this.message === void 0 ? this.name : `${this.name}: ${this.message}`;
        }, n;
      }, er2, tr2 = (e) => {
        var t = dr2(e), n = Y(t);
        return ue(t), n;
      }, tt3 = (e, t) => {
        var n = [], a = {};
        function s(u) {
          if (!a[u] && !ye[u]) {
            if (Je[u]) {
              Je[u].forEach(s);
              return;
            }
            n.push(u), a[u] = true;
          }
        }
        throw t.forEach(s), new er2(`${e}: ` + n.map(tr2).join([", "]));
      }, Vn2 = (e, t, n, a, s, u, d, f, m, w, _2, T, E) => {
        _2 = Y(_2), u = ee(s, u), f && (f = ee(d, f)), w && (w = ee(m, w)), E = ee(T, E);
        var O = Rn2(_2);
        Tt(O, function() {
          tt3(`Cannot construct ${_2} due to unbound types`, [a]);
        }), ge([e, t, n], a ? [a] : [], function(j) {
          j = j[0];
          var q, I;
          a ? (q = j.registeredClass, I = q.instancePrototype) : I = Ze2.prototype;
          var J = Ie(_2, function() {
            if (Object.getPrototypeOf(this) !== y)
              throw new _e("Use 'new' to construct " + _2);
            if (P.constructor_body === void 0)
              throw new _e(_2 + " has no accessible constructor");
            var wr2 = P.constructor_body[arguments.length];
            if (wr2 === void 0)
              throw new _e(`Tried to invoke ctor of ${_2} with invalid number of parameters (${arguments.length}) - expected (${Object.keys(P.constructor_body).toString()}) parameters instead!`);
            return wr2.apply(this, arguments);
          }), y = Object.create(I, {
            constructor: {
              value: J
            }
          });
          J.prototype = y;
          var P = new kn(_2, J, y, E, q, u, f, w);
          if (P.baseClass) {
            var N, G;
            (G = (N = P.baseClass).__derivedClasses) !== null && G !== void 0 || (N.__derivedClasses = []), P.baseClass.__derivedClasses.push(P);
          }
          var Se = new Ke(_2, P, true, false, false), at2 = new Ke(_2 + "*", P, false, false, false), gr2 = new Ke(_2 + " const*", P, false, true, false);
          return Jt[e] = {
            pointerType: at2,
            constPointerType: gr2
          }, Zt(O, J), [Se, at2, gr2];
        });
      }, Ot = (e, t) => {
        for (var n = [], a = 0; a < e; a++)
          n.push(D[t + a * 4 >> 2]);
        return n;
      };
      function qn(e) {
        for (var t = 1; t < e.length; ++t)
          if (e[t] !== null && e[t].destructorFunction === void 0)
            return true;
        return false;
      }
      function Mt2(e, t, n, a, s, u) {
        var d = t.length;
        d < 2 && x("argTypes array size mismatch! Must at least get return value and 'this' types!");
        var f = t[1] !== null && n !== null, m = qn(t), w = t[0].name !== "void", _2 = d - 2, T = new Array(_2), E = [], O = [], j = function() {
          arguments.length !== _2 && x(`function ${e} called with ${arguments.length} arguments, expected ${_2}`), O.length = 0;
          var q;
          E.length = f ? 2 : 1, E[0] = s, f && (q = t[1].toWireType(O, this), E[1] = q);
          for (var I = 0; I < _2; ++I)
            T[I] = t[I + 2].toWireType(O, arguments[I]), E.push(T[I]);
          var J = a.apply(null, E);
          function y(P) {
            if (m)
              Ct(O);
            else
              for (var N = f ? 1 : 2; N < t.length; N++) {
                var G = N === 1 ? q : T[N - 2];
                t[N].destructorFunction !== null && t[N].destructorFunction(G);
              }
            if (w)
              return t[0].fromWireType(P);
          }
          return y(J);
        };
        return Ie(e, j);
      }
      var Nn2 = (e, t, n, a, s, u) => {
        var d = Ot(t, n);
        s = ee(a, s), ge([], [e], function(f) {
          f = f[0];
          var m = `constructor ${f.name}`;
          if (f.registeredClass.constructor_body === void 0 && (f.registeredClass.constructor_body = []), f.registeredClass.constructor_body[t - 1] !== void 0)
            throw new _e(`Cannot register multiple constructors with identical number of parameters (${t - 1}) for class '${f.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
          return f.registeredClass.constructor_body[t - 1] = () => {
            tt3(`Cannot construct ${f.name} due to unbound types`, d);
          }, ge([], d, (w) => (w.splice(1, 0, null), f.registeredClass.constructor_body[t - 1] = Mt2(m, w, null, s, u), [])), [];
        });
      }, rr2 = (e) => {
        e = e.trim();
        const t = e.indexOf("(");
        return t !== -1 ? e.substr(0, t) : e;
      }, zn2 = (e, t, n, a, s, u, d, f, m) => {
        var w = Ot(n, a);
        t = Y(t), t = rr2(t), u = ee(s, u), ge([], [e], function(_2) {
          _2 = _2[0];
          var T = `${_2.name}.${t}`;
          t.startsWith("@@") && (t = Symbol[t.substring(2)]), f && _2.registeredClass.pureVirtualFunctions.push(t);
          function E() {
            tt3(`Cannot call ${T} due to unbound types`, w);
          }
          var O = _2.registeredClass.instancePrototype, j = O[t];
          return j === void 0 || j.overloadTable === void 0 && j.className !== _2.name && j.argCount === n - 2 ? (E.argCount = n - 2, E.className = _2.name, O[t] = E) : (Qt2(O, t, T), O[t].overloadTable[n - 2] = E), ge([], w, function(q) {
            var I = Mt2(T, q, _2, u, d);
            return O[t].overloadTable === void 0 ? (I.argCount = n - 2, O[t] = I) : O[t].overloadTable[n - 2] = I, [];
          }), [];
        });
      };
      function Gn2() {
        Object.assign(nr2.prototype, {
          get(e) {
            return this.allocated[e];
          },
          has(e) {
            return this.allocated[e] !== void 0;
          },
          allocate(e) {
            var t = this.freelist.pop() || this.allocated.length;
            return this.allocated[t] = e, t;
          },
          free(e) {
            this.allocated[e] = void 0, this.freelist.push(e);
          }
        });
      }
      function nr2() {
        this.allocated = [void 0], this.freelist = [];
      }
      var K2 = new nr2(), Dt = (e) => {
        e >= K2.reserved && --K2.get(e).refcount === 0 && K2.free(e);
      }, Yn2 = () => {
        for (var e = 0, t = K2.reserved; t < K2.allocated.length; ++t)
          K2.allocated[t] !== void 0 && ++e;
        return e;
      }, Jn = () => {
        K2.allocated.push({
          value: void 0
        }, {
          value: null
        }, {
          value: true
        }, {
          value: false
        }), K2.reserved = K2.allocated.length, i.count_emval_handles = Yn2;
      }, ce = {
        toValue: (e) => (e || x("Cannot use deleted val. handle = " + e), K2.get(e).value),
        toHandle: (e) => {
          switch (e) {
            case void 0:
              return 1;
            case null:
              return 2;
            case true:
              return 3;
            case false:
              return 4;
            default:
              return K2.allocate({
                refcount: 1,
                value: e
              });
          }
        }
      }, Qn2 = (e, t) => {
        t = Y(t), re(e, {
          name: t,
          fromWireType: (n) => {
            var a = ce.toValue(n);
            return Dt(n), a;
          },
          toWireType: (n, a) => ce.toHandle(a),
          argPackAdvance: ne,
          readValueFromPointer: $t2,
          destructorFunction: null
        });
      }, Xn = (e, t, n) => {
        switch (t) {
          case 1:
            return n ? function(a) {
              return this.fromWireType(R[a >> 0]);
            } : function(a) {
              return this.fromWireType(A[a >> 0]);
            };
          case 2:
            return n ? function(a) {
              return this.fromWireType(X[a >> 1]);
            } : function(a) {
              return this.fromWireType(k[a >> 1]);
            };
          case 4:
            return n ? function(a) {
              return this.fromWireType(M[a >> 2]);
            } : function(a) {
              return this.fromWireType(D[a >> 2]);
            };
          default:
            throw new TypeError(`invalid integer width (${t}): ${e}`);
        }
      }, Zn = (e, t, n, a) => {
        t = Y(t);
        function s() {
        }
        s.values = {}, re(e, {
          name: t,
          constructor: s,
          fromWireType: function(u) {
            return this.constructor.values[u];
          },
          toWireType: (u, d) => d.value,
          argPackAdvance: ne,
          readValueFromPointer: Xn(t, n, a),
          destructorFunction: null
        }), Tt(t, s);
      }, At2 = (e, t) => {
        var n = ye[e];
        return n === void 0 && x(t + " has unknown type " + tr2(e)), n;
      }, Kn2 = (e, t, n) => {
        var a = At2(e, "enum");
        t = Y(t);
        var s = a.constructor, u = Object.create(a.constructor.prototype, {
          value: {
            value: n
          },
          constructor: {
            value: Ie(`${a.name}_${t}`, function() {
            })
          }
        });
        s.values[n] = u, s[t] = u;
      }, xt2 = (e) => {
        if (e === null)
          return "null";
        var t = typeof e;
        return t === "object" || t === "array" || t === "function" ? e.toString() : "" + e;
      }, ea2 = (e, t) => {
        switch (t) {
          case 4:
            return function(n) {
              return this.fromWireType(le[n >> 2]);
            };
          case 8:
            return function(n) {
              return this.fromWireType(ie[n >> 3]);
            };
          default:
            throw new TypeError(`invalid float width (${t}): ${e}`);
        }
      }, ta = (e, t, n) => {
        t = Y(t), re(e, {
          name: t,
          fromWireType: (a) => a,
          toWireType: (a, s) => s,
          argPackAdvance: ne,
          readValueFromPointer: ea2(t, n),
          destructorFunction: null
        });
      }, ra = (e, t, n, a, s, u, d) => {
        var f = Ot(t, n);
        e = Y(e), e = rr2(e), s = ee(a, s), Tt(e, function() {
          tt3(`Cannot call ${e} due to unbound types`, f);
        }, t - 1), ge([], f, function(m) {
          var w = [m[0], null].concat(m.slice(1));
          return Zt(e, Mt2(e, w, null, s, u), t - 1), [];
        });
      }, na2 = (e, t, n) => {
        switch (t) {
          case 1:
            return n ? (a) => R[a >> 0] : (a) => A[a >> 0];
          case 2:
            return n ? (a) => X[a >> 1] : (a) => k[a >> 1];
          case 4:
            return n ? (a) => M[a >> 2] : (a) => D[a >> 2];
          default:
            throw new TypeError(`invalid integer width (${t}): ${e}`);
        }
      }, aa2 = (e, t, n, a, s) => {
        t = Y(t);
        var u = (_2) => _2;
        if (a === 0) {
          var d = 32 - 8 * n;
          u = (_2) => _2 << d >>> d;
        }
        var f = t.includes("unsigned"), m = (_2, T) => {
        }, w;
        f ? w = function(_2, T) {
          return m(T, this.name), T >>> 0;
        } : w = function(_2, T) {
          return m(T, this.name), T;
        }, re(e, {
          name: t,
          fromWireType: u,
          toWireType: w,
          argPackAdvance: ne,
          readValueFromPointer: na2(t, n, a !== 0),
          destructorFunction: null
        });
      }, oa = (e, t, n) => {
        var a = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], s = a[t];
        function u(d) {
          var f = D[d >> 2], m = D[d + 4 >> 2];
          return new s(R.buffer, m, f);
        }
        n = Y(n), re(e, {
          name: n,
          fromWireType: u,
          argPackAdvance: ne,
          readValueFromPointer: u
        }, {
          ignoreDuplicateRegistrations: true
        });
      }, ar2 = (e, t, n, a) => {
        if (!(a > 0))
          return 0;
        for (var s = n, u = n + a - 1, d = 0; d < e.length; ++d) {
          var f = e.charCodeAt(d);
          if (f >= 55296 && f <= 57343) {
            var m = e.charCodeAt(++d);
            f = 65536 + ((f & 1023) << 10) | m & 1023;
          }
          if (f <= 127) {
            if (n >= u)
              break;
            t[n++] = f;
          } else if (f <= 2047) {
            if (n + 1 >= u)
              break;
            t[n++] = 192 | f >> 6, t[n++] = 128 | f & 63;
          } else if (f <= 65535) {
            if (n + 2 >= u)
              break;
            t[n++] = 224 | f >> 12, t[n++] = 128 | f >> 6 & 63, t[n++] = 128 | f & 63;
          } else {
            if (n + 3 >= u)
              break;
            t[n++] = 240 | f >> 18, t[n++] = 128 | f >> 12 & 63, t[n++] = 128 | f >> 6 & 63, t[n++] = 128 | f & 63;
          }
        }
        return t[n] = 0, n - s;
      }, ia = (e, t, n) => ar2(e, A, t, n), or2 = (e) => {
        for (var t = 0, n = 0; n < e.length; ++n) {
          var a = e.charCodeAt(n);
          a <= 127 ? t++ : a <= 2047 ? t += 2 : a >= 55296 && a <= 57343 ? (t += 4, ++n) : t += 3;
        }
        return t;
      }, ir2 = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0, sa2 = (e, t, n) => {
        for (var a = t + n, s = t; e[s] && !(s >= a); )
          ++s;
        if (s - t > 16 && e.buffer && ir2)
          return ir2.decode(e.subarray(t, s));
        for (var u = ""; t < s; ) {
          var d = e[t++];
          if (!(d & 128)) {
            u += String.fromCharCode(d);
            continue;
          }
          var f = e[t++] & 63;
          if ((d & 224) == 192) {
            u += String.fromCharCode((d & 31) << 6 | f);
            continue;
          }
          var m = e[t++] & 63;
          if ((d & 240) == 224 ? d = (d & 15) << 12 | f << 6 | m : d = (d & 7) << 18 | f << 12 | m << 6 | e[t++] & 63, d < 65536)
            u += String.fromCharCode(d);
          else {
            var w = d - 65536;
            u += String.fromCharCode(55296 | w >> 10, 56320 | w & 1023);
          }
        }
        return u;
      }, Rt = (e, t) => e ? sa2(A, e, t) : "", ca = (e, t) => {
        t = Y(t);
        var n = t === "std::string";
        re(e, {
          name: t,
          fromWireType(a) {
            var s = D[a >> 2], u = a + 4, d;
            if (n)
              for (var f = u, m = 0; m <= s; ++m) {
                var w = u + m;
                if (m == s || A[w] == 0) {
                  var _2 = w - f, T = Rt(f, _2);
                  d === void 0 ? d = T : (d += "\0", d += T), f = w + 1;
                }
              }
            else {
              for (var E = new Array(s), m = 0; m < s; ++m)
                E[m] = String.fromCharCode(A[u + m]);
              d = E.join("");
            }
            return ue(a), d;
          },
          toWireType(a, s) {
            s instanceof ArrayBuffer && (s = new Uint8Array(s));
            var u, d = typeof s == "string";
            d || s instanceof Uint8Array || s instanceof Uint8ClampedArray || s instanceof Int8Array || x("Cannot pass non-string to std::string"), n && d ? u = or2(s) : u = s.length;
            var f = Ft(4 + u + 1), m = f + 4;
            if (D[f >> 2] = u, n && d)
              ia(s, m, u + 1);
            else if (d)
              for (var w = 0; w < u; ++w) {
                var _2 = s.charCodeAt(w);
                _2 > 255 && (ue(m), x("String has UTF-16 code units that do not fit in 8 bits")), A[m + w] = _2;
              }
            else
              for (var w = 0; w < u; ++w)
                A[m + w] = s[w];
            return a !== null && a.push(ue, f), f;
          },
          argPackAdvance: ne,
          readValueFromPointer: Xt,
          destructorFunction(a) {
            ue(a);
          }
        });
      }, sr2 = typeof TextDecoder < "u" ? new TextDecoder("utf-16le") : void 0, ua2 = (e, t) => {
        for (var n = e, a = n >> 1, s = a + t / 2; !(a >= s) && k[a]; )
          ++a;
        if (n = a << 1, n - e > 32 && sr2)
          return sr2.decode(A.subarray(e, n));
        for (var u = "", d = 0; !(d >= t / 2); ++d) {
          var f = X[e + d * 2 >> 1];
          if (f == 0)
            break;
          u += String.fromCharCode(f);
        }
        return u;
      }, la2 = (e, t, n) => {
        var a;
        if ((a = n) !== null && a !== void 0 || (n = 2147483647), n < 2)
          return 0;
        n -= 2;
        for (var s = t, u = n < e.length * 2 ? n / 2 : e.length, d = 0; d < u; ++d) {
          var f = e.charCodeAt(d);
          X[t >> 1] = f, t += 2;
        }
        return X[t >> 1] = 0, t - s;
      }, da = (e) => e.length * 2, fa = (e, t) => {
        for (var n = 0, a = ""; !(n >= t / 4); ) {
          var s = M[e + n * 4 >> 2];
          if (s == 0)
            break;
          if (++n, s >= 65536) {
            var u = s - 65536;
            a += String.fromCharCode(55296 | u >> 10, 56320 | u & 1023);
          } else
            a += String.fromCharCode(s);
        }
        return a;
      }, ha2 = (e, t, n) => {
        var a;
        if ((a = n) !== null && a !== void 0 || (n = 2147483647), n < 4)
          return 0;
        for (var s = t, u = s + n - 4, d = 0; d < e.length; ++d) {
          var f = e.charCodeAt(d);
          if (f >= 55296 && f <= 57343) {
            var m = e.charCodeAt(++d);
            f = 65536 + ((f & 1023) << 10) | m & 1023;
          }
          if (M[t >> 2] = f, t += 4, t + 4 > u)
            break;
        }
        return M[t >> 2] = 0, t - s;
      }, pa2 = (e) => {
        for (var t = 0, n = 0; n < e.length; ++n) {
          var a = e.charCodeAt(n);
          a >= 55296 && a <= 57343 && ++n, t += 4;
        }
        return t;
      }, ma = (e, t, n) => {
        n = Y(n);
        var a, s, u, d, f;
        t === 2 ? (a = ua2, s = la2, d = da, u = () => k, f = 1) : t === 4 && (a = fa, s = ha2, d = pa2, u = () => D, f = 2), re(e, {
          name: n,
          fromWireType: (m) => {
            for (var w = D[m >> 2], _2 = u(), T, E = m + 4, O = 0; O <= w; ++O) {
              var j = m + 4 + O * t;
              if (O == w || _2[j >> f] == 0) {
                var q = j - E, I = a(E, q);
                T === void 0 ? T = I : (T += "\0", T += I), E = j + t;
              }
            }
            return ue(m), T;
          },
          toWireType: (m, w) => {
            typeof w != "string" && x(`Cannot pass non-string to C++ string type ${n}`);
            var _2 = d(w), T = Ft(4 + _2 + t);
            return D[T >> 2] = _2 >> f, s(w, T + 4, _2 + t), m !== null && m.push(ue, T), T;
          },
          argPackAdvance: ne,
          readValueFromPointer: $t2,
          destructorFunction(m) {
            ue(m);
          }
        });
      }, va2 = (e, t, n, a, s, u) => {
        Ye2[e] = {
          name: Y(t),
          rawConstructor: ee(n, a),
          rawDestructor: ee(s, u),
          fields: []
        };
      }, ya2 = (e, t, n, a, s, u, d, f, m, w) => {
        Ye2[e].fields.push({
          fieldName: Y(t),
          getterReturnType: n,
          getter: ee(a, s),
          getterContext: u,
          setterArgumentType: d,
          setter: ee(f, m),
          setterContext: w
        });
      }, ga2 = (e, t) => {
        t = Y(t), re(e, {
          isVoid: true,
          name: t,
          argPackAdvance: 0,
          fromWireType: () => {
          },
          toWireType: (n, a) => {
          }
        });
      }, kt = [], wa = (e, t, n, a) => (e = kt[e], t = ce.toValue(t), e(null, t, n, a)), ba = {}, Ca2 = (e) => {
        var t = ba[e];
        return t === void 0 ? Y(e) : t;
      }, cr2 = () => {
        if (typeof globalThis == "object")
          return globalThis;
        function e(t) {
          t.$$$embind_global$$$ = t;
          var n = typeof $$$embind_global$$$ == "object" && t.$$$embind_global$$$ == t;
          return n || delete t.$$$embind_global$$$, n;
        }
        if (typeof $$$embind_global$$$ == "object" || (typeof global == "object" && e(global) ? $$$embind_global$$$ = global : typeof self == "object" && e(self) && ($$$embind_global$$$ = self), typeof $$$embind_global$$$ == "object"))
          return $$$embind_global$$$;
        throw Error("unable to get global object.");
      }, $a = (e) => e === 0 ? ce.toHandle(cr2()) : (e = Ca2(e), ce.toHandle(cr2()[e])), _a3 = (e) => {
        var t = kt.length;
        return kt.push(e), t;
      }, Sa2 = (e, t) => {
        for (var n = new Array(e), a = 0; a < e; ++a)
          n[a] = At2(D[t + a * 4 >> 2], "parameter " + a);
        return n;
      }, Pa2 = Reflect.construct, Ta2 = (e, t, n) => {
        var a = [], s = e.toWireType(a, n);
        return a.length && (D[t >> 2] = ce.toHandle(a)), s;
      }, Ea2 = (e, t, n) => {
        var a = Sa2(e, t), s = a.shift();
        e--;
        var u = new Array(e), d = (m, w, _2, T) => {
          for (var E = 0, O = 0; O < e; ++O)
            u[O] = a[O].readValueFromPointer(T + E), E += a[O].argPackAdvance;
          for (var j = n === 1 ? Pa2(w, u) : w.apply(m, u), O = 0; O < e; ++O) {
            var q, I;
            (q = (I = a[O]).deleteObject) === null || q === void 0 || q.call(I, u[O]);
          }
          return Ta2(s, _2, j);
        }, f = `methodCaller<(${a.map((m) => m.name).join(", ")}) => ${s.name}>`;
        return _a3(Ie(f, d));
      }, Oa2 = (e) => {
        e > 4 && (K2.get(e).refcount += 1);
      }, Ma = (e) => {
        var t = ce.toValue(e);
        Ct(t), Dt(e);
      }, Da = (e, t) => {
        e = At2(e, "_emval_take_value");
        var n = e.readValueFromPointer(t);
        return ce.toHandle(n);
      }, Aa = () => {
        Z("");
      }, xa2 = (e, t, n) => A.copyWithin(e, t, t + n), Ra2 = () => 2147483648, ka = (e) => {
        var t = U.buffer, n = (e - t.byteLength + 65535) / 65536;
        try {
          return U.grow(n), be(), 1;
        } catch (a) {
        }
      }, Ia2 = (e) => {
        var t = A.length;
        e >>>= 0;
        var n = Ra2();
        if (e > n)
          return false;
        for (var a = (m, w) => m + (w - m % w) % w, s = 1; s <= 4; s *= 2) {
          var u = t * (1 + 0.2 / s);
          u = Math.min(u, e + 100663296);
          var d = Math.min(n, a(Math.max(e, u), 65536)), f = ka(d);
          if (f)
            return true;
        }
        return false;
      }, It = {}, Fa2 = () => v || "./this.program", Fe2 = () => {
        if (!Fe2.strings) {
          var e = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", t = {
            USER: "web_user",
            LOGNAME: "web_user",
            PATH: "/",
            PWD: "/",
            HOME: "/home/web_user",
            LANG: e,
            _: Fa2()
          };
          for (var n in It)
            It[n] === void 0 ? delete t[n] : t[n] = It[n];
          var a = [];
          for (var n in t)
            a.push(`${n}=${t[n]}`);
          Fe2.strings = a;
        }
        return Fe2.strings;
      }, Ua = (e, t) => {
        for (var n = 0; n < e.length; ++n)
          R[t++ >> 0] = e.charCodeAt(n);
        R[t >> 0] = 0;
      }, Wa2 = (e, t) => {
        var n = 0;
        return Fe2().forEach((a, s) => {
          var u = t + n;
          D[e + s * 4 >> 2] = u, Ua(a, u), n += a.length + 1;
        }), 0;
      }, La2 = (e, t) => {
        var n = Fe2();
        D[e >> 2] = n.length;
        var a = 0;
        return n.forEach((s) => a += s.length + 1), D[t >> 2] = a, 0;
      }, ja2 = (e) => e, rt = (e) => e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0), Ha2 = (e, t) => {
        for (var n = 0, a = 0; a <= t; n += e[a++])
          ;
        return n;
      }, ur2 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], lr2 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Ba2 = (e, t) => {
        for (var n = new Date(e.getTime()); t > 0; ) {
          var a = rt(n.getFullYear()), s = n.getMonth(), u = (a ? ur2 : lr2)[s];
          if (t > u - n.getDate())
            t -= u - n.getDate() + 1, n.setDate(1), s < 11 ? n.setMonth(s + 1) : (n.setMonth(0), n.setFullYear(n.getFullYear() + 1));
          else
            return n.setDate(n.getDate() + t), n;
        }
        return n;
      };
      function Va2(e, t, n) {
        var a = or2(e) + 1, s = new Array(a);
        return ar2(e, s, 0, s.length), s;
      }
      var qa2 = (e, t) => {
        R.set(e, t);
      }, Na = (e, t, n, a) => {
        var s = D[a + 40 >> 2], u = {
          tm_sec: M[a >> 2],
          tm_min: M[a + 4 >> 2],
          tm_hour: M[a + 8 >> 2],
          tm_mday: M[a + 12 >> 2],
          tm_mon: M[a + 16 >> 2],
          tm_year: M[a + 20 >> 2],
          tm_wday: M[a + 24 >> 2],
          tm_yday: M[a + 28 >> 2],
          tm_isdst: M[a + 32 >> 2],
          tm_gmtoff: M[a + 36 >> 2],
          tm_zone: s ? Rt(s) : ""
        }, d = Rt(n), f = {
          "%c": "%a %b %d %H:%M:%S %Y",
          "%D": "%m/%d/%y",
          "%F": "%Y-%m-%d",
          "%h": "%b",
          "%r": "%I:%M:%S %p",
          "%R": "%H:%M",
          "%T": "%H:%M:%S",
          "%x": "%m/%d/%y",
          "%X": "%H:%M:%S",
          "%Ec": "%c",
          "%EC": "%C",
          "%Ex": "%m/%d/%y",
          "%EX": "%H:%M:%S",
          "%Ey": "%y",
          "%EY": "%Y",
          "%Od": "%d",
          "%Oe": "%e",
          "%OH": "%H",
          "%OI": "%I",
          "%Om": "%m",
          "%OM": "%M",
          "%OS": "%S",
          "%Ou": "%u",
          "%OU": "%U",
          "%OV": "%V",
          "%Ow": "%w",
          "%OW": "%W",
          "%Oy": "%y"
        };
        for (var m in f)
          d = d.replace(new RegExp(m, "g"), f[m]);
        var w = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], _2 = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        function T(y, P, N) {
          for (var G = typeof y == "number" ? y.toString() : y || ""; G.length < P; )
            G = N[0] + G;
          return G;
        }
        function E(y, P) {
          return T(y, P, "0");
        }
        function O(y, P) {
          function N(Se) {
            return Se < 0 ? -1 : Se > 0 ? 1 : 0;
          }
          var G;
          return (G = N(y.getFullYear() - P.getFullYear())) === 0 && (G = N(y.getMonth() - P.getMonth())) === 0 && (G = N(y.getDate() - P.getDate())), G;
        }
        function j(y) {
          switch (y.getDay()) {
            case 0:
              return new Date(y.getFullYear() - 1, 11, 29);
            case 1:
              return y;
            case 2:
              return new Date(y.getFullYear(), 0, 3);
            case 3:
              return new Date(y.getFullYear(), 0, 2);
            case 4:
              return new Date(y.getFullYear(), 0, 1);
            case 5:
              return new Date(y.getFullYear() - 1, 11, 31);
            case 6:
              return new Date(y.getFullYear() - 1, 11, 30);
          }
        }
        function q(y) {
          var P = Ba2(new Date(y.tm_year + 1900, 0, 1), y.tm_yday), N = new Date(P.getFullYear(), 0, 4), G = new Date(P.getFullYear() + 1, 0, 4), Se = j(N), at2 = j(G);
          return O(Se, P) <= 0 ? O(at2, P) <= 0 ? P.getFullYear() + 1 : P.getFullYear() : P.getFullYear() - 1;
        }
        var I = {
          "%a": (y) => w[y.tm_wday].substring(0, 3),
          "%A": (y) => w[y.tm_wday],
          "%b": (y) => _2[y.tm_mon].substring(0, 3),
          "%B": (y) => _2[y.tm_mon],
          "%C": (y) => {
            var P = y.tm_year + 1900;
            return E(P / 100 | 0, 2);
          },
          "%d": (y) => E(y.tm_mday, 2),
          "%e": (y) => T(y.tm_mday, 2, " "),
          "%g": (y) => q(y).toString().substring(2),
          "%G": (y) => q(y),
          "%H": (y) => E(y.tm_hour, 2),
          "%I": (y) => {
            var P = y.tm_hour;
            return P == 0 ? P = 12 : P > 12 && (P -= 12), E(P, 2);
          },
          "%j": (y) => E(y.tm_mday + Ha2(rt(y.tm_year + 1900) ? ur2 : lr2, y.tm_mon - 1), 3),
          "%m": (y) => E(y.tm_mon + 1, 2),
          "%M": (y) => E(y.tm_min, 2),
          "%n": () => `
`,
          "%p": (y) => y.tm_hour >= 0 && y.tm_hour < 12 ? "AM" : "PM",
          "%S": (y) => E(y.tm_sec, 2),
          "%t": () => "	",
          "%u": (y) => y.tm_wday || 7,
          "%U": (y) => {
            var P = y.tm_yday + 7 - y.tm_wday;
            return E(Math.floor(P / 7), 2);
          },
          "%V": (y) => {
            var P = Math.floor((y.tm_yday + 7 - (y.tm_wday + 6) % 7) / 7);
            if ((y.tm_wday + 371 - y.tm_yday - 2) % 7 <= 2 && P++, P) {
              if (P == 53) {
                var N = (y.tm_wday + 371 - y.tm_yday) % 7;
                N != 4 && (N != 3 || !rt(y.tm_year)) && (P = 1);
              }
            } else {
              P = 52;
              var G = (y.tm_wday + 7 - y.tm_yday - 1) % 7;
              (G == 4 || G == 5 && rt(y.tm_year % 400 - 1)) && P++;
            }
            return E(P, 2);
          },
          "%w": (y) => y.tm_wday,
          "%W": (y) => {
            var P = y.tm_yday + 7 - (y.tm_wday + 6) % 7;
            return E(Math.floor(P / 7), 2);
          },
          "%y": (y) => (y.tm_year + 1900).toString().substring(2),
          "%Y": (y) => y.tm_year + 1900,
          "%z": (y) => {
            var P = y.tm_gmtoff, N = P >= 0;
            return P = Math.abs(P) / 60, P = P / 60 * 100 + P % 60, (N ? "+" : "-") + ("0000" + P).slice(-4);
          },
          "%Z": (y) => y.tm_zone,
          "%%": () => "%"
        };
        d = d.replace(/%%/g, "\0\0");
        for (var m in I)
          d.includes(m) && (d = d.replace(new RegExp(m, "g"), I[m](u)));
        d = d.replace(/\0\0/g, "%");
        var J = Va2(d);
        return J.length > t ? 0 : (qa2(J, e), J.length - 1);
      }, za2 = (e, t, n, a, s) => Na(e, t, n, a);
      qt2 = i.InternalError = class extends Error {
        constructor(e) {
          super(e), this.name = "InternalError";
        }
      }, gn2(), _e = i.BindingError = class extends Error {
        constructor(e) {
          super(e), this.name = "BindingError";
        }
      }, Dn(), Tn2(), Wn2(), er2 = i.UnboundTypeError = Bn2(Error, "UnboundTypeError"), Gn2(), Jn();
      var Ga2 = {
        s: sn2,
        u: cn2,
        b: ln,
        g: dn2,
        q: fn2,
        J: hn,
        f: pn2,
        V: mn2,
        d: un2,
        da: vn2,
        Q: yn2,
        _: bn,
        ca: Vn2,
        ba: Nn2,
        w: zn2,
        Y: Qn2,
        x: Zn,
        h: Kn2,
        L: ta,
        M: ra,
        t: aa2,
        o: oa,
        K: ca,
        C: ma,
        A: va2,
        ea: ya2,
        $: ga2,
        R: wa,
        ha: Dt,
        fa: $a,
        Z: Ea2,
        N: Oa2,
        O: Ma,
        aa: Da,
        B: Aa,
        X: xa2,
        W: Ia2,
        T: Wa2,
        U: La2,
        E: uo2,
        D: Za2,
        F: co2,
        n: lo2,
        a: Ya2,
        e: eo2,
        m: Xa2,
        k: ro2,
        H: io2,
        v: ao2,
        G: so2,
        z: ho2,
        P: mo2,
        l: to2,
        j: Ka2,
        c: Qa2,
        p: Ja2,
        I: oo2,
        r: fo2,
        i: no2,
        y: po2,
        ga: ja2,
        S: za2
      }, z = on(), ue = i._free = (e) => (ue = i._free = z.ka)(e), Ft = i._malloc = (e) => (Ft = i._malloc = z.la)(e), dr2 = (e) => (dr2 = z.na)(e), L = (e, t) => (L = z.oa)(e, t), Ue = (e) => (Ue = z.pa)(e), B = () => (B = z.qa)(), V = (e) => (V = z.ra)(e), fr2 = (e) => (fr2 = z.sa)(e), hr2 = (e) => (hr2 = z.ta)(e), pr2 = (e, t, n) => (pr2 = z.ua)(e, t, n), mr2 = (e) => (mr2 = z.va)(e);
      i.dynCall_viijii = (e, t, n, a, s, u, d) => (i.dynCall_viijii = z.wa)(e, t, n, a, s, u, d);
      var vr2 = i.dynCall_jiiii = (e, t, n, a, s) => (vr2 = i.dynCall_jiiii = z.xa)(e, t, n, a, s);
      i.dynCall_iiiiij = (e, t, n, a, s, u, d) => (i.dynCall_iiiiij = z.ya)(e, t, n, a, s, u, d), i.dynCall_iiiiijj = (e, t, n, a, s, u, d, f, m) => (i.dynCall_iiiiijj = z.za)(e, t, n, a, s, u, d, f, m), i.dynCall_iiiiiijj = (e, t, n, a, s, u, d, f, m, w) => (i.dynCall_iiiiiijj = z.Aa)(e, t, n, a, s, u, d, f, m, w);
      function Ya2(e, t) {
        var n = B();
        try {
          return H(e)(t);
        } catch (a) {
          if (V(n), a !== a + 0)
            throw a;
          L(1, 0);
        }
      }
      function Ja2(e, t, n, a) {
        var s = B();
        try {
          H(e)(t, n, a);
        } catch (u) {
          if (V(s), u !== u + 0)
            throw u;
          L(1, 0);
        }
      }
      function Qa2(e, t, n) {
        var a = B();
        try {
          H(e)(t, n);
        } catch (s) {
          if (V(a), s !== s + 0)
            throw s;
          L(1, 0);
        }
      }
      function Xa2(e, t, n, a) {
        var s = B();
        try {
          return H(e)(t, n, a);
        } catch (u) {
          if (V(s), u !== u + 0)
            throw u;
          L(1, 0);
        }
      }
      function Za2(e, t, n, a, s) {
        var u = B();
        try {
          return H(e)(t, n, a, s);
        } catch (d) {
          if (V(u), d !== d + 0)
            throw d;
          L(1, 0);
        }
      }
      function Ka2(e, t) {
        var n = B();
        try {
          H(e)(t);
        } catch (a) {
          if (V(n), a !== a + 0)
            throw a;
          L(1, 0);
        }
      }
      function eo2(e, t, n) {
        var a = B();
        try {
          return H(e)(t, n);
        } catch (s) {
          if (V(a), s !== s + 0)
            throw s;
          L(1, 0);
        }
      }
      function to2(e) {
        var t = B();
        try {
          H(e)();
        } catch (n) {
          if (V(t), n !== n + 0)
            throw n;
          L(1, 0);
        }
      }
      function ro2(e, t, n, a, s) {
        var u = B();
        try {
          return H(e)(t, n, a, s);
        } catch (d) {
          if (V(u), d !== d + 0)
            throw d;
          L(1, 0);
        }
      }
      function no2(e, t, n, a, s, u, d, f, m, w, _2) {
        var T = B();
        try {
          H(e)(t, n, a, s, u, d, f, m, w, _2);
        } catch (E) {
          if (V(T), E !== E + 0)
            throw E;
          L(1, 0);
        }
      }
      function ao2(e, t, n, a, s, u, d) {
        var f = B();
        try {
          return H(e)(t, n, a, s, u, d);
        } catch (m) {
          if (V(f), m !== m + 0)
            throw m;
          L(1, 0);
        }
      }
      function oo2(e, t, n, a, s) {
        var u = B();
        try {
          H(e)(t, n, a, s);
        } catch (d) {
          if (V(u), d !== d + 0)
            throw d;
          L(1, 0);
        }
      }
      function io2(e, t, n, a, s, u) {
        var d = B();
        try {
          return H(e)(t, n, a, s, u);
        } catch (f) {
          if (V(d), f !== f + 0)
            throw f;
          L(1, 0);
        }
      }
      function so2(e, t, n, a, s, u, d, f) {
        var m = B();
        try {
          return H(e)(t, n, a, s, u, d, f);
        } catch (w) {
          if (V(m), w !== w + 0)
            throw w;
          L(1, 0);
        }
      }
      function co2(e, t, n, a) {
        var s = B();
        try {
          return H(e)(t, n, a);
        } catch (u) {
          if (V(s), u !== u + 0)
            throw u;
          L(1, 0);
        }
      }
      function uo2(e, t, n, a) {
        var s = B();
        try {
          return H(e)(t, n, a);
        } catch (u) {
          if (V(s), u !== u + 0)
            throw u;
          L(1, 0);
        }
      }
      function lo2(e) {
        var t = B();
        try {
          return H(e)();
        } catch (n) {
          if (V(t), n !== n + 0)
            throw n;
          L(1, 0);
        }
      }
      function fo2(e, t, n, a, s, u, d, f) {
        var m = B();
        try {
          H(e)(t, n, a, s, u, d, f);
        } catch (w) {
          if (V(m), w !== w + 0)
            throw w;
          L(1, 0);
        }
      }
      function ho2(e, t, n, a, s, u, d, f, m, w, _2, T) {
        var E = B();
        try {
          return H(e)(t, n, a, s, u, d, f, m, w, _2, T);
        } catch (O) {
          if (V(E), O !== O + 0)
            throw O;
          L(1, 0);
        }
      }
      function po2(e, t, n, a, s, u, d, f, m, w, _2, T, E, O, j, q) {
        var I = B();
        try {
          H(e)(t, n, a, s, u, d, f, m, w, _2, T, E, O, j, q);
        } catch (J) {
          if (V(I), J !== J + 0)
            throw J;
          L(1, 0);
        }
      }
      function mo2(e, t, n, a, s) {
        var u = B();
        try {
          return vr2(e, t, n, a, s);
        } catch (d) {
          if (V(u), d !== d + 0)
            throw d;
          L(1, 0);
        }
      }
      var nt;
      ve = function e() {
        nt || yr2(), nt || (ve = e);
      };
      function yr2() {
        if (te > 0 || (He2(), te > 0))
          return;
        function e() {
          nt || (nt = true, i.calledRun = true, !W && (ft(), c(i), i.onRuntimeInitialized && i.onRuntimeInitialized(), ht2()));
        }
        i.setStatus ? (i.setStatus("Running..."), setTimeout(function() {
          setTimeout(function() {
            i.setStatus("");
          }, 1), e();
        }, 1)) : e();
      }
      if (i.preInit)
        for (typeof i.preInit == "function" && (i.preInit = [i.preInit]); i.preInit.length > 0; )
          i.preInit.pop()();
      return yr2(), o.ready;
    };
  })();
  function Yo(r) {
    return Bt(
      dt2,
      r
    );
  }
  async function Jo(r, o) {
    return zo(
      dt2,
      r,
      o
    );
  }
  async function Qo(r, o) {
    return Go(
      dt2,
      r,
      o
    );
  }
  var Le2;
  var je2 = class extends EventTarget {
    constructor(o = {}) {
      var i;
      super(), Co(this, Le2, void 0);
      try {
        const c = (i = o == null ? void 0 : o.formats) == null ? void 0 : i.filter(
          (l) => l !== "unknown"
        );
        if ((c == null ? void 0 : c.length) === 0)
          throw new TypeError("Hint option provided, but is empty.");
        c == null || c.forEach((l) => {
          if (!ct2.has(l))
            throw new TypeError(
              `Failed to read the 'formats' property from 'BarcodeDetectorOptions': The provided value '${l}' is not a valid enum value of type BarcodeFormat.`
            );
        }), $o2(this, Le2, c != null ? c : []), Yo().then((l) => {
          this.dispatchEvent(
            new CustomEvent("load", {
              detail: l
            })
          );
        }).catch((l) => {
          this.dispatchEvent(new CustomEvent("error", { detail: l }));
        });
      } catch (c) {
        throw Cr2(
          c,
          "Failed to construct 'BarcodeDetector'"
        );
      }
    }
    static async getSupportedFormats() {
      return _o.filter((o) => o !== "unknown");
    }
    async detect(o) {
      try {
        const i = await Do2(o);
        if (i === null)
          return [];
        let c;
        try {
          Lr2(i) ? c = await Jo(i, {
            tryHarder: true,
            formats: br2(this, Le2).map((l) => ct2.get(l))
          }) : c = await Qo(i, {
            tryHarder: true,
            formats: br2(this, Le2).map((l) => ct2.get(l))
          });
        } catch (l) {
          throw console.error(l), new DOMException(
            "Barcode detection service unavailable.",
            "NotSupportedError"
          );
        }
        return c.map((l) => {
          const {
            topLeft: { x: h2, y: v },
            topRight: { x: g, y: b },
            bottomLeft: { x: p2, y: C },
            bottomRight: { x: S, y: $2 }
          } = l.position, F = Math.min(h2, g, p2, S), U = Math.min(v, b, C, $2), W = Math.max(h2, g, p2, S), R = Math.max(v, b, C, $2);
          return {
            boundingBox: new DOMRectReadOnly(
              F,
              U,
              W - F,
              R - U
            ),
            rawValue: l.text,
            format: So(l.format),
            cornerPoints: [
              {
                x: h2,
                y: v
              },
              {
                x: g,
                y: b
              },
              {
                x: S,
                y: $2
              },
              {
                x: p2,
                y: C
              }
            ]
          };
        });
      } catch (i) {
        throw Cr2(
          i,
          "Failed to execute 'detect' on 'BarcodeDetector'"
        );
      }
    }
  };
  Le2 = /* @__PURE__ */ new WeakMap();
  var Vt2 = (r, o, i = "error") => {
    let c, l;
    const h2 = new Promise(
      (v, g) => {
        c = v, l = g, r.addEventListener(o, c), r.addEventListener(i, l);
      }
    );
    return h2.finally(() => {
      r.removeEventListener(o, c), r.removeEventListener(i, l);
    }), h2;
  };
  var Sr2 = (r) => new Promise((o) => setTimeout(o, r));
  var Vr2 = class extends Error {
    constructor() {
      super("this browser has no Stream API support"), this.name = "StreamApiNotSupportedError";
    }
  };
  var Zo = class extends Error {
    constructor() {
      super(
        "camera access is only permitted in secure context. Use HTTPS or localhost rather than HTTP."
      ), this.name = "InsecureContextError";
    }
  };
  var Ko = class extends Error {
    constructor() {
      super(
        "Loading camera stream timed out after 6 seconds. If you are on iOS in PWA mode, this is a known issue (see https://github.com/gruhn/vue-qrcode-reader/issues/298)"
      ), this.name = "StreamLoadTimeoutError";
    }
  };
  var ei = (r) => {
    let o = false, i;
    return (...c) => (o || (i = r(c), o = true), i);
  };
  function ae(r, o) {
    if (r === false)
      throw new Error(o != null ? o : "assertion failure");
  }
  function Pr2(r) {
    throw new Error("this code should be unreachable");
  }
  function ti() {
    return navigator.platform.toUpperCase().includes("MAC");
  }
  var qr2;
  async function ri(r) {
    if (window.BarcodeDetector === void 0)
      return console.debug("[vue-qrcode-reader] Native BarcodeDetector not supported. Will use polyfill."), new je2({ formats: r });
    const o = await window.BarcodeDetector.getSupportedFormats(), i = r.filter((c) => !o.includes(c));
    return i.length > 0 ? (console.debug(`[vue-qrcode-reader] Native BarcodeDetector does not support formats ${JSON.stringify(i)}. Will use polyfill.`), new je2({ formats: r })) : ti() && r.includes("pdf417") ? (console.debug("[vue-qrcode-reader] Native BarcodeDetector is buggy for PDF417 codes on MacOS. Will use polyfill."), new je2({ formats: r })) : (console.debug("[vue-qrcode-reader] Will use native BarcodeDetector."), new window.BarcodeDetector({ formats: r }));
  }
  async function Nr2(r) {
    qr2 = await ri(r);
  }
  var ni = async (r, {
    detectHandler: o,
    locateHandler: i,
    minDelay: c,
    formats: l
  }) => {
    console.debug("[vue-qrcode-reader] start scanning"), await Nr2(l);
    const h2 = (v) => async (g) => {
      if (r.readyState === 0)
        console.debug("[vue-qrcode-reader] stop scanning: video element readyState is 0");
      else {
        const { lastScanned: b, contentBefore: p2, lastScanHadContent: C } = v;
        if (g - b < c)
          window.requestAnimationFrame(h2(v));
        else {
          const S = await qr2.detect(r), $2 = S.some((W) => !p2.includes(W.rawValue));
          $2 && o(S);
          const F = S.length > 0;
          F && i(S), !F && C && i(S);
          const U = {
            lastScanned: g,
            lastScanHadContent: F,
            contentBefore: $2 ? S.map((W) => W.rawValue) : p2
          };
          window.requestAnimationFrame(h2(U));
        }
      }
    };
    h2({
      lastScanned: performance.now(),
      contentBefore: [],
      lastScanHadContent: false
    })(performance.now());
  };
  var Gr2 = {};
  var Q = {};
  Object.defineProperty(Q, "__esModule", {
    value: true
  });
  Q.compactObject = Qr2;
  Q.deprecated = pi;
  var ii = Q.detectBrowser = mi;
  Q.disableLog = di;
  Q.disableWarnings = fi;
  Q.extractVersion = ut2;
  Q.filterStats = vi;
  Q.log = hi;
  Q.walkStats = lt;
  Q.wrapPeerConnectionEvent = li;
  function si(r, o, i) {
    return o = ci(o), o in r ? Object.defineProperty(r, o, { value: i, enumerable: true, configurable: true, writable: true }) : r[o] = i, r;
  }
  function ci(r) {
    var o = ui(r, "string");
    return pe(o) === "symbol" ? o : String(o);
  }
  function ui(r, o) {
    if (pe(r) !== "object" || r === null)
      return r;
    var i = r[Symbol.toPrimitive];
    if (i !== void 0) {
      var c = i.call(r, o);
      if (pe(c) !== "object")
        return c;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (o === "string" ? String : Number)(r);
  }
  function pe(r) {
    "@babel/helpers - typeof";
    return pe = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o) {
      return typeof o;
    } : function(o) {
      return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, pe(r);
  }
  var Yr2 = true;
  var Jr2 = true;
  function ut2(r, o, i) {
    var c = r.match(o);
    return c && c.length >= i && parseInt(c[i], 10);
  }
  function li(r, o, i) {
    if (r.RTCPeerConnection) {
      var c = r.RTCPeerConnection.prototype, l = c.addEventListener;
      c.addEventListener = function(v, g) {
        if (v !== o)
          return l.apply(this, arguments);
        var b = function(C) {
          var S = i(C);
          S && (g.handleEvent ? g.handleEvent(S) : g(S));
        };
        return this._eventMap = this._eventMap || {}, this._eventMap[o] || (this._eventMap[o] = /* @__PURE__ */ new Map()), this._eventMap[o].set(g, b), l.apply(this, [v, b]);
      };
      var h2 = c.removeEventListener;
      c.removeEventListener = function(v, g) {
        if (v !== o || !this._eventMap || !this._eventMap[o])
          return h2.apply(this, arguments);
        if (!this._eventMap[o].has(g))
          return h2.apply(this, arguments);
        var b = this._eventMap[o].get(g);
        return this._eventMap[o].delete(g), this._eventMap[o].size === 0 && delete this._eventMap[o], Object.keys(this._eventMap).length === 0 && delete this._eventMap, h2.apply(this, [v, b]);
      }, Object.defineProperty(c, "on" + o, {
        get: function() {
          return this["_on" + o];
        },
        set: function(g) {
          this["_on" + o] && (this.removeEventListener(o, this["_on" + o]), delete this["_on" + o]), g && this.addEventListener(o, this["_on" + o] = g);
        },
        enumerable: true,
        configurable: true
      });
    }
  }
  function di(r) {
    return typeof r != "boolean" ? new Error("Argument type: " + pe(r) + ". Please use a boolean.") : (Yr2 = r, r ? "adapter.js logging disabled" : "adapter.js logging enabled");
  }
  function fi(r) {
    return typeof r != "boolean" ? new Error("Argument type: " + pe(r) + ". Please use a boolean.") : (Jr2 = !r, "adapter.js deprecation warnings " + (r ? "disabled" : "enabled"));
  }
  function hi() {
    if ((typeof window > "u" ? "undefined" : pe(window)) === "object") {
      if (Yr2)
        return;
      typeof console < "u" && typeof console.log == "function" && console.log.apply(console, arguments);
    }
  }
  function pi(r, o) {
    Jr2 && console.warn(r + " is deprecated, please use " + o + " instead.");
  }
  function mi(r) {
    var o = {
      browser: null,
      version: null
    };
    if (typeof r > "u" || !r.navigator || !r.navigator.userAgent)
      return o.browser = "Not a browser.", o;
    var i = r.navigator;
    if (i.mozGetUserMedia)
      o.browser = "firefox", o.version = ut2(i.userAgent, /Firefox\/(\d+)\./, 1);
    else if (i.webkitGetUserMedia || r.isSecureContext === false && r.webkitRTCPeerConnection)
      o.browser = "chrome", o.version = ut2(i.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
    else if (r.RTCPeerConnection && i.userAgent.match(/AppleWebKit\/(\d+)\./))
      o.browser = "safari", o.version = ut2(i.userAgent, /AppleWebKit\/(\d+)\./, 1), o.supportsUnifiedPlan = r.RTCRtpTransceiver && "currentDirection" in r.RTCRtpTransceiver.prototype;
    else
      return o.browser = "Not a supported browser.", o;
    return o;
  }
  function Tr2(r) {
    return Object.prototype.toString.call(r) === "[object Object]";
  }
  function Qr2(r) {
    return Tr2(r) ? Object.keys(r).reduce(function(o, i) {
      var c = Tr2(r[i]), l = c ? Qr2(r[i]) : r[i], h2 = c && !Object.keys(l).length;
      return l === void 0 || h2 ? o : Object.assign(o, si({}, i, l));
    }, {}) : r;
  }
  function lt(r, o, i) {
    !o || i.has(o.id) || (i.set(o.id, o), Object.keys(o).forEach(function(c) {
      c.endsWith("Id") ? lt(r, r.get(o[c]), i) : c.endsWith("Ids") && o[c].forEach(function(l) {
        lt(r, r.get(l), i);
      });
    }));
  }
  function vi(r, o, i) {
    var c = i ? "outbound-rtp" : "inbound-rtp", l = /* @__PURE__ */ new Map();
    if (o === null)
      return l;
    var h2 = [];
    return r.forEach(function(v) {
      v.type === "track" && v.trackIdentifier === o.id && h2.push(v);
    }), h2.forEach(function(v) {
      r.forEach(function(g) {
        g.type === c && g.trackId === v.id && lt(r, g, l);
      });
    }), l;
  }
  Object.defineProperty(Gr2, "__esModule", {
    value: true
  });
  var yi = Gr2.shimGetUserMedia = bi;
  var gi = wi(Q);
  function Xr2(r) {
    if (typeof WeakMap != "function")
      return null;
    var o = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap();
    return (Xr2 = function(l) {
      return l ? i : o;
    })(r);
  }
  function wi(r, o) {
    if (r && r.__esModule)
      return r;
    if (r === null || he(r) !== "object" && typeof r != "function")
      return { default: r };
    var i = Xr2(o);
    if (i && i.has(r))
      return i.get(r);
    var c = {}, l = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var h2 in r)
      if (h2 !== "default" && Object.prototype.hasOwnProperty.call(r, h2)) {
        var v = l ? Object.getOwnPropertyDescriptor(r, h2) : null;
        v && (v.get || v.set) ? Object.defineProperty(c, h2, v) : c[h2] = r[h2];
      }
    return c.default = r, i && i.set(r, c), c;
  }
  function he(r) {
    "@babel/helpers - typeof";
    return he = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o) {
      return typeof o;
    } : function(o) {
      return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, he(r);
  }
  var Er2 = gi.log;
  function bi(r, o) {
    var i = r && r.navigator;
    if (i.mediaDevices) {
      var c = function(p2) {
        if (he(p2) !== "object" || p2.mandatory || p2.optional)
          return p2;
        var C = {};
        return Object.keys(p2).forEach(function(S) {
          if (!(S === "require" || S === "advanced" || S === "mediaSource")) {
            var $2 = he(p2[S]) === "object" ? p2[S] : {
              ideal: p2[S]
            };
            $2.exact !== void 0 && typeof $2.exact == "number" && ($2.min = $2.max = $2.exact);
            var F = function(R, A) {
              return R ? R + A.charAt(0).toUpperCase() + A.slice(1) : A === "deviceId" ? "sourceId" : A;
            };
            if ($2.ideal !== void 0) {
              C.optional = C.optional || [];
              var U = {};
              typeof $2.ideal == "number" ? (U[F("min", S)] = $2.ideal, C.optional.push(U), U = {}, U[F("max", S)] = $2.ideal, C.optional.push(U)) : (U[F("", S)] = $2.ideal, C.optional.push(U));
            }
            $2.exact !== void 0 && typeof $2.exact != "number" ? (C.mandatory = C.mandatory || {}, C.mandatory[F("", S)] = $2.exact) : ["min", "max"].forEach(function(W) {
              $2[W] !== void 0 && (C.mandatory = C.mandatory || {}, C.mandatory[F(W, S)] = $2[W]);
            });
          }
        }), p2.advanced && (C.optional = (C.optional || []).concat(p2.advanced)), C;
      }, l = function(p2, C) {
        if (o.version >= 61)
          return C(p2);
        if (p2 = JSON.parse(JSON.stringify(p2)), p2 && he(p2.audio) === "object") {
          var S = function(R, A, X) {
            A in R && !(X in R) && (R[X] = R[A], delete R[A]);
          };
          p2 = JSON.parse(JSON.stringify(p2)), S(p2.audio, "autoGainControl", "googAutoGainControl"), S(p2.audio, "noiseSuppression", "googNoiseSuppression"), p2.audio = c(p2.audio);
        }
        if (p2 && he(p2.video) === "object") {
          var $2 = p2.video.facingMode;
          $2 = $2 && (he($2) === "object" ? $2 : {
            ideal: $2
          });
          var F = o.version < 66;
          if ($2 && ($2.exact === "user" || $2.exact === "environment" || $2.ideal === "user" || $2.ideal === "environment") && !(i.mediaDevices.getSupportedConstraints && i.mediaDevices.getSupportedConstraints().facingMode && !F)) {
            delete p2.video.facingMode;
            var U;
            if ($2.exact === "environment" || $2.ideal === "environment" ? U = ["back", "rear"] : ($2.exact === "user" || $2.ideal === "user") && (U = ["front"]), U)
              return i.mediaDevices.enumerateDevices().then(function(W) {
                W = W.filter(function(A) {
                  return A.kind === "videoinput";
                });
                var R = W.find(function(A) {
                  return U.some(function(X) {
                    return A.label.toLowerCase().includes(X);
                  });
                });
                return !R && W.length && U.includes("back") && (R = W[W.length - 1]), R && (p2.video.deviceId = $2.exact ? {
                  exact: R.deviceId
                } : {
                  ideal: R.deviceId
                }), p2.video = c(p2.video), Er2("chrome: " + JSON.stringify(p2)), C(p2);
              });
          }
          p2.video = c(p2.video);
        }
        return Er2("chrome: " + JSON.stringify(p2)), C(p2);
      }, h2 = function(p2) {
        return o.version >= 64 ? p2 : {
          name: {
            PermissionDeniedError: "NotAllowedError",
            PermissionDismissedError: "NotAllowedError",
            InvalidStateError: "NotAllowedError",
            DevicesNotFoundError: "NotFoundError",
            ConstraintNotSatisfiedError: "OverconstrainedError",
            TrackStartError: "NotReadableError",
            MediaDeviceFailedDueToShutdown: "NotAllowedError",
            MediaDeviceKillSwitchOn: "NotAllowedError",
            TabCaptureError: "AbortError",
            ScreenCaptureError: "AbortError",
            DeviceCaptureError: "AbortError"
          }[p2.name] || p2.name,
          message: p2.message,
          constraint: p2.constraint || p2.constraintName,
          toString: function() {
            return this.name + (this.message && ": ") + this.message;
          }
        };
      }, v = function(p2, C, S) {
        l(p2, function($2) {
          i.webkitGetUserMedia($2, C, function(F) {
            S && S(h2(F));
          });
        });
      };
      if (i.getUserMedia = v.bind(i), i.mediaDevices.getUserMedia) {
        var g = i.mediaDevices.getUserMedia.bind(i.mediaDevices);
        i.mediaDevices.getUserMedia = function(b) {
          return l(b, function(p2) {
            return g(p2).then(function(C) {
              if (p2.audio && !C.getAudioTracks().length || p2.video && !C.getVideoTracks().length)
                throw C.getTracks().forEach(function(S) {
                  S.stop();
                }), new DOMException("", "NotFoundError");
              return C;
            }, function(C) {
              return Promise.reject(h2(C));
            });
          });
        };
      }
    }
  }
  var Zr2 = {};
  Object.defineProperty(Zr2, "__esModule", {
    value: true
  });
  var Ci = Zr2.shimGetUserMedia = Si;
  var $i = _i(Q);
  function Kr2(r) {
    if (typeof WeakMap != "function")
      return null;
    var o = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap();
    return (Kr2 = function(l) {
      return l ? i : o;
    })(r);
  }
  function _i(r, o) {
    if (r && r.__esModule)
      return r;
    if (r === null || Pe(r) !== "object" && typeof r != "function")
      return { default: r };
    var i = Kr2(o);
    if (i && i.has(r))
      return i.get(r);
    var c = {}, l = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var h2 in r)
      if (h2 !== "default" && Object.prototype.hasOwnProperty.call(r, h2)) {
        var v = l ? Object.getOwnPropertyDescriptor(r, h2) : null;
        v && (v.get || v.set) ? Object.defineProperty(c, h2, v) : c[h2] = r[h2];
      }
    return c.default = r, i && i.set(r, c), c;
  }
  function Pe(r) {
    "@babel/helpers - typeof";
    return Pe = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o) {
      return typeof o;
    } : function(o) {
      return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, Pe(r);
  }
  function Si(r, o) {
    var i = r && r.navigator, c = r && r.MediaStreamTrack;
    if (i.getUserMedia = function(b, p2, C) {
      $i.deprecated("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), i.mediaDevices.getUserMedia(b).then(p2, C);
    }, !(o.version > 55 && "autoGainControl" in i.mediaDevices.getSupportedConstraints())) {
      var l = function(p2, C, S) {
        C in p2 && !(S in p2) && (p2[S] = p2[C], delete p2[C]);
      }, h2 = i.mediaDevices.getUserMedia.bind(i.mediaDevices);
      if (i.mediaDevices.getUserMedia = function(b) {
        return Pe(b) === "object" && Pe(b.audio) === "object" && (b = JSON.parse(JSON.stringify(b)), l(b.audio, "autoGainControl", "mozAutoGainControl"), l(b.audio, "noiseSuppression", "mozNoiseSuppression")), h2(b);
      }, c && c.prototype.getSettings) {
        var v = c.prototype.getSettings;
        c.prototype.getSettings = function() {
          var b = v.apply(this, arguments);
          return l(b, "mozAutoGainControl", "autoGainControl"), l(b, "mozNoiseSuppression", "noiseSuppression"), b;
        };
      }
      if (c && c.prototype.applyConstraints) {
        var g = c.prototype.applyConstraints;
        c.prototype.applyConstraints = function(b) {
          return this.kind === "audio" && Pe(b) === "object" && (b = JSON.parse(JSON.stringify(b)), l(b, "autoGainControl", "mozAutoGainControl"), l(b, "noiseSuppression", "mozNoiseSuppression")), g.apply(this, [b]);
        };
      }
    }
  }
  var oe = {};
  Object.defineProperty(oe, "__esModule", {
    value: true
  });
  oe.shimAudioContext = ki;
  oe.shimCallbacksAPI = Mi;
  oe.shimConstraints = rn;
  oe.shimCreateOfferLegacy = Ri;
  var Pi = oe.shimGetUserMedia = Di;
  oe.shimLocalStreamsAPI = Ei;
  oe.shimRTCIceServerUrls = Ai;
  oe.shimRemoteStreamsAPI = Oi;
  oe.shimTrackEventTransceiver = xi;
  var en2 = Ti(Q);
  function tn(r) {
    if (typeof WeakMap != "function")
      return null;
    var o = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap();
    return (tn = function(l) {
      return l ? i : o;
    })(r);
  }
  function Ti(r, o) {
    if (r && r.__esModule)
      return r;
    if (r === null || me(r) !== "object" && typeof r != "function")
      return { default: r };
    var i = tn(o);
    if (i && i.has(r))
      return i.get(r);
    var c = {}, l = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var h2 in r)
      if (h2 !== "default" && Object.prototype.hasOwnProperty.call(r, h2)) {
        var v = l ? Object.getOwnPropertyDescriptor(r, h2) : null;
        v && (v.get || v.set) ? Object.defineProperty(c, h2, v) : c[h2] = r[h2];
      }
    return c.default = r, i && i.set(r, c), c;
  }
  function me(r) {
    "@babel/helpers - typeof";
    return me = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o) {
      return typeof o;
    } : function(o) {
      return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, me(r);
  }
  function Ei(r) {
    if (!(me(r) !== "object" || !r.RTCPeerConnection)) {
      if ("getLocalStreams" in r.RTCPeerConnection.prototype || (r.RTCPeerConnection.prototype.getLocalStreams = function() {
        return this._localStreams || (this._localStreams = []), this._localStreams;
      }), !("addStream" in r.RTCPeerConnection.prototype)) {
        var o = r.RTCPeerConnection.prototype.addTrack;
        r.RTCPeerConnection.prototype.addStream = function(c) {
          var l = this;
          this._localStreams || (this._localStreams = []), this._localStreams.includes(c) || this._localStreams.push(c), c.getAudioTracks().forEach(function(h2) {
            return o.call(l, h2, c);
          }), c.getVideoTracks().forEach(function(h2) {
            return o.call(l, h2, c);
          });
        }, r.RTCPeerConnection.prototype.addTrack = function(c) {
          for (var l = this, h2 = arguments.length, v = new Array(h2 > 1 ? h2 - 1 : 0), g = 1; g < h2; g++)
            v[g - 1] = arguments[g];
          return v && v.forEach(function(b) {
            l._localStreams ? l._localStreams.includes(b) || l._localStreams.push(b) : l._localStreams = [b];
          }), o.apply(this, arguments);
        };
      }
      "removeStream" in r.RTCPeerConnection.prototype || (r.RTCPeerConnection.prototype.removeStream = function(c) {
        var l = this;
        this._localStreams || (this._localStreams = []);
        var h2 = this._localStreams.indexOf(c);
        if (h2 !== -1) {
          this._localStreams.splice(h2, 1);
          var v = c.getTracks();
          this.getSenders().forEach(function(g) {
            v.includes(g.track) && l.removeTrack(g);
          });
        }
      });
    }
  }
  function Oi(r) {
    if (!(me(r) !== "object" || !r.RTCPeerConnection) && ("getRemoteStreams" in r.RTCPeerConnection.prototype || (r.RTCPeerConnection.prototype.getRemoteStreams = function() {
      return this._remoteStreams ? this._remoteStreams : [];
    }), !("onaddstream" in r.RTCPeerConnection.prototype))) {
      Object.defineProperty(r.RTCPeerConnection.prototype, "onaddstream", {
        get: function() {
          return this._onaddstream;
        },
        set: function(c) {
          var l = this;
          this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = c), this.addEventListener("track", this._onaddstreampoly = function(h2) {
            h2.streams.forEach(function(v) {
              if (l._remoteStreams || (l._remoteStreams = []), !l._remoteStreams.includes(v)) {
                l._remoteStreams.push(v);
                var g = new Event("addstream");
                g.stream = v, l.dispatchEvent(g);
              }
            });
          });
        }
      });
      var o = r.RTCPeerConnection.prototype.setRemoteDescription;
      r.RTCPeerConnection.prototype.setRemoteDescription = function() {
        var c = this;
        return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(l) {
          l.streams.forEach(function(h2) {
            if (c._remoteStreams || (c._remoteStreams = []), !(c._remoteStreams.indexOf(h2) >= 0)) {
              c._remoteStreams.push(h2);
              var v = new Event("addstream");
              v.stream = h2, c.dispatchEvent(v);
            }
          });
        }), o.apply(c, arguments);
      };
    }
  }
  function Mi(r) {
    if (!(me(r) !== "object" || !r.RTCPeerConnection)) {
      var o = r.RTCPeerConnection.prototype, i = o.createOffer, c = o.createAnswer, l = o.setLocalDescription, h2 = o.setRemoteDescription, v = o.addIceCandidate;
      o.createOffer = function(p2, C) {
        var S = arguments.length >= 2 ? arguments[2] : arguments[0], $2 = i.apply(this, [S]);
        return C ? ($2.then(p2, C), Promise.resolve()) : $2;
      }, o.createAnswer = function(p2, C) {
        var S = arguments.length >= 2 ? arguments[2] : arguments[0], $2 = c.apply(this, [S]);
        return C ? ($2.then(p2, C), Promise.resolve()) : $2;
      };
      var g = function(p2, C, S) {
        var $2 = l.apply(this, [p2]);
        return S ? ($2.then(C, S), Promise.resolve()) : $2;
      };
      o.setLocalDescription = g, g = function(p2, C, S) {
        var $2 = h2.apply(this, [p2]);
        return S ? ($2.then(C, S), Promise.resolve()) : $2;
      }, o.setRemoteDescription = g, g = function(p2, C, S) {
        var $2 = v.apply(this, [p2]);
        return S ? ($2.then(C, S), Promise.resolve()) : $2;
      }, o.addIceCandidate = g;
    }
  }
  function Di(r) {
    var o = r && r.navigator;
    if (o.mediaDevices && o.mediaDevices.getUserMedia) {
      var i = o.mediaDevices, c = i.getUserMedia.bind(i);
      o.mediaDevices.getUserMedia = function(l) {
        return c(rn(l));
      };
    }
    !o.getUserMedia && o.mediaDevices && o.mediaDevices.getUserMedia && (o.getUserMedia = function(h2, v, g) {
      o.mediaDevices.getUserMedia(h2).then(v, g);
    }.bind(o));
  }
  function rn(r) {
    return r && r.video !== void 0 ? Object.assign({}, r, {
      video: en2.compactObject(r.video)
    }) : r;
  }
  function Ai(r) {
    if (r.RTCPeerConnection) {
      var o = r.RTCPeerConnection;
      r.RTCPeerConnection = function(c, l) {
        if (c && c.iceServers) {
          for (var h2 = [], v = 0; v < c.iceServers.length; v++) {
            var g = c.iceServers[v];
            g.urls === void 0 && g.url ? (en2.deprecated("RTCIceServer.url", "RTCIceServer.urls"), g = JSON.parse(JSON.stringify(g)), g.urls = g.url, delete g.url, h2.push(g)) : h2.push(c.iceServers[v]);
          }
          c.iceServers = h2;
        }
        return new o(c, l);
      }, r.RTCPeerConnection.prototype = o.prototype, "generateCertificate" in o && Object.defineProperty(r.RTCPeerConnection, "generateCertificate", {
        get: function() {
          return o.generateCertificate;
        }
      });
    }
  }
  function xi(r) {
    me(r) === "object" && r.RTCTrackEvent && "receiver" in r.RTCTrackEvent.prototype && !("transceiver" in r.RTCTrackEvent.prototype) && Object.defineProperty(r.RTCTrackEvent.prototype, "transceiver", {
      get: function() {
        return {
          receiver: this.receiver
        };
      }
    });
  }
  function Ri(r) {
    var o = r.RTCPeerConnection.prototype.createOffer;
    r.RTCPeerConnection.prototype.createOffer = function(c) {
      if (c) {
        typeof c.offerToReceiveAudio < "u" && (c.offerToReceiveAudio = !!c.offerToReceiveAudio);
        var l = this.getTransceivers().find(function(v) {
          return v.receiver.track.kind === "audio";
        });
        c.offerToReceiveAudio === false && l ? l.direction === "sendrecv" ? l.setDirection ? l.setDirection("sendonly") : l.direction = "sendonly" : l.direction === "recvonly" && (l.setDirection ? l.setDirection("inactive") : l.direction = "inactive") : c.offerToReceiveAudio === true && !l && this.addTransceiver("audio", {
          direction: "recvonly"
        }), typeof c.offerToReceiveVideo < "u" && (c.offerToReceiveVideo = !!c.offerToReceiveVideo);
        var h2 = this.getTransceivers().find(function(v) {
          return v.receiver.track.kind === "video";
        });
        c.offerToReceiveVideo === false && h2 ? h2.direction === "sendrecv" ? h2.setDirection ? h2.setDirection("sendonly") : h2.direction = "sendonly" : h2.direction === "recvonly" && (h2.setDirection ? h2.setDirection("inactive") : h2.direction = "inactive") : c.offerToReceiveVideo === true && !h2 && this.addTransceiver("video", {
          direction: "recvonly"
        });
      }
      return o.apply(this, arguments);
    };
  }
  function ki(r) {
    me(r) !== "object" || r.AudioContext || (r.AudioContext = r.webkitAudioContext);
  }
  var Ii = ei(() => {
    const r = ii(window);
    switch (r.browser) {
      case "chrome":
        yi(window, r);
        break;
      case "firefox":
        Ci(window, r);
        break;
      case "safari":
        Pi(window, r);
        break;
      default:
        throw new Vr2();
    }
  });
  var Te2 = Promise.resolve({ type: "stop", data: {} });
  async function Or2(r, o, i) {
    var g, b, p2;
    if (console.debug(
      "[vue-qrcode-reader] starting camera with constraints: ",
      JSON.stringify(o)
    ), window.isSecureContext !== true)
      throw new Zo();
    if (((g = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : g.getUserMedia) === void 0)
      throw new Vr2();
    Ii(), console.debug("[vue-qrcode-reader] calling getUserMedia");
    const c = await navigator.mediaDevices.getUserMedia({
      audio: false,
      video: o
    });
    r.srcObject !== void 0 ? r.srcObject = c : r.mozSrcObject !== void 0 ? r.mozSrcObject = c : window.URL.createObjectURL ? r.src = window.URL.createObjectURL(c) : window.webkitURL ? r.src = window.webkitURL.createObjectURL(c) : r.src = c.id, r.play(), console.debug("[vue-qrcode-reader] waiting for video element to load"), await Promise.race([
      Vt2(r, "loadeddata"),
      Sr2(6e3).then(() => {
        throw new Ko();
      })
    ]), console.debug("[vue-qrcode-reader] video element loaded"), await Sr2(500);
    const [l] = c.getVideoTracks(), h2 = (p2 = (b = l == null ? void 0 : l.getCapabilities) == null ? void 0 : b.call(l)) != null ? p2 : {};
    let v = false;
    return i && h2.torch && (await l.applyConstraints({ advanced: [{ torch: true }] }), v = true), console.debug("[vue-qrcode-reader] camera ready"), {
      type: "start",
      data: {
        videoEl: r,
        stream: c,
        capabilities: h2,
        constraints: o,
        isTorchOn: v
      }
    };
  }
  async function Fi(r, {
    constraints: o,
    torch: i,
    restart: c = false
  }) {
    Te2 = Te2.then((h2) => {
      if (h2.type === "start") {
        const {
          data: {
            videoEl: v,
            stream: g,
            constraints: b,
            isTorchOn: p2
          }
        } = h2;
        return !c && r === v && o === b && i === p2 ? h2 : nn(v, g, p2).then(
          () => Or2(r, o, i)
        );
      } else if (h2.type === "stop" || h2.type === "failed")
        return Or2(r, o, i);
      Pr2();
    }).catch((h2) => (console.debug(`[vue-qrcode-reader] starting camera failed with "${h2}"`), { type: "failed", error: h2 }));
    const l = await Te2;
    if (l.type === "stop")
      throw new Error("Something went wrong with the camera task queue (start task).");
    if (l.type === "failed")
      throw l.error;
    if (l.type === "start")
      return l.data.capabilities;
    Pr2();
  }
  async function nn(r, o, i) {
    console.debug("[vue-qrcode-reader] stopping camera"), r.src = "", r.srcObject = null, r.load(), await Vt2(r, "error");
    for (const c of o.getTracks())
      i != null || await c.applyConstraints({ advanced: [{ torch: false }] }), o.removeTrack(c), c.stop();
    return {
      type: "stop",
      data: {}
    };
  }
  async function st() {
    if (Te2 = Te2.then((o) => {
      if (o.type === "stop" || o.type === "failed")
        return o;
      const {
        data: { videoEl: i, stream: c, isTorchOn: l }
      } = o;
      return nn(i, c, l);
    }), (await Te2).type === "start")
      throw new Error("Something went wrong with the camera task queue (stop task).");
  }
  var Ui = /* @__PURE__ */ defineComponent({
    __name: "QrcodeStream",
    props: {
      constraints: { default: () => ({ facingMode: "environment" }) },
      formats: { default: () => ["qr_code"] },
      paused: { type: Boolean, default: false },
      torch: { type: Boolean, default: false },
      track: { type: Function, default: void 0 }
    },
    emits: ["detect", "camera-on", "camera-off", "error"],
    setup(r, { emit: o }) {
      const i = r, c = o, l = ref(i.constraints), h2 = ref(i.formats);
      watch2(
        () => i.constraints,
        (k, M) => {
          JSON.stringify(k) !== JSON.stringify(M) && (l.value = k);
        },
        { deep: true }
      ), watch2(
        () => i.formats,
        (k, M) => {
          JSON.stringify(k) !== JSON.stringify(M) && (h2.value = k);
        },
        { deep: true }
      );
      const v = ref(), g = ref(), b = ref(), p2 = ref(false), C = ref(false);
      onMounted(() => {
        C.value = true;
      }), onUnmounted(() => {
        st();
      });
      const S = computed2(() => ({
        torch: i.torch,
        constraints: l.value,
        shouldStream: C.value && !i.paused
      }));
      watch2(
        S,
        async (k) => {
          const M = b.value;
          ae(
            M !== void 0,
            "cameraSettings watcher should never be triggered when component is not mounted. Thus video element should always be defined."
          );
          const D = v.value;
          ae(
            D !== void 0,
            "cameraSettings watcher should never be triggered when component is not mounted. Thus canvas should always be defined."
          );
          const le = D.getContext("2d");
          if (ae(le !== null, "if cavnas is defined, canvas 2d context should also be non-null"), k.shouldStream) {
            st(), p2.value = false;
            try {
              const ie = await Fi(M, k);
              C.value ? (p2.value = true, c("camera-on", ie)) : await st();
            } catch (ie) {
              c("error", ie);
            }
          } else
            D.width = M.videoWidth, D.height = M.videoHeight, le.drawImage(M, 0, 0, M.videoWidth, M.videoHeight), st(), p2.value = false, c("camera-off");
        },
        { deep: true }
      ), watch2(h2, async (k) => {
        C.value && await Nr2(k);
      });
      const $2 = computed2(() => S.value.shouldStream && p2.value);
      watch2($2, (k) => {
        if (k) {
          ae(
            v.value !== void 0,
            "shouldScan watcher should only be triggered when component is mounted. Thus pause frame canvas is defined"
          ), F(v.value), ae(
            g.value !== void 0,
            "shouldScan watcher should only be triggered when component is mounted. Thus tracking canvas is defined"
          ), F(g.value);
          const M = () => i.track === void 0 ? 500 : 40;
          ae(
            b.value !== void 0,
            "shouldScan watcher should only be triggered when component is mounted. Thus video element is defined"
          ), ni(b.value, {
            detectHandler: (D) => c("detect", D),
            formats: h2.value,
            locateHandler: U,
            minDelay: M()
          });
        }
      });
      const F = (k) => {
        const M = k.getContext("2d");
        ae(M !== null, "canvas 2d context should always be non-null"), M.clearRect(0, 0, k.width, k.height);
      }, U = (k) => {
        const M = g.value;
        ae(
          M !== void 0,
          "onLocate handler should only be called when component is mounted. Thus tracking canvas is always defined."
        );
        const D = b.value;
        if (ae(
          D !== void 0,
          "onLocate handler should only be called when component is mounted. Thus video element is always defined."
        ), k.length === 0 || i.track === void 0)
          F(M);
        else {
          const le = D.offsetWidth, ie = D.offsetHeight, be = D.videoWidth, Ce2 = D.videoHeight, Oe2 = Math.max(le / be, ie / Ce2), Me = be * Oe2, He2 = Ce2 * Oe2, ft = Me / be, ht2 = He2 / Ce2, pt = (le - Me) / 2, mt = (ie - He2) / 2, De = ({ x: de, y: Z }) => ({
            x: Math.floor(de * ft),
            y: Math.floor(Z * ht2)
          }), te = ({ x: de, y: Z }) => ({
            x: Math.floor(de + pt),
            y: Math.floor(Z + mt)
          }), ve = k.map((de) => {
            const { boundingBox: Z, cornerPoints: vt } = de, { x: Ve, y: fe } = te(
              De({
                x: Z.x,
                y: Z.y
              })
            ), { x: qe2, y: yt } = De({
              x: Z.width,
              y: Z.height
            });
            return __spreadProps(__spreadValues({}, de), {
              cornerPoints: vt.map((Ne2) => te(De(Ne2))),
              boundingBox: DOMRectReadOnly.fromRect({ x: Ve, y: fe, width: qe2, height: yt })
            });
          });
          M.width = D.offsetWidth, M.height = D.offsetHeight;
          const Be = M.getContext("2d");
          ae(Be !== null, "canvas 2d context should always be non-null"), i.track(ve, Be);
        }
      }, W = {
        width: "100%",
        height: "100%",
        position: "relative",
        "z-index": "0"
      }, R = {
        width: "100%",
        height: "100%",
        position: "absolute",
        top: "0",
        left: "0"
      }, A = {
        width: "100%",
        height: "100%",
        "object-fit": "cover"
      }, X = computed2(() => $2.value ? A : __spreadProps(__spreadValues({}, A), {
        visibility: "hidden",
        position: "absolute"
      }));
      return (k, M) => (openBlock(), createElementBlock("div", { style: W }, [
        createBaseVNode("video", {
          ref_key: "videoRef",
          ref: b,
          style: normalizeStyle(X.value),
          autoplay: "",
          muted: "",
          playsinline: ""
        }, null, 4),
        withDirectives(createBaseVNode("canvas", {
          id: "qrcode-stream-pause-frame",
          ref_key: "pauseFrameRef",
          ref: v,
          style: A
        }, null, 512), [
          [vShow, !$2.value]
        ]),
        createBaseVNode("canvas", {
          id: "qrcode-stream-tracking-layer",
          ref_key: "trackingLayerRef",
          ref: g,
          style: R
        }, null, 512),
        createBaseVNode("div", { style: R }, [
          renderSlot(k.$slots, "default")
        ])
      ]));
    }
  });

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/CameraScanner.vue?type=script
  var CameraScanner_default = {
    name: "CameraScanner",
    components: {
      QrcodeStream: Ui
    },
    props: {
      scanType: {
        type: String,
        default: "Both"
      }
    },
    data() {
      return {
        scannerDialog: false,
        scanResult: "",
        scanFormat: "",
        errorMessage: "",
        cameraPermissionDenied: false,
        isScanning: false,
        torchActive: false,
        selectedDeviceId: null,
        cameras: []
      };
    },
    computed: {
      readerFormats() {
        const availableFormats = [
          "qr_code",
          "ean_13",
          "ean_8",
          "code_128",
          "code_39",
          "code_93",
          "codabar",
          "upc_a",
          "upc_e",
          "itf"
        ];
        if (this.scanType === "QR Code") {
          return ["qr_code"];
        }
        if (this.scanType === "Barcode") {
          return availableFormats.filter((f) => f !== "qr_code");
        }
        return availableFormats;
      }
    },
    methods: {
      async startScanning() {
        this.scannerDialog = true;
        this.errorMessage = "";
        this.scanResult = "";
        this.scanFormat = "";
        this.cameraPermissionDenied = false;
        this.isScanning = true;
        await this.$nextTick();
        await this.listCameras();
      },
      async listCameras() {
        try {
          if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
            console.warn("MediaDevices API not supported.");
            this.cameras = [];
            return;
          }
          const devices = await navigator.mediaDevices.enumerateDevices();
          this.cameras = devices.filter((device) => device.kind === "videoinput");
          if (this.cameras.length > 0 && !this.selectedDeviceId) {
            const rearCamera = this.cameras.find((camera) => /back|rear|environment/i.test(camera.label));
            this.selectedDeviceId = rearCamera ? rearCamera.deviceId : this.cameras[0].deviceId;
          }
        } catch (error) {
          console.error("Error listing cameras:", error);
          this.cameras = [];
        }
      },
      onDetect(detectedCodes) {
        if (detectedCodes && detectedCodes.length > 0) {
          const firstResult = detectedCodes[0];
          this.scanResult = firstResult.rawValue;
          this.scanFormat = firstResult.format;
          this.errorMessage = "";
          this.$emit("barcode-scanned", this.scanResult);
          if (typeof frappe !== "undefined" && frappe.show_alert) {
            frappe.show_alert({
              message: this.__("Code scanned successfully") + ` (${this.scanFormat})`,
              indicator: "green"
            }, 3);
          }
          this.isScanning = false;
          setTimeout(() => {
            this.scanResult = "";
            this.scanFormat = "";
            this.isScanning = true;
          }, 1e3);
        }
      },
      onError(error) {
        this.errorMessage = error.name || "Unknown error";
        if (error.name === "NotAllowedError") {
          this.cameraPermissionDenied = true;
          this.errorMessage = this.__("Camera permission denied. Please allow camera access in your browser settings.");
        } else if (error.name === "NotFoundError" || error.name === "DevicesNotFoundError") {
          this.errorMessage = this.__("No camera found on this device.");
        } else if (error.name === "NotSupportedError") {
          this.errorMessage = this.__("Secure context (HTTPS) required for camera access.");
        } else if (error.name === "AbortError") {
          this.errorMessage = this.__("Camera access aborted.");
        } else {
          this.errorMessage = this.__("Error accessing camera:") + ` ${error.message}`;
        }
        console.error("Camera error:", error);
        this.isScanning = false;
      },
      stopScanning() {
        this.isScanning = false;
        this.scannerDialog = false;
        this.scanResult = "";
        this.scanFormat = "";
        this.errorMessage = "";
        this.torchActive = false;
        this.$emit("scanner-closed");
      },
      async toggleTorch() {
        this.torchActive = !this.torchActive;
      },
      async switchCamera() {
        if (this.cameras.length > 1) {
          const currentIndex = this.cameras.findIndex((cam) => cam.deviceId === this.selectedDeviceId);
          const nextIndex = (currentIndex + 1) % this.cameras.length;
          this.selectedDeviceId = this.cameras[nextIndex].deviceId;
          this.isScanning = false;
          await this.$nextTick();
          this.isScanning = true;
          if (typeof frappe !== "undefined" && frappe.show_alert) {
            frappe.show_alert({
              message: this.__("Switched to: ") + (this.cameras[nextIndex].label || `Camera ${nextIndex + 1}`),
              indicator: "blue"
            }, 2);
          }
        }
      },
      handleEscKey(event2) {
        if (event2.key === "Escape" && this.scannerDialog) {
          event2.preventDefault();
          this.stopScanning();
        }
      }
    },
    watch: {
      scannerDialog(newVal) {
        if (newVal) {
          if (!this.selectedDeviceId && this.cameras.length === 0) {
            this.listCameras();
          }
        } else {
          this.isScanning = false;
          this.torchActive = false;
        }
      }
    },
    mounted() {
      if (typeof document !== "undefined") {
        document.addEventListener("keydown", this.handleEscKey);
      }
    },
    beforeUnmount() {
      if (typeof document !== "undefined") {
        document.removeEventListener("keydown", this.handleEscKey);
      }
      this.stopScanning();
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/CameraScanner.vue?type=template
  var _withScopeId2 = (n) => (pushScopeId("data-v-5eb7f7b8"), n = n(), popScopeId(), n);
  var _hoisted_115 = { key: 0 };
  var _hoisted_28 = {
    key: 0,
    class: "scanner-container"
  };
  var _hoisted_38 = {
    key: 0,
    class: "scanning-overlay"
  };
  var _hoisted_45 = /* @__PURE__ */ _withScopeId2(() => /* @__PURE__ */ createBaseVNode("div", { class: "scan-line" }, null, -1));
  var _hoisted_55 = /* @__PURE__ */ _withScopeId2(() => /* @__PURE__ */ createBaseVNode("div", { class: "scan-corners" }, [
    /* @__PURE__ */ createBaseVNode("div", { class: "corner top-left" }),
    /* @__PURE__ */ createBaseVNode("div", { class: "corner top-right" }),
    /* @__PURE__ */ createBaseVNode("div", { class: "corner bottom-left" }),
    /* @__PURE__ */ createBaseVNode("div", { class: "corner bottom-right" })
  ], -1));
  var _hoisted_65 = [
    _hoisted_45,
    _hoisted_55
  ];
  var _hoisted_74 = { class: "status-messages pa-3" };
  var _hoisted_84 = /* @__PURE__ */ _withScopeId2(() => /* @__PURE__ */ createBaseVNode("br", null, null, -1));
  var _hoisted_94 = /* @__PURE__ */ _withScopeId2(() => /* @__PURE__ */ createBaseVNode("br", null, null, -1));
  var _hoisted_104 = { class: "pa-4 text-center" };
  var _hoisted_116 = { class: "mt-2" };
  var _hoisted_125 = { class: "mt-2" };
  var _hoisted_135 = { class: "d-flex gap-2" };
  function render10(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_icon = resolveComponent("v-icon");
    const _component_v_chip = resolveComponent("v-chip");
    const _component_v_spacer = resolveComponent("v-spacer");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_card_title = resolveComponent("v-card-title");
    const _component_qrcode_stream = resolveComponent("qrcode-stream");
    const _component_v_alert = resolveComponent("v-alert");
    const _component_v_card_text = resolveComponent("v-card-text");
    const _component_v_card_actions = resolveComponent("v-card-actions");
    const _component_v_card = resolveComponent("v-card");
    const _component_v_dialog = resolveComponent("v-dialog");
    return openBlock(), createBlock(_component_v_dialog, {
      modelValue: $data.scannerDialog,
      "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.scannerDialog = $event),
      "max-width": "600px",
      persistent: "false"
    }, {
      default: withCtx(() => [
        createVNode(_component_v_card, null, {
          default: withCtx(() => [
            createVNode(_component_v_card_title, { class: "text-h5 text-primary d-flex align-center" }, {
              default: withCtx(() => [
                createVNode(_component_v_icon, {
                  class: "mr-2",
                  size: "large"
                }, {
                  default: withCtx(() => [
                    createTextVNode("mdi-camera")
                  ]),
                  _: 1
                }),
                createTextVNode(" " + toDisplayString(_ctx.__("Scan QR Code/Barcode")) + " ", 1),
                createVNode(_component_v_chip, {
                  class: "ml-2",
                  size: "small",
                  color: "primary"
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString($props.scanType === "Both" ? "Auto Detect" : $props.scanType), 1)
                  ]),
                  _: 1
                }),
                createVNode(_component_v_spacer),
                createVNode(_component_v_btn, {
                  icon: "mdi-close",
                  onClick: withModifiers($options.stopScanning, ["stop"]),
                  color: "error",
                  variant: "text",
                  size: "large",
                  title: _ctx.__("Close Scanner")
                }, null, 8, ["onClick", "title"])
              ]),
              _: 1
            }),
            createVNode(_component_v_card_text, { class: "pa-0" }, {
              default: withCtx(() => [
                !$data.cameraPermissionDenied ? (openBlock(), createElementBlock("div", _hoisted_115, [
                  createCommentVNode(" Scanner container "),
                  $data.isScanning && $data.scannerDialog ? (openBlock(), createElementBlock("div", _hoisted_28, [
                    createVNode(_component_qrcode_stream, {
                      formats: $options.readerFormats,
                      torch: $data.torchActive,
                      camera: $data.selectedDeviceId ? { deviceId: $data.selectedDeviceId, exact: $data.selectedDeviceId } : "auto",
                      onDetect: $options.onDetect,
                      onError: $options.onError,
                      onCameraOn: _cache[0] || (_cache[0] = ($event) => $data.isScanning = true),
                      onCameraOff: _cache[1] || (_cache[1] = ($event) => $data.isScanning = false),
                      style: { "width": "100%", "height": "350px", "object-fit": "cover" }
                    }, {
                      default: withCtx(() => [
                        createCommentVNode(" Optional: You can put a loading indicator or overlay here "),
                        !$data.scanResult ? (openBlock(), createElementBlock("div", _hoisted_38, [..._hoisted_65])) : createCommentVNode("v-if", true)
                      ]),
                      _: 1
                    }, 8, ["formats", "torch", "camera", "onDetect", "onError"])
                  ])) : createCommentVNode("v-if", true),
                  createCommentVNode(" Status messages "),
                  createBaseVNode("div", _hoisted_74, [
                    $data.errorMessage ? (openBlock(), createBlock(_component_v_alert, {
                      key: 0,
                      type: "error",
                      variant: "tonal",
                      class: "mb-2"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_v_icon, null, {
                          default: withCtx(() => [
                            createTextVNode("mdi-alert-circle")
                          ]),
                          _: 1
                        }),
                        createTextVNode(" " + toDisplayString($data.errorMessage), 1)
                      ]),
                      _: 1
                    })) : createCommentVNode("v-if", true),
                    $data.scanResult ? (openBlock(), createBlock(_component_v_alert, {
                      key: 1,
                      type: "success",
                      variant: "tonal",
                      class: "mb-2"
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.__("Successfully scanned:")) + " ", 1),
                        createBaseVNode("strong", null, toDisplayString($data.scanResult), 1),
                        _hoisted_84,
                        createBaseVNode("small", null, "Format: " + toDisplayString($data.scanFormat), 1)
                      ]),
                      _: 1
                    })) : createCommentVNode("v-if", true),
                    !$data.scanResult && !$data.errorMessage && $data.isScanning && $data.scannerDialog ? (openBlock(), createBlock(_component_v_alert, {
                      key: 2,
                      type: "info",
                      variant: "tonal"
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.__("Position the QR code or barcode within the scanning area")) + " ", 1),
                        _hoisted_94,
                        createBaseVNode("small", null, toDisplayString(_ctx.__("Detecting formats:")) + " " + toDisplayString($options.readerFormats.join(", ")), 1)
                      ]),
                      _: 1
                    })) : createCommentVNode("v-if", true)
                  ])
                ])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createCommentVNode(" Camera permission denied message "),
                  createBaseVNode("div", _hoisted_104, [
                    createVNode(_component_v_icon, {
                      size: "64",
                      color: "error"
                    }, {
                      default: withCtx(() => [
                        createTextVNode("mdi-camera-off")
                      ]),
                      _: 1
                    }),
                    createBaseVNode("h3", _hoisted_116, toDisplayString(_ctx.__("Camera Access Required")), 1),
                    createBaseVNode("p", _hoisted_125, toDisplayString(_ctx.__("Please allow camera access to scan codes")), 1),
                    createCommentVNode(" Requesting permission is handled by the browser when QrcodeStream tries to access camera ")
                  ])
                ], 2112))
              ]),
              _: 1
            }),
            createCommentVNode(" Action buttons "),
            createVNode(_component_v_card_actions, { class: "justify-space-between pa-3" }, {
              default: withCtx(() => [
                createBaseVNode("div", _hoisted_135, [
                  createCommentVNode(" Flashlight toggle "),
                  $data.isScanning && $data.cameras.length > 0 ? (openBlock(), createBlock(_component_v_btn, {
                    key: 0,
                    onClick: $options.toggleTorch,
                    color: $data.torchActive ? "warning" : "default",
                    variant: "outlined",
                    size: "small"
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_v_icon, null, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString($data.torchActive ? "mdi-flashlight" : "mdi-flashlight-off"), 1)
                        ]),
                        _: 1
                      }),
                      createTextVNode(" " + toDisplayString($data.torchActive ? _ctx.__("Flash On") : _ctx.__("Flash Off")), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick", "color"])) : createCommentVNode("v-if", true),
                  createCommentVNode(" Camera switch "),
                  $data.isScanning && $data.cameras.length > 1 ? (openBlock(), createBlock(_component_v_btn, {
                    key: 1,
                    onClick: $options.switchCamera,
                    color: "default",
                    variant: "outlined",
                    size: "small"
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_v_icon, null, {
                        default: withCtx(() => [
                          createTextVNode("mdi-camera-switch")
                        ]),
                        _: 1
                      }),
                      createTextVNode(" " + toDisplayString(_ctx.__("Switch Camera")), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick"])) : createCommentVNode("v-if", true)
                ]),
                createCommentVNode(" Cancel button "),
                createVNode(_component_v_btn, {
                  onClick: withModifiers($options.stopScanning, ["stop"]),
                  color: "error",
                  variant: "outlined"
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.__("Cancel")), 1)
                  ]),
                  _: 1
                }, 8, ["onClick"])
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["modelValue"]);
  }

  // ../posawesome/posawesome/public/js/posapp/components/pos/CameraScanner.vue
  CameraScanner_default.render = render10;
  CameraScanner_default.__file = "../posawesome/posawesome/public/js/posapp/components/pos/CameraScanner.vue";
  CameraScanner_default.__scopeId = "data-v-5eb7f7b8";
  var CameraScanner_default2 = CameraScanner_default;

  // ../posawesome/posawesome/public/js/posapp/mixins/responsive.js
  var responsiveMixin = {
    data() {
      return {
        windowWidth: window.innerWidth,
        windowHeight: window.innerHeight,
        baseWidth: window.innerWidth,
        baseHeight: window.innerHeight
      };
    },
    computed: {
      widthScale() {
        return this.windowWidth / this.baseWidth;
      },
      heightScale() {
        return this.windowHeight / this.baseHeight;
      },
      averageScale() {
        return (this.widthScale + this.heightScale) / 2;
      },
      dynamicSpacing() {
        const baseSpacing = {
          xs: 4,
          sm: 8,
          md: 16,
          lg: 24,
          xl: 32
        };
        return {
          xs: Math.max(2, Math.round(baseSpacing.xs * this.averageScale)),
          sm: Math.max(4, Math.round(baseSpacing.sm * this.averageScale)),
          md: Math.max(8, Math.round(baseSpacing.md * this.averageScale)),
          lg: Math.max(12, Math.round(baseSpacing.lg * this.averageScale)),
          xl: Math.max(16, Math.round(baseSpacing.xl * this.averageScale))
        };
      },
      responsiveStyles() {
        let cardHeightVh;
        if (this.windowWidth <= 480) {
          cardHeightVh = Math.round(45 * this.heightScale);
        } else if (this.windowWidth <= 768) {
          cardHeightVh = Math.round(55 * this.heightScale);
        } else {
          cardHeightVh = Math.round(60 * this.heightScale);
        }
        cardHeightVh = Math.max(30, Math.min(cardHeightVh, 70));
        return {
          "--dynamic-xs": `${this.dynamicSpacing.xs}px`,
          "--dynamic-sm": `${this.dynamicSpacing.sm}px`,
          "--dynamic-md": `${this.dynamicSpacing.md}px`,
          "--dynamic-lg": `${this.dynamicSpacing.lg}px`,
          "--dynamic-xl": `${this.dynamicSpacing.xl}px`,
          "--container-height": `${Math.round(68 * this.heightScale)}vh`,
          "--card-height": `${cardHeightVh}vh`,
          "--font-scale": this.averageScale.toFixed(2)
        };
      }
    },
    mounted() {
      this.handleResize();
      window.addEventListener("resize", this.handleResize);
    },
    beforeUnmount() {
      window.removeEventListener("resize", this.handleResize);
    },
    methods: {
      handleResize() {
        this.windowWidth = window.innerWidth;
        this.windowHeight = window.innerHeight;
      }
    }
  };

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/ItemsSelector.vue?type=script
  var ItemsSelector_default = {
    mixins: [format_default, responsiveMixin],
    components: {
      CameraScanner: CameraScanner_default2
    },
    data: () => ({
      pos_profile: "",
      flags: {},
      items_view: "list",
      item_group: "ALL",
      loading: false,
      items_group: ["ALL"],
      items: [],
      search: "",
      first_search: "",
      search_backup: "",
      itemsPerPage: 50,
      offersCount: 0,
      appliedOffersCount: 0,
      couponsCount: 0,
      appliedCouponsCount: 0,
      customer_price_list: null,
      customer: null,
      new_line: false,
      qty: 1,
      refresh_interval: null,
      currentRequest: null,
      abortController: null,
      itemDetailsRetryCount: 0,
      itemDetailsRetryTimeout: null,
      items_loaded: false,
      selected_currency: "",
      exchange_rate: 1,
      prePopulateInProgress: false,
      itemWorker: null,
      items_request_token: 0,
      show_item_settings: false,
      hide_qty_decimals: false,
      temp_hide_qty_decimals: false,
      hide_zero_rate_items: false,
      temp_hide_zero_rate_items: false,
      isDragging: false,
      search_from_scanner: false
    }),
    watch: {
      customer: import_lodash.default.debounce(function() {
        if (this.pos_profile.posa_force_reload_items) {
          if (this.pos_profile.posa_smart_reload_mode) {
            if (!this.items_loaded || !this.filtered_items.length) {
              this.items_loaded = false;
              this.get_items(true);
            } else {
              this.$nextTick(() => this.refreshPricesForVisibleItems());
            }
          } else {
            this.items_loaded = false;
            this.get_items(true);
          }
          return;
        }
        if (this.items_loaded && this.filtered_items && this.filtered_items.length > 0) {
          this.$nextTick(() => this.refreshPricesForVisibleItems());
        } else {
          this.get_items();
        }
      }, 300),
      customer_price_list: import_lodash.default.debounce(function() {
        if (this.pos_profile.posa_force_reload_items) {
          if (this.pos_profile.posa_smart_reload_mode) {
            if (!this.items_loaded || !this.items.length) {
              this.items_loaded = false;
              this.get_items(true);
            } else {
              this.$nextTick(() => this.refreshPricesForVisibleItems());
            }
          } else {
            this.items_loaded = false;
            this.get_items(true);
          }
          return;
        }
        if (this.items_loaded && this.items && this.items.length > 0) {
          const cached = getCachedPriceListItems(this.customer_price_list);
          if (cached && cached.length) {
            const map2 = {};
            cached.forEach((ci2) => {
              map2[ci2.item_code] = ci2;
            });
            this.items.forEach((it2) => {
              const ci2 = map2[it2.item_code];
              if (ci2) {
                it2.rate = ci2.rate;
                it2.price_list_rate = ci2.price_list_rate || ci2.rate;
              }
            });
            this.eventBus.emit("set_all_items", this.items);
            this.update_items_details(this.items);
            return;
          }
        }
        this.items_loaded = false;
        this.get_items(true);
      }, 300),
      new_line() {
        this.eventBus.emit("set_new_line", this.new_line);
      },
      filtered_items(new_value, old_value) {
        if (!this.pos_profile.pose_use_limit_search && new_value.length !== old_value.length) {
          this.update_items_details(new_value);
        }
      },
      first_search: import_lodash.default.debounce(function(val) {
        this.search_onchange();
      }, 300),
      selected_currency() {
        this.applyCurrencyConversionToItems();
      },
      exchange_rate() {
        this.applyCurrencyConversionToItems();
      }
    },
    methods: {
      async handleProductBundleSearch(searchValue) {
        if (!searchValue || searchValue.trim() === "") {
          console.warn("No search value provided for product bundle search");
          return false;
        }
        console.log(`Searching for product bundle: ${searchValue}`);
        try {
          const potentialBundleItem = this.items.find(
            (item) => item.item_code === searchValue || item.item_code.toLowerCase() === searchValue.toLowerCase() || item.item_name.toLowerCase().includes(searchValue.toLowerCase())
          );
          if (potentialBundleItem) {
            console.log("Found potential bundle item:", potentialBundleItem);
            const bundleResult = await this.processProductBundle(potentialBundleItem.item_code, this.qty || 1);
            if (bundleResult) {
              this.clearSearchForm();
              frappe.show_alert({
                message: `Product bundle added: ${potentialBundleItem.item_name}`,
                indicator: "green"
              }, 3);
              return true;
            } else {
              console.log("Item is not a product bundle, adding as regular item");
              this.addItemFromSearch(potentialBundleItem, searchValue);
              return true;
            }
          } else {
            return await this.searchAndAddProductBundle(searchValue);
          }
        } catch (error) {
          console.error("Error in product bundle search:", error);
          this.eventBus.emit("show_message", {
            title: `Error searching for product bundle: ${error.message}`,
            color: "error"
          });
          return false;
        }
      },
      async searchAndAddProductBundle(searchTerm) {
        try {
          console.log(`Searching for product bundle via API: ${searchTerm}`);
          const response = await new Promise((resolve2, reject) => {
            frappe.call({
              method: "posawesome.posawesome.api.posapp.search_product_bundle",
              args: {
                search_term: searchTerm,
                pos_profile: this.pos_profile
              },
              callback: function(r) {
                resolve2(r);
              },
              error: function(err) {
                reject(err);
              }
            });
          });
          if (response.message && response.message.length > 0) {
            const bundle = response.message[0];
            console.log("Found product bundle via API:", bundle);
            const bundleResult = await this.processProductBundle(bundle.item_code, this.qty || 1);
            if (bundleResult) {
              this.clearSearchForm();
              frappe.show_alert({
                message: `Product bundle added: ${bundle.name}`,
                indicator: "green"
              }, 3);
              return true;
            }
          }
          console.log(`No product bundle found for: ${searchTerm}`);
          return false;
        } catch (error) {
          console.error("Error searching product bundle via API:", error);
          return false;
        }
      },
      async handleBarcodeSearch(searchValue = null, isScanned = false) {
        const barcodeValue = searchValue || this.first_search || this.search;
        if (!barcodeValue || barcodeValue.trim() === "") {
          console.warn("No barcode value provided");
          return;
        }
        console.log(`Processing ${isScanned ? "scanned" : "manual"} barcode:`, barcodeValue);
        this.first_search = barcodeValue;
        this.search = barcodeValue;
        this.search_backup = "";
        if (isScanned) {
          frappe.show_alert({
            message: `Searching for: ${barcodeValue}`,
            indicator: "blue"
          }, 2);
        }
        if (this.pos_profile.custom_product_bundle) {
          console.log("Product bundle enabled, checking for bundles first...");
          const bundleFound = await this.handleProductBundleSearch(barcodeValue);
          if (bundleFound) {
            return;
          }
        }
        let foundItem = this.findItemByBarcode(barcodeValue);
        if (foundItem) {
          console.log("Found item by exact barcode match:", foundItem);
          this.addItemFromSearch(foundItem, barcodeValue);
          return;
        }
        foundItem = this.items.find(
          (item) => item.item_code === barcodeValue || item.item_code.toLowerCase() === barcodeValue.toLowerCase()
        );
        if (foundItem) {
          console.log("Found item by item code match:", foundItem);
          this.addItemFromSearch(foundItem, barcodeValue);
          return;
        }
        if (this.pos_profile.posa_scale_barcode_start && barcodeValue.startsWith(this.pos_profile.posa_scale_barcode_start)) {
          const scaledItem = this.handleScaleBarcode(barcodeValue);
          if (scaledItem) {
            this.addItemFromSearch(scaledItem, barcodeValue);
            return;
          }
        }
        if (this.pos_profile.posa_search_serial_no) {
          foundItem = this.findItemBySerialNumber(barcodeValue);
          if (foundItem) {
            console.log("Found item by serial number:", foundItem);
            foundItem.to_set_serial_no = barcodeValue;
            this.flags.serial_no = barcodeValue;
            this.addItemFromSearch(foundItem, barcodeValue);
            return;
          }
        }
        if (this.pos_profile.posa_search_batch_no) {
          foundItem = this.findItemByBatchNumber(barcodeValue);
          if (foundItem) {
            console.log("Found item by batch number:", foundItem);
            foundItem.to_set_batch_no = barcodeValue;
            foundItem.batch_no = barcodeValue;
            this.flags.batch_no = barcodeValue;
            this.addItemFromSearch(foundItem, barcodeValue);
            return;
          }
        }
        const partialMatches = this.searchItemsByName(barcodeValue);
        if (partialMatches.length === 1) {
          console.log("Found item by name search:", partialMatches[0]);
          this.addItemFromSearch(partialMatches[0], barcodeValue);
        } else if (partialMatches.length > 1) {
          console.log("Multiple items found, showing first match:", partialMatches[0]);
          this.addItemFromSearch(partialMatches[0], barcodeValue);
        } else {
          this.handleItemNotFound(barcodeValue, isScanned);
        }
      },
      findItemByBarcode(barcode) {
        return this.items.find((item) => {
          if (item.barcode === barcode)
            return true;
          if (item.item_barcode && Array.isArray(item.item_barcode)) {
            return item.item_barcode.some((bc) => bc.barcode === barcode);
          }
          if (item.barcodes && Array.isArray(item.barcodes)) {
            return item.barcodes.some((bc) => bc.barcode === barcode);
          }
          return false;
        });
      },
      findItemBySerialNumber(serialNo) {
        return this.items.find((item) => {
          if (item.serial_no_data && Array.isArray(item.serial_no_data)) {
            return item.serial_no_data.some((sn2) => sn2.serial_no === serialNo);
          }
          return false;
        });
      },
      findItemByBatchNumber(batchNo) {
        return this.items.find((item) => {
          if (item.batch_no_data && Array.isArray(item.batch_no_data)) {
            return item.batch_no_data.some((bn) => bn.batch_no === batchNo);
          }
          return false;
        });
      },
      searchItemsByName(searchTerm) {
        const term = searchTerm.toLowerCase();
        return this.items.filter((item) => {
          const matchesName = item.item_name.toLowerCase().includes(term);
          const matchesCode = item.item_code.toLowerCase().includes(term);
          const matchesOEM = item.custom_oem_part_number && item.custom_oem_part_number.toLowerCase().includes(term);
          return matchesName || matchesCode || matchesOEM;
        });
      },
      handleScaleBarcode(barcode) {
        const itemCode = barcode.substr(0, 7);
        const foundItem = this.items.find(
          (item) => item.item_code === itemCode || item.barcode === itemCode
        );
        if (foundItem) {
          const qty = this.get_item_qty(barcode);
          foundItem.qty = qty;
          return foundItem;
        }
        return null;
      },
      addItemFromSearch(item, originalSearch) {
        if (!item)
          return;
        const itemToAdd = __spreadValues({}, item);
        const qtyVal = this.qty != null ? this.qty : 1;
        itemToAdd.qty = Math.abs(qtyVal);
        if (item.item_barcode && Array.isArray(item.item_barcode)) {
          const barcodeMatch = item.item_barcode.find((bc) => bc.barcode === originalSearch);
          if (barcodeMatch && barcodeMatch.posa_uom) {
            itemToAdd.uom = barcodeMatch.posa_uom;
            this.eventBus.emit("calc_uom", itemToAdd, barcodeMatch.posa_uom);
          }
        }
        if (itemToAdd.actual_qty === 0 && this.pos_profile.posa_display_items_in_stock) {
          this.eventBus.emit("show_message", {
            title: `No stock available for ${itemToAdd.item_name}`,
            color: "warning"
          });
          this.update_items_details([itemToAdd]);
          return;
        }
        if (!itemToAdd.item_uoms || itemToAdd.item_uoms.length === 0) {
          const cachedUoms = getItemUOMs2(itemToAdd.item_code);
          if (cachedUoms.length > 0) {
            itemToAdd.item_uoms = cachedUoms;
          } else if (itemToAdd.stock_uom) {
            itemToAdd.item_uoms = [{ uom: itemToAdd.stock_uom, conversion_factor: 1 }];
          }
        }
        if (this.pos_profile.posa_allow_multi_currency && this.selected_currency !== this.pos_profile.currency) {
          itemToAdd.base_rate = itemToAdd.rate;
          itemToAdd.base_price_list_rate = itemToAdd.price_list_rate;
          itemToAdd.rate = this.getConvertedRate(itemToAdd);
          itemToAdd.price_list_rate = this.getConvertedRate(itemToAdd);
          itemToAdd.currency = this.selected_currency;
        }
        this.eventBus.emit("add_item", itemToAdd);
        frappe.show_alert({
          message: `Added: ${itemToAdd.item_name}`,
          indicator: "green"
        }, 3);
        this.clearSearchForm();
        this.$nextTick(() => {
          var _a3;
          (_a3 = this.$refs.debounce_search) == null ? void 0 : _a3.focus();
        });
      },
      handleItemNotFound(searchValue, isScanned = false) {
        const message2 = `No item found for: ${searchValue}`;
        console.warn(message2);
        this.eventBus.emit("show_message", {
          title: message2,
          color: "error"
        });
        frappe.utils.play_sound("error");
        frappe.show_alert({
          message: message2,
          indicator: "red"
        }, 5);
        if (isScanned) {
          setTimeout(() => {
            this.clearSearchForm();
          }, 2e3);
        }
      },
      clearSearchForm() {
        this.search = "";
        this.first_search = "";
        this.search_backup = "";
        this.qty = 1;
        this.flags.serial_no = null;
        this.flags.batch_no = null;
      },
      refreshPricesForVisibleItems() {
        const vm2 = this;
        if (!vm2.filtered_items || vm2.filtered_items.length === 0)
          return;
        vm2.loading = true;
        if (vm2.currentRequest) {
          vm2.abortController.abort();
          vm2.currentRequest = null;
        }
        const itemCodes = vm2.filtered_items.map((it2) => it2.item_code);
        const cacheResult = getCachedItemDetails(vm2.pos_profile.name, vm2.active_price_list, itemCodes);
        const updates = [];
        cacheResult.cached.forEach((det) => {
          const item = vm2.filtered_items.find((it2) => it2.item_code === det.item_code);
          if (item) {
            const upd = {
              actual_qty: det.actual_qty,
              serial_no_data: det.serial_no_data,
              batch_no_data: det.batch_no_data
            };
            if (det.item_uoms && det.item_uoms.length > 0) {
              upd.item_uoms = det.item_uoms;
              saveItemUOMs(item.item_code, det.item_uoms);
            }
            if (det.rate !== void 0) {
              if (det.rate !== 0 || !item.rate) {
                upd.rate = det.rate;
                upd.price_list_rate = det.price_list_rate || det.rate;
              }
            }
            updates.push({ item, upd });
          }
        });
        if (cacheResult.missing.length === 0) {
          vm2.$nextTick(() => {
            updates.forEach(({ item, upd }) => Object.assign(item, upd));
            updateLocalStockCache(cacheResult.cached);
            vm2.loading = false;
          });
          return;
        }
        vm2.abortController = new AbortController();
        const itemsToFetch = vm2.filtered_items.filter((it2) => cacheResult.missing.includes(it2.item_code));
        frappe.call({
          method: "posawesome.posawesome.api.items.get_items_details",
          args: {
            pos_profile: JSON.stringify(vm2.pos_profile),
            items_data: JSON.stringify(itemsToFetch),
            price_list: vm2.active_price_list
          },
          freeze: false,
          signal: vm2.abortController.signal,
          callback: function(r) {
            if (r.message) {
              r.message.forEach((updItem) => {
                const item = vm2.filtered_items.find((it2) => it2.item_code === updItem.item_code);
                if (item) {
                  const upd = {
                    actual_qty: updItem.actual_qty,
                    serial_no_data: updItem.serial_no_data,
                    batch_no_data: updItem.batch_no_data
                  };
                  if (updItem.item_uoms && updItem.item_uoms.length > 0) {
                    upd.item_uoms = updItem.item_uoms;
                    saveItemUOMs(item.item_code, updItem.item_uoms);
                  }
                  if (updItem.rate !== void 0) {
                    if (updItem.rate !== 0 || !item.rate) {
                      upd.rate = updItem.rate;
                      upd.price_list_rate = updItem.price_list_rate || updItem.rate;
                    }
                  }
                  updates.push({ item, upd });
                }
              });
              vm2.$nextTick(() => {
                updates.forEach(({ item, upd }) => Object.assign(item, upd));
                updateLocalStockCache(r.message);
                saveItemDetailsCache(vm2.pos_profile.name, vm2.active_price_list, r.message);
                vm2.loading = false;
              });
            }
          },
          error: function(err) {
            if (err.name !== "AbortError") {
              console.error("Error fetching item details:", err);
              vm2.loading = false;
            }
          }
        });
      },
      async getProductBundle(item_code) {
        try {
          const response = await new Promise((resolve2, reject) => {
            frappe.call({
              method: "posawesome.posawesome.api.posapp.get_product_bundle",
              args: {
                item_code,
                pos_profile: this.pos_profile
              },
              callback: function(r) {
                resolve2(r);
              },
              error: function(err) {
                reject(err);
              }
            });
          });
          return response.message;
        } catch (error) {
          console.error("Error fetching product bundle:", error);
          throw error;
        }
      },
      async processProductBundle(item_code, quantity = 1) {
        if (!this.pos_profile.custom_product_bundle) {
          return false;
        }
        try {
          console.log(`Processing product bundle for item: ${item_code}`);
          const product_bundle = await this.getProductBundle(item_code);
          if (product_bundle && product_bundle.items && Array.isArray(product_bundle.items)) {
            console.log("Product bundle found:", product_bundle);
            let allItemsAdded = true;
            let addedCount = 0;
            for (const bundle_item of product_bundle.items) {
              try {
                const item_details = this.items.find((item) => item.item_code === bundle_item.item_code);
                if (item_details) {
                  const bundle_qty = (bundle_item.qty || 1) * quantity;
                  const enhanced_bundle_item = __spreadProps(__spreadValues({}, item_details), {
                    qty: bundle_qty,
                    uom: bundle_item.uom || item_details.stock_uom,
                    is_bundle_item: true,
                    parent_bundle: item_code,
                    custom_bundle_id: product_bundle.name,
                    bundle_item_description: bundle_item.description || "",
                    rate: item_details.rate,
                    price_list_rate: item_details.price_list_rate || item_details.rate
                  });
                  console.log(`Adding bundle item: ${bundle_item.item_code} with qty: ${bundle_qty}`);
                  this.eventBus.emit("add_item", enhanced_bundle_item);
                  addedCount++;
                  await new Promise((resolve2) => setTimeout(resolve2, 100));
                } else {
                  console.warn(`Bundle item not found in items list: ${bundle_item.item_code}`);
                  this.eventBus.emit("show_message", {
                    title: `Bundle item not available: ${bundle_item.item_code}`,
                    color: "warning"
                  });
                  allItemsAdded = false;
                }
              } catch (itemError) {
                console.error(`Error processing bundle item ${bundle_item.item_code}:`, itemError);
                allItemsAdded = false;
              }
            }
            if (addedCount > 0) {
              const messageColor = allItemsAdded ? "success" : "warning";
              const messageText = allItemsAdded ? `Product bundle "${product_bundle.name}" added successfully (${addedCount} items)` : `Product bundle "${product_bundle.name}" partially added (${addedCount} items)`;
              this.eventBus.emit("show_message", {
                title: messageText,
                color: messageColor
              });
              return true;
            } else {
              this.eventBus.emit("show_message", {
                title: `No items could be added from bundle: ${product_bundle.name}`,
                color: "error"
              });
              return false;
            }
          } else {
            console.log(`No product bundle found for item: ${item_code}`);
            return false;
          }
        } catch (error) {
          console.error("Error processing product bundle:", error);
          return false;
        }
      },
      show_offers() {
        this.eventBus.emit("show_offers", "true");
      },
      show_coupons() {
        this.eventBus.emit("show_coupons", "true");
      },
      async get_items(force_server = false) {
        await initPromise;
        const request_token = ++this.items_request_token;
        if (!this.pos_profile) {
          console.error("No POS Profile");
          return;
        }
        if (force_server && this.pos_profile.posa_local_storage) {
          localStorage.setItem("items_storage", "");
        }
        const vm2 = this;
        this.loading = true;
        let search = this.get_search(this.first_search);
        let gr2 = vm2.item_group !== "ALL" ? vm2.item_group.toLowerCase() : "";
        let sr2 = search || "";
        if (this.items_loaded && !force_server && !this.first_search && !this.pos_profile.pose_use_limit_search) {
          console.info("Items already loaded, skipping reload");
          if (this.filtered_items && this.filtered_items.length > 0) {
            this.update_items_details(this.filtered_items);
          }
          this.loading = false;
          return;
        }
        if (!force_server && !this.pos_profile.pose_use_limit_search) {
          const cached = getCachedPriceListItems(vm2.customer_price_list);
          if (cached && cached.length) {
            vm2.items = cached;
            vm2.items.forEach((it2) => {
              if (!it2.item_uoms || it2.item_uoms.length === 0) {
                const cachedUoms = getItemUOMs2(it2.item_code);
                if (cachedUoms.length > 0) {
                  it2.item_uoms = cachedUoms;
                } else if (it2.stock_uom) {
                  it2.item_uoms = [{ uom: it2.stock_uom, conversion_factor: 1 }];
                }
              }
            });
            this.eventBus.emit("set_all_items", vm2.items);
            vm2.loading = false;
            vm2.items_loaded = true;
            if (vm2.items && vm2.items.length > 0) {
              vm2.prePopulateStockCache(vm2.items);
              vm2.update_items_details(vm2.items);
            }
            return;
          }
        }
        if (vm2.pos_profile.posa_local_storage && getItemsStorage().length && !vm2.pos_profile.pose_use_limit_search && !force_server) {
          vm2.items = getItemsStorage();
          vm2.items.forEach((it2) => {
            if (!it2.item_uoms || it2.item_uoms.length === 0) {
              const cached = getItemUOMs2(it2.item_code);
              if (cached.length > 0) {
                it2.item_uoms = cached;
              } else if (it2.stock_uom) {
                it2.item_uoms = [{ uom: it2.stock_uom, conversion_factor: 1 }];
              }
            }
          });
          this.eventBus.emit("set_all_items", vm2.items);
          vm2.loading = false;
          vm2.items_loaded = true;
          if (vm2.items && vm2.items.length > 0) {
            await vm2.prePopulateStockCache(vm2.items);
            vm2.update_items_details(vm2.items);
          }
          return;
        }
        if (this.itemWorker) {
          try {
            const res = await fetch(
              "/api/method/posawesome.posawesome.api.items.get_items",
              {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  "X-Frappe-CSRF-Token": frappe.csrf_token
                },
                credentials: "same-origin",
                body: JSON.stringify({
                  pos_profile: JSON.stringify(vm2.pos_profile),
                  price_list: vm2.customer_price_list,
                  item_group: gr2,
                  search_value: sr2,
                  customer: vm2.customer
                })
              }
            );
            const text = await res.text();
            this.itemWorker.onmessage = async (ev) => {
              if (this.items_request_token !== request_token)
                return;
              if (ev.data.type === "parsed") {
                const parsed = ev.data.items;
                vm2.items = parsed.message || parsed;
                savePriceListItems(vm2.customer_price_list, vm2.items);
                vm2.items.forEach((it2) => {
                  if (it2.item_uoms && it2.item_uoms.length > 0) {
                    saveItemUOMs(it2.item_code, it2.item_uoms);
                  } else {
                    const cached = getItemUOMs2(it2.item_code);
                    if (cached.length > 0) {
                      it2.item_uoms = cached;
                    } else if (it2.stock_uom) {
                      it2.item_uoms = [{ uom: it2.stock_uom, conversion_factor: 1 }];
                    }
                  }
                });
                vm2.eventBus.emit("set_all_items", vm2.items);
                vm2.loading = false;
                vm2.items_loaded = true;
                console.info("Items Loaded");
                vm2.prePopulateStockCache(vm2.items);
                vm2.$nextTick(() => {
                  if (vm2.search && !vm2.pos_profile.pose_use_limit_search) {
                    vm2.search_onchange();
                  }
                });
                if (vm2.items && vm2.items.length > 0) {
                  vm2.update_items_details(vm2.items);
                }
                if (vm2.pos_profile.posa_local_storage && !vm2.pos_profile.pose_use_limit_search) {
                  try {
                    setItemsStorage(vm2.items);
                    vm2.items.forEach((it2) => {
                      if (it2.item_uoms && it2.item_uoms.length > 0) {
                        saveItemUOMs(it2.item_code, it2.item_uoms);
                      }
                    });
                  } catch (e) {
                    console.error(e);
                  }
                }
                if (vm2.pos_profile.pose_use_limit_search) {
                  vm2.handleBarcodeSearch();
                }
                if (vm2.itemWorker) {
                  vm2.itemWorker.terminate();
                  vm2.itemWorker = null;
                }
              } else if (ev.data.type === "error") {
                console.error("Item worker parse error:", ev.data.error);
                vm2.loading = false;
              }
            };
            this.itemWorker.postMessage({ type: "parse_and_cache", json: text, priceList: vm2.customer_price_list });
          } catch (err) {
            console.error("Failed to fetch items", err);
            vm2.loading = false;
          }
        } else {
          frappe.call({
            method: "posawesome.posawesome.api.items.get_items",
            args: {
              pos_profile: JSON.stringify(vm2.pos_profile),
              price_list: vm2.customer_price_list,
              item_group: gr2,
              search_value: sr2,
              customer: vm2.customer
            },
            callback: async function(r) {
              if (vm2.items_request_token !== request_token)
                return;
              if (r.message) {
                vm2.items = r.message;
                vm2.items.forEach((it2) => {
                  if (it2.item_uoms && it2.item_uoms.length > 0) {
                    saveItemUOMs(it2.item_code, it2.item_uoms);
                  } else {
                    const cached = getItemUOMs2(it2.item_code);
                    if (cached.length > 0) {
                      it2.item_uoms = cached;
                    } else if (it2.stock_uom) {
                      it2.item_uoms = [{ uom: it2.stock_uom, conversion_factor: 1 }];
                    }
                  }
                });
                vm2.eventBus.emit("set_all_items", vm2.items);
                vm2.loading = false;
                vm2.items_loaded = true;
                savePriceListItems(vm2.customer_price_list, vm2.items);
                console.info("Items Loaded");
                vm2.prePopulateStockCache(vm2.items);
                vm2.$nextTick(() => {
                  if (vm2.search && !vm2.pos_profile.pose_use_limit_search) {
                    vm2.search_onchange();
                  }
                });
                if (vm2.items && vm2.items.length > 0) {
                  vm2.update_items_details(vm2.items);
                }
                if (vm2.pos_profile.posa_local_storage && !vm2.pos_profile.pose_use_limit_search) {
                  try {
                    setItemsStorage(r.message);
                    r.message.forEach((it2) => {
                      if (it2.item_uoms && it2.item_uoms.length > 0) {
                        saveItemUOMs(it2.item_code, it2.item_uoms);
                      }
                    });
                  } catch (e) {
                    console.error(e);
                  }
                }
                if (vm2.pos_profile.pose_use_limit_search) {
                  vm2.handleBarcodeSearch();
                }
              }
            }
          });
        }
      },
      get_items_groups() {
        if (!this.pos_profile) {
          console.log("No POS Profile");
          return;
        }
        if (this.pos_profile.item_groups.length > 0) {
          this.pos_profile.item_groups.forEach((element) => {
            if (element.item_group !== "All Item Groups") {
              this.items_group.push(element.item_group);
            }
          });
        } else {
          const vm2 = this;
          frappe.call({
            method: "posawesome.posawesome.api.items.get_items_groups",
            args: {},
            callback: function(r) {
              if (r.message) {
                r.message.forEach((element) => {
                  vm2.items_group.push(element.name);
                });
              }
            }
          });
        }
      },
      getItemsHeaders() {
        const items_headers = [
          {
            title: __("Name"),
            align: "start",
            sortable: true,
            key: "item_name"
          },
          {
            title: __("Code"),
            align: "start",
            sortable: true,
            key: "item_code"
          },
          { title: __("Rate"), key: "rate", align: "start" },
          { title: __("Available QTY"), key: "actual_qty", align: "start" },
          { title: __("UOM"), key: "stock_uom", align: "start" }
        ];
        if (!this.pos_profile.posa_display_item_code) {
          items_headers.splice(1, 1);
        }
        return items_headers;
      },
      click_item_row(event2, { item }) {
        this.add_item(item);
      },
      async add_item(item) {
        var _a3, _b;
        item = __spreadValues({}, item);
        if (item.has_variants) {
          this.eventBus.emit("open_variants_model", item, this.items);
        } else {
          if (item.actual_qty === 0 && this.pos_profile.posa_display_items_in_stock) {
            this.eventBus.emit("show_message", {
              title: `No stock available for ${item.item_name}`,
              color: "warning"
            });
            this.update_items_details([item]);
            return;
          }
          if (!item.item_uoms || item.item_uoms.length === 0) {
            this.update_items_details([item]);
            if (!item.item_uoms || item.item_uoms.length === 0) {
              item.item_uoms = [{ uom: item.stock_uom, conversion_factor: 1 }];
            }
          }
          if (this.pos_profile.custom_product_bundle) {
            console.log("Checking if item is a product bundle:", item.item_code);
            const quantity = Math.abs(this.qty != null ? this.qty : 1);
            const bundleProcessed = await this.processProductBundle(item.item_code, quantity);
            if (bundleProcessed) {
              this.qty = 1;
              this.search = "";
              this.first_search = "";
              this.search_backup = "";
              (_a3 = this.$refs.debounce_search) == null ? void 0 : _a3.focus();
              return;
            }
          }
          if (this.pos_profile.posa_allow_multi_currency) {
            this.applyCurrencyConversionToItem(item);
            const base_rate = item.original_currency === this.pos_profile.currency ? item.original_rate : item.original_rate * (item.plc_conversion_rate || this.exchange_rate);
            item.base_rate = base_rate;
            item.base_price_list_rate = base_rate;
          }
          if (!item.qty || item.qty === 1) {
            let qtyVal = this.qty != null ? this.qty : 1;
            qtyVal = Math.abs(qtyVal);
            if (this.hide_qty_decimals) {
              qtyVal = Math.trunc(qtyVal);
            }
            item.qty = qtyVal;
          }
          this.eventBus.emit("add_item", item);
          this.qty = 1;
          this.search = "";
          this.first_search = "";
          this.search_backup = "";
          (_b = this.$refs.debounce_search) == null ? void 0 : _b.focus();
        }
      },
      enter_event() {
        if (!this.first_search || this.filtered_items.length === 0) {
          return;
        }
        this.handleBarcodeSearch(this.first_search, false);
      },
      clearAndFocusSearch() {
        var _a3;
        this.search = "";
        this.first_search = "";
        this.search_backup = "";
        (_a3 = this.$refs.debounce_search) == null ? void 0 : _a3.focus();
      },
      search_onchange: import_lodash.default.debounce(function(newSearchTerm) {
        const vm2 = this;
        if (newSearchTerm)
          vm2.search = newSearchTerm;
        if (vm2.pos_profile.pose_use_limit_search) {
          if (vm2.search && vm2.search.length >= 3) {
            vm2.get_items();
          }
        } else {
          const current_items = [...vm2.filtered_items];
          if (vm2.search && vm2.search.length >= 3) {
            vm2.handleBarcodeSearch();
          }
          if (vm2.filtered_items && vm2.filtered_items.length > 0) {
            setTimeout(() => {
              vm2.update_items_details(vm2.filtered_items);
            }, 300);
          }
        }
        if (fromScanner) {
          vm2.clearSearch();
          vm2.$refs.debounce_search && vm2.$refs.debounce_search.focus();
          vm2.search_from_scanner = false;
        }
      }, 300),
      get_item_qty(first_search) {
        const qtyVal = this.qty != null ? this.qty : 1;
        let scal_qty = Math.abs(qtyVal);
        if (first_search.startsWith(this.pos_profile.posa_scale_barcode_start)) {
          let pesokg1 = first_search.substr(7, 5);
          let pesokg;
          if (pesokg1.startsWith("0000")) {
            pesokg = "0.00" + pesokg1.substr(4);
          } else if (pesokg1.startsWith("000")) {
            pesokg = "0.0" + pesokg1.substr(3);
          } else if (pesokg1.startsWith("00")) {
            pesokg = "0." + pesokg1.substr(2);
          } else if (pesokg1.startsWith("0")) {
            pesokg = pesokg1.substr(1, 1) + "." + pesokg1.substr(2, pesokg1.length);
          } else if (!pesokg1.startsWith("0")) {
            pesokg = pesokg1.substr(0, 2) + "." + pesokg1.substr(2, pesokg1.length);
          }
          scal_qty = pesokg;
        }
        if (this.hide_qty_decimals) {
          scal_qty = Math.trunc(scal_qty);
        }
        return scal_qty;
      },
      get_search(first_search) {
        let search_term = "";
        if (first_search && first_search.startsWith(this.pos_profile.posa_scale_barcode_start)) {
          search_term = first_search.substr(0, 7);
        } else {
          search_term = first_search;
        }
        return search_term;
      },
      esc_event() {
        this.search = null;
        this.first_search = null;
        this.search_backup = null;
        this.qty = 1;
        this.$refs.debounce_search.focus();
      },
      update_items_details(items) {
        const vm2 = this;
        if (!items || !items.length)
          return;
        if (vm2.itemDetailsRetryTimeout) {
          clearTimeout(vm2.itemDetailsRetryTimeout);
          vm2.itemDetailsRetryTimeout = null;
        }
        const itemCodes = items.map((it2) => it2.item_code);
        const cacheResult = getCachedItemDetails(vm2.pos_profile.name, vm2.active_price_list, itemCodes);
        cacheResult.cached.forEach((det) => {
          const item = items.find((it2) => it2.item_code === det.item_code);
          if (item) {
            Object.assign(item, {
              actual_qty: det.actual_qty,
              serial_no_data: det.serial_no_data,
              batch_no_data: det.batch_no_data,
              has_batch_no: det.has_batch_no,
              has_serial_no: det.has_serial_no
            });
            if (det.item_uoms && det.item_uoms.length > 0) {
              item.item_uoms = det.item_uoms;
              saveItemUOMs(item.item_code, det.item_uoms);
            }
            if (det.rate !== void 0) {
              if (det.rate !== 0 || !item.rate) {
                item.rate = det.rate;
                item.price_list_rate = det.price_list_rate || det.rate;
              }
            }
            if (!item.original_rate) {
              item.original_rate = item.rate;
              item.original_currency = item.currency || vm2.pos_profile.currency;
            }
            vm2.applyCurrencyConversionToItem(item);
          }
        });
        let allCached = cacheResult.missing.length === 0;
        items.forEach((item) => {
          const localQty = getLocalStock(item.item_code);
          if (localQty !== null) {
            item.actual_qty = localQty;
          } else {
            allCached = false;
          }
          if (!item.item_uoms || item.item_uoms.length === 0) {
            const cachedUoms = getItemUOMs2(item.item_code);
            if (cachedUoms.length > 0) {
              item.item_uoms = cachedUoms;
            } else if (isOffline()) {
              item.item_uoms = [{ uom: item.stock_uom, conversion_factor: 1 }];
            } else {
              allCached = false;
            }
          }
        });
        if (isOffline() || allCached) {
          vm2.itemDetailsRetryCount = 0;
          return;
        }
        if (vm2.currentRequest) {
          vm2.abortController.abort();
          vm2.currentRequest = null;
        }
        vm2.abortController = new AbortController();
        const itemsToFetch = items.filter((it2) => cacheResult.missing.includes(it2.item_code));
        vm2.currentRequest = frappe.call({
          method: "posawesome.posawesome.api.items.get_items_details",
          args: {
            pos_profile: JSON.stringify(vm2.pos_profile),
            items_data: JSON.stringify(itemsToFetch),
            price_list: vm2.active_price_list
          },
          freeze: false,
          signal: vm2.abortController.signal,
          callback: function(r) {
            if (r.message) {
              vm2.itemDetailsRetryCount = 0;
              let qtyChanged = false;
              let updatedItems = [];
              vm2.$nextTick(() => {
                items.forEach((item) => {
                  const updated_item = r.message.find(
                    (element) => element.item_code == item.item_code
                  );
                  if (updated_item) {
                    const prev_qty = item.actual_qty;
                    updatedItems.push({
                      item,
                      updates: {
                        actual_qty: updated_item.actual_qty,
                        serial_no_data: updated_item.serial_no_data,
                        batch_no_data: updated_item.batch_no_data,
                        has_batch_no: updated_item.has_batch_no,
                        has_serial_no: updated_item.has_serial_no,
                        item_uoms: updated_item.item_uoms && updated_item.item_uoms.length > 0 ? updated_item.item_uoms : item.item_uoms
                      }
                    });
                    if (prev_qty > 0 && updated_item.actual_qty === 0) {
                      qtyChanged = true;
                    }
                    if (updated_item.item_uoms && updated_item.item_uoms.length > 0) {
                      saveItemUOMs(item.item_code, updated_item.item_uoms);
                    }
                  }
                });
                updatedItems.forEach(({ item, updates }) => {
                  Object.assign(item, updates);
                  vm2.applyCurrencyConversionToItem(item);
                });
                updateLocalStockCache(r.message);
                saveItemDetailsCache(vm2.pos_profile.name, vm2.active_price_list, r.message);
                if (qtyChanged) {
                  vm2.$forceUpdate();
                }
              });
            }
          },
          error: function(err) {
            if (err.name !== "AbortError") {
              console.error("Error fetching item details:", err);
              items.forEach((item) => {
                const localQty = getLocalStock(item.item_code);
                if (localQty !== null) {
                  item.actual_qty = localQty;
                }
                if (!item.item_uoms || item.item_uoms.length === 0) {
                  const cached = getItemUOMs2(item.item_code);
                  if (cached.length > 0) {
                    item.item_uoms = cached;
                  }
                }
              });
              if (!isOffline()) {
                vm2.itemDetailsRetryCount += 1;
                const delay = Math.min(32e3, 1e3 * Math.pow(2, vm2.itemDetailsRetryCount - 1));
                vm2.itemDetailsRetryTimeout = setTimeout(() => {
                  vm2.update_items_details(items);
                }, delay);
              }
            }
          }
        });
        this.cleanupBeforeDestroy = () => {
          if (vm2.abortController) {
            vm2.abortController.abort();
          }
        };
      },
      update_cur_items_details() {
        if (this.filtered_items && this.filtered_items.length > 0) {
          this.update_items_details(this.filtered_items);
        }
      },
      async prePopulateStockCache(items) {
        if (this.prePopulateInProgress) {
          return;
        }
        this.prePopulateInProgress = true;
        try {
          if (isStockCacheReady()) {
            console.debug("Stock cache already initialized");
            return;
          }
          console.info("Pre-populating stock cache for", items.length, "items");
          await initializeStockCache(items, this.pos_profile);
        } catch (error) {
          console.error("Failed to pre-populate stock cache:", error);
        } finally {
          this.prePopulateInProgress = false;
        }
      },
      applyCurrencyConversionToItems() {
        if (!this.items || !this.items.length)
          return;
        this.items.forEach((it2) => this.applyCurrencyConversionToItem(it2));
      },
      applyCurrencyConversionToItem(item) {
        if (!item)
          return;
        const base = this.pos_profile.currency;
        if (!item.original_rate) {
          item.original_rate = item.rate;
          item.original_currency = item.currency || base;
        }
        const price_list_rate = item.original_rate;
        const base_rate = price_list_rate * (item.plc_conversion_rate || 1);
        item.base_rate = base_rate;
        item.base_price_list_rate = price_list_rate;
        const converted_rate = item.original_currency === this.selected_currency ? price_list_rate : price_list_rate * (this.exchange_rate || 1);
        item.rate = this.flt(converted_rate, this.currency_precision);
        item.currency = this.selected_currency;
        item.price_list_rate = item.rate;
      },
      scan_barcoud() {
        const vm2 = this;
        try {
          if (document._scannerAttached) {
            return;
          }
          onScan.attachTo(document, {
            suffixKeyCodes: [],
            keyCodeMapper: function(oEvent) {
              oEvent.stopImmediatePropagation();
              oEvent.preventDefault();
              return onScan.decodeKeyEvent(oEvent);
            },
            onScan: function(sCode) {
              setTimeout(() => {
                vm2.trigger_onscan(sCode);
              }, 300);
            }
          });
          document._scannerAttached = true;
        } catch (error) {
          console.warn("Scanner initialization error:", error.message);
        }
      },
      trigger_onscan(sCode) {
        this.search_from_scanner = true;
        this.first_search = sCode;
        this.search = sCode;
        this.$nextTick(() => {
          if (this.filtered_items.length == 0) {
            this.eventBus.emit("show_message", {
              title: `No Item has this barcode "${sCode}"`,
              color: "error"
            });
            frappe.utils.play_sound("error");
          } else {
            this.enter_event();
          }
          this.clearSearch();
          this.$refs.debounce_search && this.$refs.debounce_search.focus();
        });
      },
      generateWordCombinations(inputString) {
        const words = inputString.split(" ");
        const wordCount = words.length;
        const combinations = [];
        function permute(arr, m = []) {
          if (arr.length === 0) {
            combinations.push(m.join(" "));
          } else {
            for (let i = 0; i < arr.length; i++) {
              const current = arr.slice();
              const next = current.splice(i, 1);
              permute(current.slice(), m.concat(next));
            }
          }
        }
        permute(words);
        return combinations;
      },
      clearSearch() {
        this.search_backup = this.first_search;
        this.first_search = "";
        this.search = "";
      },
      restoreSearch() {
        if (this.first_search === "") {
          this.first_search = this.search_backup;
          this.search = this.search_backup;
        }
      },
      handleItemSearchFocus() {
        this.first_search = "";
        this.search = "";
      },
      clearQty() {
        this.qty = null;
      },
      startCameraScanning() {
        if (this.$refs.cameraScanner) {
          this.$refs.cameraScanner.startScanning();
        }
      },
      onBarcodeScanned(scannedCode) {
        console.log("Barcode scanned:", scannedCode);
        this.handleBarcodeSearch(scannedCode, true);
        this.search = "";
      },
      getConvertedRate(item) {
        if (!item.rate)
          return 0;
        if (!this.exchange_rate)
          return item.rate;
        const convertedRate = item.rate / this.exchange_rate;
        return this.flt(convertedRate, 4);
      },
      currencySymbol(currency) {
        return get_currency_symbol(currency);
      },
      format_currency(value, currency, precision) {
        const prec = typeof precision === "number" ? precision : this.currency_precision;
        return this.formatCurrency(value, prec);
      },
      ratePrecision(value) {
        const numericValue = typeof value === "string" ? parseFloat(value) : value;
        return Number.isInteger(numericValue) ? 0 : this.currency_precision;
      },
      format_number(value, precision) {
        const prec = typeof precision === "number" ? precision : this.float_precision;
        return this.formatFloat(value, prec);
      },
      hasDecimalPrecision(value) {
        if (this.exchange_rate && this.exchange_rate !== 1) {
          let convertedValue = value * this.exchange_rate;
          return !Number.isInteger(convertedValue);
        }
        return !Number.isInteger(value);
      },
      toggleItemSettings() {
        this.temp_hide_qty_decimals = this.hide_qty_decimals;
        this.temp_hide_zero_rate_items = this.hide_zero_rate_items;
        this.show_item_settings = true;
      },
      cancelItemSettings() {
        this.show_item_settings = false;
      },
      applyItemSettings() {
        this.hide_qty_decimals = this.temp_hide_qty_decimals;
        this.hide_zero_rate_items = this.temp_hide_zero_rate_items;
        this.saveItemSettings();
        this.show_item_settings = false;
      },
      onDragStart(event2, item) {
        this.isDragging = true;
        event2.dataTransfer.setData("application/json", JSON.stringify({
          type: "item-from-selector",
          item
        }));
        event2.dataTransfer.effectAllowed = "copy";
        this.eventBus.emit("item-drag-start", item);
      },
      onDragEnd(event2) {
        this.isDragging = false;
        this.eventBus.emit("item-drag-end");
      },
      saveItemSettings() {
        try {
          const settings = {
            hide_qty_decimals: this.hide_qty_decimals,
            hide_zero_rate_items: this.hide_zero_rate_items
          };
          localStorage.setItem("posawesome_item_selector_settings", JSON.stringify(settings));
        } catch (e) {
          console.error("Failed to save item selector settings:", e);
        }
      },
      loadItemSettings() {
        try {
          const saved2 = localStorage.getItem("posawesome_item_selector_settings");
          if (saved2) {
            const opts = JSON.parse(saved2);
            if (typeof opts.hide_qty_decimals === "boolean") {
              this.hide_qty_decimals = opts.hide_qty_decimals;
            }
            if (typeof opts.hide_zero_rate_items === "boolean") {
              this.hide_zero_rate_items = opts.hide_zero_rate_items;
            }
          }
        } catch (e) {
          console.error("Failed to load item selector settings:", e);
        }
      }
    },
    computed: {
      headers() {
        return this.getItemsHeaders();
      },
      filtered_items() {
        this.search = this.get_search(this.first_search).trim();
        if (!this.pos_profile.pose_use_limit_search) {
          let filtred_list = [];
          let filtred_group_list = [];
          if (this.item_group != "ALL") {
            filtred_group_list = this.items.filter(
              (item) => item.item_group.toLowerCase().includes(this.item_group.toLowerCase())
            );
          } else {
            filtred_group_list = this.items;
          }
          if (!this.search || this.search.length < 3) {
            let filtered = [];
            if (this.pos_profile.posa_show_template_items && this.pos_profile.posa_hide_variants_items) {
              filtered = filtred_group_list.filter((item) => !item.variant_of).slice(0, this.itemsPerPage);
            } else {
              filtered = filtred_group_list.slice(0, this.itemsPerPage);
            }
            if (this.hide_zero_rate_items) {
              filtered = filtered.filter((item) => parseFloat(item.rate) !== 0);
            }
            filtered.forEach((item) => {
              if (item.actual_qty === void 0) {
                item.actual_qty = 0;
              }
            });
            return filtered;
          } else if (this.search) {
            const term = this.search.toLowerCase();
            filtred_list = filtred_group_list.filter(
              (item) => item.item_barcode.some((b) => b.barcode === this.search)
            );
            if (filtred_list.length === 0) {
              filtred_list = filtred_group_list.filter(
                (item) => item.item_code.toLowerCase().includes(term) || item.item_name.toLowerCase().includes(term)
              );
            }
            if (filtred_list.length === 0) {
              const search_combinations = this.generateWordCombinations(this.search);
              filtred_list = filtred_group_list.filter((item) => {
                const nameLower = item.item_name.toLowerCase();
                return search_combinations.some((element) => {
                  element = element.toLowerCase().trim();
                  const element_regex = new RegExp(`.*${element.split("").join(".*")}.*`);
                  return element_regex.test(nameLower);
                });
              });
            }
            if (filtred_list.length === 0 && this.pos_profile.posa_search_serial_no) {
              filtred_list = filtred_group_list.filter((item) => {
                for (let element of item.serial_no_data) {
                  if (element.serial_no === this.search) {
                    this.flags.serial_no = this.search;
                    return true;
                  }
                }
                return false;
              });
            }
            if (filtred_list.length === 0 && this.pos_profile.posa_search_batch_no) {
              filtred_list = filtred_group_list.filter((item) => {
                for (let element of item.batch_no_data) {
                  if (element.batch_no === this.search) {
                    this.flags.batch_no = this.search;
                    return true;
                  }
                }
                return false;
              });
            }
          }
          let final_filtered_list = [];
          if (this.pos_profile.posa_show_template_items && this.pos_profile.posa_hide_variants_items) {
            final_filtered_list = filtred_list.filter((item) => !item.variant_of).slice(0, this.itemsPerPage);
          } else {
            final_filtered_list = filtred_list.slice(0, this.itemsPerPage);
          }
          if (this.hide_zero_rate_items) {
            final_filtered_list = final_filtered_list.filter((item) => parseFloat(item.rate) !== 0);
          }
          final_filtered_list.forEach((item) => {
            if (item.actual_qty === void 0) {
              item.actual_qty = 0;
            }
          });
          if (final_filtered_list.length > 0) {
            setTimeout(() => {
              this.update_items_details(final_filtered_list);
            }, 100);
          }
          return final_filtered_list;
        } else {
          const items_list = this.items.slice(0, this.itemsPerPage);
          items_list.forEach((item) => {
            if (item.actual_qty === void 0) {
              item.actual_qty = 0;
            }
          });
          if (this.hide_zero_rate_items) {
            return items_list.filter((item) => parseFloat(item.rate) !== 0);
          }
          return items_list;
        }
      },
      debounce_search: {
        get() {
          return this.first_search;
        },
        set: import_lodash.default.debounce(function(newValue) {
          this.first_search = (newValue || "").trim();
        }, 200)
      },
      debounce_qty: {
        get() {
          if (this.qty === null || this.qty === "")
            return "";
          return this.hide_qty_decimals ? Math.trunc(this.qty) : this.qty;
        },
        set: import_lodash.default.debounce(function(value) {
          let parsed = parseFloat(String(value).replace(/,/g, ""));
          if (isNaN(parsed)) {
            parsed = null;
          }
          if (this.hide_qty_decimals && parsed != null) {
            parsed = Math.trunc(parsed);
          }
          this.qty = parsed;
        }, 200)
      },
      isDarkTheme() {
        return this.$theme.current === "dark";
      },
      active_price_list() {
        return this.customer_price_list || this.pos_profile && this.pos_profile.selling_price_list;
      }
    },
    created: function() {
      this.loadItemSettings();
      if (typeof Worker !== "undefined") {
        try {
          const workerUrl = "/assets/posawesome/js/posapp/workers/itemWorker.js";
          this.itemWorker = new Worker(workerUrl, { type: "classic" });
          this.itemWorker.onerror = function(event2) {
            console.error("Worker error:", event2);
            console.error("Message:", event2.message);
            console.error("Filename:", event2.filename);
            console.error("Line number:", event2.lineno);
          };
          console.log("Created worker nowwwwww");
        } catch (e) {
          console.error("Failed to start item worker", e);
          this.itemWorker = null;
        }
      }
      this.$nextTick(function() {
      });
      this.eventBus.on("register_pos_profile", async (data) => {
        await initPromise;
        this.pos_profile = data.pos_profile;
        if (this.pos_profile.posa_force_reload_items && !this.pos_profile.posa_smart_reload_mode) {
          await this.get_items(true);
        } else {
          await this.get_items();
        }
        this.get_items_groups();
        this.items_view = this.pos_profile.posa_default_card_view ? "card" : "list";
      });
      this.eventBus.on("update_cur_items_details", () => {
        this.update_cur_items_details();
      });
      this.eventBus.on("update_offers_counters", (data) => {
        this.offersCount = data.offersCount;
        this.appliedOffersCount = data.appliedOffersCount;
      });
      this.eventBus.on("update_coupons_counters", (data) => {
        this.couponsCount = data.couponsCount;
        this.appliedCouponsCount = data.appliedCouponsCount;
      });
      this.eventBus.on("update_customer_price_list", (data) => {
        this.customer_price_list = data;
      });
      this.eventBus.on("update_customer", (data) => {
        this.customer = data;
      });
      this.eventBus.on("server-online", async () => {
        if (this.items && this.items.length > 0) {
          await this.update_items_details(this.items);
        }
      });
      this.update_cur_items_details();
      this.refresh_interval = setInterval(() => {
        if (this.filtered_items && this.filtered_items.length > 0) {
          this.update_cur_items_details();
        }
      }, 3e4);
      this.eventBus.on("update_currency", (data) => {
        this.selected_currency = data.currency;
        this.exchange_rate = data.exchange_rate;
        this.applyCurrencyConversionToItems();
        this.update_cur_items_details();
      });
    },
    mounted() {
      this.scan_barcoud();
    },
    beforeUnmount() {
      if (this.refresh_interval) {
        clearInterval(this.refresh_interval);
      }
      if (this.itemDetailsRetryTimeout) {
        clearTimeout(this.itemDetailsRetryTimeout);
      }
      this.itemDetailsRetryCount = 0;
      if (this.cleanupBeforeDestroy) {
        this.cleanupBeforeDestroy();
      }
      if (document._scannerAttached) {
        try {
          onScan.detachFrom(document);
          document._scannerAttached = false;
        } catch (error) {
          console.warn("Scanner detach error:", error.message);
        }
      }
      if (this.itemWorker) {
        this.itemWorker.terminate();
      }
      this.eventBus.off("update_currency");
      this.eventBus.off("server-online");
      this.eventBus.off("register_pos_profile");
      this.eventBus.off("update_cur_items_details");
      this.eventBus.off("update_offers_counters");
      this.eventBus.off("update_coupons_counters");
      this.eventBus.off("update_customer_price_list");
      this.eventBus.off("update_customer");
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/ItemsSelector.vue?type=template
  var _hoisted_117 = { class: "dynamic-padding" };
  var _hoisted_29 = { class: "settings-container" };
  var _hoisted_39 = { class: "text-caption text-primary truncate" };
  var _hoisted_46 = {
    key: 0,
    class: "text-caption text-success truncate"
  };
  var _hoisted_56 = { class: "text-caption golden--text truncate" };
  var _hoisted_66 = { key: 1 };
  var _hoisted_75 = { class: "text-primary" };
  var _hoisted_85 = {
    key: 0,
    class: "text-success"
  };
  var _hoisted_95 = { class: "golden--text" };
  function render11(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_progress_linear = resolveComponent("v-progress-linear");
    const _component_v_progress_circular = resolveComponent("v-progress-circular");
    const _component_v_overlay = resolveComponent("v-overlay");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_text_field = resolveComponent("v-text-field");
    const _component_v_col = resolveComponent("v-col");
    const _component_v_checkbox = resolveComponent("v-checkbox");
    const _component_v_spacer = resolveComponent("v-spacer");
    const _component_v_card_title = resolveComponent("v-card-title");
    const _component_v_divider = resolveComponent("v-divider");
    const _component_v_switch = resolveComponent("v-switch");
    const _component_v_card_text = resolveComponent("v-card-text");
    const _component_v_card_actions = resolveComponent("v-card-actions");
    const _component_v_card = resolveComponent("v-card");
    const _component_v_dialog = resolveComponent("v-dialog");
    const _component_v_img = resolveComponent("v-img");
    const _component_v_data_table_virtual = resolveComponent("v-data-table-virtual");
    const _component_v_row = resolveComponent("v-row");
    const _component_v_select = resolveComponent("v-select");
    const _component_v_btn_toggle = resolveComponent("v-btn-toggle");
    const _component_CameraScanner = resolveComponent("CameraScanner");
    return openBlock(), createElementBlock("div", {
      style: normalizeStyle(_ctx.responsiveStyles)
    }, [
      createVNode(_component_v_card, {
        class: normalizeClass(["selection mx-auto my-0 py-0 mt-3 dynamic-card", $options.isDarkTheme ? "" : "bg-grey-lighten-5"]),
        style: normalizeStyle({ height: _ctx.responsiveStyles["--container-height"], maxHeight: _ctx.responsiveStyles["--container-height"], backgroundColor: $options.isDarkTheme ? "#121212" : "" })
      }, {
        default: withCtx(() => [
          createVNode(_component_v_progress_linear, {
            active: _ctx.loading,
            indeterminate: _ctx.loading,
            absolute: "",
            location: "top",
            color: "info"
          }, null, 8, ["active", "indeterminate"]),
          createVNode(_component_v_overlay, {
            "model-value": _ctx.loading,
            class: "align-center justify-center",
            absolute: ""
          }, {
            default: withCtx(() => [
              createVNode(_component_v_progress_circular, {
                indeterminate: "",
                color: "primary",
                size: "48"
              })
            ]),
            _: 1
          }, 8, ["model-value"]),
          createCommentVNode(" Add dynamic-padding wrapper like Invoice component "),
          createBaseVNode("div", _hoisted_117, [
            createVNode(_component_v_row, { class: "items" }, {
              default: withCtx(() => [
                createVNode(_component_v_col, { class: "pb-0" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      clearable: "",
                      autofocus: "",
                      variant: "solo",
                      color: "primary",
                      label: _ctx.frappe._("Search Items"),
                      hint: "Search by item code, serial number, batch no or barcode",
                      "hide-details": "",
                      modelValue: $options.debounce_search,
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $options.debounce_search = $event),
                      onKeydown: [
                        withKeys($options.esc_event, ["esc"]),
                        _cache[1] || (_cache[1] = withKeys(($event) => $options.handleBarcodeSearch(), ["enter"]))
                      ],
                      "onClick:clear": $options.clearSearch,
                      "prepend-inner-icon": "mdi-magnify",
                      onFocus: $options.handleItemSearchFocus,
                      ref: "debounce_search"
                    }, createSlots({ _: 2 }, [
                      _ctx.pos_profile.posa_enable_camera_scanning ? {
                        name: "append-inner",
                        fn: withCtx(() => [
                          createVNode(_component_v_btn, {
                            icon: "mdi-camera",
                            size: "small",
                            color: "primary",
                            variant: "text",
                            onClick: $options.startCameraScanning,
                            title: _ctx.__("Scan with Camera")
                          }, null, 8, ["onClick", "title"])
                        ]),
                        key: "0"
                      } : void 0
                    ]), 1032, ["label", "modelValue", "onKeydown", "onClick:clear", "onFocus"])
                  ]),
                  _: 1
                }),
                _ctx.pos_profile.posa_input_qty ? (openBlock(), createBlock(_component_v_col, {
                  key: 0,
                  cols: "3",
                  class: "pb-0"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      variant: "solo",
                      color: "primary",
                      label: _ctx.frappe._("QTY"),
                      "hide-details": "",
                      modelValue: $options.debounce_qty,
                      "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $options.debounce_qty = $event),
                      type: "text",
                      onKeydown: [
                        withKeys($options.enter_event, ["enter"]),
                        withKeys($options.esc_event, ["esc"])
                      ],
                      onFocus: $options.clearQty
                    }, null, 8, ["label", "modelValue", "onKeydown", "onFocus"])
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true),
                _ctx.pos_profile.posa_new_line ? (openBlock(), createBlock(_component_v_col, {
                  key: 1,
                  cols: "2",
                  class: "pb-0"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_v_checkbox, {
                      modelValue: _ctx.new_line,
                      "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.new_line = $event),
                      color: "accent",
                      value: "true",
                      label: "NLine",
                      density: "default",
                      "hide-details": ""
                    }, null, 8, ["modelValue"])
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true),
                createVNode(_component_v_col, {
                  cols: "12",
                  class: "dynamic-margin-xs"
                }, {
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_29, [
                      createVNode(_component_v_btn, {
                        density: "compact",
                        variant: "text",
                        color: "primary",
                        "prepend-icon": "mdi-cog-outline",
                        onClick: $options.toggleItemSettings,
                        class: "settings-btn"
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.__("Settings")), 1)
                        ]),
                        _: 1
                      }, 8, ["onClick"]),
                      createVNode(_component_v_dialog, {
                        modelValue: _ctx.show_item_settings,
                        "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => _ctx.show_item_settings = $event),
                        "max-width": "400px"
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_v_card, null, {
                            default: withCtx(() => [
                              createVNode(_component_v_card_title, { class: "text-h6 pa-4 d-flex align-center" }, {
                                default: withCtx(() => [
                                  createBaseVNode("span", null, toDisplayString(_ctx.__("Item Selector Settings")), 1),
                                  createVNode(_component_v_spacer),
                                  createVNode(_component_v_btn, {
                                    icon: "mdi-close",
                                    variant: "text",
                                    density: "compact",
                                    onClick: _cache[4] || (_cache[4] = ($event) => _ctx.show_item_settings = false)
                                  })
                                ]),
                                _: 1
                              }),
                              createVNode(_component_v_divider),
                              createVNode(_component_v_card_text, { class: "pa-4" }, {
                                default: withCtx(() => [
                                  createVNode(_component_v_switch, {
                                    modelValue: _ctx.temp_hide_qty_decimals,
                                    "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => _ctx.temp_hide_qty_decimals = $event),
                                    label: _ctx.__("Hide quantity decimals"),
                                    "hide-details": "",
                                    density: "compact",
                                    color: "primary",
                                    class: "mb-2"
                                  }, null, 8, ["modelValue", "label"]),
                                  createVNode(_component_v_switch, {
                                    modelValue: _ctx.temp_hide_zero_rate_items,
                                    "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => _ctx.temp_hide_zero_rate_items = $event),
                                    label: _ctx.__("Hide zero rated items"),
                                    "hide-details": "",
                                    density: "compact",
                                    color: "primary"
                                  }, null, 8, ["modelValue", "label"])
                                ]),
                                _: 1
                              }),
                              createVNode(_component_v_card_actions, { class: "pa-4 pt-0" }, {
                                default: withCtx(() => [
                                  createVNode(_component_v_btn, {
                                    color: "error",
                                    variant: "text",
                                    onClick: $options.cancelItemSettings
                                  }, {
                                    default: withCtx(() => [
                                      createTextVNode(toDisplayString(_ctx.__("Cancel")), 1)
                                    ]),
                                    _: 1
                                  }, 8, ["onClick"]),
                                  createVNode(_component_v_spacer),
                                  createVNode(_component_v_btn, {
                                    color: "primary",
                                    variant: "tonal",
                                    onClick: $options.applyItemSettings
                                  }, {
                                    default: withCtx(() => [
                                      createTextVNode(toDisplayString(_ctx.__("Apply")), 1)
                                    ]),
                                    _: 1
                                  }, 8, ["onClick"])
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }, 8, ["modelValue"])
                    ])
                  ]),
                  _: 1
                }),
                createVNode(_component_v_col, {
                  cols: "12",
                  class: "pt-0 mt-0"
                }, {
                  default: withCtx(() => [
                    _ctx.items_view == "card" ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      fluid: "",
                      class: "items-grid dynamic-scroll",
                      ref: "itemsContainer",
                      style: normalizeStyle({ maxHeight: "calc(" + _ctx.responsiveStyles["--container-height"] + " - 80px)" })
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList($options.filtered_items, (item) => {
                        return openBlock(), createBlock(_component_v_card, {
                          key: item.item_code,
                          hover: "",
                          class: "dynamic-item-card",
                          draggable: true,
                          onDragstart: ($event) => $options.onDragStart($event, item),
                          onDragend: $options.onDragEnd,
                          onClick: ($event) => $options.add_item(item)
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_img, {
                              src: item.image || "/assets/posawesome/js/posapp/components/pos/placeholder-image.png",
                              class: "text-white align-end",
                              gradient: "to bottom, rgba(0,0,0,0), rgba(0,0,0,0.4)",
                              height: "100px"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_v_card_text, { class: "text-caption px-1 pb-0 truncate" }, {
                                  default: withCtx(() => [
                                    createTextVNode(toDisplayString(item.item_name), 1)
                                  ]),
                                  _: 2
                                }, 1024)
                              ]),
                              _: 2
                            }, 1032, ["src"]),
                            createVNode(_component_v_card_text, { class: "text--primary pa-1" }, {
                              default: withCtx(() => [
                                createBaseVNode("div", _hoisted_39, toDisplayString($options.currencySymbol(item.original_currency || _ctx.pos_profile.currency) || "") + " " + toDisplayString($options.format_currency(
                                  item.base_price_list_rate || item.rate,
                                  item.original_currency || _ctx.pos_profile.currency,
                                  $options.ratePrecision(item.base_price_list_rate || item.rate)
                                )), 1),
                                _ctx.pos_profile.posa_allow_multi_currency && _ctx.selected_currency !== _ctx.pos_profile.currency ? (openBlock(), createElementBlock("div", _hoisted_46, toDisplayString($options.currencySymbol(_ctx.selected_currency) || "") + " " + toDisplayString($options.format_currency(
                                  item.rate,
                                  _ctx.selected_currency,
                                  $options.ratePrecision(item.rate)
                                )), 1)) : createCommentVNode("v-if", true),
                                createBaseVNode("div", _hoisted_56, toDisplayString($options.format_number(item.actual_qty, _ctx.hide_qty_decimals ? 0 : 4) || 0) + " " + toDisplayString(item.stock_uom || ""), 1)
                              ]),
                              _: 2
                            }, 1024)
                          ]),
                          _: 2
                        }, 1032, ["onDragstart", "onDragend", "onClick"]);
                      }), 128))
                    ], 4)) : (openBlock(), createElementBlock("div", _hoisted_66, [
                      createVNode(_component_v_data_table_virtual, {
                        headers: $options.headers,
                        items: $options.filtered_items,
                        class: "sleek-data-table overflow-y-auto",
                        style: normalizeStyle({ maxHeight: "calc(" + _ctx.responsiveStyles["--container-height"] + " - 80px)" }),
                        "item-key": "item_code",
                        "onClick:row": $options.click_item_row
                      }, {
                        "item.rate": withCtx(({ item }) => [
                          createBaseVNode("div", null, [
                            createBaseVNode("div", _hoisted_75, toDisplayString($options.currencySymbol(item.original_currency || _ctx.pos_profile.currency)) + " " + toDisplayString($options.format_currency(
                              item.base_price_list_rate || item.rate,
                              item.original_currency || _ctx.pos_profile.currency,
                              $options.ratePrecision(item.base_price_list_rate || item.rate)
                            )), 1),
                            _ctx.pos_profile.posa_allow_multi_currency && _ctx.selected_currency !== _ctx.pos_profile.currency ? (openBlock(), createElementBlock("div", _hoisted_85, toDisplayString($options.currencySymbol(_ctx.selected_currency)) + " " + toDisplayString($options.format_currency(
                              item.rate,
                              _ctx.selected_currency,
                              $options.ratePrecision(item.rate)
                            )), 1)) : createCommentVNode("v-if", true)
                          ])
                        ]),
                        "item.actual_qty": withCtx(({ item }) => [
                          createBaseVNode("span", _hoisted_95, toDisplayString($options.format_number(item.actual_qty, _ctx.hide_qty_decimals ? 0 : 4)), 1)
                        ]),
                        _: 1
                      }, 8, ["headers", "items", "style", "onClick:row"])
                    ]))
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ])
        ]),
        _: 1
      }, 8, ["class", "style"]),
      createVNode(_component_v_card, { class: "cards mb-0 mt-3 dynamic-padding" }, {
        default: withCtx(() => [
          createVNode(_component_v_row, {
            "no-gutters": "",
            align: "center",
            justify: "center",
            class: "dynamic-spacing-sm"
          }, {
            default: withCtx(() => [
              createVNode(_component_v_col, {
                cols: "12",
                class: "mb-2"
              }, {
                default: withCtx(() => [
                  createVNode(_component_v_select, {
                    items: _ctx.items_group,
                    label: _ctx.frappe._("Items Group"),
                    density: "compact",
                    variant: "solo",
                    "hide-details": "",
                    modelValue: _ctx.item_group,
                    "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => _ctx.item_group = $event)
                  }, null, 8, ["items", "label", "modelValue"])
                ]),
                _: 1
              }),
              _ctx.pos_profile.posa_enable_price_list_dropdown ? (openBlock(), createBlock(_component_v_col, {
                key: 0,
                cols: "12",
                class: "mb-2"
              }, {
                default: withCtx(() => [
                  createVNode(_component_v_text_field, {
                    density: "compact",
                    variant: "solo",
                    color: "primary",
                    label: _ctx.frappe._("Price List"),
                    "hide-details": "",
                    "model-value": $options.active_price_list,
                    readonly: ""
                  }, null, 8, ["label", "model-value"])
                ]),
                _: 1
              })) : createCommentVNode("v-if", true),
              createVNode(_component_v_col, {
                cols: "3",
                class: "dynamic-margin-xs"
              }, {
                default: withCtx(() => [
                  createVNode(_component_v_btn_toggle, {
                    modelValue: _ctx.items_view,
                    "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => _ctx.items_view = $event),
                    color: "primary",
                    group: "",
                    density: "compact",
                    rounded: ""
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_v_btn, {
                        size: "small",
                        value: "list"
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.__("List")), 1)
                        ]),
                        _: 1
                      }),
                      createVNode(_component_v_btn, {
                        size: "small",
                        value: "card"
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.__("Card")), 1)
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["modelValue"])
                ]),
                _: 1
              }),
              createVNode(_component_v_col, {
                cols: "5",
                class: "dynamic-margin-xs"
              }, {
                default: withCtx(() => [
                  createVNode(_component_v_btn, {
                    size: "small",
                    block: "",
                    color: "warning",
                    variant: "text",
                    onClick: $options.show_offers,
                    class: "action-btn-consistent"
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.offersCount) + " " + toDisplayString(_ctx.__("Offers")), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick"])
                ]),
                _: 1
              }),
              createVNode(_component_v_col, {
                cols: "4",
                class: "dynamic-margin-xs"
              }, {
                default: withCtx(() => [
                  createVNode(_component_v_btn, {
                    size: "small",
                    block: "",
                    color: "primary",
                    variant: "text",
                    onClick: $options.show_coupons,
                    class: "action-btn-consistent"
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.couponsCount) + " " + toDisplayString(_ctx.__("Coupons")), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick"])
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      }),
      createCommentVNode(" Camera Scanner Component "),
      _ctx.pos_profile.posa_enable_camera_scanning ? (openBlock(), createBlock(_component_CameraScanner, {
        key: 0,
        ref: "cameraScanner",
        "scan-type": _ctx.pos_profile.posa_camera_scan_type || "Both",
        onBarcodeScanned: $options.onBarcodeScanned
      }, null, 8, ["scan-type", "onBarcodeScanned"])) : createCommentVNode("v-if", true)
    ], 4);
  }

  // ../posawesome/posawesome/public/js/posapp/components/pos/ItemsSelector.vue
  ItemsSelector_default.render = render11;
  ItemsSelector_default.__file = "../posawesome/posawesome/public/js/posapp/components/pos/ItemsSelector.vue";
  ItemsSelector_default.__scopeId = "data-v-02d997a2";
  var ItemsSelector_default2 = ItemsSelector_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/UpdateCustomer.vue?type=script
  var UpdateCustomer_default = {
    data: () => ({
      customerDialog: false,
      confirmDialog: false,
      pos_profile: "",
      customer_id: "",
      customer_name: "",
      tax_id: "",
      mobile_no: "",
      address_line1: "",
      city: "",
      country: "Pakistan",
      email_id: "",
      referral_code: "",
      birthday: "",
      birthday_menu: false,
      group: "",
      groups: [],
      territory: "",
      territorys: [],
      genders: [],
      customer_type: "Individual",
      gender: "",
      loyalty_points: null,
      loyalty_program: null,
      countries: [
        "Afghanistan",
        "Australia",
        "Bahrain",
        "Bangladesh",
        "Canada",
        "China",
        "Denmark",
        "France",
        "Germany",
        "India",
        "Indonesia",
        "Italy",
        "Japan",
        "Kuwait",
        "Malaysia",
        "Nepal",
        "Netherlands",
        "New Zealand",
        "Norway",
        "Oman",
        "Pakistan",
        "Philippines",
        "Qatar",
        "Saudi Arabia",
        "Singapore",
        "South Korea",
        "Spain",
        "Sri Lanka",
        "Sweden",
        "Switzerland",
        "Syria",
        "Thailand",
        "United Arab Emirates",
        "United Kingdom",
        "United States",
        "Vietnam",
        "Yemen"
      ]
    }),
    watch: {
      birthday(newVal) {
        if (newVal && /^\d{8}$/.test(newVal)) {
          try {
            const day = newVal.substring(0, 2);
            const month = newVal.substring(2, 4);
            const year = newVal.substring(4);
            this.birthday = `${day}-${month}-${year}`;
            this.updateCalendarDate(day, month, year);
          } catch (error) {
            console.error("Error processing 8-digit date:", error);
          }
        } else if (newVal && /^\d{2}-\d{2}-\d{4}$/.test(newVal)) {
          try {
            const parts = newVal.split("-");
            const day = parts[0];
            const month = parts[1];
            const year = parts[2];
            this.updateCalendarDate(day, month, year);
          } catch (error) {
            console.error("Error processing formatted date:", error);
          }
        }
      },
      birthday_menu(isOpen) {
        if (isOpen && this.birthday && /^\d{2}-\d{2}-\d{4}$/.test(this.birthday)) {
          try {
            const parts = this.birthday.split("-");
            const day = parts[0];
            const month = parts[1];
            const year = parts[2];
            this.$nextTick(() => {
              this.updateCalendarDate(day, month, year);
            });
          } catch (error) {
            console.error("Error updating calendar on menu open:", error);
          }
        }
      }
    },
    computed: {
      isDarkTheme() {
        return this.$theme.current === "dark";
      }
    },
    methods: {
      updateCalendarDate(day, month, year) {
        const wasOpen = this.birthday_menu;
        this.birthday_menu = false;
        this.$nextTick(() => {
          const tempDate = `${year}-${month}-${day}`;
          setTimeout(() => {
            if (this.$refs.birthday_menu) {
              this.$refs.birthday_menu.date = tempDate;
              if (wasOpen) {
                this.birthday_menu = true;
              }
            }
          }, 50);
        });
      },
      confirm_close() {
        if (this.customer_name || this.tax_id || this.mobile_no || this.address_line1 || this.email_id || this.referral_code || this.birthday) {
          this.confirmDialog = true;
        } else {
          this.close_dialog();
        }
      },
      confirmClose() {
        this.confirmDialog = false;
        this.close_dialog();
      },
      close_dialog() {
        this.customerDialog = false;
        this.clear_customer();
      },
      clear_customer() {
        this.customer_name = "";
        this.tax_id = "";
        this.mobile_no = "";
        this.address_line1 = "";
        this.city = "";
        this.country = this.pos_profile && this.pos_profile.posa_default_country || "Pakistan";
        this.email_id = "";
        this.referral_code = "";
        this.birthday = "";
        this.group = frappe.defaults.get_user_default("Customer Group");
        this.territory = frappe.defaults.get_user_default("Territory");
        this.customer_id = "";
        this.customer_type = "Individual";
        this.gender = "";
        this.loyalty_points = null;
        this.loyalty_program = null;
      },
      getCustomerGroups() {
        if (this.groups.length > 0)
          return;
        const vm2 = this;
        frappe.db.get_list("Customer Group", {
          fields: ["name"],
          filters: { is_group: 0 },
          limit: 1e3,
          order_by: "name"
        }).then((data) => {
          if (data.length > 0) {
            data.forEach((el) => {
              vm2.groups.push(el.name);
            });
          }
        });
      },
      getCustomerTerritorys() {
        if (this.territorys.length > 0)
          return;
        const vm2 = this;
        frappe.db.get_list("Territory", {
          fields: ["name"],
          filters: { is_group: 0 },
          limit: 5e3,
          order_by: "name"
        }).then((data) => {
          if (data.length > 0) {
            data.forEach((el) => {
              vm2.territorys.push(el.name);
            });
          }
        });
      },
      getGenders() {
        const vm2 = this;
        frappe.db.get_list("Gender", {
          fields: ["name"],
          page_length: 10
        }).then((data) => {
          if (data.length > 0) {
            data.forEach((el) => {
              vm2.genders.push(el.name);
            });
          }
        });
      },
      formatBirthdayOnInput() {
        if (this.birthday && /^\d{8}$/.test(this.birthday)) {
          try {
            const day = this.birthday.substring(0, 2);
            const month = this.birthday.substring(2, 4);
            const year = this.birthday.substring(4);
            this.birthday = `${day}-${month}-${year}`;
          } catch (error) {
            console.error("Error formatting date:", error);
          }
        }
      },
      submit_dialog() {
        const vm2 = this;
        if (!this.customer_name) {
          frappe.throw(__("Customer Name is required"));
          return;
        }
        if (!this.group) {
          frappe.throw(__("Customer group is required"));
          return;
        }
        if (!this.territory) {
          frappe.throw(__("Customer territory is required"));
          return;
        }
        let formatted_birthday = null;
        if (this.birthday) {
          try {
            if (/^\d{8}$/.test(this.birthday)) {
              const day = this.birthday.substring(0, 2);
              const month = this.birthday.substring(2, 4);
              const year = this.birthday.substring(4);
              formatted_birthday = `${year}-${month}-${day}`;
            } else if (/^\d{1,2}-\d{1,2}-\d{4}$/.test(this.birthday)) {
              const parts = this.birthday.split("-");
              if (parts.length === 3) {
                const day = parts[0].padStart(2, "0");
                const month = parts[1].padStart(2, "0");
                const year = parts[2];
                formatted_birthday = `${year}-${month}-${day}`;
              }
            } else if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(this.birthday)) {
              const parts = this.birthday.split("/");
              if (parts.length === 3) {
                const day = parts[0].padStart(2, "0");
                const month = parts[1].padStart(2, "0");
                const year = parts[2];
                formatted_birthday = `${year}-${month}-${day}`;
              }
            } else if (this.birthday) {
              try {
                const date2 = new Date(this.birthday);
                if (!isNaN(date2.getTime())) {
                  const year = date2.getFullYear();
                  const month = String(date2.getMonth() + 1).padStart(2, "0");
                  const day = String(date2.getDate()).padStart(2, "0");
                  formatted_birthday = `${year}-${month}-${day}`;
                }
              } catch (e) {
                console.error("Failed to parse date:", e);
              }
            }
          } catch (error) {
            console.error("Error formatting date:", error);
            formatted_birthday = null;
          }
        }
        const args = {
          customer_id: this.customer_id,
          customer_name: this.customer_name,
          tax_id: this.tax_id,
          mobile_no: this.mobile_no,
          address_line1: this.address_line1,
          city: this.city,
          country: this.country,
          email_id: this.email_id,
          referral_code: this.referral_code,
          birthday: formatted_birthday || this.birthday,
          customer_group: this.group,
          territory: this.territory,
          customer_type: this.customer_type,
          gender: this.gender
        };
        const apiArgs = __spreadProps(__spreadValues({}, args), {
          company: vm2.pos_profile.company,
          pos_profile_doc: JSON.stringify(vm2.pos_profile),
          method: this.customer_id ? "update" : "create"
        });
        if (isOffline()) {
          saveOfflineCustomer({ args: apiArgs });
          vm2.eventBus.emit("show_message", { title: __("Customer saved offline"), color: "warning" });
          args.name = this.customer_name;
          vm2.eventBus.emit("add_customer_to_list", args);
          vm2.eventBus.emit("set_customer", args.name);
          vm2.close_dialog();
          return;
        }
        frappe.call({
          method: "posawesome.posawesome.api.customers.create_customer",
          args: apiArgs,
          callback: (r) => {
            if (!r.exc && r.message.name) {
              let text = __("Customer created successfully.");
              if (vm2.customer_id) {
                text = __("Customer updated successfully.");
              }
              vm2.eventBus.emit("show_message", {
                title: text,
                color: "success"
              });
              args.name = r.message.name;
              frappe.utils.play_sound("submit");
              vm2.eventBus.emit("add_customer_to_list", args);
              vm2.eventBus.emit("set_customer", r.message.name);
              vm2.eventBus.emit("fetch_customer_details");
              vm2.close_dialog();
            } else {
              frappe.utils.play_sound("error");
              vm2.eventBus.emit("show_message", {
                title: __("Customer creation failed."),
                color: "error"
              });
            }
          }
        });
      },
      onDateSelect() {
        this.birthday_menu = false;
        if (this.birthday) {
          try {
            let dateObj;
            if (typeof this.birthday === "object") {
              dateObj = this.birthday;
            } else if (typeof this.birthday === "string" && (this.birthday.includes("GMT") || this.birthday.includes("T"))) {
              dateObj = new Date(this.birthday);
            } else {
              return;
            }
            const year = dateObj.getFullYear();
            const month = String(dateObj.getMonth() + 1).padStart(2, "0");
            const day = String(dateObj.getDate()).padStart(2, "0");
            this.birthday = `${day}-${month}-${year}`;
          } catch (error) {
            console.error("Error formatting date from picker:", error);
          }
        }
      }
    },
    created: function() {
      this.eventBus.on("open_update_customer", (data) => {
        this.customerDialog = true;
        if (data) {
          this.customer_name = data.customer_name;
          this.customer_id = data.name;
          this.address_line1 = data.address_line1 || "";
          this.city = data.city || "";
          this.country = data.country || this.pos_profile && this.pos_profile.posa_default_country || "Pakistan";
          this.tax_id = data.tax_id;
          this.mobile_no = data.mobile_no;
          this.email_id = data.email_id;
          this.referral_code = data.referral_code;
          this.birthday = data.birthday;
          this.group = data.customer_group;
          this.territory = data.territory;
          this.loyalty_points = data.loyalty_points;
          this.loyalty_program = data.loyalty_program;
          this.gender = data.gender;
        } else {
          this.country = this.pos_profile && this.pos_profile.posa_default_country || "Pakistan";
        }
      });
      this.eventBus.on("register_pos_profile", (data) => {
        this.pos_profile = data.pos_profile;
        this.country = this.pos_profile && this.pos_profile.posa_default_country || "Pakistan";
      });
      this.eventBus.on("payments_register_pos_profile", (data) => {
        this.pos_profile = data.pos_profile;
        this.country = this.pos_profile && this.pos_profile.posa_default_country || "Pakistan";
      });
      this.getCustomerGroups();
      this.getCustomerTerritorys();
      this.getGenders();
      this.group = frappe.defaults.get_user_default("Customer Group");
      this.territory = frappe.defaults.get_user_default("Territory");
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/UpdateCustomer.vue?type=template
  var _hoisted_118 = {
    key: 0,
    class: "text-h5 text-primary"
  };
  var _hoisted_210 = {
    key: 1,
    class: "text-h5 text-primary"
  };
  function render12(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_card_title = resolveComponent("v-card-title");
    const _component_v_text_field = resolveComponent("v-text-field");
    const _component_v_col = resolveComponent("v-col");
    const _component_v_select = resolveComponent("v-select");
    const _component_v_autocomplete = resolveComponent("v-autocomplete");
    const _component_v_row = resolveComponent("v-row");
    const _component_v_container = resolveComponent("v-container");
    const _component_v_card_text = resolveComponent("v-card-text");
    const _component_v_spacer = resolveComponent("v-spacer");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_card_actions = resolveComponent("v-card-actions");
    const _component_v_card = resolveComponent("v-card");
    const _component_v_dialog = resolveComponent("v-dialog");
    return openBlock(), createBlock(_component_v_row, { justify: "center" }, {
      default: withCtx(() => [
        createVNode(_component_v_dialog, {
          modelValue: _ctx.customerDialog,
          "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => _ctx.customerDialog = $event),
          "max-width": "600px",
          persistent: ""
        }, {
          default: withCtx(() => [
            createVNode(_component_v_card, null, {
              default: withCtx(() => [
                createVNode(_component_v_card_title, null, {
                  default: withCtx(() => [
                    _ctx.customer_id ? (openBlock(), createElementBlock("span", _hoisted_118, toDisplayString(_ctx.__("Update Customer")), 1)) : (openBlock(), createElementBlock("span", _hoisted_210, toDisplayString(_ctx.__("Create Customer")), 1))
                  ]),
                  _: 1
                }),
                createVNode(_component_v_card_text, { class: "pa-0" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_container, null, {
                      default: withCtx(() => [
                        createVNode(_component_v_row, null, {
                          default: withCtx(() => [
                            createVNode(_component_v_col, { cols: "12" }, {
                              default: withCtx(() => [
                                createVNode(_component_v_text_field, {
                                  density: "compact",
                                  color: "primary",
                                  label: _ctx.frappe._("Customer Name") + " *",
                                  "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                                  "hide-details": "",
                                  class: "dark-field",
                                  modelValue: _ctx.customer_name,
                                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.customer_name = $event)
                                }, null, 8, ["label", "bg-color", "modelValue"])
                              ]),
                              _: 1
                            }),
                            createVNode(_component_v_col, { cols: "6" }, {
                              default: withCtx(() => [
                                createVNode(_component_v_text_field, {
                                  density: "compact",
                                  color: "primary",
                                  label: _ctx.frappe._("Tax ID"),
                                  "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                                  class: "dark-field",
                                  "hide-details": "",
                                  modelValue: _ctx.tax_id,
                                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.tax_id = $event)
                                }, null, 8, ["label", "bg-color", "modelValue"])
                              ]),
                              _: 1
                            }),
                            createVNode(_component_v_col, { cols: "6" }, {
                              default: withCtx(() => [
                                createVNode(_component_v_text_field, {
                                  density: "compact",
                                  color: "primary",
                                  label: _ctx.frappe._("Mobile No"),
                                  "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                                  class: "dark-field",
                                  "hide-details": "",
                                  modelValue: _ctx.mobile_no,
                                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.mobile_no = $event)
                                }, null, 8, ["label", "bg-color", "modelValue"])
                              ]),
                              _: 1
                            }),
                            createVNode(_component_v_col, { cols: "12" }, {
                              default: withCtx(() => [
                                createVNode(_component_v_text_field, {
                                  density: "compact",
                                  color: "primary",
                                  label: _ctx.__("Address Line 1"),
                                  "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                                  "hide-details": "",
                                  class: "dark-field",
                                  modelValue: _ctx.address_line1,
                                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.address_line1 = $event)
                                }, null, 8, ["label", "bg-color", "modelValue"])
                              ]),
                              _: 1
                            }),
                            createVNode(_component_v_col, {
                              cols: "12",
                              sm: "6"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_v_text_field, {
                                  modelValue: _ctx.city,
                                  "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.city = $event),
                                  variant: "outlined",
                                  density: "compact",
                                  label: _ctx.__("City"),
                                  "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                                  class: "dark-field"
                                }, null, 8, ["modelValue", "label", "bg-color"])
                              ]),
                              _: 1
                            }),
                            createVNode(_component_v_col, {
                              cols: "12",
                              sm: "6"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_v_select, {
                                  modelValue: _ctx.country,
                                  "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => _ctx.country = $event),
                                  items: _ctx.countries,
                                  variant: "outlined",
                                  density: "compact",
                                  label: _ctx.__("Country"),
                                  "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                                  class: "dark-field"
                                }, null, 8, ["modelValue", "items", "label", "bg-color"])
                              ]),
                              _: 1
                            }),
                            createVNode(_component_v_col, { cols: "6" }, {
                              default: withCtx(() => [
                                createVNode(_component_v_text_field, {
                                  density: "compact",
                                  color: "primary",
                                  label: _ctx.frappe._("Email Id"),
                                  "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                                  class: "dark-field",
                                  "hide-details": "",
                                  modelValue: _ctx.email_id,
                                  "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => _ctx.email_id = $event)
                                }, null, 8, ["label", "bg-color", "modelValue"])
                              ]),
                              _: 1
                            }),
                            createVNode(_component_v_col, { cols: "6" }, {
                              default: withCtx(() => [
                                createVNode(_component_v_select, {
                                  density: "compact",
                                  label: "Gender",
                                  items: _ctx.genders,
                                  modelValue: _ctx.gender,
                                  "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => _ctx.gender = $event),
                                  "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                                  class: "dark-field"
                                }, null, 8, ["items", "modelValue", "bg-color"])
                              ]),
                              _: 1
                            }),
                            createVNode(_component_v_col, { cols: "6" }, {
                              default: withCtx(() => [
                                createVNode(_component_v_text_field, {
                                  density: "compact",
                                  color: "primary",
                                  label: _ctx.frappe._("Referral Code"),
                                  "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                                  class: "dark-field",
                                  "hide-details": "",
                                  modelValue: _ctx.referral_code,
                                  "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => _ctx.referral_code = $event)
                                }, null, 8, ["label", "bg-color", "modelValue"])
                              ]),
                              _: 1
                            }),
                            createVNode(_component_v_col, { cols: "6" }, {
                              default: withCtx(() => [
                                createVNode(_component_v_text_field, {
                                  modelValue: _ctx.birthday,
                                  "onUpdate:modelValue": [
                                    _cache[9] || (_cache[9] = ($event) => _ctx.birthday = $event),
                                    $options.formatBirthdayOnInput
                                  ],
                                  label: _ctx.frappe._("Birthday (DD-MM-YYYY)"),
                                  density: "compact",
                                  clearable: "",
                                  "hide-details": "",
                                  color: "primary",
                                  placeholder: "DD-MM-YYYY",
                                  "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                                  class: "dark-field"
                                }, null, 8, ["modelValue", "label", "onUpdate:modelValue", "bg-color"])
                              ]),
                              _: 1
                            }),
                            createVNode(_component_v_col, { cols: "6" }, {
                              default: withCtx(() => [
                                createVNode(_component_v_autocomplete, {
                                  clearable: "",
                                  density: "compact",
                                  "auto-select-first": "",
                                  color: "primary",
                                  label: _ctx.frappe._("Customer Group") + " *",
                                  modelValue: _ctx.group,
                                  "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => _ctx.group = $event),
                                  items: _ctx.groups,
                                  "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                                  class: "dark-field",
                                  "no-data-text": _ctx.__("Group not found"),
                                  "hide-details": "",
                                  required: ""
                                }, null, 8, ["label", "modelValue", "items", "bg-color", "no-data-text"])
                              ]),
                              _: 1
                            }),
                            createVNode(_component_v_col, { cols: "6" }, {
                              default: withCtx(() => [
                                createVNode(_component_v_autocomplete, {
                                  clearable: "",
                                  density: "compact",
                                  "auto-select-first": "",
                                  color: "primary",
                                  label: _ctx.frappe._("Territory") + " *",
                                  modelValue: _ctx.territory,
                                  "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => _ctx.territory = $event),
                                  items: _ctx.territorys,
                                  "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                                  class: "dark-field",
                                  "no-data-text": _ctx.__("Territory not found"),
                                  "hide-details": "",
                                  required: ""
                                }, null, 8, ["label", "modelValue", "items", "bg-color", "no-data-text"])
                              ]),
                              _: 1
                            }),
                            _ctx.loyalty_program ? (openBlock(), createBlock(_component_v_col, {
                              key: 0,
                              cols: "6"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_v_text_field, {
                                  modelValue: _ctx.loyalty_program,
                                  "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => _ctx.loyalty_program = $event),
                                  label: _ctx.frappe._("Loyalty Program"),
                                  density: "compact",
                                  readonly: "",
                                  "hide-details": "",
                                  "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                                  class: "dark-field"
                                }, null, 8, ["modelValue", "label", "bg-color"])
                              ]),
                              _: 1
                            })) : createCommentVNode("v-if", true),
                            _ctx.loyalty_points ? (openBlock(), createBlock(_component_v_col, {
                              key: 1,
                              cols: "6"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_v_text_field, {
                                  modelValue: _ctx.loyalty_points,
                                  "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => _ctx.loyalty_points = $event),
                                  label: _ctx.frappe._("Loyalty Points"),
                                  density: "compact",
                                  readonly: "",
                                  "hide-details": "",
                                  "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                                  class: "dark-field"
                                }, null, 8, ["modelValue", "label", "bg-color"])
                              ]),
                              _: 1
                            })) : createCommentVNode("v-if", true)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                createVNode(_component_v_card_actions, null, {
                  default: withCtx(() => [
                    createVNode(_component_v_spacer),
                    createVNode(_component_v_btn, {
                      color: "error",
                      theme: "dark",
                      onClick: $options.confirm_close
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.__("Close")), 1)
                      ]),
                      _: 1
                    }, 8, ["onClick"]),
                    createVNode(_component_v_btn, {
                      color: "success",
                      theme: "dark",
                      onClick: $options.submit_dialog
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.__("Submit")), 1)
                      ]),
                      _: 1
                    }, 8, ["onClick"])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["modelValue"]),
        createCommentVNode(" Confirmation Dialog "),
        createVNode(_component_v_dialog, {
          modelValue: _ctx.confirmDialog,
          "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => _ctx.confirmDialog = $event),
          "max-width": "400px"
        }, {
          default: withCtx(() => [
            createVNode(_component_v_card, null, {
              default: withCtx(() => [
                createVNode(_component_v_card_title, { class: "text-h5 text-primary" }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.__("Confirm Close")), 1)
                  ]),
                  _: 1
                }),
                createVNode(_component_v_card_text, null, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.__("Are you sure you want to close? All entered data will be lost.")), 1)
                  ]),
                  _: 1
                }),
                createVNode(_component_v_card_actions, null, {
                  default: withCtx(() => [
                    createVNode(_component_v_spacer),
                    createVNode(_component_v_btn, {
                      color: "primary",
                      onClick: _cache[15] || (_cache[15] = ($event) => _ctx.confirmDialog = false)
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.__("Continue Editing")), 1)
                      ]),
                      _: 1
                    }),
                    createVNode(_component_v_btn, {
                      color: "error",
                      onClick: $options.confirmClose
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.__("Yes, Close")), 1)
                      ]),
                      _: 1
                    }, 8, ["onClick"])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]),
      _: 1
    });
  }

  // ../posawesome/posawesome/public/js/posapp/components/pos/UpdateCustomer.vue
  UpdateCustomer_default.render = render12;
  UpdateCustomer_default.__file = "../posawesome/posawesome/public/js/posapp/components/pos/UpdateCustomer.vue";
  UpdateCustomer_default.__scopeId = "data-v-10c4be0d";
  var UpdateCustomer_default2 = UpdateCustomer_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/Customer.vue?type=script
  var Customer_default = {
    props: {
      pos_profile: Object
    },
    data: () => ({
      pos_profile: "",
      customers: [],
      customer: "",
      internalCustomer: null,
      tempSelectedCustomer: null,
      isMenuOpen: false,
      readonly: false,
      customer_info: {},
      loadingCustomers: false,
      customerSearch: ""
    }),
    components: {
      UpdateCustomer: UpdateCustomer_default2
    },
    computed: {
      isDarkTheme() {
        return this.$theme.current === "dark";
      },
      filteredCustomers() {
        const search = this.customerSearch.toLowerCase();
        let results = this.customers;
        if (search) {
          results = results.filter((cust) => {
            return cust.customer_name && cust.customer_name.toLowerCase().includes(search) || cust.tax_id && cust.tax_id.toLowerCase().includes(search) || cust.email_id && cust.email_id.toLowerCase().includes(search) || cust.mobile_no && cust.mobile_no.toLowerCase().includes(search) || cust.name && cust.name.toLowerCase().includes(search);
          });
        }
        return results;
      }
    },
    methods: {
      onCustomerMenuToggle(isOpen) {
        this.isMenuOpen = isOpen;
        if (isOpen) {
          this.internalCustomer = null;
          this.$nextTick(() => {
            setTimeout(() => {
              var _a3, _b;
              const dropdown = (_b = (_a3 = this.$refs.customerDropdown) == null ? void 0 : _a3.$el) == null ? void 0 : _b.querySelector(".v-overlay__content .v-select-list");
              if (dropdown)
                dropdown.scrollTop = 0;
            }, 50);
          });
        } else {
          if (this.tempSelectedCustomer) {
            this.internalCustomer = this.tempSelectedCustomer;
            this.customer = this.tempSelectedCustomer;
            this.eventBus.emit("update_customer", this.customer);
          } else if (this.customer) {
            this.internalCustomer = this.customer;
          }
          this.tempSelectedCustomer = null;
        }
      },
      onCustomerChange(val) {
        this.tempSelectedCustomer = val;
        if (!this.isMenuOpen && val) {
          this.customer = val;
          this.eventBus.emit("update_customer", val);
        }
      },
      onCustomerSearch(val) {
        this.customerSearch = val || "";
      },
      handleEnter(event2) {
        var _a3;
        const inputText = ((_a3 = event2.target.value) == null ? void 0 : _a3.toLowerCase()) || "";
        const matched = this.customers.find((cust) => {
          var _a4, _b;
          return ((_a4 = cust.customer_name) == null ? void 0 : _a4.toLowerCase().includes(inputText)) || ((_b = cust.name) == null ? void 0 : _b.toLowerCase().includes(inputText));
        });
        if (matched) {
          this.tempSelectedCustomer = matched.name;
          this.internalCustomer = matched.name;
          this.customer = matched.name;
          this.eventBus.emit("update_customer", matched.name);
          this.isMenuOpen = false;
          event2.target.blur();
        }
      },
      get_customer_names() {
        var vm2 = this;
        if (this.customers.length > 0)
          return;
        if (vm2.pos_profile.posa_local_storage && getCustomerStorage().length) {
          try {
            vm2.customers = getCustomerStorage();
          } catch (e) {
            console.error("Failed to parse customer cache:", e);
            vm2.customers = [];
          }
        }
        this.loadingCustomers = true;
        frappe.call({
          method: "posawesome.posawesome.api.customers.get_customer_names",
          args: {
            pos_profile: this.pos_profile.pos_profile
          },
          callback: function(r) {
            if (r.message) {
              vm2.customers = r.message;
              if (vm2.pos_profile.posa_local_storage) {
                setCustomerStorage(r.message);
              }
            }
            vm2.loadingCustomers = false;
          },
          error: function(err) {
            console.error("Failed to fetch customers:", err);
            vm2.loadingCustomers = false;
          }
        });
      },
      new_customer() {
        this.eventBus.emit("open_update_customer", null);
      },
      edit_customer() {
        this.eventBus.emit("open_update_customer", this.customer_info);
      }
    },
    created() {
      if (getCustomerStorage().length) {
        try {
          this.customers = getCustomerStorage();
        } catch (e) {
          console.error("Failed to parse customer cache:", e);
          this.customers = [];
        }
      }
      this.$nextTick(() => {
        this.eventBus.on("register_pos_profile", (pos_profile) => {
          this.pos_profile = pos_profile;
          this.get_customer_names();
        });
        this.eventBus.on("payments_register_pos_profile", (pos_profile) => {
          this.pos_profile = pos_profile;
          this.get_customer_names();
        });
        this.eventBus.on("set_customer", (customer) => {
          this.customer = customer;
          this.internalCustomer = customer;
        });
        this.eventBus.on("add_customer_to_list", (customer) => {
          const index = this.customers.findIndex(
            (c) => c.name === customer.name
          );
          if (index !== -1) {
            this.customers.splice(index, 1, customer);
          } else {
            this.customers.push(customer);
          }
          if (this.pos_profile.posa_local_storage) {
            setCustomerStorage(this.customers);
          }
          this.customer = customer.name;
          this.internalCustomer = customer.name;
          this.eventBus.emit("update_customer", customer.name);
        });
        this.eventBus.on("set_customer_readonly", (value) => {
          this.readonly = value;
        });
        this.eventBus.on("set_customer_info_to_edit", (data) => {
          this.customer_info = data;
        });
        this.eventBus.on("fetch_customer_details", () => {
          this.get_customer_names();
        });
      });
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/Customer.vue?type=template
  var _hoisted_119 = { class: "customer-input-wrapper" };
  var _hoisted_211 = ["innerHTML"];
  var _hoisted_310 = ["innerHTML"];
  var _hoisted_47 = ["innerHTML"];
  var _hoisted_57 = ["innerHTML"];
  var _hoisted_67 = ["innerHTML"];
  var _hoisted_76 = { class: "mt-4" };
  function render13(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_icon = resolveComponent("v-icon");
    const _component_v_tooltip = resolveComponent("v-tooltip");
    const _component_v_list_item_subtitle = resolveComponent("v-list-item-subtitle");
    const _component_v_list_item = resolveComponent("v-list-item");
    const _component_v_autocomplete = resolveComponent("v-autocomplete");
    const _component_UpdateCustomer = resolveComponent("UpdateCustomer");
    return openBlock(), createElementBlock(Fragment, null, [
      createCommentVNode(" ? Disable dropdown if either readonly or loadingCustomers is true "),
      createBaseVNode("div", _hoisted_119, [
        createVNode(_component_v_autocomplete, {
          ref: "customerDropdown",
          class: "customer-autocomplete sleek-field",
          density: "compact",
          clearable: "",
          variant: "solo",
          color: "primary",
          label: _ctx.frappe._("Customer"),
          modelValue: _ctx.internalCustomer,
          "onUpdate:modelValue": [
            _cache[2] || (_cache[2] = ($event) => _ctx.internalCustomer = $event),
            $options.onCustomerChange
          ],
          items: $options.filteredCustomers,
          "item-title": "customer_name",
          "item-value": "name",
          "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
          "no-data-text": _ctx.__("Customers not found"),
          "hide-details": "",
          customFilter: () => true,
          disabled: _ctx.readonly || _ctx.loadingCustomers,
          "menu-props": { closeOnContentClick: false },
          "onUpdate:menu": $options.onCustomerMenuToggle,
          "onUpdate:search": $options.onCustomerSearch,
          onKeydown: withKeys($options.handleEnter, ["enter"]),
          "virtual-scroll": true,
          "virtual-scroll-item-height": 48
        }, {
          "prepend-inner": withCtx(() => [
            createVNode(_component_v_tooltip, { text: "Edit customer" }, {
              activator: withCtx(({ props }) => [
                createVNode(_component_v_icon, mergeProps(props, {
                  class: "icon-button",
                  onMousedown: _cache[0] || (_cache[0] = withModifiers(() => {
                  }, ["prevent", "stop"])),
                  onClick: withModifiers($options.edit_customer, ["stop"])
                }), {
                  default: withCtx(() => [
                    createTextVNode(" mdi-account-edit ")
                  ]),
                  _: 2
                }, 1040, ["onClick"])
              ]),
              _: 1
            })
          ]),
          "append-inner": withCtx(() => [
            createVNode(_component_v_tooltip, { text: "Add new customer" }, {
              activator: withCtx(({ props }) => [
                createVNode(_component_v_icon, mergeProps(props, {
                  class: "icon-button",
                  onMousedown: _cache[1] || (_cache[1] = withModifiers(() => {
                  }, ["prevent", "stop"])),
                  onClick: withModifiers($options.new_customer, ["stop"])
                }), {
                  default: withCtx(() => [
                    createTextVNode(" mdi-plus ")
                  ]),
                  _: 2
                }, 1040, ["onClick"])
              ]),
              _: 1
            })
          ]),
          item: withCtx(({ props, item }) => [
            createVNode(_component_v_list_item, normalizeProps(guardReactiveProps(props)), {
              default: withCtx(() => [
                item.raw.customer_name !== item.raw.name ? (openBlock(), createBlock(_component_v_list_item_subtitle, { key: 0 }, {
                  default: withCtx(() => [
                    createBaseVNode("div", {
                      innerHTML: `ID: ${item.raw.name}`
                    }, null, 8, _hoisted_211)
                  ]),
                  _: 2
                }, 1024)) : createCommentVNode("v-if", true),
                item.raw.tax_id ? (openBlock(), createBlock(_component_v_list_item_subtitle, { key: 1 }, {
                  default: withCtx(() => [
                    createBaseVNode("div", {
                      innerHTML: `TAX ID: ${item.raw.tax_id}`
                    }, null, 8, _hoisted_310)
                  ]),
                  _: 2
                }, 1024)) : createCommentVNode("v-if", true),
                item.raw.email_id ? (openBlock(), createBlock(_component_v_list_item_subtitle, { key: 2 }, {
                  default: withCtx(() => [
                    createBaseVNode("div", {
                      innerHTML: `Email: ${item.raw.email_id}`
                    }, null, 8, _hoisted_47)
                  ]),
                  _: 2
                }, 1024)) : createCommentVNode("v-if", true),
                item.raw.mobile_no ? (openBlock(), createBlock(_component_v_list_item_subtitle, { key: 3 }, {
                  default: withCtx(() => [
                    createBaseVNode("div", {
                      innerHTML: `Mobile No: ${item.raw.mobile_no}`
                    }, null, 8, _hoisted_57)
                  ]),
                  _: 2
                }, 1024)) : createCommentVNode("v-if", true),
                item.raw.primary_address ? (openBlock(), createBlock(_component_v_list_item_subtitle, { key: 4 }, {
                  default: withCtx(() => [
                    createBaseVNode("div", {
                      innerHTML: `Primary Address: ${item.raw.primary_address}`
                    }, null, 8, _hoisted_67)
                  ]),
                  _: 2
                }, 1024)) : createCommentVNode("v-if", true)
              ]),
              _: 2
            }, 1040)
          ]),
          _: 1
        }, 8, ["label", "modelValue", "items", "bg-color", "no-data-text", "disabled", "onUpdate:menu", "onUpdate:modelValue", "onUpdate:search", "onKeydown"]),
        createCommentVNode(" Update customer modal "),
        createBaseVNode("div", _hoisted_76, [
          createVNode(_component_UpdateCustomer)
        ])
      ])
    ], 2112);
  }

  // ../posawesome/posawesome/public/js/posapp/components/pos/Customer.vue
  Customer_default.render = render13;
  Customer_default.__file = "../posawesome/posawesome/public/js/posapp/components/pos/Customer.vue";
  Customer_default.__scopeId = "data-v-45726972";
  var Customer_default2 = Customer_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/DeliveryCharges.vue?type=script
  var DeliveryCharges_default = {
    props: {
      pos_profile: Object,
      delivery_charges: Array,
      selected_delivery_charge: [Object, String],
      delivery_charges_rate: Number,
      deliveryChargesFilter: Function,
      formatCurrency: Function,
      currencySymbol: Function,
      readonly: Boolean
    },
    data() {
      return {
        internal_selected_delivery_charge: this.selected_delivery_charge
      };
    },
    watch: {
      selected_delivery_charge(val) {
        this.internal_selected_delivery_charge = val;
      }
    },
    methods: {
      onUpdate(val) {
        this.$emit("update:selected_delivery_charge", val);
      }
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/DeliveryCharges.vue?type=template
  function render14(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_list_item_title = resolveComponent("v-list-item-title");
    const _component_v_list_item_subtitle = resolveComponent("v-list-item-subtitle");
    const _component_v_list_item = resolveComponent("v-list-item");
    const _component_v_autocomplete = resolveComponent("v-autocomplete");
    const _component_v_col = resolveComponent("v-col");
    const _component_v_text_field = resolveComponent("v-text-field");
    const _component_v_row = resolveComponent("v-row");
    return $props.pos_profile.posa_use_delivery_charges ? (openBlock(), createBlock(_component_v_row, {
      key: 0,
      align: "center",
      class: "items px-3 py-2 mt-0"
    }, {
      default: withCtx(() => [
        createVNode(_component_v_col, {
          cols: "8",
          class: "pb-0 mb-0 pr-0 pt-0"
        }, {
          default: withCtx(() => [
            createVNode(_component_v_autocomplete, {
              density: "compact",
              clearable: "",
              "auto-select-first": "",
              variant: "outlined",
              color: "primary",
              label: _ctx.frappe._("Delivery Charges"),
              modelValue: $data.internal_selected_delivery_charge,
              "onUpdate:modelValue": [
                _cache[0] || (_cache[0] = ($event) => $data.internal_selected_delivery_charge = $event),
                $options.onUpdate
              ],
              items: $props.delivery_charges,
              "item-title": "name",
              "item-value": "name",
              "return-object": "",
              "bg-color": "white",
              "no-data-text": _ctx.__("Charges not found"),
              "hide-details": "",
              customFilter: $props.deliveryChargesFilter,
              disabled: $props.readonly
            }, {
              item: withCtx(({ props, item }) => [
                createVNode(_component_v_list_item, normalizeProps(guardReactiveProps(props)), {
                  default: withCtx(() => [
                    createVNode(_component_v_list_item_title, {
                      class: "text-primary text-subtitle-1",
                      innerHTML: item.raw.name
                    }, null, 8, ["innerHTML"]),
                    createVNode(_component_v_list_item_subtitle, {
                      innerHTML: `Rate: ${item.raw.rate}`
                    }, null, 8, ["innerHTML"])
                  ]),
                  _: 2
                }, 1040)
              ]),
              _: 1
            }, 8, ["label", "modelValue", "items", "no-data-text", "customFilter", "disabled", "onUpdate:modelValue"])
          ]),
          _: 1
        }),
        createVNode(_component_v_col, {
          cols: "4",
          class: "pb-0 mb-0 pt-0"
        }, {
          default: withCtx(() => [
            createVNode(_component_v_text_field, {
              density: "compact",
              variant: "outlined",
              color: "primary",
              label: _ctx.frappe._("Delivery Charges Rate"),
              "bg-color": "white",
              "hide-details": "",
              "model-value": $props.formatCurrency($props.delivery_charges_rate),
              prefix: $props.currencySymbol($props.pos_profile.currency),
              disabled: ""
            }, null, 8, ["label", "model-value", "prefix"])
          ]),
          _: 1
        })
      ]),
      _: 1
    })) : createCommentVNode("v-if", true);
  }

  // ../posawesome/posawesome/public/js/posapp/components/pos/DeliveryCharges.vue
  DeliveryCharges_default.render = render14;
  DeliveryCharges_default.__file = "../posawesome/posawesome/public/js/posapp/components/pos/DeliveryCharges.vue";
  var DeliveryCharges_default2 = DeliveryCharges_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/PostingDateRow.vue?type=script
  var PostingDateRow_default = {
    props: {
      pos_profile: Object,
      posting_date_display: String,
      customer_balance: Number,
      formatCurrency: Function,
      priceList: String,
      priceLists: Array
    },
    data() {
      return {
        internal_posting_date_display: this.posting_date_display,
        internal_price_list: this.priceList
      };
    },
    computed: {
      isDarkTheme() {
        var _a3;
        return ((_a3 = this.$theme) == null ? void 0 : _a3.current) === "dark";
      }
    },
    watch: {
      posting_date_display(val) {
        this.internal_posting_date_display = val;
      },
      priceList(val) {
        this.internal_price_list = val;
      }
    },
    methods: {
      onUpdate(val) {
        this.$emit("update:posting_date_display", val);
      },
      onPriceListUpdate(val) {
        this.$emit("update:priceList", val);
      }
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/PostingDateRow.vue?type=template
  var _hoisted_120 = {
    key: 0,
    class: "balance-field ml-3"
  };
  var _hoisted_212 = { class: "balance-value" };
  var _hoisted_311 = { class: "balance-field" };
  var _hoisted_48 = { class: "balance-value" };
  function render15(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_VueDatePicker = resolveComponent("VueDatePicker");
    const _component_v_col = resolveComponent("v-col");
    const _component_v_select = resolveComponent("v-select");
    const _component_v_row = resolveComponent("v-row");
    return $props.pos_profile.posa_allow_change_posting_date ? (openBlock(), createBlock(_component_v_row, {
      key: 0,
      align: "center",
      class: "items px-3 py-2 mt-0"
    }, {
      default: withCtx(() => [
        createVNode(_component_v_col, {
          cols: "4",
          class: "pb-2"
        }, {
          default: withCtx(() => [
            createVNode(_component_VueDatePicker, {
              modelValue: $data.internal_posting_date_display,
              "onUpdate:modelValue": [
                _cache[0] || (_cache[0] = ($event) => $data.internal_posting_date_display = $event),
                $options.onUpdate
              ],
              "model-type": "format",
              format: "dd-MM-yyyy",
              "auto-apply": "",
              placeholder: _ctx.frappe._("Posting Date"),
              dark: $options.isDarkTheme,
              class: "dark-field"
            }, null, 8, ["modelValue", "placeholder", "dark", "onUpdate:modelValue"])
          ]),
          _: 1
        }),
        $props.pos_profile.posa_enable_price_list_dropdown ? (openBlock(), createBlock(_component_v_col, {
          key: 0,
          cols: "6",
          class: "pb-2 d-flex align-center"
        }, {
          default: withCtx(() => [
            createVNode(_component_v_select, {
              density: "comfortable",
              variant: "outlined",
              color: "primary",
              items: $props.priceLists,
              label: _ctx.frappe._("Price List"),
              modelValue: $data.internal_price_list,
              "onUpdate:modelValue": [
                _cache[1] || (_cache[1] = ($event) => $data.internal_price_list = $event),
                $options.onPriceListUpdate
              ],
              "hide-details": "",
              class: "flex-grow-1"
            }, null, 8, ["items", "label", "modelValue", "onUpdate:modelValue"]),
            $props.pos_profile.posa_show_customer_balance ? (openBlock(), createElementBlock("div", _hoisted_120, [
              createBaseVNode("strong", null, toDisplayString(_ctx.__("Customer Balance")) + ":", 1),
              createBaseVNode("span", _hoisted_212, toDisplayString($props.formatCurrency($props.customer_balance)), 1)
            ])) : createCommentVNode("v-if", true)
          ]),
          _: 1
        })) : $props.pos_profile.posa_show_customer_balance ? (openBlock(), createBlock(_component_v_col, {
          key: 1,
          cols: "8",
          class: "pb-2 d-flex align-center"
        }, {
          default: withCtx(() => [
            createBaseVNode("div", _hoisted_311, [
              createBaseVNode("strong", null, toDisplayString(_ctx.__("Customer Balance")) + ":", 1),
              createBaseVNode("span", _hoisted_48, toDisplayString($props.formatCurrency($props.customer_balance)), 1)
            ])
          ]),
          _: 1
        })) : createCommentVNode("v-if", true)
      ]),
      _: 1
    })) : createCommentVNode("v-if", true);
  }

  // ../posawesome/posawesome/public/js/posapp/components/pos/PostingDateRow.vue
  PostingDateRow_default.render = render15;
  PostingDateRow_default.__file = "../posawesome/posawesome/public/js/posapp/components/pos/PostingDateRow.vue";
  PostingDateRow_default.__scopeId = "data-v-b00d5d3d";
  var PostingDateRow_default2 = PostingDateRow_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/MultiCurrencyRow.vue?type=script
  var MultiCurrencyRow_default = {
    props: {
      pos_profile: Object,
      selected_currency: String,
      plc_conversion_rate: Number,
      conversion_rate: Number,
      available_currencies: Array,
      isNumber: Function,
      price_list_currency: String
    },
    data() {
      return {
        internal_selected_currency: this.selected_currency,
        internal_plc_rate: this.plc_conversion_rate,
        internal_conversion_rate: this.conversion_rate
      };
    },
    watch: {
      selected_currency(val) {
        this.internal_selected_currency = val;
      },
      plc_conversion_rate(val) {
        this.internal_plc_rate = val;
      },
      conversion_rate(val) {
        this.internal_conversion_rate = val;
      }
    },
    methods: {
      onCurrencyUpdate(val) {
        this.$emit("update:selected_currency", val);
      },
      onPlcRateChange() {
        this.$emit("update:plc_conversion_rate", this.internal_plc_rate);
      },
      onConversionChange() {
        this.$emit("update:conversion_rate", this.internal_conversion_rate);
      }
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/MultiCurrencyRow.vue?type=template
  function render16(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_select = resolveComponent("v-select");
    const _component_v_col = resolveComponent("v-col");
    const _component_v_text_field = resolveComponent("v-text-field");
    const _component_v_row = resolveComponent("v-row");
    return $props.pos_profile.posa_allow_multi_currency ? (openBlock(), createBlock(_component_v_row, {
      key: 0,
      align: "center",
      class: "items px-3 py-2 mt-0"
    }, {
      default: withCtx(() => [
        createVNode(_component_v_col, {
          cols: "4",
          class: "pb-2"
        }, {
          default: withCtx(() => [
            createVNode(_component_v_select, {
              density: "compact",
              variant: "outlined",
              color: "primary",
              label: _ctx.frappe._("Currency"),
              "bg-color": "white",
              "hide-details": "",
              modelValue: $data.internal_selected_currency,
              "onUpdate:modelValue": [
                _cache[0] || (_cache[0] = ($event) => $data.internal_selected_currency = $event),
                $options.onCurrencyUpdate
              ],
              items: $props.available_currencies
            }, null, 8, ["label", "modelValue", "items", "onUpdate:modelValue"])
          ]),
          _: 1
        }),
        createVNode(_component_v_col, {
          cols: "4",
          class: "pb-2"
        }, {
          default: withCtx(() => [
            createVNode(_component_v_text_field, {
              density: "compact",
              variant: "outlined",
              color: "primary",
              label: "Price List " + $props.price_list_currency + " to " + $data.internal_selected_currency,
              "bg-color": "white",
              "hide-details": "",
              modelValue: $data.internal_plc_rate,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.internal_plc_rate = $event),
              rules: [$props.isNumber],
              onChange: $options.onPlcRateChange
            }, null, 8, ["label", "modelValue", "rules", "onChange"])
          ]),
          _: 1
        }),
        createVNode(_component_v_col, {
          cols: "4",
          class: "pb-2"
        }, {
          default: withCtx(() => [
            createVNode(_component_v_text_field, {
              density: "compact",
              variant: "outlined",
              color: "primary",
              label: _ctx.frappe._("Conversion Rate"),
              "bg-color": "white",
              "hide-details": "",
              modelValue: $data.internal_conversion_rate,
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.internal_conversion_rate = $event),
              rules: [$props.isNumber],
              onChange: $options.onConversionChange
            }, null, 8, ["label", "modelValue", "rules", "onChange"])
          ]),
          _: 1
        })
      ]),
      _: 1
    })) : createCommentVNode("v-if", true);
  }

  // ../posawesome/posawesome/public/js/posapp/components/pos/MultiCurrencyRow.vue
  MultiCurrencyRow_default.render = render16;
  MultiCurrencyRow_default.__file = "../posawesome/posawesome/public/js/posapp/components/pos/MultiCurrencyRow.vue";
  var MultiCurrencyRow_default2 = MultiCurrencyRow_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/CancelSaleDialog.vue?type=script
  var CancelSaleDialog_default = {
    props: {
      modelValue: Boolean
    },
    emits: ["update:modelValue", "confirm"],
    methods: {
      onConfirm() {
        this.$emit("confirm");
      }
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/CancelSaleDialog.vue?type=template
  var _hoisted_121 = { class: "text-h5 text-primary" };
  function render17(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_card_title = resolveComponent("v-card-title");
    const _component_v_card_text = resolveComponent("v-card-text");
    const _component_v_spacer = resolveComponent("v-spacer");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_card_actions = resolveComponent("v-card-actions");
    const _component_v_card = resolveComponent("v-card");
    const _component_v_dialog = resolveComponent("v-dialog");
    return openBlock(), createBlock(_component_v_dialog, {
      "model-value": $props.modelValue,
      "max-width": "330",
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.$emit("update:modelValue", $event))
    }, {
      default: withCtx(() => [
        createVNode(_component_v_card, null, {
          default: withCtx(() => [
            createVNode(_component_v_card_title, { class: "text-h5" }, {
              default: withCtx(() => [
                createBaseVNode("span", _hoisted_121, toDisplayString(_ctx.__("Cancel Sale ?")), 1)
              ]),
              _: 1
            }),
            createVNode(_component_v_card_text, null, {
              default: withCtx(() => [
                createTextVNode(' This would cancel and delete the current sale. To save it as Draft, click the "Save and Clear" instead. ')
              ]),
              _: 1
            }),
            createVNode(_component_v_card_actions, null, {
              default: withCtx(() => [
                createVNode(_component_v_spacer),
                createVNode(_component_v_btn, {
                  color: "error",
                  onClick: $options.onConfirm
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.__("Yes, Cancel sale")), 1)
                  ]),
                  _: 1
                }, 8, ["onClick"]),
                createVNode(_component_v_btn, {
                  color: "warning",
                  onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", false))
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.__("Back")), 1)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["model-value"]);
  }

  // ../posawesome/posawesome/public/js/posapp/components/pos/CancelSaleDialog.vue
  CancelSaleDialog_default.render = render17;
  CancelSaleDialog_default.__file = "../posawesome/posawesome/public/js/posapp/components/pos/CancelSaleDialog.vue";
  var CancelSaleDialog_default2 = CancelSaleDialog_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/InvoiceSummary.vue?type=script
  var InvoiceSummary_default = {
    props: {
      pos_profile: Object,
      total_qty: [Number, String],
      additional_discount: Number,
      additional_discount_percentage: Number,
      total_items_discount_amount: Number,
      subtotal: Number,
      displayCurrency: String,
      formatFloat: Function,
      formatCurrency: Function,
      currencySymbol: Function,
      discount_percentage_offer_name: [String, Number],
      isNumber: Function
    },
    emits: [
      "update:additional_discount",
      "update:additional_discount_percentage",
      "update_discount_umount",
      "save-and-clear",
      "load-drafts",
      "select-order",
      "cancel-sale",
      "open-returns",
      "print-draft",
      "show-payment"
    ],
    computed: {
      isDarkTheme() {
        var _a3;
        return ((_a3 = this.$theme) == null ? void 0 : _a3.current) === "dark";
      },
      hide_qty_decimals() {
        try {
          const saved2 = localStorage.getItem("posawesome_item_selector_settings");
          if (saved2) {
            const opts = JSON.parse(saved2);
            return !!opts.hide_qty_decimals;
          }
        } catch (e) {
          console.error("Failed to load item selector settings:", e);
        }
        return false;
      }
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/InvoiceSummary.vue?type=template
  function render18(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_text_field = resolveComponent("v-text-field");
    const _component_v_col = resolveComponent("v-col");
    const _component_v_row = resolveComponent("v-row");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_card = resolveComponent("v-card");
    return openBlock(), createBlock(_component_v_card, {
      class: normalizeClass(["cards mb-0 mt-3 py-2 px-3 rounded-lg", $options.isDarkTheme ? "" : "bg-grey-lighten-4"]),
      style: normalizeStyle($options.isDarkTheme ? "background-color:#1E1E1E" : "")
    }, {
      default: withCtx(() => [
        createVNode(_component_v_row, { dense: "" }, {
          default: withCtx(() => [
            createCommentVNode(" Summary Info "),
            createVNode(_component_v_col, {
              cols: "12",
              md: "7"
            }, {
              default: withCtx(() => [
                createVNode(_component_v_row, { dense: "" }, {
                  default: withCtx(() => [
                    createCommentVNode(" Total Qty "),
                    createVNode(_component_v_col, { cols: "6" }, {
                      default: withCtx(() => [
                        createVNode(_component_v_text_field, {
                          "model-value": $props.formatFloat($props.total_qty, $options.hide_qty_decimals ? 0 : void 0),
                          label: _ctx.frappe._("Total Qty"),
                          "prepend-inner-icon": "mdi-format-list-numbered",
                          variant: "solo",
                          density: "compact",
                          readonly: "",
                          color: "accent"
                        }, null, 8, ["model-value", "label"])
                      ]),
                      _: 1
                    }),
                    createCommentVNode(" Additional Discount (Amount or Percentage) "),
                    !$props.pos_profile.posa_use_percentage_discount ? (openBlock(), createBlock(_component_v_col, {
                      key: 0,
                      cols: "6"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_v_text_field, {
                          "model-value": $props.additional_discount,
                          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:additional_discount", $event)),
                          label: _ctx.frappe._("Additional Discount"),
                          "prepend-inner-icon": "mdi-cash-minus",
                          variant: "solo",
                          density: "compact",
                          color: "warning",
                          prefix: $props.currencySymbol($props.pos_profile.currency),
                          disabled: !$props.pos_profile.posa_allow_user_to_edit_additional_discount || !!$props.discount_percentage_offer_name
                        }, null, 8, ["model-value", "label", "prefix", "disabled"])
                      ]),
                      _: 1
                    })) : (openBlock(), createBlock(_component_v_col, {
                      key: 1,
                      cols: "6"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_v_text_field, {
                          "model-value": $props.additional_discount_percentage,
                          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.$emit("update:additional_discount_percentage", $event)),
                          onChange: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("update_discount_umount")),
                          rules: [$props.isNumber],
                          label: _ctx.frappe._("Additional Discount %"),
                          suffix: "%",
                          "prepend-inner-icon": "mdi-percent",
                          variant: "solo",
                          density: "compact",
                          color: "warning",
                          disabled: !$props.pos_profile.posa_allow_user_to_edit_additional_discount || !!$props.discount_percentage_offer_name
                        }, null, 8, ["model-value", "rules", "label", "disabled"])
                      ]),
                      _: 1
                    })),
                    createCommentVNode(" Items Discount "),
                    createVNode(_component_v_col, { cols: "6" }, {
                      default: withCtx(() => [
                        createVNode(_component_v_text_field, {
                          "model-value": $props.formatCurrency($props.total_items_discount_amount),
                          prefix: $props.currencySymbol($props.displayCurrency),
                          label: _ctx.frappe._("Items Discounts"),
                          "prepend-inner-icon": "mdi-tag-minus",
                          variant: "solo",
                          density: "compact",
                          color: "warning",
                          readonly: ""
                        }, null, 8, ["model-value", "prefix", "label"])
                      ]),
                      _: 1
                    }),
                    createCommentVNode(" Total (moved to maintain row alignment) "),
                    createVNode(_component_v_col, { cols: "6" }, {
                      default: withCtx(() => [
                        createVNode(_component_v_text_field, {
                          "model-value": $props.formatCurrency($props.subtotal),
                          prefix: $props.currencySymbol($props.displayCurrency),
                          label: _ctx.frappe._("Total"),
                          "prepend-inner-icon": "mdi-cash",
                          variant: "solo",
                          density: "compact",
                          readonly: "",
                          color: "success"
                        }, null, 8, ["model-value", "prefix", "label"])
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            createCommentVNode(" Action Buttons "),
            createVNode(_component_v_col, {
              cols: "12",
              md: "5"
            }, {
              default: withCtx(() => [
                createVNode(_component_v_row, { dense: "" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_col, { cols: "6" }, {
                      default: withCtx(() => [
                        createVNode(_component_v_btn, {
                          block: "",
                          color: "accent",
                          theme: "dark",
                          "prepend-icon": "mdi-content-save",
                          onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("save-and-clear"))
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(_ctx.__("Save & Clear")), 1)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    createVNode(_component_v_col, { cols: "6" }, {
                      default: withCtx(() => [
                        createVNode(_component_v_btn, {
                          block: "",
                          color: "warning",
                          theme: "dark",
                          "prepend-icon": "mdi-file-document",
                          onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("load-drafts")),
                          class: "white-text-btn"
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(_ctx.__("Load Drafts")), 1)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    $props.pos_profile.custom_allow_select_sales_order == 1 ? (openBlock(), createBlock(_component_v_col, {
                      key: 0,
                      cols: "6"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_v_btn, {
                          block: "",
                          color: "info",
                          theme: "dark",
                          "prepend-icon": "mdi-book-search",
                          onClick: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("select-order"))
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(_ctx.__("Select S.O")), 1)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })) : createCommentVNode("v-if", true),
                    createVNode(_component_v_col, { cols: "6" }, {
                      default: withCtx(() => [
                        createVNode(_component_v_btn, {
                          block: "",
                          color: "error",
                          theme: "dark",
                          "prepend-icon": "mdi-close-circle",
                          onClick: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("cancel-sale"))
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(_ctx.__("Cancel Sale")), 1)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    $props.pos_profile.posa_allow_return == 1 ? (openBlock(), createBlock(_component_v_col, {
                      key: 1,
                      cols: "6"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_v_btn, {
                          block: "",
                          color: "secondary",
                          theme: "dark",
                          "prepend-icon": "mdi-backup-restore",
                          onClick: _cache[7] || (_cache[7] = ($event) => _ctx.$emit("open-returns"))
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(_ctx.__("Sales Return")), 1)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })) : createCommentVNode("v-if", true),
                    $props.pos_profile.posa_allow_print_draft_invoices ? (openBlock(), createBlock(_component_v_col, {
                      key: 2,
                      cols: "6"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_v_btn, {
                          block: "",
                          color: "primary",
                          theme: "dark",
                          "prepend-icon": "mdi-printer",
                          onClick: _cache[8] || (_cache[8] = ($event) => _ctx.$emit("print-draft"))
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(_ctx.__("Print Draft")), 1)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })) : createCommentVNode("v-if", true),
                    createVNode(_component_v_col, { cols: "12" }, {
                      default: withCtx(() => [
                        createVNode(_component_v_btn, {
                          block: "",
                          color: "success",
                          theme: "dark",
                          size: "large",
                          "prepend-icon": "mdi-credit-card",
                          onClick: _cache[9] || (_cache[9] = ($event) => _ctx.$emit("show-payment"))
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(_ctx.__("PAY")), 1)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["class", "style"]);
  }

  // ../posawesome/posawesome/public/js/posapp/components/pos/InvoiceSummary.vue
  InvoiceSummary_default.render = render18;
  InvoiceSummary_default.__file = "../posawesome/posawesome/public/js/posapp/components/pos/InvoiceSummary.vue";
  InvoiceSummary_default.__scopeId = "data-v-ab85018a";
  var InvoiceSummary_default2 = InvoiceSummary_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/ItemsTable.vue?type=script
  var ItemsTable_default = {
    name: "ItemsTable",
    props: {
      headers: Array,
      items: Array,
      expanded: Array,
      itemsPerPage: Number,
      itemSearch: String,
      pos_profile: Object,
      invoice_doc: Object,
      invoiceType: String,
      displayCurrency: String,
      formatFloat: Function,
      formatCurrency: Function,
      currencySymbol: Function,
      isNumber: Function,
      setFormatedQty: Function,
      calcStockQty: Function,
      setFormatedCurrency: Function,
      calcPrices: Function,
      calcUom: Function,
      setSerialNo: Function,
      setBatchQty: Function,
      validateDueDate: Function,
      removeItem: Function,
      subtractOne: Function,
      addOne: Function,
      isReturnInvoice: Boolean,
      toggleOffer: Function
    },
    data() {
      return {
        draggedItem: null,
        draggedIndex: null,
        dragOverIndex: null,
        isDragging: false
      };
    },
    computed: {
      headerProps() {
        return this.isDarkTheme ? { style: "background-color:#121212;color:#fff" } : {};
      },
      isDarkTheme() {
        return this.$theme.current === "dark";
      },
      hide_qty_decimals() {
        try {
          const saved2 = localStorage.getItem("posawesome_item_selector_settings");
          if (saved2) {
            const opts = JSON.parse(saved2);
            return !!opts.hide_qty_decimals;
          }
        } catch (e) {
          console.error("Failed to load item selector settings:", e);
        }
        return false;
      }
    },
    methods: {
      onDragOverFromSelector(event2) {
        const dragData = event2.dataTransfer.types.includes("application/json");
        if (dragData) {
          event2.preventDefault();
          event2.dataTransfer.dropEffect = "copy";
        }
      },
      onDragEnterFromSelector(event2) {
        this.$emit("show-drop-feedback", true);
      },
      onDragLeaveFromSelector(event2) {
        if (!event2.currentTarget.contains(event2.relatedTarget)) {
          this.$emit("show-drop-feedback", false);
        }
      },
      onDropFromSelector(event2) {
        event2.preventDefault();
        try {
          const dragData = JSON.parse(event2.dataTransfer.getData("application/json"));
          if (dragData.type === "item-from-selector") {
            this.$emit("add-item-from-drag", dragData.item);
            this.$emit("item-dropped", false);
          }
        } catch (error) {
          console.error("Error parsing drag data:", error);
        }
      }
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/ItemsTable.vue?type=template
  var _hoisted_126 = { class: "amount-value" };
  var _hoisted_213 = { class: "currency-display" };
  var _hoisted_312 = { class: "currency-symbol" };
  var _hoisted_49 = { class: "amount-value" };
  var _hoisted_58 = { class: "currency-display" };
  var _hoisted_68 = { class: "currency-symbol" };
  var _hoisted_77 = { class: "amount-value" };
  var _hoisted_86 = { class: "amount-value" };
  var _hoisted_96 = { class: "currency-display" };
  var _hoisted_105 = { class: "currency-symbol" };
  var _hoisted_1110 = { class: "amount-value" };
  var _hoisted_127 = { class: "currency-display" };
  var _hoisted_136 = { class: "currency-symbol" };
  var _hoisted_144 = { class: "amount-value" };
  var _hoisted_154 = ["colspan"];
  var _hoisted_164 = { class: "expanded-content" };
  var _hoisted_174 = { class: "action-panel" };
  var _hoisted_184 = { class: "action-button-group" };
  var _hoisted_194 = { class: "action-label" };
  var _hoisted_203 = { class: "action-button-group" };
  var _hoisted_214 = { class: "action-label" };
  var _hoisted_222 = { class: "action-label" };
  var _hoisted_232 = { class: "item-details-form" };
  var _hoisted_242 = { class: "form-row" };
  var _hoisted_252 = { class: "form-field" };
  var _hoisted_262 = { class: "form-field" };
  var _hoisted_272 = { class: "form-field" };
  var _hoisted_282 = { class: "form-row" };
  var _hoisted_292 = { class: "form-field" };
  var _hoisted_30 = { class: "form-field" };
  var _hoisted_31 = { class: "form-field" };
  var _hoisted_322 = { class: "form-row" };
  var _hoisted_332 = { class: "form-field" };
  var _hoisted_342 = { class: "form-field" };
  var _hoisted_352 = { class: "form-field" };
  var _hoisted_362 = { class: "form-row" };
  var _hoisted_372 = { class: "form-field" };
  var _hoisted_382 = { class: "form-field" };
  var _hoisted_392 = {
    key: 0,
    class: "form-field"
  };
  var _hoisted_40 = {
    key: 0,
    class: "form-section"
  };
  var _hoisted_41 = { class: "form-row" };
  var _hoisted_422 = { class: "form-field" };
  var _hoisted_432 = { class: "form-row" };
  var _hoisted_442 = { class: "form-field full-width" };
  var _hoisted_452 = {
    key: 1,
    class: "form-section"
  };
  var _hoisted_462 = { class: "form-row" };
  var _hoisted_472 = { class: "form-field" };
  var _hoisted_482 = { class: "form-field" };
  var _hoisted_492 = { class: "form-field" };
  var _hoisted_50 = {
    key: 2,
    class: "form-section"
  };
  var _hoisted_51 = { class: "form-row" };
  var _hoisted_522 = { class: "form-field" };
  var _hoisted_532 = { class: "form-row" };
  var _hoisted_542 = { class: "form-field" };
  var _hoisted_552 = { class: "form-field" };
  var _hoisted_562 = { class: "form-field" };
  function render19(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_checkbox_btn = resolveComponent("v-checkbox-btn");
    const _component_v_icon = resolveComponent("v-icon");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_text_field = resolveComponent("v-text-field");
    const _component_v_select = resolveComponent("v-select");
    const _component_v_checkbox = resolveComponent("v-checkbox");
    const _component_v_autocomplete = resolveComponent("v-autocomplete");
    const _component_v_list_item_title = resolveComponent("v-list-item-title");
    const _component_v_list_item_subtitle = resolveComponent("v-list-item-subtitle");
    const _component_v_list_item = resolveComponent("v-list-item");
    const _component_VueDatePicker = resolveComponent("VueDatePicker");
    const _component_v_data_table_virtual = resolveComponent("v-data-table-virtual");
    return openBlock(), createElementBlock("div", {
      class: "my-0 py-0 overflow-y-auto items-table-container",
      style: normalizeStyle({ height: "calc(var(--container-height) - 80px)", maxHeight: "calc(var(--container-height) - 80px)" }),
      onDragover: _cache[1] || (_cache[1] = ($event) => $options.onDragOverFromSelector($event)),
      onDrop: _cache[2] || (_cache[2] = ($event) => $options.onDropFromSelector($event)),
      onDragenter: _cache[3] || (_cache[3] = (...args) => $options.onDragEnterFromSelector && $options.onDragEnterFromSelector(...args)),
      onDragleave: _cache[4] || (_cache[4] = (...args) => $options.onDragLeaveFromSelector && $options.onDragLeaveFromSelector(...args))
    }, [
      createVNode(_component_v_data_table_virtual, {
        headers: $props.headers,
        items: $props.items,
        theme: _ctx.$theme.current,
        expanded: $props.expanded,
        "show-expand": "",
        "item-value": "posa_row_id",
        class: "modern-items-table elevation-2",
        "items-per-page": $props.itemsPerPage,
        "expand-on-click": "",
        density: "compact",
        "hide-default-footer": "",
        "single-expand": true,
        "header-props": $options.headerProps,
        "onUpdate:expanded": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:expanded", $event)),
        search: $props.itemSearch
      }, {
        "item.qty": withCtx(({ item }) => [
          createBaseVNode("div", _hoisted_126, toDisplayString($props.formatFloat(item.qty, $options.hide_qty_decimals ? 0 : void 0)), 1)
        ]),
        "item.rate": withCtx(({ item }) => [
          createBaseVNode("div", _hoisted_213, [
            createBaseVNode("span", _hoisted_312, toDisplayString($props.currencySymbol($props.displayCurrency)), 1),
            createBaseVNode("span", _hoisted_49, toDisplayString($props.formatCurrency(item.rate)), 1)
          ])
        ]),
        "item.amount": withCtx(({ item }) => [
          createBaseVNode("div", _hoisted_58, [
            createBaseVNode("span", _hoisted_68, toDisplayString($props.currencySymbol($props.displayCurrency)), 1),
            createBaseVNode("span", _hoisted_77, toDisplayString($props.formatCurrency(item.qty * item.rate)), 1)
          ])
        ]),
        "item.discount_value": withCtx(({ item }) => [
          createBaseVNode("div", _hoisted_86, toDisplayString($props.formatFloat(item.discount_percentage || (item.price_list_rate ? item.discount_amount / item.price_list_rate * 100 : 0))) + "% ", 1)
        ]),
        "item.discount_amount": withCtx(({ item }) => [
          createBaseVNode("div", _hoisted_96, [
            createBaseVNode("span", _hoisted_105, toDisplayString($props.currencySymbol($props.displayCurrency)), 1),
            createBaseVNode("span", _hoisted_1110, toDisplayString($props.formatCurrency(item.discount_amount || 0)), 1)
          ])
        ]),
        "item.price_list_rate": withCtx(({ item }) => [
          createBaseVNode("div", _hoisted_127, [
            createBaseVNode("span", _hoisted_136, toDisplayString($props.currencySymbol($props.displayCurrency)), 1),
            createBaseVNode("span", _hoisted_144, toDisplayString($props.formatCurrency(item.price_list_rate)), 1)
          ])
        ]),
        "item.posa_is_offer": withCtx(({ item }) => [
          createVNode(_component_v_checkbox_btn, {
            modelValue: item.posa_is_offer,
            "onUpdate:modelValue": ($event) => item.posa_is_offer = $event,
            class: "center",
            onChange: ($event) => $props.toggleOffer(item)
          }, null, 8, ["modelValue", "onUpdate:modelValue", "onChange"])
        ]),
        "expanded-row": withCtx(({ item }) => [
          createBaseVNode("td", {
            colspan: $props.headers.length,
            class: "ma-0 pa-0"
          }, [
            createBaseVNode("div", _hoisted_164, [
              createCommentVNode(" Action buttons with improved layout and visual feedback "),
              createBaseVNode("div", _hoisted_174, [
                createBaseVNode("div", _hoisted_184, [
                  createVNode(_component_v_btn, {
                    disabled: !!item.posa_is_replace,
                    icon: "mdi-trash-can-outline",
                    size: "large",
                    color: "error",
                    variant: "tonal",
                    class: "item-action-btn delete-btn",
                    onClick: withModifiers(($event) => $props.removeItem(item), ["stop"])
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_v_icon, { size: "large" }, {
                        default: withCtx(() => [
                          createTextVNode("mdi-trash-can-outline")
                        ]),
                        _: 1
                      }),
                      createBaseVNode("span", _hoisted_194, toDisplayString(_ctx.__("Remove")), 1)
                    ]),
                    _: 2
                  }, 1032, ["disabled", "onClick"])
                ]),
                createBaseVNode("div", _hoisted_203, [
                  createVNode(_component_v_btn, {
                    disabled: !!item.posa_is_replace,
                    size: "large",
                    color: "warning",
                    variant: "tonal",
                    class: "item-action-btn minus-btn",
                    onClick: withModifiers(($event) => $props.subtractOne(item), ["stop"])
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_v_icon, { size: "large" }, {
                        default: withCtx(() => [
                          createTextVNode("mdi-minus-circle-outline")
                        ]),
                        _: 1
                      }),
                      createBaseVNode("span", _hoisted_214, toDisplayString(_ctx.__("Decrease")), 1)
                    ]),
                    _: 2
                  }, 1032, ["disabled", "onClick"]),
                  createVNode(_component_v_btn, {
                    disabled: !!item.posa_is_replace,
                    size: "large",
                    color: "success",
                    variant: "tonal",
                    class: "item-action-btn plus-btn",
                    onClick: withModifiers(($event) => $props.addOne(item), ["stop"])
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_v_icon, { size: "large" }, {
                        default: withCtx(() => [
                          createTextVNode("mdi-plus-circle-outline")
                        ]),
                        _: 1
                      }),
                      createBaseVNode("span", _hoisted_222, toDisplayString(_ctx.__("Increase")), 1)
                    ]),
                    _: 2
                  }, 1032, ["disabled", "onClick"])
                ])
              ]),
              createCommentVNode(" Item details form with all fields "),
              createBaseVNode("div", _hoisted_232, [
                createCommentVNode(" First row of fields "),
                createBaseVNode("div", _hoisted_242, [
                  createBaseVNode("div", _hoisted_252, [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      variant: "outlined",
                      color: "primary",
                      label: _ctx.frappe._("Item Code"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "hide-details": "",
                      modelValue: item.item_code,
                      "onUpdate:modelValue": ($event) => item.item_code = $event,
                      disabled: "",
                      "prepend-inner-icon": "mdi-barcode"
                    }, null, 8, ["label", "bg-color", "modelValue", "onUpdate:modelValue"])
                  ]),
                  createBaseVNode("div", _hoisted_262, [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      variant: "outlined",
                      color: "primary",
                      label: _ctx.frappe._("QTY"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "hide-details": "",
                      "model-value": $props.formatFloat(item.qty, $options.hide_qty_decimals ? 0 : void 0),
                      onChange: ($event) => [
                        $props.setFormatedQty(item, "qty", null, false, $event.target.value),
                        $props.calcStockQty(item, item.qty)
                      ],
                      rules: [$props.isNumber],
                      disabled: !!item.posa_is_replace,
                      "prepend-inner-icon": "mdi-numeric"
                    }, null, 8, ["label", "bg-color", "model-value", "onChange", "rules", "disabled"])
                  ]),
                  createBaseVNode("div", _hoisted_272, [
                    createVNode(_component_v_select, {
                      density: "compact",
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      label: _ctx.frappe._("UOM"),
                      modelValue: item.uom,
                      "onUpdate:modelValue": [($event) => item.uom = $event, ($event) => $props.calcUom(item, $event)],
                      items: item.item_uoms,
                      variant: "outlined",
                      "item-title": "uom",
                      "item-value": "uom",
                      "hide-details": "",
                      disabled: !!item.posa_is_replace || $props.isReturnInvoice && $props.invoice_doc.return_against,
                      "prepend-inner-icon": "mdi-weight"
                    }, null, 8, ["bg-color", "label", "modelValue", "onUpdate:modelValue", "items", "disabled"])
                  ])
                ]),
                createCommentVNode(" Second row of fields "),
                createBaseVNode("div", _hoisted_282, [
                  createBaseVNode("div", _hoisted_292, [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      variant: "outlined",
                      color: "primary",
                      id: "rate",
                      label: _ctx.frappe._("Rate"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "hide-details": "",
                      "model-value": $props.formatCurrency(item.rate),
                      onChange: ($event) => [
                        $props.setFormatedCurrency(item, "rate", null, false, $event),
                        $props.calcPrices(item, $event.target.value, $event)
                      ],
                      disabled: !!item.posa_is_replace || !!item.posa_offer_applied,
                      "prepend-inner-icon": "mdi-currency-usd"
                    }, null, 8, ["label", "bg-color", "model-value", "onChange", "disabled"])
                  ]),
                  createBaseVNode("div", _hoisted_30, [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      variant: "outlined",
                      color: "primary",
                      id: "discount_percentage",
                      label: _ctx.frappe._("Discount %"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "hide-details": "",
                      "model-value": $props.formatFloat(item.discount_percentage || 0),
                      onChange: ($event) => [
                        $props.setFormatedCurrency(item, "discount_percentage", null, false, $event),
                        $props.calcPrices(item, $event.target.value, $event)
                      ],
                      disabled: !!item.posa_is_replace || !!item.posa_offer_applied,
                      "prepend-inner-icon": "mdi-percent"
                    }, null, 8, ["label", "bg-color", "model-value", "onChange", "disabled"])
                  ]),
                  createBaseVNode("div", _hoisted_31, [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      variant: "outlined",
                      color: "primary",
                      id: "discount_amount",
                      label: _ctx.frappe._("Discount Amount"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "hide-details": "",
                      "model-value": $props.formatCurrency(item.discount_amount || 0),
                      onChange: ($event) => [
                        $props.setFormatedCurrency(item, "discount_amount", null, false, $event),
                        $props.calcPrices(item, $event.target.value, $event)
                      ],
                      disabled: !!item.posa_is_replace || !!item.posa_offer_applied,
                      "prepend-inner-icon": "mdi-tag-minus"
                    }, null, 8, ["label", "bg-color", "model-value", "onChange", "disabled"])
                  ])
                ]),
                createCommentVNode(" Third row of fields "),
                createBaseVNode("div", _hoisted_322, [
                  createBaseVNode("div", _hoisted_332, [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      variant: "outlined",
                      color: "primary",
                      label: _ctx.frappe._("Price list Rate"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "hide-details": "",
                      "model-value": $props.formatCurrency(item.price_list_rate),
                      disabled: "",
                      prefix: $props.currencySymbol($props.pos_profile.currency)
                    }, null, 8, ["label", "bg-color", "model-value", "prefix"])
                  ]),
                  createBaseVNode("div", _hoisted_342, [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      variant: "outlined",
                      color: "primary",
                      label: _ctx.frappe._("Available QTY"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "hide-details": "",
                      "model-value": $props.formatFloat(item.actual_qty),
                      disabled: ""
                    }, null, 8, ["label", "bg-color", "model-value"])
                  ]),
                  createBaseVNode("div", _hoisted_352, [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      variant: "outlined",
                      color: "primary",
                      label: _ctx.frappe._("Group"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "hide-details": "",
                      modelValue: item.item_group,
                      "onUpdate:modelValue": ($event) => item.item_group = $event,
                      disabled: ""
                    }, null, 8, ["label", "bg-color", "modelValue", "onUpdate:modelValue"])
                  ])
                ]),
                createCommentVNode(" Fourth row of fields "),
                createBaseVNode("div", _hoisted_362, [
                  createBaseVNode("div", _hoisted_372, [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      variant: "outlined",
                      color: "primary",
                      label: _ctx.frappe._("Stock QTY"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "hide-details": "",
                      "model-value": $props.formatFloat(item.stock_qty),
                      disabled: ""
                    }, null, 8, ["label", "bg-color", "model-value"])
                  ]),
                  createBaseVNode("div", _hoisted_382, [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      variant: "outlined",
                      color: "primary",
                      label: _ctx.frappe._("Stock UOM"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "hide-details": "",
                      modelValue: item.stock_uom,
                      "onUpdate:modelValue": ($event) => item.stock_uom = $event,
                      disabled: ""
                    }, null, 8, ["label", "bg-color", "modelValue", "onUpdate:modelValue"])
                  ]),
                  item.posa_offer_applied ? (openBlock(), createElementBlock("div", _hoisted_392, [
                    createVNode(_component_v_checkbox, {
                      density: "compact",
                      label: _ctx.frappe._("Offer Applied"),
                      modelValue: item.posa_offer_applied,
                      "onUpdate:modelValue": ($event) => item.posa_offer_applied = $event,
                      readonly: "",
                      "hide-details": "",
                      class: "mt-1"
                    }, null, 8, ["label", "modelValue", "onUpdate:modelValue"])
                  ])) : createCommentVNode("v-if", true)
                ]),
                createCommentVNode(" Serial Number Section "),
                item.has_serial_no == 1 || item.serial_no ? (openBlock(), createElementBlock("div", _hoisted_40, [
                  createBaseVNode("div", _hoisted_41, [
                    createBaseVNode("div", _hoisted_422, [
                      createVNode(_component_v_text_field, {
                        density: "compact",
                        variant: "outlined",
                        color: "primary",
                        label: _ctx.frappe._("Serial No QTY"),
                        "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                        class: "dark-field",
                        "hide-details": "",
                        modelValue: item.serial_no_selected_count,
                        "onUpdate:modelValue": ($event) => item.serial_no_selected_count = $event,
                        type: "number",
                        disabled: ""
                      }, null, 8, ["label", "bg-color", "modelValue", "onUpdate:modelValue"])
                    ])
                  ]),
                  createBaseVNode("div", _hoisted_432, [
                    createBaseVNode("div", _hoisted_442, [
                      createVNode(_component_v_autocomplete, {
                        modelValue: item.serial_no_selected,
                        "onUpdate:modelValue": [($event) => item.serial_no_selected = $event, ($event) => $props.setSerialNo(item)],
                        items: item.serial_no_data,
                        "item-title": "serial_no",
                        "item-value": "serial_no",
                        variant: "outlined",
                        density: "compact",
                        chips: "",
                        color: "primary",
                        "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                        class: "dark-field",
                        label: _ctx.frappe._("Serial No"),
                        multiple: ""
                      }, null, 8, ["modelValue", "onUpdate:modelValue", "items", "bg-color", "label"])
                    ])
                  ])
                ])) : createCommentVNode("v-if", true),
                createCommentVNode(" Batch Number Section "),
                item.has_batch_no == 1 || item.batch_no ? (openBlock(), createElementBlock("div", _hoisted_452, [
                  createBaseVNode("div", _hoisted_462, [
                    createBaseVNode("div", _hoisted_472, [
                      createVNode(_component_v_text_field, {
                        density: "compact",
                        variant: "outlined",
                        color: "primary",
                        label: _ctx.frappe._("Batch No. Available QTY"),
                        "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                        class: "dark-field",
                        "hide-details": "",
                        "model-value": $props.formatFloat(item.actual_batch_qty),
                        disabled: ""
                      }, null, 8, ["label", "bg-color", "model-value"])
                    ]),
                    createBaseVNode("div", _hoisted_482, [
                      createVNode(_component_v_text_field, {
                        density: "compact",
                        variant: "outlined",
                        color: "primary",
                        label: _ctx.frappe._("Batch No Expiry Date"),
                        "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                        class: "dark-field",
                        "hide-details": "",
                        modelValue: item.batch_no_expiry_date,
                        "onUpdate:modelValue": ($event) => item.batch_no_expiry_date = $event,
                        disabled: ""
                      }, null, 8, ["label", "bg-color", "modelValue", "onUpdate:modelValue"])
                    ]),
                    createBaseVNode("div", _hoisted_492, [
                      createVNode(_component_v_autocomplete, {
                        modelValue: item.batch_no,
                        "onUpdate:modelValue": [($event) => item.batch_no = $event, ($event) => $props.setBatchQty(item, $event)],
                        items: item.batch_no_data,
                        "item-title": "batch_no",
                        variant: "outlined",
                        density: "compact",
                        color: "primary",
                        "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                        class: "dark-field",
                        label: _ctx.frappe._("Batch No"),
                        "hide-details": ""
                      }, {
                        item: withCtx(({ props, item: item2 }) => [
                          createVNode(_component_v_list_item, normalizeProps(guardReactiveProps(props)), {
                            default: withCtx(() => [
                              createVNode(_component_v_list_item_title, {
                                innerHTML: item2.raw.batch_no
                              }, null, 8, ["innerHTML"]),
                              createVNode(_component_v_list_item_subtitle, {
                                innerHTML: `Available QTY  '${item2.raw.batch_qty}' - Expiry Date ${item2.raw.expiry_date}`
                              }, null, 8, ["innerHTML"])
                            ]),
                            _: 2
                          }, 1040)
                        ]),
                        _: 2
                      }, 1032, ["modelValue", "onUpdate:modelValue", "items", "bg-color", "label"])
                    ])
                  ])
                ])) : createCommentVNode("v-if", true),
                createCommentVNode(" Delivery Date Section "),
                $props.pos_profile.posa_allow_sales_order && $props.invoiceType == "Order" ? (openBlock(), createElementBlock("div", _hoisted_50, [
                  createBaseVNode("div", _hoisted_51, [
                    createBaseVNode("div", _hoisted_522, [
                      createVNode(_component_VueDatePicker, {
                        modelValue: item.posa_delivery_date,
                        "onUpdate:modelValue": [($event) => item.posa_delivery_date = $event, ($event) => $props.validateDueDate(item)],
                        "model-type": "format",
                        format: "dd-MM-yyyy",
                        "min-date": new Date(),
                        "auto-apply": "",
                        dark: $options.isDarkTheme
                      }, null, 8, ["modelValue", "onUpdate:modelValue", "min-date", "dark"])
                    ])
                  ])
                ])) : createCommentVNode("v-if", true),
                createCommentVNode(" Fourth row for warehouse and other details "),
                createBaseVNode("div", _hoisted_532, [
                  createBaseVNode("div", _hoisted_542, [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      variant: "outlined",
                      color: "primary",
                      label: _ctx.frappe._("Warehouse"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "hide-details": "",
                      modelValue: item.warehouse,
                      "onUpdate:modelValue": ($event) => item.warehouse = $event,
                      disabled: "",
                      "prepend-inner-icon": "mdi-warehouse"
                    }, null, 8, ["label", "bg-color", "modelValue", "onUpdate:modelValue"])
                  ]),
                  createBaseVNode("div", _hoisted_552, [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      variant: "outlined",
                      color: "primary",
                      label: _ctx.frappe._("Price List Rate"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "hide-details": "",
                      "model-value": $props.formatCurrency(item.price_list_rate || 0),
                      disabled: "",
                      "prepend-inner-icon": "mdi-format-list-numbered"
                    }, null, 8, ["label", "bg-color", "model-value"])
                  ]),
                  createBaseVNode("div", _hoisted_562, [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      variant: "outlined",
                      color: "primary",
                      label: _ctx.frappe._("Amount"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "hide-details": "",
                      "model-value": $props.formatCurrency(item.qty * item.rate),
                      disabled: "",
                      "prepend-inner-icon": "mdi-calculator"
                    }, null, 8, ["label", "bg-color", "model-value"])
                  ])
                ])
              ])
            ])
          ], 8, _hoisted_154)
        ]),
        _: 1
      }, 8, ["headers", "items", "theme", "expanded", "items-per-page", "header-props", "search"])
    ], 36);
  }

  // ../posawesome/posawesome/public/js/posapp/components/pos/ItemsTable.vue
  ItemsTable_default.render = render19;
  ItemsTable_default.__file = "../posawesome/posawesome/public/js/posapp/components/pos/ItemsTable.vue";
  ItemsTable_default.__scopeId = "data-v-d222eb8d";
  var ItemsTable_default2 = ItemsTable_default;

  // ../posawesome/posawesome/public/js/posapp/components/pos/invoiceComputed.js
  var invoiceComputed_default = {
    total_qty() {
      this.close_payments();
      let qty = 0;
      this.items.forEach((item) => {
        qty += flt(item.qty);
      });
      return this.flt(qty, this.float_precision);
    },
    Total() {
      let sum = 0;
      this.items.forEach((item) => {
        const qty = this.isReturnInvoice ? Math.abs(flt(item.qty)) : flt(item.qty);
        const rate = flt(item.rate);
        sum += qty * rate;
      });
      return this.flt(sum, this.currency_precision);
    },
    subtotal() {
      this.close_payments();
      let sum = 0;
      this.items.forEach((item) => {
        const qty = this.isReturnInvoice ? Math.abs(flt(item.qty)) : flt(item.qty);
        const rate = flt(item.rate);
        sum += qty * rate;
      });
      const additional_discount = this.flt(this.additional_discount);
      sum -= additional_discount;
      const delivery_charges = this.flt(this.delivery_charges_rate);
      sum += delivery_charges;
      return this.flt(sum, this.currency_precision);
    },
    total_items_discount_amount() {
      let sum = 0;
      this.items.forEach((item) => {
        if (this.isReturnInvoice) {
          sum += Math.abs(flt(item.qty)) * flt(item.discount_amount);
        } else {
          sum += flt(item.qty) * flt(item.discount_amount);
        }
      });
      return this.flt(sum, this.float_precision);
    },
    formatted_posting_date: {
      get() {
        if (!this.posting_date)
          return "";
        const parts = this.posting_date.split("-");
        if (parts.length === 3) {
          return `${parts[2]}-${parts[1]}-${parts[0]}`;
        }
        return this.posting_date;
      },
      set(val) {
        const parts = val.split("-");
        if (parts.length === 3) {
          this.posting_date = `${parts[2]}-${parts[1]}-${parts[0]}`;
        } else {
          this.posting_date = val;
        }
      }
    },
    currencySymbol() {
      return (currency) => {
        return get_currency_symbol(currency || this.selected_currency || this.pos_profile.currency);
      };
    },
    displayCurrency() {
      return this.selected_currency || this.pos_profile.currency;
    },
    isReturnInvoice() {
      return this.invoiceType === "Return" || this.invoice_doc && this.invoice_doc.is_return;
    },
    itemTableHeaders() {
      return [
        {
          text: __("Item"),
          value: "item_name",
          width: "35%"
        },
        {
          text: __("Qty"),
          value: "qty",
          width: "15%"
        },
        {
          text: __(`Rate (${this.displayCurrency})`),
          value: "rate",
          width: "20%"
        },
        {
          text: __(`Amount (${this.displayCurrency})`),
          value: "amount",
          width: "20%"
        },
        {
          text: __("Action"),
          value: "actions",
          sortable: false,
          width: "10%"
        }
      ];
    }
  };

  // ../posawesome/posawesome/public/js/posapp/components/pos/invoiceWatchers.js
  var invoiceWatchers_default = {
    customer() {
      this.close_payments();
      this.eventBus.emit("set_customer", this.customer);
      this.fetch_customer_details();
      this.fetch_customer_balance();
      this.set_delivery_charges();
    },
    customer_info() {
      this.eventBus.emit("set_customer_info_to_edit", this.customer_info);
    },
    expanded(data_value) {
      if (data_value.length > 0) {
        this.update_item_detail(data_value[0]);
      }
    },
    discount_percentage_offer_name() {
      this.eventBus.emit("update_discount_percentage_offer_name", {
        value: this.discount_percentage_offer_name
      });
    },
    items: {
      deep: true,
      handler(items) {
        this.handelOffers();
        this.$forceUpdate();
      }
    },
    invoiceType() {
      this.eventBus.emit("update_invoice_type", this.invoiceType);
    },
    additional_discount() {
      if (!this.additional_discount || this.additional_discount == 0) {
        this.additional_discount_percentage = 0;
      } else if (this.pos_profile.posa_use_percentage_discount) {
        if (this.Total && this.Total !== 0) {
          this.additional_discount_percentage = this.additional_discount / this.Total * 100;
        } else {
          this.additional_discount_percentage = 0;
        }
      } else {
        this.additional_discount_percentage = 0;
      }
    },
    posting_date: {
      handler(newVal) {
        this.posting_date_display = this.formatDateForDisplay(newVal);
      },
      immediate: true
    },
    posting_date_display(newVal) {
      this.posting_date = this.formatDateForBackend(newVal);
    },
    selected_price_list(newVal) {
      clearPriceListCache();
      const price_list = newVal === this.pos_profile.selling_price_list ? null : newVal;
      this.eventBus.emit("update_customer_price_list", price_list);
      const applied = newVal || this.pos_profile.selling_price_list;
      this.apply_cached_price_list(applied);
      if (this.pos_profile.posa_allow_multi_currency && applied) {
        frappe.call({
          method: "posawesome.posawesome.api.invoices.get_price_list_currency",
          args: { price_list: applied },
          callback: (r) => {
            if (r.message) {
              this.price_list_currency = r.message;
              this.update_currency(r.message);
            }
          }
        });
      }
    },
    selected_currency() {
      clearPriceListCache();
      if (this.items && this.items.length) {
        this.update_item_rates();
      }
    },
    exchange_rate() {
      if (this.items && this.items.length) {
        this.update_item_rates();
      }
    }
  };

  // ../posawesome/posawesome/public/js/posapp/components/pos/invoice-item/itemAddition.js
  var itemAddition_default = {
    remove_item(item) {
      const index = this.items.findIndex(
        (el) => el.posa_row_id == item.posa_row_id
      );
      if (index >= 0) {
        this.items.splice(index, 1);
      }
      this.expanded = this.expanded.filter((id) => id !== item.posa_row_id);
    },
    add_item(item) {
      if (!item.uom) {
        item.uom = item.stock_uom;
      }
      let index = -1;
      if (!this.new_line) {
        if (this.pos_profile.posa_auto_set_batch && item.has_batch_no) {
          index = this.items.findIndex(
            (el) => el.item_code === item.item_code && el.uom === item.uom && !el.posa_is_offer && !el.posa_is_replace
          );
        } else {
          index = this.items.findIndex(
            (el) => el.item_code === item.item_code && el.uom === item.uom && !el.posa_is_offer && !el.posa_is_replace && (el.batch_no && item.batch_no && el.batch_no === item.batch_no || !el.batch_no && !item.batch_no)
          );
        }
      }
      let new_item;
      if (index === -1 || this.new_line) {
        new_item = this.get_new_item(item);
        if (item.has_serial_no && item.to_set_serial_no) {
          new_item.serial_no_selected = [];
          new_item.serial_no_selected.push(item.to_set_serial_no);
          item.to_set_serial_no = null;
        }
        if (item.has_batch_no && item.to_set_batch_no) {
          new_item.batch_no = item.to_set_batch_no;
          item.to_set_batch_no = null;
          item.batch_no = null;
          this.set_batch_qty(new_item, new_item.batch_no, false);
        }
        if (this.isReturnInvoice) {
          new_item.qty = -Math.abs(new_item.qty || 1);
        }
        this.items.unshift(new_item);
        this.update_item_detail(new_item, true);
        if (!this.pos_profile.posa_auto_set_batch && new_item.has_batch_no || new_item.has_serial_no) {
          this.$nextTick(() => {
            this.expanded = [new_item.posa_row_id];
          });
        }
      } else {
        const cur_item = this.items[index];
        this.update_items_details([cur_item]);
        if (item.has_serial_no && item.to_set_serial_no) {
          if (cur_item.serial_no_selected.includes(item.to_set_serial_no)) {
            this.eventBus.emit("show_message", {
              title: __(`This Serial Number {0} has already been added!`, [
                item.to_set_serial_no
              ]),
              color: "warning"
            });
            item.to_set_serial_no = null;
            return;
          }
          cur_item.serial_no_selected.push(item.to_set_serial_no);
          item.to_set_serial_no = null;
        }
        if (this.isReturnInvoice) {
          cur_item.qty -= item.qty || 1;
        } else {
          cur_item.qty += item.qty || 1;
        }
        this.calc_stock_qty(cur_item, cur_item.qty);
        if (cur_item.has_batch_no && cur_item.batch_no) {
          this.set_batch_qty(cur_item, cur_item.batch_no, false);
        }
        this.set_serial_no(cur_item);
      }
      this.$forceUpdate();
      if (new_item && (!this.pos_profile.posa_auto_set_batch && new_item.has_batch_no || new_item.has_serial_no)) {
        this.expanded = [new_item.posa_row_id];
      }
    },
    get_new_item(item) {
      const new_item = __spreadValues({}, item);
      if (!item.qty) {
        item.qty = 1;
      }
      if (!item.posa_is_offer) {
        item.posa_is_offer = 0;
      }
      if (!item.posa_is_replace) {
        item.posa_is_replace = "";
      }
      new_item._manual_rate_set = false;
      if (this.isReturnInvoice && item.qty > 0) {
        item.qty = -Math.abs(item.qty);
      }
      new_item.stock_qty = item.qty;
      new_item.discount_amount = 0;
      new_item.discount_percentage = 0;
      new_item.discount_amount_per_item = 0;
      new_item.price_list_rate = item.rate;
      const baseCurrency = this.price_list_currency || this.pos_profile.currency;
      if (this.selected_currency !== baseCurrency) {
        new_item.base_price_list_rate = item.rate / this.exchange_rate;
        new_item.base_rate = item.rate / this.exchange_rate;
        new_item.base_discount_amount = 0;
      } else {
        new_item.base_price_list_rate = item.rate;
        new_item.base_rate = item.rate;
        new_item.base_discount_amount = 0;
      }
      new_item.qty = item.qty;
      new_item.uom = item.uom ? item.uom : item.stock_uom;
      new_item.item_uoms = item.item_uoms || [];
      if (new_item.item_uoms.length === 0 && new_item.stock_uom) {
        new_item.item_uoms.push({ uom: new_item.stock_uom, conversion_factor: 1 });
      }
      new_item.actual_batch_qty = "";
      new_item.batch_no_expiry_date = item.batch_no_expiry_date || null;
      new_item.conversion_factor = 1;
      new_item.posa_offers = JSON.stringify([]);
      new_item.posa_offer_applied = 0;
      new_item.posa_is_offer = item.posa_is_offer;
      new_item.posa_is_replace = item.posa_is_replace || null;
      new_item.is_free_item = 0;
      new_item.posa_notes = "";
      new_item.posa_delivery_date = "";
      new_item.posa_row_id = this.makeid(20);
      if (new_item.has_serial_no && !new_item.serial_no_selected) {
        new_item.serial_no_selected = [];
        new_item.serial_no_selected_count = 0;
      }
      if (!this.pos_profile.posa_auto_set_batch && new_item.has_batch_no || new_item.has_serial_no) {
        this.expanded.push(new_item);
      }
      return new_item;
    },
    clear_invoice() {
      this.items = [];
      this.posa_offers = [];
      this.expanded = [];
      this.eventBus.emit("set_pos_coupons", []);
      this.posa_coupons = [];
      this.invoice_doc = "";
      this.return_doc = "";
      this.discount_amount = 0;
      this.additional_discount = 0;
      this.additional_discount_percentage = 0;
      this.delivery_charges_rate = 0;
      this.selected_delivery_charge = "";
      this.posting_date = frappe.datetime.nowdate();
      this.customer = this.pos_profile.customer;
      this.eventBus.emit("set_customer_readonly", false);
      this.invoiceType = this.pos_profile.posa_default_sales_order ? "Order" : "Invoice";
      this.invoiceTypes = ["Invoice", "Order"];
    }
  };

  // ../posawesome/posawesome/public/js/posapp/components/pos/invoice-item/batchSerial.js
  var batchSerial_default = {
    set_serial_no(item) {
      console.log(item);
      if (!item.has_serial_no)
        return;
      item.serial_no = "";
      item.serial_no_selected.forEach((element) => {
        item.serial_no += element + "\n";
      });
      item.serial_no_selected_count = item.serial_no_selected.length;
      if (item.serial_no_selected_count != item.stock_qty) {
        item.qty = item.serial_no_selected_count;
        this.calc_stock_qty(item, item.qty);
        this.$forceUpdate();
      }
    },
    set_batch_qty(item, value, update = true) {
      console.log("Setting batch quantity:", item, value);
      const existing_items = this.items.filter(
        (element) => element.item_code == item.item_code && element.posa_row_id != item.posa_row_id
      );
      const used_batches = {};
      item.batch_no_data.forEach((batch2) => {
        used_batches[batch2.batch_no] = __spreadProps(__spreadValues({}, batch2), {
          used_qty: 0,
          remaining_qty: batch2.batch_qty
        });
        existing_items.forEach((element) => {
          if (element.batch_no && element.batch_no == batch2.batch_no) {
            used_batches[batch2.batch_no].used_qty += element.qty;
            used_batches[batch2.batch_no].remaining_qty -= element.qty;
            used_batches[batch2.batch_no].batch_qty -= element.qty;
          }
        });
      });
      const batch_no_data = Object.values(used_batches).filter((batch2) => batch2.remaining_qty > 0).sort((a, b) => {
        if (a.expiry_date && b.expiry_date) {
          return new Date(a.expiry_date) - new Date(b.expiry_date);
        } else if (a.expiry_date) {
          return -1;
        } else if (b.expiry_date) {
          return 1;
        } else if (a.manufacturing_date && b.manufacturing_date) {
          return new Date(a.manufacturing_date) - new Date(b.manufacturing_date);
        } else if (a.manufacturing_date) {
          return -1;
        } else if (b.manufacturing_date) {
          return 1;
        } else {
          return b.remaining_qty - a.remaining_qty;
        }
      });
      if (batch_no_data.length > 0) {
        let batch_to_use = null;
        if (value) {
          batch_to_use = batch_no_data.find((batch2) => batch2.batch_no == value);
        }
        if (!batch_to_use) {
          batch_to_use = batch_no_data[0];
        }
        item.batch_no = batch_to_use.batch_no;
        item.actual_batch_qty = batch_to_use.batch_qty;
        item.batch_no_expiry_date = batch_to_use.expiry_date;
        if (batch_to_use.batch_price) {
          item.base_batch_price = batch_to_use.batch_price;
          const baseCurrency = this.price_list_currency || this.pos_profile.currency;
          if (this.selected_currency !== baseCurrency) {
            item.batch_price = this.flt(batch_to_use.batch_price / this.exchange_rate, this.currency_precision);
          } else {
            item.batch_price = batch_to_use.batch_price;
          }
          item.base_price_list_rate = item.base_batch_price;
          item.base_rate = item.base_batch_price;
          if (this.selected_currency !== baseCurrency) {
            item.price_list_rate = item.batch_price;
            item.rate = item.batch_price;
          } else {
            item.price_list_rate = item.base_batch_price;
            item.rate = item.base_batch_price;
          }
          item.discount_percentage = 0;
          item.discount_amount = 0;
          item.base_discount_amount = 0;
          item.amount = this.flt(item.qty * item.rate, this.currency_precision);
          item.base_amount = this.flt(item.qty * item.base_rate, this.currency_precision);
          console.log("Updated batch prices:", {
            base_batch_price: item.base_batch_price,
            batch_price: item.batch_price,
            rate: item.rate,
            base_rate: item.base_rate,
            price_list_rate: item.price_list_rate,
            exchange_rate: this.exchange_rate
          });
        } else if (update) {
          item.batch_price = null;
          item.base_batch_price = null;
          this.update_item_detail(item);
        }
      } else {
        item.batch_no = null;
        item.actual_batch_qty = null;
        item.batch_no_expiry_date = null;
        item.batch_price = null;
        item.base_batch_price = null;
      }
      item.batch_no_data = batch_no_data;
      this.$forceUpdate();
    }
  };

  // ../posawesome/posawesome/public/js/posapp/components/pos/invoice-item/discounts.js
  var discounts_default = {
    update_discount_umount() {
      const value = flt(this.additional_discount_percentage);
      if (value < -100 || value > 100) {
        this.additional_discount_percentage = 0;
        this.additional_discount = 0;
        return;
      }
      if (this.Total && this.Total !== 0) {
        this.additional_discount = this.Total * value / 100;
      } else {
        this.additional_discount = 0;
      }
    },
    calc_prices(item, value, $event) {
      var _a3;
      if (!((_a3 = $event == null ? void 0 : $event.target) == null ? void 0 : _a3.id) || !item)
        return;
      const fieldId = $event.target.id;
      let newValue = flt(value, this.currency_precision);
      try {
        if (fieldId === "rate") {
          item._manual_rate_set = true;
        }
        if (newValue < 0) {
          newValue = 0;
          this.eventBus.emit("show_message", {
            title: __("Negative values not allowed"),
            color: "error"
          });
        }
        const baseCurrency = this.price_list_currency || this.pos_profile.currency;
        const converted_price_list_rate = this.selected_currency !== baseCurrency ? this.flt(item.price_list_rate / this.exchange_rate, this.currency_precision) : item.price_list_rate;
        switch (fieldId) {
          case "rate":
            item.base_rate = this.flt(newValue / this.exchange_rate, this.currency_precision);
            item.rate = newValue;
            item.discount_amount = this.flt(converted_price_list_rate - item.rate, this.currency_precision);
            item.base_discount_amount = this.flt(item.price_list_rate - item.base_rate, this.currency_precision);
            if (converted_price_list_rate) {
              item.discount_percentage = this.flt(item.discount_amount / converted_price_list_rate * 100, this.float_precision);
            }
            break;
          case "discount_amount":
            console.log("[calc_prices] Event Target ID:", fieldId);
            console.log("[calc_prices] RAW value received by function:", value);
            console.log("[calc_prices] Original item.price_list_rate:", item.price_list_rate);
            console.log("[calc_prices] Converted price_list_rate for calc:", converted_price_list_rate);
            console.log("[calc_prices] Input value (newValue before Math.min):", newValue);
            newValue = Math.min(newValue, converted_price_list_rate);
            console.log("[calc_prices] Input value (newValue after Math.min):", newValue);
            item.base_discount_amount = this.flt(newValue / this.exchange_rate, this.currency_precision);
            item.discount_amount = newValue;
            console.log("[calc_prices] Updated item.discount_amount:", item.discount_amount);
            console.log("[calc_prices] Updated item.base_discount_amount:", item.base_discount_amount);
            item.rate = this.flt(converted_price_list_rate - item.discount_amount, this.currency_precision);
            item.base_rate = this.flt(item.price_list_rate - item.base_discount_amount, this.currency_precision);
            console.log("[calc_prices] Calculated item.rate:", item.rate);
            console.log("[calc_prices] Calculated item.base_rate:", item.base_rate);
            if (converted_price_list_rate) {
              item.discount_percentage = this.flt(item.discount_amount / converted_price_list_rate * 100, this.float_precision);
            } else {
              item.discount_percentage = 0;
            }
            console.log("[calc_prices] Calculated item.discount_percentage:", item.discount_percentage);
            break;
          case "discount_percentage":
            newValue = Math.min(newValue, 100);
            item.discount_percentage = this.flt(newValue, this.float_precision);
            item.discount_amount = this.flt(converted_price_list_rate * item.discount_percentage / 100, this.currency_precision);
            item.base_discount_amount = this.flt(item.price_list_rate * item.discount_percentage / 100, this.currency_precision);
            item.rate = this.flt(converted_price_list_rate - item.discount_amount, this.currency_precision);
            item.base_rate = this.flt(item.price_list_rate - item.base_discount_amount, this.currency_precision);
            break;
        }
        if (item.rate < 0) {
          item.rate = 0;
          item.base_rate = 0;
          item.discount_amount = converted_price_list_rate;
          item.base_discount_amount = item.price_list_rate;
          item.discount_percentage = 100;
        }
        this.calc_stock_qty(item, item.qty);
        this.$forceUpdate();
      } catch (error) {
        console.error("Error calculating prices:", error);
        this.eventBus.emit("show_message", {
          title: __("Error calculating prices"),
          color: "error"
        });
      }
    },
    calc_item_price(item) {
      if (item._skip_calc) {
        item._skip_calc = false;
        return;
      }
      if (!item.posa_offer_applied) {
        if (item.price_list_rate) {
          if (!item.base_price_list_rate) {
            item.base_price_list_rate = item.price_list_rate;
            item.base_rate = item.rate;
          }
          const baseCurrency2 = this.price_list_currency || this.pos_profile.currency;
          if (this.selected_currency !== baseCurrency2) {
            item.price_list_rate = this.flt(item.base_price_list_rate / this.exchange_rate, this.currency_precision);
            item.rate = this.flt(item.base_rate / this.exchange_rate, this.currency_precision);
          } else {
            item.price_list_rate = item.base_price_list_rate;
            item.rate = item.base_rate;
          }
        }
      }
      if (item.discount_percentage) {
        const price_list_rate = item.price_list_rate;
        const discount_amount = this.flt(price_list_rate * item.discount_percentage / 100, this.currency_precision);
        item.discount_amount = discount_amount;
        item.rate = this.flt(price_list_rate - discount_amount, this.currency_precision);
        const baseCurrency2 = this.price_list_currency || this.pos_profile.currency;
        if (this.selected_currency !== baseCurrency2) {
          item.base_discount_amount = this.flt(discount_amount / this.exchange_rate, this.currency_precision);
        } else {
          item.base_discount_amount = item.discount_amount;
        }
      }
      item.amount = this.flt(item.qty * item.rate, this.currency_precision);
      const baseCurrency = this.price_list_currency || this.pos_profile.currency;
      if (this.selected_currency !== baseCurrency) {
        item.base_amount = this.flt(item.amount / this.exchange_rate, this.currency_precision);
      } else {
        item.base_amount = item.amount;
      }
      this.$forceUpdate();
    }
  };

  // ../posawesome/posawesome/public/js/posapp/components/pos/invoice-item/stockUtils.js
  var stockUtils_default = {
    calc_uom(item, value) {
      let new_uom = item.item_uoms.find((element) => element.uom == value);
      if (!new_uom) {
        const cached = getItemUOMs(item.item_code);
        if (cached.length) {
          item.item_uoms = cached;
          new_uom = cached.find((u) => u.uom == value);
        }
      }
      if (!new_uom && item.stock_uom === value) {
        new_uom = { uom: item.stock_uom, conversion_factor: 1 };
        if (!item.item_uoms)
          item.item_uoms = [];
        item.item_uoms.push(new_uom);
      }
      if (!new_uom) {
        this.eventBus.emit("show_message", {
          title: __("UOM not found"),
          color: "error"
        });
        return;
      }
      const old_conversion_factor = item.conversion_factor || 1;
      item.conversion_factor = new_uom.conversion_factor;
      const conversion_ratio = item.conversion_factor / old_conversion_factor;
      if (!item.posa_offer_applied) {
        item.discount_amount = 0;
        item.discount_percentage = 0;
      }
      if (!item.original_base_rate && !item.posa_offer_applied) {
        item.original_base_rate = item.base_rate / old_conversion_factor;
        item.original_base_price_list_rate = item.base_price_list_rate / old_conversion_factor;
      }
      if (item.posa_offer_applied) {
        const offer = this.posOffers && Array.isArray(this.posOffers) ? this.posOffers.find((o) => {
          if (!o || !o.items)
            return false;
          const items = typeof o.items === "string" ? JSON.parse(o.items) : o.items;
          return Array.isArray(items) && items.includes(item.posa_row_id);
        }) : null;
        if (offer && offer.discount_type === "Rate") {
          const converted_rate = flt(offer.rate * item.conversion_factor);
          item.base_rate = converted_rate;
          item.base_price_list_rate = converted_rate;
          const baseCurrency = this.price_list_currency || this.pos_profile.currency;
          if (this.selected_currency !== baseCurrency) {
            item.rate = this.flt(converted_rate / this.exchange_rate, this.currency_precision);
            item.price_list_rate = item.rate;
          } else {
            item.rate = converted_rate;
            item.price_list_rate = converted_rate;
          }
        } else if (offer && offer.discount_type === "Discount Percentage") {
          let updated_base_price;
          if (item.original_base_price_list_rate) {
            updated_base_price = this.flt(item.original_base_price_list_rate * item.conversion_factor, this.currency_precision);
          } else {
            updated_base_price = this.flt(item.base_price_list_rate * conversion_ratio, this.currency_precision);
          }
          item.base_price_list_rate = updated_base_price;
          const base_discount = this.flt(updated_base_price * offer.discount_percentage / 100, this.currency_precision);
          item.base_discount_amount = base_discount;
          item.base_rate = this.flt(updated_base_price - base_discount, this.currency_precision);
          const baseCurrency = this.price_list_currency || this.pos_profile.currency;
          if (this.selected_currency !== baseCurrency) {
            item.price_list_rate = this.flt(updated_base_price / this.exchange_rate, this.currency_precision);
            item.discount_amount = this.flt(base_discount / this.exchange_rate, this.currency_precision);
            item.rate = this.flt(item.base_rate / this.exchange_rate, this.currency_precision);
          } else {
            item.price_list_rate = updated_base_price;
            item.discount_amount = base_discount;
            item.rate = item.base_rate;
          }
        }
      } else {
        if (item.batch_price) {
          item.base_rate = item.batch_price * item.conversion_factor;
          item.base_price_list_rate = item.base_rate;
        } else if (item.original_base_rate) {
          item.base_rate = item.original_base_rate * item.conversion_factor;
          item.base_price_list_rate = item.original_base_price_list_rate * item.conversion_factor;
        }
        const baseCurrency = this.price_list_currency || this.pos_profile.currency;
        if (this.selected_currency !== baseCurrency) {
          item.rate = this.flt(item.base_rate / this.exchange_rate, this.currency_precision);
          item.price_list_rate = this.flt(item.base_price_list_rate / this.exchange_rate, this.currency_precision);
        } else {
          item.rate = item.base_rate;
          item.price_list_rate = item.base_price_list_rate;
        }
      }
      this.calc_stock_qty(item, item.qty);
      this.$forceUpdate();
    },
    calc_stock_qty(item, value) {
      item.stock_qty = item.conversion_factor * value;
    }
  };

  // ../posawesome/posawesome/public/js/posapp/plugins/print.js
  function silentPrint(url) {
    if (!url)
      return;
    try {
      const iframe = document.createElement("iframe");
      iframe.style.position = "fixed";
      iframe.style.right = "0";
      iframe.style.bottom = "0";
      iframe.style.width = "0";
      iframe.style.height = "0";
      iframe.style.border = "0";
      iframe.onload = () => {
        try {
          iframe.contentWindow.focus();
          iframe.contentWindow.print();
        } finally {
          setTimeout(() => iframe.remove(), 1e3);
        }
      };
      iframe.src = url;
      document.body.appendChild(iframe);
    } catch (err) {
      console.error("Silent print failed, falling back to new window", err);
      const win = window.open(url, "_blank");
      if (win) {
        win.addEventListener("load", () => win.print(), { once: true });
      }
    }
  }

  // ../posawesome/posawesome/public/js/posapp/components/pos/invoiceOfferMethods.js
  var invoiceOfferMethods_default = {
    checkOfferIsAppley(item, offer) {
      let applied = false;
      const item_offers = JSON.parse(item.posa_offers);
      for (const row_id of item_offers) {
        const exist_offer = this.posa_offers.find((el) => row_id == el.row_id);
        if (exist_offer && exist_offer.offer_name == offer.name) {
          applied = true;
          break;
        }
      }
      return applied;
    },
    handelOffers() {
      const offers = [];
      this.posOffers.forEach((offer) => {
        if (offer.apply_on === "Item Code") {
          const itemOffer = this.getItemOffer(offer);
          if (itemOffer) {
            offers.push(itemOffer);
          }
        } else if (offer.apply_on === "Item Group") {
          const groupOffer = this.getGroupOffer(offer);
          if (groupOffer) {
            offers.push(groupOffer);
          }
        } else if (offer.apply_on === "Brand") {
          const brandOffer = this.getBrandOffer(offer);
          if (brandOffer) {
            offers.push(brandOffer);
          }
        } else if (offer.apply_on === "Transaction") {
          const transactionOffer = this.getTransactionOffer(offer);
          if (transactionOffer) {
            offers.push(transactionOffer);
          }
        }
      });
      this.setItemGiveOffer(offers);
      this.updatePosOffers(offers);
    },
    setItemGiveOffer(offers) {
      offers.forEach((offer) => {
        if (offer.apply_on == "Item Code" && offer.apply_type == "Item Code" && offer.replace_item) {
          offer.give_item = offer.item;
          offer.apply_item_code = offer.item;
        } else if (offer.apply_on == "Item Group" && offer.apply_type == "Item Group" && offer.replace_cheapest_item) {
          const offerItemCode = this.getCheapestItem(offer).item_code;
          offer.give_item = offerItemCode;
          offer.apply_item_code = offerItemCode;
        }
      });
    },
    getCheapestItem(offer) {
      let itemsRowID;
      if (typeof offer.items === "string") {
        itemsRowID = JSON.parse(offer.items);
      } else {
        itemsRowID = offer.items;
      }
      const itemsList = [];
      itemsRowID.forEach((row_id) => {
        itemsList.push(this.getItemFromRowID(row_id));
      });
      const result = itemsList.reduce(function(res, obj) {
        return !obj.posa_is_replace && !obj.posa_is_offer && obj.price_list_rate < res.price_list_rate ? obj : res;
      });
      return result;
    },
    getItemFromRowID(row_id) {
      const item = this.items.find((el) => el.posa_row_id == row_id);
      return item;
    },
    checkQtyAnountOffer(offer, qty, amount) {
      let min_qty = false;
      let max_qty = false;
      let min_amt = false;
      let max_amt = false;
      const applys = [];
      if (offer.min_qty || offer.min_qty == 0) {
        if (qty >= offer.min_qty) {
          min_qty = true;
        }
        applys.push(min_qty);
      }
      if (offer.max_qty > 0) {
        if (qty <= offer.max_qty) {
          max_qty = true;
        }
        applys.push(max_qty);
      }
      if (offer.min_amt > 0) {
        if (amount >= offer.min_amt) {
          min_amt = true;
        }
        applys.push(min_amt);
      }
      if (offer.max_amt > 0) {
        if (amount <= offer.max_amt) {
          max_amt = true;
        }
        applys.push(max_amt);
      }
      let apply2 = false;
      if (!applys.includes(false)) {
        apply2 = true;
      }
      const res = {
        apply: apply2,
        conditions: { min_qty, max_qty, min_amt, max_amt }
      };
      return res;
    },
    checkOfferCoupon(offer) {
      if (offer.coupon_based) {
        const coupon = this.posa_coupons.find(
          (el) => offer.name == el.pos_offer
        );
        if (coupon) {
          offer.coupon = coupon.coupon;
          return true;
        } else {
          return false;
        }
      } else {
        offer.coupon = null;
        return true;
      }
    },
    getItemOffer(offer) {
      let apply_offer = null;
      if (offer.apply_on === "Item Code") {
        if (this.checkOfferCoupon(offer)) {
          this.items.forEach((item) => {
            if (!item.posa_is_offer && item.item_code === offer.item) {
              const items = [];
              if (offer.offer === "Item Price" && item.posa_offer_applied && !this.checkOfferIsAppley(item, offer)) {
              } else {
                const res = this.checkQtyAnountOffer(
                  offer,
                  item.stock_qty,
                  item.stock_qty * item.price_list_rate
                );
                if (res.apply) {
                  items.push(item.posa_row_id);
                  offer.items = items;
                  apply_offer = offer;
                }
              }
            }
          });
        }
      }
      return apply_offer;
    },
    getGroupOffer(offer) {
      let apply_offer = null;
      if (offer.apply_on === "Item Group") {
        if (this.checkOfferCoupon(offer)) {
          const items = [];
          let total_count = 0;
          let total_amount = 0;
          this.items.forEach((item) => {
            if (!item.posa_is_offer && item.item_group === offer.item_group) {
              if (offer.offer === "Item Price" && item.posa_offer_applied && !this.checkOfferIsAppley(item, offer)) {
              } else {
                total_count += item.stock_qty;
                total_amount += item.stock_qty * item.price_list_rate;
                items.push(item.posa_row_id);
              }
            }
          });
          if (total_count || total_amount) {
            const res = this.checkQtyAnountOffer(
              offer,
              total_count,
              total_amount
            );
            if (res.apply) {
              offer.items = items;
              apply_offer = offer;
            }
          }
        }
      }
      return apply_offer;
    },
    getBrandOffer(offer) {
      let apply_offer = null;
      if (offer.apply_on === "Brand") {
        if (this.checkOfferCoupon(offer)) {
          const items = [];
          let total_count = 0;
          let total_amount = 0;
          this.items.forEach((item) => {
            if (!item.posa_is_offer && item.brand === offer.brand) {
              if (offer.offer === "Item Price" && item.posa_offer_applied && !this.checkOfferIsAppley(item, offer)) {
              } else {
                total_count += item.stock_qty;
                total_amount += item.stock_qty * item.price_list_rate;
                items.push(item.posa_row_id);
              }
            }
          });
          if (total_count || total_amount) {
            const res = this.checkQtyAnountOffer(
              offer,
              total_count,
              total_amount
            );
            if (res.apply) {
              offer.items = items;
              apply_offer = offer;
            }
          }
        }
      }
      return apply_offer;
    },
    getTransactionOffer(offer) {
      let apply_offer = null;
      if (offer.apply_on === "Transaction") {
        if (this.checkOfferCoupon(offer)) {
          let total_qty = 0;
          this.items.forEach((item) => {
            if (!item.posa_is_offer && !item.posa_is_replace) {
              total_qty += item.stock_qty;
            }
          });
          const items = [];
          const total_count = total_qty;
          const total_amount = this.Total;
          if (total_count || total_amount) {
            const res = this.checkQtyAnountOffer(
              offer,
              total_count,
              total_amount
            );
            if (res.apply) {
              this.items.forEach((item) => {
                items.push(item.posa_row_id);
              });
              offer.items = items;
              apply_offer = offer;
            }
          }
        }
      }
      return apply_offer;
    },
    updatePosOffers(offers) {
      this.eventBus.emit("update_pos_offers", offers);
    },
    updateInvoiceOffers(offers) {
      this.posa_offers.forEach((invoiceOffer) => {
        const existOffer = offers.find(
          (offer) => invoiceOffer.row_id == offer.row_id
        );
        if (!existOffer) {
          this.removeApplyOffer(invoiceOffer);
        }
      });
      offers.forEach((offer) => {
        const existOffer = this.posa_offers.find(
          (invoiceOffer) => invoiceOffer.row_id == offer.row_id
        );
        if (existOffer) {
          existOffer.items = JSON.stringify(offer.items);
          if (existOffer.offer === "Give Product" && existOffer.give_item && existOffer.give_item != offer.give_item) {
            const item_to_remove = this.items.find(
              (item) => item.posa_row_id == existOffer.give_item_row_id
            );
            if (item_to_remove) {
              const updated_item_offers = offer.items.filter(
                (row_id) => row_id != item_to_remove.posa_row_id
              );
              offer.items = updated_item_offers;
              this.remove_item(item_to_remove);
              existOffer.give_item_row_id = null;
              existOffer.give_item = null;
            }
            const newItemOffer = this.ApplyOnGiveProduct(offer);
            if (offer.replace_cheapest_item) {
              const cheapestItem = this.getCheapestItem(offer);
              const oldBaseItem = this.items.find(
                (el) => el.posa_row_id == item_to_remove.posa_is_replace
              );
              newItemOffer.qty = item_to_remove.qty;
              if (oldBaseItem && !oldBaseItem.posa_is_replace) {
                oldBaseItem.qty += item_to_remove.qty;
              } else {
                const restoredItem = this.ApplyOnGiveProduct(
                  {
                    given_qty: item_to_remove.qty
                  },
                  item_to_remove.item_code
                );
                restoredItem.posa_is_offer = 0;
                this.items.unshift(restoredItem);
              }
              newItemOffer.posa_is_offer = 0;
              newItemOffer.posa_is_replace = cheapestItem.posa_row_id;
              const diffQty = cheapestItem.qty - newItemOffer.qty;
              if (diffQty <= 0) {
                newItemOffer.qty += diffQty;
                this.remove_item(cheapestItem);
                newItemOffer.posa_row_id = cheapestItem.posa_row_id;
                newItemOffer.posa_is_replace = newItemOffer.posa_row_id;
              } else {
                cheapestItem.qty = diffQty;
              }
            }
            this.items.unshift(newItemOffer);
            existOffer.give_item_row_id = newItemOffer.posa_row_id;
            existOffer.give_item = newItemOffer.item_code;
          } else if (existOffer.offer === "Give Product" && existOffer.give_item && existOffer.give_item == offer.give_item && (offer.replace_item || offer.replace_cheapest_item)) {
            this.$nextTick(function() {
              const offerItem = this.getItemFromRowID(
                existOffer.give_item_row_id
              );
              const diff = offer.given_qty - offerItem.qty;
              if (diff > 0) {
                const itemsRowID = JSON.parse(existOffer.items);
                const itemsList = [];
                itemsRowID.forEach((row_id) => {
                  itemsList.push(this.getItemFromRowID(row_id));
                });
                const existItem = itemsList.find(
                  (el) => el.item_code == offerItem.item_code && el.posa_is_replace != offerItem.posa_row_id
                );
                if (existItem) {
                  const diffExistQty = existItem.qty - diff;
                  if (diffExistQty > 0) {
                    offerItem.qty += diff;
                    existItem.qty -= diff;
                  } else {
                    offerItem.qty += existItem.qty;
                    this.remove_item(existItem);
                  }
                }
              }
            });
          } else if (existOffer.offer === "Item Price") {
            this.ApplyOnPrice(offer);
          } else if (existOffer.offer === "Grand Total") {
            this.ApplyOnTotal(offer);
          }
          this.addOfferToItems(existOffer);
        } else {
          this.applyNewOffer(offer);
        }
      });
    },
    removeApplyOffer(invoiceOffer) {
      if (invoiceOffer.offer === "Item Price") {
        this.RemoveOnPrice(invoiceOffer);
        const index = this.posa_offers.findIndex(
          (el) => el.row_id === invoiceOffer.row_id
        );
        this.posa_offers.splice(index, 1);
      }
      if (invoiceOffer.offer === "Give Product") {
        const item_to_remove = this.items.find(
          (item) => item.posa_row_id == invoiceOffer.give_item_row_id
        );
        const index = this.posa_offers.findIndex(
          (el) => el.row_id === invoiceOffer.row_id
        );
        this.posa_offers.splice(index, 1);
        this.remove_item(item_to_remove);
      }
      if (invoiceOffer.offer === "Grand Total") {
        this.RemoveOnTotal(invoiceOffer);
        const index = this.posa_offers.findIndex(
          (el) => el.row_id === invoiceOffer.row_id
        );
        this.posa_offers.splice(index, 1);
      }
      if (invoiceOffer.offer === "Loyalty Point") {
        const index = this.posa_offers.findIndex(
          (el) => el.row_id === invoiceOffer.row_id
        );
        this.posa_offers.splice(index, 1);
      }
      this.deleteOfferFromItems(invoiceOffer);
    },
    applyNewOffer(offer) {
      if (offer.offer === "Item Price") {
        this.ApplyOnPrice(offer);
      }
      if (offer.offer === "Give Product") {
        let itemsRowID;
        if (typeof offer.items === "string") {
          itemsRowID = JSON.parse(offer.items);
        } else {
          itemsRowID = offer.items;
        }
        if (offer.apply_on == "Item Code" && offer.apply_type == "Item Code" && offer.replace_item) {
          const item = this.ApplyOnGiveProduct(offer, offer.item);
          item.posa_is_replace = itemsRowID[0];
          const baseItem = this.items.find(
            (el) => el.posa_row_id == item.posa_is_replace
          );
          const diffQty = baseItem.qty - offer.given_qty;
          item.posa_is_offer = 0;
          if (diffQty <= 0) {
            item.qty = baseItem.qty;
            this.remove_item(baseItem);
            item.posa_row_id = item.posa_is_replace;
          } else {
            baseItem.qty = diffQty;
          }
          this.items.unshift(item);
          offer.give_item_row_id = item.posa_row_id;
        } else if (offer.apply_on == "Item Group" && offer.apply_type == "Item Group" && offer.replace_cheapest_item) {
          const itemsList = [];
          itemsRowID.forEach((row_id) => {
            itemsList.push(this.getItemFromRowID(row_id));
          });
          const baseItem = itemsList.find(
            (el) => el.item_code == offer.give_item
          );
          const item = this.ApplyOnGiveProduct(offer, offer.give_item);
          item.posa_is_offer = 0;
          item.posa_is_replace = baseItem.posa_row_id;
          const diffQty = baseItem.qty - offer.given_qty;
          if (diffQty <= 0) {
            item.qty = baseItem.qty;
            this.remove_item(baseItem);
            item.posa_row_id = item.posa_is_replace;
          } else {
            baseItem.qty = diffQty;
          }
          this.items.unshift(item);
          offer.give_item_row_id = item.posa_row_id;
        } else {
          const item = this.ApplyOnGiveProduct(offer);
          this.items.unshift(item);
          if (item) {
            offer.give_item_row_id = item.posa_row_id;
          }
        }
      }
      if (offer.offer === "Grand Total") {
        this.ApplyOnTotal(offer);
      }
      if (offer.offer === "Loyalty Point") {
        this.eventBus.emit("show_message", {
          title: __("Loyalty Point Offer Applied"),
          color: "success"
        });
      }
      const newOffer = {
        offer_name: offer.name,
        row_id: offer.row_id,
        apply_on: offer.apply_on,
        offer: offer.offer,
        items: JSON.stringify(offer.items),
        give_item: offer.give_item,
        give_item_row_id: offer.give_item_row_id,
        offer_applied: offer.offer_applied,
        coupon_based: offer.coupon_based,
        coupon: offer.coupon
      };
      this.posa_offers.push(newOffer);
      this.addOfferToItems(newOffer);
    },
    ApplyOnGiveProduct(offer, item_code) {
      if (!item_code) {
        item_code = offer.give_item;
      }
      const items = this.allItems;
      const item = items.find((item2) => item2.item_code == item_code);
      if (!item) {
        return;
      }
      const new_item = __spreadValues({}, item);
      new_item.qty = offer.given_qty;
      new_item.stock_qty = offer.given_qty;
      if (offer.discount_type === "Rate") {
        new_item.base_rate = offer.rate;
        const baseCurrency = this.price_list_currency || this.pos_profile.currency;
        if (this.selected_currency !== baseCurrency) {
          new_item.rate = this.flt(offer.rate * this.exchange_rate, this.currency_precision);
        } else {
          new_item.rate = offer.rate;
        }
      } else if (offer.discount_type === "Discount Percentage") {
        const base_price = item.base_rate || item.rate / this.exchange_rate;
        const base_discount = this.flt(base_price * offer.discount_percentage / 100, this.currency_precision);
        new_item.base_discount_amount = base_discount;
        new_item.base_rate = this.flt(base_price - base_discount, this.currency_precision);
        const baseCurrency = this.price_list_currency || this.pos_profile.currency;
        if (this.selected_currency !== baseCurrency) {
          new_item.discount_amount = this.flt(base_discount * this.exchange_rate, this.currency_precision);
          new_item.rate = this.flt(new_item.base_rate * this.exchange_rate, this.currency_precision);
        } else {
          new_item.discount_amount = base_discount;
          new_item.rate = new_item.base_rate;
        }
      } else {
        const baseCurrency = this.price_list_currency || this.pos_profile.currency;
        if (this.selected_currency !== baseCurrency) {
          new_item.base_rate = item.base_rate || item.rate / this.exchange_rate;
          new_item.rate = item.rate;
        } else {
          new_item.base_rate = item.rate;
          new_item.rate = item.rate;
        }
      }
      if (offer.discount_type === "Discount Amount") {
        new_item.base_discount_amount = offer.discount_amount;
        const baseCurrency = this.price_list_currency || this.pos_profile.currency;
        if (this.selected_currency !== baseCurrency) {
          new_item.discount_amount = this.flt(offer.discount_amount * this.exchange_rate, this.currency_precision);
        } else {
          new_item.discount_amount = offer.discount_amount;
        }
      } else if (offer.discount_type !== "Discount Percentage") {
        new_item.base_discount_amount = 0;
        new_item.discount_amount = 0;
      }
      new_item.discount_percentage = offer.discount_type === "Discount Percentage" ? offer.discount_percentage : 0;
      new_item.discount_amount_per_item = 0;
      new_item.uom = item.uom ? item.uom : item.stock_uom;
      new_item.actual_batch_qty = "";
      new_item.conversion_factor = 1;
      new_item.posa_offers = JSON.stringify([]);
      new_item.posa_offer_applied = offer.discount_type === "Rate" || offer.discount_type === "Discount Amount" || offer.discount_type === "Discount Percentage" ? 1 : 0;
      new_item.posa_is_offer = 1;
      new_item.posa_is_replace = null;
      new_item.posa_notes = "";
      new_item.posa_delivery_date = "";
      const is_free = offer.discount_type === "Rate" && !offer.rate || offer.discount_type === "Discount Percentage" && offer.discount_percentage == 100;
      new_item.is_free_item = is_free ? 1 : 0;
      if (is_free) {
        new_item.base_price_list_rate = 0;
        new_item.price_list_rate = 0;
      } else {
        new_item.price_list_rate = item.rate;
        const baseCurrency = this.price_list_currency || this.pos_profile.currency;
        if (this.selected_currency !== baseCurrency) {
          new_item.base_price_list_rate = this.flt(item.rate / this.exchange_rate, this.currency_precision);
        } else {
          new_item.base_price_list_rate = item.rate;
        }
      }
      new_item.posa_row_id = this.makeid(20);
      if (!this.pos_profile.posa_auto_set_batch && new_item.has_batch_no || new_item.has_serial_no) {
        this.expanded.push(new_item);
      }
      this.update_item_detail(new_item);
      return new_item;
    },
    ApplyOnPrice(offer) {
      console.log("Applying price offer:", offer);
      if (!offer || !Array.isArray(this.items))
        return;
      this.items.forEach((item) => {
        if (!item || !offer.items || !Array.isArray(offer.items))
          return;
        if (offer.items.includes(item.posa_row_id)) {
          const item_offers = item.posa_offers ? JSON.parse(item.posa_offers) : [];
          if (!Array.isArray(item_offers))
            return;
          if (!item_offers.includes(offer.row_id)) {
            if (!item.posa_offer_applied) {
              const cf = flt(item.conversion_factor || 1);
              item.original_base_rate = item.base_rate / cf;
              item.original_base_price_list_rate = item.base_price_list_rate / cf;
              item.original_rate = item.rate / cf;
              item.original_price_list_rate = item.price_list_rate / cf;
              console.log("Storing original rates (normalized to conversion factor 1):", {
                original_base_rate: item.original_base_rate,
                original_base_price_list_rate: item.original_base_price_list_rate,
                original_rate: item.original_rate,
                original_price_list_rate: item.original_price_list_rate,
                conversion_factor: cf
              });
            }
            const conversion_factor = flt(item.conversion_factor || 1);
            if (offer.discount_type === "Rate") {
              const base_offer_rate = flt(offer.rate * conversion_factor);
              item.base_rate = base_offer_rate;
              item.base_price_list_rate = base_offer_rate;
              const baseCurrency = this.price_list_currency || this.pos_profile.currency;
              if (this.selected_currency !== baseCurrency) {
                item.rate = this.flt(base_offer_rate * this.exchange_rate, this.currency_precision);
                item.price_list_rate = item.rate;
              } else {
                item.rate = base_offer_rate;
                item.price_list_rate = base_offer_rate;
              }
              item.discount_percentage = 0;
              item.discount_amount = 0;
              item.base_discount_amount = 0;
            } else if (offer.discount_type === "Discount Percentage") {
              item.discount_percentage = offer.discount_percentage;
              const base_price = this.flt(
                (item.original_base_price_list_rate || item.base_price_list_rate / conversion_factor) * conversion_factor,
                this.currency_precision
              );
              const base_discount = this.flt(base_price * offer.discount_percentage / 100, this.currency_precision);
              item.base_discount_amount = base_discount;
              item.base_rate = this.flt(base_price - base_discount, this.currency_precision);
              item.base_price_list_rate = base_price;
              const baseCurrency = this.price_list_currency || this.pos_profile.currency;
              if (this.selected_currency !== baseCurrency) {
                item.price_list_rate = this.flt(base_price * this.exchange_rate, this.currency_precision);
                item.discount_amount = this.flt(base_discount * this.exchange_rate, this.currency_precision);
                item.rate = this.flt(item.base_rate * this.exchange_rate, this.currency_precision);
              } else {
                item.price_list_rate = base_price;
                item.discount_amount = base_discount;
                item.rate = item.base_rate;
              }
            }
            item.amount = this.flt(item.qty * item.rate, this.currency_precision);
            item.base_amount = this.flt(item.qty * item.base_rate, this.currency_precision);
            console.log("Updated rates after applying offer:", {
              rate: item.rate,
              base_rate: item.base_rate,
              price_list_rate: item.price_list_rate,
              base_price_list_rate: item.base_price_list_rate,
              discount_amount: item.discount_amount,
              base_discount_amount: item.base_discount_amount,
              amount: item.amount,
              base_amount: item.base_amount
            });
            item.posa_offer_applied = 1;
            this.$forceUpdate();
          }
        }
      });
    },
    RemoveOnPrice(offer) {
      console.log("Removing price offer:", offer);
      if (!offer || !Array.isArray(this.items))
        return;
      this.items.forEach((item) => {
        if (!item || !item.posa_offers)
          return;
        try {
          const item_offers = JSON.parse(item.posa_offers);
          if (!Array.isArray(item_offers))
            return;
          if (item_offers.includes(offer.row_id)) {
            console.log("Found item with offer:", item);
            if (!item.original_base_rate) {
              console.warn("Original rates not found, fetching from server");
              this.update_item_detail(item);
              return;
            }
            const cf = flt(item.conversion_factor || 1);
            console.log("Restoring original rates with conversion factor:", {
              original_base_rate: item.original_base_rate,
              original_base_price_list_rate: item.original_base_price_list_rate,
              conversion_factor: cf
            });
            item.base_rate = this.flt(item.original_base_rate * cf, this.currency_precision);
            item.base_price_list_rate = this.flt(item.original_base_price_list_rate * cf, this.currency_precision);
            const baseCurrency = this.price_list_currency || this.pos_profile.currency;
            if (this.selected_currency !== baseCurrency) {
              item.rate = this.flt(item.base_rate * this.exchange_rate, this.currency_precision);
              item.price_list_rate = this.flt(item.base_price_list_rate * this.exchange_rate, this.currency_precision);
            } else {
              item.rate = item.base_rate;
              item.price_list_rate = item.base_price_list_rate;
            }
            item.discount_percentage = 0;
            item.discount_amount = 0;
            item.base_discount_amount = 0;
            item.amount = this.flt(item.qty * item.rate, this.currency_precision);
            item.base_amount = this.flt(item.qty * item.base_rate, this.currency_precision);
            const remaining_offers = item_offers.filter((id) => id !== offer.row_id);
            if (remaining_offers.length === 0) {
              item.original_base_rate = null;
              item.original_base_price_list_rate = null;
              item.original_rate = null;
              item.original_price_list_rate = null;
              item.posa_offer_applied = 0;
            }
            item.posa_offers = JSON.stringify(remaining_offers);
            console.log("Updated rates after removing offer:", {
              rate: item.rate,
              base_rate: item.base_rate,
              price_list_rate: item.price_list_rate,
              base_price_list_rate: item.base_price_list_rate,
              amount: item.amount,
              base_amount: item.base_amount,
              remaining_offers
            });
            this.$forceUpdate();
          }
        } catch (error) {
          console.error("Error removing price offer:", error);
          this.eventBus.emit("show_message", {
            title: __("Error removing price offer"),
            color: "error",
            message: error.message
          });
        }
      });
    },
    ApplyOnTotal(offer) {
      if (!offer.name) {
        offer = this.posOffers.find((el) => el.name == offer.offer_name);
      }
      if (this.discount_percentage_offer_name === offer.name && this.discount_amount !== 0) {
        return;
      }
      if ((!this.discount_percentage_offer_name || this.discount_percentage_offer_name == offer.name) && offer.discount_percentage > 0 && offer.discount_percentage <= 100) {
        this.discount_amount = this.flt(
          flt(this.Total) * flt(offer.discount_percentage) / 100,
          this.currency_precision
        );
        this.discount_percentage_offer_name = offer.name;
        this.additional_discount = this.discount_amount;
        if (this.Total && this.Total !== 0) {
          this.additional_discount_percentage = this.discount_amount / this.Total * 100;
        } else {
          this.additional_discount_percentage = 0;
        }
      }
    },
    RemoveOnTotal(offer) {
      if (this.discount_percentage_offer_name && this.discount_percentage_offer_name == offer.offer_name) {
        this.discount_amount = 0;
        this.discount_percentage_offer_name = null;
        this.additional_discount = 0;
        this.additional_discount_percentage = 0;
      }
    },
    addOfferToItems(offer) {
      if (!offer || !offer.items || !Array.isArray(this.items))
        return;
      try {
        const offer_items = typeof offer.items === "string" ? JSON.parse(offer.items) : offer.items;
        if (!Array.isArray(offer_items))
          return;
        offer_items.forEach((el) => {
          this.items.forEach((exist_item) => {
            if (!exist_item || !exist_item.posa_row_id)
              return;
            if (exist_item.posa_row_id == el) {
              const item_offers = exist_item.posa_offers ? JSON.parse(exist_item.posa_offers) : [];
              if (!Array.isArray(item_offers))
                return;
              if (!item_offers.includes(offer.row_id)) {
                item_offers.push(offer.row_id);
                if (offer.offer === "Item Price") {
                  exist_item.posa_offer_applied = 1;
                }
              }
              exist_item.posa_offers = JSON.stringify(item_offers);
            }
          });
        });
      } catch (error) {
        console.error("Error adding offer to items:", error);
        this.eventBus.emit("show_message", {
          title: __("Error adding offer to items"),
          color: "error",
          message: error.message
        });
      }
    },
    deleteOfferFromItems(offer) {
      if (!offer || !offer.items || !Array.isArray(this.items))
        return;
      try {
        const offer_items = typeof offer.items === "string" ? JSON.parse(offer.items) : offer.items;
        if (!Array.isArray(offer_items))
          return;
        offer_items.forEach((el) => {
          this.items.forEach((exist_item) => {
            if (!exist_item || !exist_item.posa_row_id)
              return;
            if (exist_item.posa_row_id == el) {
              const item_offers = exist_item.posa_offers ? JSON.parse(exist_item.posa_offers) : [];
              if (!Array.isArray(item_offers))
                return;
              const updated_item_offers = item_offers.filter(
                (row_id) => row_id != offer.row_id
              );
              if (offer.offer === "Item Price") {
                exist_item.posa_offer_applied = 0;
              }
              exist_item.posa_offers = JSON.stringify(updated_item_offers);
            }
          });
        });
      } catch (error) {
        console.error("Error deleting offer from items:", error);
        this.eventBus.emit("show_message", {
          title: __("Error deleting offer from items"),
          color: "error",
          message: error.message
        });
      }
    },
    validate_due_date(item) {
      const today = frappe.datetime.now_date();
      const parse_today = Date.parse(today);
      const backend_date = this.formatDateForBackend(item.posa_delivery_date);
      const new_date = Date.parse(backend_date);
      if (isNaN(new_date) || new_date < parse_today) {
        setTimeout(() => {
          item.posa_delivery_date = this.formatDateForDisplay(today);
        }, 0);
      } else {
        item.posa_delivery_date = this.formatDateForDisplay(backend_date);
      }
    },
    load_print_page(invoice_name) {
      const print_format = this.pos_profile.print_format_for_online || this.pos_profile.print_format;
      const letter_head = this.pos_profile.letter_head || 0;
      const url = frappe.urllib.get_base_url() + "/printview?doctype=Sales%20Invoice&name=" + invoice_name + "&trigger_print=1&format=" + print_format + "&no_letterhead=" + letter_head;
      if (this.pos_profile.posa_silent_print) {
        silentPrint(url);
      } else {
        const printWindow = window.open(url, "Print");
        printWindow.addEventListener(
          "load",
          function() {
            printWindow.print();
          },
          { once: true }
        );
      }
    },
    formatDateForBackend(date2) {
      if (!date2)
        return null;
      if (typeof date2 === "string") {
        if (/^\d{4}-\d{2}-\d{2}$/.test(date2)) {
          return date2;
        }
        if (/^\d{1,2}-\d{1,2}-\d{4}$/.test(date2)) {
          const [d2, m, y] = date2.split("-");
          return `${y}-${m.padStart(2, "0")}-${d2.padStart(2, "0")}`;
        }
      }
      const d = new Date(date2);
      if (!isNaN(d.getTime())) {
        const year = d.getFullYear();
        const month = `0${d.getMonth() + 1}`.slice(-2);
        const day = `0${d.getDate()}`.slice(-2);
        return `${year}-${month}-${day}`;
      }
      return date2;
    },
    formatDateForDisplay(date2) {
      if (!date2)
        return "";
      if (typeof date2 === "string" && /^\d{4}-\d{2}-\d{2}$/.test(date2)) {
        const [y, m, d2] = date2.split("-");
        return `${d2}-${m}-${y}`;
      }
      const d = new Date(date2);
      if (!isNaN(d.getTime())) {
        const year = d.getFullYear();
        const month = `0${d.getMonth() + 1}`.slice(-2);
        const day = `0${d.getDate()}`.slice(-2);
        return `${day}-${month}-${year}`;
      }
      return date2;
    },
    toggleOffer(item) {
      this.$nextTick(() => {
        if (!item.posa_is_offer) {
          item.posa_offers = JSON.stringify([]);
          item.posa_offer_applied = 0;
          item.discount_percentage = 0;
          item.discount_amount = 0;
          item.rate = item.price_list_rate;
          this.calc_item_price(item);
          this.handelOffers();
        }
        this.$forceUpdate();
      });
    }
  };

  // ../posawesome/posawesome/public/js/posapp/components/pos/invoiceShortcuts.js
  var invoiceShortcuts_default = {
    shortOpenFirstItem(e) {
      if (e.key.toLowerCase() === "a" && (e.ctrlKey || e.metaKey)) {
        try {
          e.preventDefault();
          e.stopPropagation();
          if (!this.items || this.items.length === 0) {
            console.log("No items to expand/collapse");
            return;
          }
          const firstItem = this.items[0];
          console.log("Processing first item:", firstItem.item_code);
          const isExpanded = this.expanded.includes(firstItem.posa_row_id);
          if (isExpanded) {
            console.log("Collapsing item:", firstItem.item_code);
            this.expanded = [];
          } else {
            console.log("Expanding item:", firstItem.item_code);
            this.expanded = [firstItem.posa_row_id];
            this.$nextTick(() => {
              this.update_item_detail(firstItem);
            });
          }
        } catch (error) {
          console.error("Error in shortOpenFirstItem:", error);
          this.eventBus.emit("show_message", {
            title: __("Error toggling item details"),
            color: "error"
          });
        }
      }
    },
    handleExpandedUpdate(newExpanded) {
      console.log("Expanded state updated:", newExpanded);
      this.expanded = newExpanded;
      if (newExpanded && newExpanded.length > 0) {
        const expandedItemId = newExpanded[0];
        const expandedItem = this.items.find((item) => item.posa_row_id === expandedItemId);
        if (expandedItem) {
          this.$nextTick(() => {
            this.update_item_detail(expandedItem);
          });
        }
      }
    },
    shortOpenPayment(e) {
      if (e.key === "s" && (e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        this.show_payment();
      }
    },
    shortDeleteFirstItem(e) {
      if (e.key === "d" && (e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        this.remove_item(this.items[0]);
      }
    },
    shortSelectDiscount(e) {
      console.log("Shortcut pressed:", e.key, e.ctrlKey);
      if (e.key.toLowerCase() === "e" && (e.ctrlKey || e.metaKey)) {
        console.log("Focusing discount field");
        e.preventDefault();
        e.stopPropagation();
        if (this.$refs.discount) {
          this.$refs.discount.focus();
          console.log("Discount field focused");
        } else {
          console.log("Discount field ref not found");
        }
      }
    }
  };

  // ../posawesome/posawesome/public/js/posapp/components/pos/invoiceItemMethods.js
  var invoiceItemMethods_default = {
    remove_item(item) {
      const index = this.items.findIndex(
        (el) => el.posa_row_id == item.posa_row_id
      );
      if (index >= 0) {
        this.items.splice(index, 1);
      }
      this.expanded = this.expanded.filter((id) => id !== item.posa_row_id);
    },
    add_item(item) {
      if (!item.uom) {
        item.uom = item.stock_uom;
      }
      let index = -1;
      if (!this.new_line) {
        if (this.pos_profile.posa_auto_set_batch && item.has_batch_no) {
          index = this.items.findIndex(
            (el) => el.item_code === item.item_code && el.uom === item.uom && !el.posa_is_offer && !el.posa_is_replace
          );
        } else {
          index = this.items.findIndex(
            (el) => el.item_code === item.item_code && el.uom === item.uom && !el.posa_is_offer && !el.posa_is_replace && (el.batch_no && item.batch_no && el.batch_no === item.batch_no || !el.batch_no && !item.batch_no)
          );
        }
      }
      let new_item;
      if (index === -1 || this.new_line) {
        new_item = this.get_new_item(item);
        if (item.has_serial_no && item.to_set_serial_no) {
          new_item.serial_no_selected = [];
          new_item.serial_no_selected.push(item.to_set_serial_no);
          item.to_set_serial_no = null;
        }
        if (item.has_batch_no && item.to_set_batch_no) {
          new_item.batch_no = item.to_set_batch_no;
          item.to_set_batch_no = null;
          item.batch_no = null;
          this.set_batch_qty(new_item, new_item.batch_no, false);
        }
        if (this.isReturnInvoice) {
          new_item.qty = -Math.abs(new_item.qty || 1);
        }
        this.items.unshift(new_item);
        this.update_item_detail(new_item, true);
        if (!this.pos_profile.posa_auto_set_batch && new_item.has_batch_no || new_item.has_serial_no) {
          this.$nextTick(() => {
            this.expanded = [new_item.posa_row_id];
          });
        }
      } else {
        const cur_item = this.items[index];
        this.update_items_details([cur_item]);
        if (item.has_serial_no && item.to_set_serial_no) {
          if (cur_item.serial_no_selected.includes(item.to_set_serial_no)) {
            this.eventBus.emit("show_message", {
              title: __(`This Serial Number {0} has already been added!`, [
                item.to_set_serial_no
              ]),
              color: "warning"
            });
            item.to_set_serial_no = null;
            return;
          }
          cur_item.serial_no_selected.push(item.to_set_serial_no);
          item.to_set_serial_no = null;
        }
        if (this.isReturnInvoice) {
          cur_item.qty -= item.qty || 1;
        } else {
          cur_item.qty += item.qty || 1;
        }
        this.calc_stock_qty(cur_item, cur_item.qty);
        if (cur_item.has_batch_no && cur_item.batch_no) {
          this.set_batch_qty(cur_item, cur_item.batch_no, false);
        }
        this.set_serial_no(cur_item);
      }
      this.$forceUpdate();
      if (new_item && (!this.pos_profile.posa_auto_set_batch && new_item.has_batch_no || new_item.has_serial_no)) {
        this.expanded = [new_item.posa_row_id];
      }
    },
    get_new_item(item) {
      const new_item = __spreadValues({}, item);
      if (!new_item.warehouse) {
        new_item.warehouse = this.pos_profile.warehouse;
      }
      if (!item.qty) {
        item.qty = 1;
      }
      if (!item.posa_is_offer) {
        item.posa_is_offer = 0;
      }
      if (!item.posa_is_replace) {
        item.posa_is_replace = "";
      }
      new_item._manual_rate_set = false;
      if (this.isReturnInvoice && item.qty > 0) {
        item.qty = -Math.abs(item.qty);
      }
      new_item.stock_qty = item.qty;
      new_item.discount_amount = 0;
      new_item.discount_percentage = 0;
      new_item.discount_amount_per_item = 0;
      new_item.price_list_rate = item.rate;
      const baseCurrency = this.price_list_currency || this.pos_profile.currency;
      if (this.selected_currency !== baseCurrency) {
        new_item.base_price_list_rate = item.base_price_list_rate || item.rate / this.exchange_rate;
        new_item.base_rate = item.base_rate || item.rate / this.exchange_rate;
        new_item.base_discount_amount = 0;
      } else {
        new_item.base_price_list_rate = item.base_price_list_rate || item.rate;
        new_item.base_rate = item.base_rate || item.rate;
        new_item.base_discount_amount = 0;
      }
      new_item.qty = item.qty;
      new_item.uom = item.uom ? item.uom : item.stock_uom;
      new_item.item_uoms = item.item_uoms || [];
      if (new_item.item_uoms.length === 0 && new_item.stock_uom) {
        new_item.item_uoms.push({ uom: new_item.stock_uom, conversion_factor: 1 });
      }
      new_item.actual_batch_qty = "";
      new_item.batch_no_expiry_date = item.batch_no_expiry_date || null;
      new_item.conversion_factor = 1;
      new_item.posa_offers = JSON.stringify([]);
      new_item.posa_offer_applied = 0;
      new_item.posa_is_offer = item.posa_is_offer;
      new_item.posa_is_replace = item.posa_is_replace || null;
      new_item.is_free_item = 0;
      new_item.posa_notes = "";
      new_item.posa_delivery_date = "";
      new_item.posa_row_id = this.makeid(20);
      if (new_item.has_serial_no && !new_item.serial_no_selected) {
        new_item.serial_no_selected = [];
        new_item.serial_no_selected_count = 0;
      }
      if (!this.pos_profile.posa_auto_set_batch && new_item.has_batch_no || new_item.has_serial_no) {
        this.expanded.push(new_item);
      }
      return new_item;
    },
    clear_invoice() {
      this.items = [];
      this.posa_offers = [];
      this.expanded = [];
      this.eventBus.emit("set_pos_coupons", []);
      this.posa_coupons = [];
      this.invoice_doc = "";
      this.return_doc = "";
      this.discount_amount = 0;
      this.additional_discount = 0;
      this.additional_discount_percentage = 0;
      this.delivery_charges_rate = 0;
      this.selected_delivery_charge = "";
      this.posting_date = frappe.datetime.nowdate();
      this.customer = this.pos_profile.customer;
      this.eventBus.emit("set_customer_readonly", false);
      this.invoiceType = this.pos_profile.posa_default_sales_order ? "Order" : "Invoice";
      this.invoiceTypes = ["Invoice", "Order"];
    },
    async fetch_customer_balance() {
      var _a3;
      try {
        if (!this.customer) {
          this.customer_balance = 0;
          return;
        }
        if (isOffline()) {
          const cachedBalance = getCachedCustomerBalance(this.customer);
          if (cachedBalance !== null) {
            this.customer_balance = cachedBalance;
            return;
          } else {
            this.customer_balance = 0;
            this.eventBus.emit("show_message", {
              title: __("Customer balance unavailable offline"),
              text: __("Balance will be updated when connection is restored"),
              color: "warning"
            });
            return;
          }
        }
        const r = await frappe.call({
          method: "posawesome.posawesome.api.customer.get_customer_balance",
          args: { customer: this.customer }
        });
        const balance = ((_a3 = r == null ? void 0 : r.message) == null ? void 0 : _a3.balance) || 0;
        this.customer_balance = balance;
        saveCustomerBalance(this.customer, balance);
      } catch (error) {
        console.error("Error fetching balance:", error);
        const cachedBalance = getCachedCustomerBalance(this.customer);
        if (cachedBalance !== null) {
          this.customer_balance = cachedBalance;
          this.eventBus.emit("show_message", {
            title: __("Using cached customer balance"),
            text: __("Could not fetch latest balance from server"),
            color: "warning"
          });
        } else {
          this.eventBus.emit("show_message", {
            title: __("Error fetching customer balance"),
            color: "error"
          });
          this.customer_balance = 0;
        }
      }
    },
    async cancel_invoice() {
      const doc2 = this.get_invoice_doc();
      this.invoiceType = this.pos_profile.posa_default_sales_order ? "Order" : "Invoice";
      this.invoiceTypes = ["Invoice", "Order"];
      this.posting_date = frappe.datetime.nowdate();
      var vm2 = this;
      if (doc2.name && this.pos_profile.posa_allow_delete) {
        await frappe.call({
          method: "posawesome.posawesome.api.invoices.delete_invoice",
          args: { invoice: doc2.name },
          async: true,
          callback: function(r) {
            if (r.message) {
              vm2.eventBus.emit("show_message", {
                text: r.message,
                color: "warning"
              });
            }
          }
        });
      }
      this.clear_invoice();
      this.cancel_dialog = false;
    },
    async load_invoice(data = {}) {
      console.log("load_invoice called with data:", {
        is_return: data.is_return,
        return_against: data.return_against,
        customer: data.customer,
        items_count: data.items ? data.items.length : 0
      });
      this.clear_invoice();
      if (data.is_return) {
        console.log("Processing return invoice");
        if (data.return_against) {
          console.log("Return has reference to invoice:", data.return_against);
          this.eventBus.emit("set_customer_readonly", true);
        } else {
          console.log("Return without invoice reference, customer can be selected");
          this.eventBus.emit("set_customer_readonly", false);
        }
        this.invoiceType = "Return";
        this.invoiceTypes = ["Return"];
      }
      this.invoice_doc = data;
      this.items = data.items || [];
      console.log("Items set:", this.items.length, "items");
      if (this.items.length > 0) {
        this.update_items_details(this.items);
        this.posa_offers = data.posa_offers || [];
        this.items.forEach((item) => {
          if (!item.posa_row_id) {
            item.posa_row_id = this.makeid(20);
          }
          if (item.batch_no) {
            this.set_batch_qty(item, item.batch_no);
          }
        });
      } else {
        console.log("Warning: No items in return invoice");
      }
      this.customer = data.customer;
      this.posting_date = this.formatDateForBackend(
        data.posting_date || frappe.datetime.nowdate()
      );
      this.discount_amount = data.discount_amount;
      this.additional_discount_percentage = data.additional_discount_percentage;
      if (this.items.length > 0) {
        this.items.forEach((item) => {
          if (item.serial_no) {
            item.serial_no_selected = [];
            const serial_list = item.serial_no.split("\n");
            serial_list.forEach((element) => {
              if (element.length) {
                item.serial_no_selected.push(element);
              }
            });
            item.serial_no_selected_count = item.serial_no_selected.length;
          }
        });
      }
      if (data.is_return) {
        console.log("Setting return values for discounts");
        this.discount_amount = -data.discount_amount;
        this.additional_discount_percentage = -data.additional_discount_percentage;
        this.return_doc = data;
      } else {
        this.eventBus.emit("set_pos_coupons", data.posa_coupons);
      }
      console.log("load_invoice completed, invoice state:", {
        invoiceType: this.invoiceType,
        is_return: this.invoice_doc.is_return,
        items: this.items.length,
        customer: this.customer
      });
    },
    save_and_clear_invoice() {
      const doc2 = this.get_invoice_doc();
      if (doc2.name) {
        old_invoice = this.update_invoice(doc2);
      } else {
        if (doc2.items.length) {
          old_invoice = this.update_invoice(doc2);
        } else {
          this.eventBus.emit("show_message", {
            title: `Nothing to save`,
            color: "error"
          });
        }
      }
      if (!old_invoice) {
        this.eventBus.emit("show_message", {
          title: `Error saving the current invoice`,
          color: "error"
        });
      } else {
        this.clear_invoice();
        return old_invoice;
      }
    },
    async new_order(data = {}) {
      let old_invoice2 = null;
      this.eventBus.emit("set_customer_readonly", false);
      this.expanded = [];
      this.posa_offers = [];
      this.eventBus.emit("set_pos_coupons", []);
      this.posa_coupons = [];
      this.return_doc = "";
      if (!data.name && !data.is_return) {
        this.items = [];
        this.customer = this.pos_profile.customer;
        this.invoice_doc = "";
        this.discount_amount = 0;
        this.additional_discount_percentage = 0;
        this.invoiceType = "Invoice";
        this.invoiceTypes = ["Invoice", "Order"];
      } else {
        if (data.is_return) {
          if (data.return_against) {
            this.eventBus.emit("set_customer_readonly", true);
          } else {
            this.eventBus.emit("set_customer_readonly", false);
          }
          this.invoiceType = "Return";
          this.invoiceTypes = ["Return"];
        }
        this.invoice_doc = data;
        this.items = data.items;
        this.update_items_details(this.items);
        this.posa_offers = data.posa_offers || [];
        this.items.forEach((item) => {
          if (!item.posa_row_id) {
            item.posa_row_id = this.makeid(20);
          }
          if (item.batch_no) {
            this.set_batch_qty(item, item.batch_no);
          }
        });
        this.customer = data.customer;
        this.posting_date = this.formatDateForBackend(
          data.posting_date || frappe.datetime.nowdate()
        );
        this.discount_amount = data.discount_amount;
        this.additional_discount_percentage = data.additional_discount_percentage;
        this.items.forEach((item) => {
          if (item.serial_no) {
            item.serial_no_selected = [];
            const serial_list = item.serial_no.split("\n");
            serial_list.forEach((element) => {
              if (element.length) {
                item.serial_no_selected.push(element);
              }
            });
            item.serial_no_selected_count = item.serial_no_selected.length;
          }
        });
      }
      return old_invoice2;
    },
    get_invoice_doc() {
      let doc2 = {};
      if (this.invoice_doc.name) {
        doc2 = __spreadValues({}, this.invoice_doc);
      }
      if (this.invoiceType === "Order" && this.pos_profile.posa_create_only_sales_order) {
        doc2.doctype = "Sales Order";
      } else {
        doc2.doctype = "Sales Invoice";
      }
      doc2.is_pos = 1;
      doc2.ignore_pricing_rule = 1;
      doc2.company = doc2.company || this.pos_profile.company;
      doc2.pos_profile = doc2.pos_profile || this.pos_profile.name;
      doc2.currency = this.selected_currency || this.pos_profile.currency;
      doc2.conversion_rate = this.invoice_doc && this.invoice_doc.conversion_rate || this.conversion_rate || 1;
      doc2.price_list_currency = this.price_list_currency || doc2.currency;
      doc2.plc_conversion_rate = this.invoice_doc && this.invoice_doc.plc_conversion_rate || (doc2.price_list_currency === doc2.currency ? 1 : this.exchange_rate);
      doc2.campaign = doc2.campaign || this.pos_profile.campaign;
      doc2.selling_price_list = this.pos_profile.selling_price_list;
      doc2.naming_series = doc2.naming_series || this.pos_profile.naming_series;
      doc2.customer = this.customer;
      const isReturn = this.isReturnInvoice;
      doc2.is_return = isReturn ? 1 : 0;
      const items = this.get_invoice_items();
      doc2.items = items;
      let total = this.Total;
      if (isReturn && total > 0)
        total = -Math.abs(total);
      doc2.total = total;
      doc2.net_total = total;
      doc2.base_total = total * (this.exchange_rate || 1);
      doc2.base_net_total = total * (this.exchange_rate || 1);
      let discountAmount = flt(this.additional_discount);
      if (isReturn && discountAmount > 0)
        discountAmount = -Math.abs(discountAmount);
      doc2.discount_amount = discountAmount;
      doc2.base_discount_amount = discountAmount * (this.exchange_rate || 1);
      let discountPercentage = flt(this.additional_discount_percentage);
      if (isReturn && discountPercentage > 0)
        discountPercentage = -Math.abs(discountPercentage);
      doc2.additional_discount_percentage = discountPercentage;
      let grandTotal = this.subtotal;
      if (this.invoice_doc && this.invoice_doc.taxes) {
        this.invoice_doc.taxes.forEach((tax) => {
          if (tax.tax_amount) {
            grandTotal += flt(tax.tax_amount);
          }
        });
      }
      if (isReturn && grandTotal > 0)
        grandTotal = -Math.abs(grandTotal);
      doc2.grand_total = grandTotal;
      doc2.base_grand_total = grandTotal * (this.exchange_rate || 1);
      if (this.pos_profile.disable_rounded_total) {
        doc2.rounded_total = flt(grandTotal, this.currency_precision);
        doc2.base_rounded_total = flt(doc2.base_grand_total, this.currency_precision);
      } else {
        doc2.rounded_total = this.roundAmount(grandTotal);
        doc2.base_rounded_total = this.roundAmount(doc2.base_grand_total);
      }
      doc2.posa_pos_opening_shift = this.pos_opening_shift.name;
      doc2.payments = this.get_payments();
      doc2.taxes = [];
      if (this.invoice_doc && this.invoice_doc.taxes) {
        doc2.taxes = this.invoice_doc.taxes.map((tax) => {
          return {
            account_head: tax.account_head,
            charge_type: tax.charge_type || "On Net Total",
            description: tax.description,
            rate: tax.rate,
            tax_amount: tax.tax_amount,
            total: tax.total,
            base_tax_amount: tax.tax_amount * (this.exchange_rate || 1),
            base_total: tax.total * (this.exchange_rate || 1)
          };
        });
      }
      if (isReturn) {
        if (this.invoice_doc.return_against) {
          doc2.return_against = this.invoice_doc.return_against;
        }
        doc2.update_stock = 1;
        if (doc2.grand_total > 0)
          doc2.grand_total = -Math.abs(doc2.grand_total);
        if (doc2.base_grand_total > 0)
          doc2.base_grand_total = -Math.abs(doc2.base_grand_total);
        if (doc2.rounded_total > 0)
          doc2.rounded_total = -Math.abs(doc2.rounded_total);
        if (doc2.base_rounded_total > 0)
          doc2.base_rounded_total = -Math.abs(doc2.base_rounded_total);
        if (doc2.total > 0)
          doc2.total = -Math.abs(doc2.total);
        if (doc2.base_total > 0)
          doc2.base_total = -Math.abs(doc2.base_total);
        if (doc2.net_total > 0)
          doc2.net_total = -Math.abs(doc2.net_total);
        if (doc2.base_net_total > 0)
          doc2.base_net_total = -Math.abs(doc2.base_net_total);
        if (doc2.payments && doc2.payments.length) {
          doc2.payments.forEach((payment) => {
            if (payment.amount > 0)
              payment.amount = -Math.abs(payment.amount);
            if (payment.base_amount > 0)
              payment.base_amount = -Math.abs(payment.base_amount);
          });
        }
      }
      doc2.posa_offers = this.posa_offers;
      doc2.posa_coupons = this.posa_coupons;
      doc2.posa_delivery_charges = this.selected_delivery_charge.name;
      doc2.posa_delivery_charges_rate = this.delivery_charges_rate || 0;
      doc2.posting_date = this.formatDateForBackend(this.posting_date_display);
      doc2.ignore_pricing_rule = 1;
      doc2.price_list_currency = this.price_list_currency || doc2.currency;
      doc2.plc_conversion_rate = this.exchange_rate || doc2.conversion_rate;
      doc2.ignore_default_fields = 1;
      doc2.posa_is_offer_applied = this.posa_offers.length > 0 ? 1 : 0;
      const baseCurrency = this.price_list_currency || this.pos_profile.currency;
      if (this.selected_currency !== baseCurrency) {
        const multiplier = isReturn ? -1 : 1;
        doc2.base_total = total / this.exchange_rate * multiplier;
        doc2.base_net_total = total / this.exchange_rate * multiplier;
        doc2.base_discount_amount = discountAmount / this.exchange_rate * multiplier;
        doc2.base_grand_total = grandTotal / this.exchange_rate * multiplier;
        doc2.base_rounded_total = grandTotal / this.exchange_rate * multiplier;
      } else {
        const multiplier = isReturn ? -1 : 1;
        doc2.base_total = total * multiplier;
        doc2.base_net_total = total * multiplier;
        doc2.base_discount_amount = discountAmount * multiplier;
        doc2.base_grand_total = grandTotal * multiplier;
        doc2.base_rounded_total = grandTotal * multiplier;
      }
      if (doc2.payments && doc2.payments.length) {
        doc2.payments.forEach((payment) => {
          if (this.selected_currency !== baseCurrency) {
            payment.base_amount = payment.amount / this.exchange_rate;
          } else {
            payment.base_amount = payment.amount;
          }
          if (isReturn) {
            payment.amount = -Math.abs(payment.amount);
            payment.base_amount = -Math.abs(payment.base_amount);
          }
        });
      }
      return doc2;
    },
    async get_invoice_from_order_doc() {
      let doc2 = {};
      if (this.invoice_doc.doctype == "Sales Order") {
        await frappe.call({
          method: "posawesome.posawesome.api.invoices.create_sales_invoice_from_order",
          args: {
            sales_order: this.invoice_doc.name
          },
          callback: function(r) {
            if (r.message) {
              doc2 = r.message;
            }
          }
        });
      } else {
        doc2 = this.invoice_doc;
      }
      const Items = [];
      const updatedItemsData = this.get_invoice_items();
      doc2.items.forEach((item) => {
        const updatedData = updatedItemsData.find(
          (updatedItem) => updatedItem.item_code === item.item_code
        );
        if (updatedData) {
          item.item_code = updatedData.item_code;
          item.posa_row_id = updatedData.posa_row_id;
          item.posa_offers = updatedData.posa_offers;
          item.posa_offer_applied = updatedData.posa_offer_applied;
          item.posa_is_offer = updatedData.posa_is_offer;
          item.posa_is_replace = updatedData.posa_is_replace;
          item.is_free_item = updatedData.is_free_item;
          item.qty = flt(updatedData.qty);
          item.rate = flt(updatedData.rate);
          item.uom = updatedData.uom;
          item.amount = flt(updatedData.qty) * flt(updatedData.rate);
          item.conversion_factor = updatedData.conversion_factor;
          item.serial_no = updatedData.serial_no;
          item.discount_percentage = flt(updatedData.discount_percentage);
          item.discount_amount = flt(updatedData.discount_amount);
          item.batch_no = updatedData.batch_no;
          item.posa_notes = updatedData.posa_notes;
          item.posa_delivery_date = this.formatDateForDisplay(
            updatedData.posa_delivery_date
          );
          item.price_list_rate = updatedData.price_list_rate;
          Items.push(item);
        }
      });
      doc2.items = Items;
      const newItems = [...doc2.items];
      const existingItemCodes = new Set(newItems.map((item) => item.item_code));
      updatedItemsData.forEach((updatedItem) => {
        if (!existingItemCodes.has(updatedItem.item_code)) {
          newItems.push(updatedItem);
        }
      });
      doc2.items = newItems;
      doc2.update_stock = 1;
      doc2.is_pos = 1;
      doc2.payments = this.get_payments();
      return doc2;
    },
    get_invoice_items() {
      const items_list = [];
      const isReturn = this.isReturnInvoice;
      this.items.forEach((item) => {
        const new_item = __spreadProps(__spreadValues({
          item_code: item.item_code,
          item_name: item.item_name || item.item_code,
          posa_row_id: item.posa_row_id,
          posa_offers: item.posa_offers,
          posa_offer_applied: item.posa_offer_applied,
          posa_is_offer: item.posa_is_offer,
          posa_is_replace: item.posa_is_replace,
          is_free_item: item.is_free_item,
          qty: flt(item.qty),
          uom: item.uom,
          conversion_factor: item.conversion_factor,
          serial_no: item.serial_no
        }, item.sales_invoice_item && { sales_invoice_item: item.sales_invoice_item }), {
          discount_percentage: flt(item.discount_percentage),
          batch_no: item.batch_no,
          posa_notes: item.posa_notes,
          posa_delivery_date: this.formatDateForBackend(item.posa_delivery_date)
        });
        if (isReturn && !new_item.sales_invoice_item && item.name) {
          new_item.sales_invoice_item = item.name;
        }
        const baseCurrency = this.price_list_currency || this.pos_profile.currency;
        if (this.selected_currency !== baseCurrency) {
          new_item.rate = flt(item.rate);
          new_item.base_rate = item.base_rate || flt(item.rate / this.exchange_rate);
          new_item.price_list_rate = flt(item.price_list_rate);
          new_item.base_price_list_rate = item.base_price_list_rate || flt(item.price_list_rate / this.exchange_rate);
          new_item.amount = flt(item.qty) * new_item.rate;
          new_item.base_amount = new_item.amount / this.exchange_rate;
          new_item.discount_amount = flt(item.discount_amount);
          new_item.base_discount_amount = item.base_discount_amount || flt(item.discount_amount / this.exchange_rate);
        } else {
          new_item.rate = flt(item.rate);
          new_item.base_rate = item.base_rate || flt(item.rate);
          new_item.price_list_rate = flt(item.price_list_rate);
          new_item.base_price_list_rate = item.base_price_list_rate || flt(item.price_list_rate);
          new_item.amount = flt(item.qty) * new_item.rate;
          new_item.base_amount = new_item.amount;
          new_item.discount_amount = flt(item.discount_amount);
          new_item.base_discount_amount = item.base_discount_amount || flt(item.discount_amount);
        }
        if (isReturn) {
          new_item.qty = -Math.abs(new_item.qty);
          new_item.amount = -Math.abs(new_item.amount);
          new_item.base_amount = -Math.abs(new_item.base_amount);
          new_item.discount_amount = -Math.abs(new_item.discount_amount);
          new_item.base_discount_amount = -Math.abs(new_item.base_discount_amount);
        }
        items_list.push(new_item);
      });
      return items_list;
    },
    get_order_items() {
      const items_list = [];
      this.items.forEach((item) => {
        const new_item = {
          item_code: item.item_code,
          item_name: item.item_name || item.item_code,
          posa_row_id: item.posa_row_id,
          posa_offers: item.posa_offers,
          posa_offer_applied: item.posa_offer_applied,
          posa_is_offer: item.posa_is_offer,
          posa_is_replace: item.posa_is_replace,
          is_free_item: item.is_free_item,
          qty: flt(item.qty),
          rate: flt(item.rate),
          uom: item.uom,
          amount: flt(item.qty) * flt(item.rate),
          conversion_factor: item.conversion_factor,
          serial_no: item.serial_no,
          discount_percentage: flt(item.discount_percentage),
          discount_amount: flt(item.discount_amount),
          batch_no: item.batch_no,
          posa_notes: item.posa_notes,
          posa_delivery_date: item.posa_delivery_date,
          price_list_rate: item.price_list_rate
        };
        items_list.push(new_item);
      });
      return items_list;
    },
    get_payments() {
      const payments = [];
      const total_amount = this.subtotal;
      let remaining_amount = total_amount;
      this.pos_profile.payments.forEach((payment, index) => {
        const payment_amount = index === 0 ? remaining_amount : payment.amount || 0;
        const adjusted_amount = this.isReturnInvoice ? -Math.abs(payment_amount) : payment_amount;
        const baseCurrency = this.price_list_currency || this.pos_profile.currency;
        const base_amount = this.selected_currency !== baseCurrency ? this.flt(adjusted_amount / (this.exchange_rate || 1), this.currency_precision) : adjusted_amount;
        payments.push({
          amount: adjusted_amount,
          base_amount,
          mode_of_payment: payment.mode_of_payment,
          default: payment.default,
          account: payment.account || "",
          type: payment.type || "Cash",
          currency: this.selected_currency || this.pos_profile.currency,
          conversion_rate: this.conversion_rate || 1
        });
        remaining_amount -= payment_amount;
      });
      console.log("Generated payments:", {
        currency: this.selected_currency,
        exchange_rate: this.exchange_rate,
        payments: payments.map((p2) => ({
          mode: p2.mode_of_payment,
          amount: p2.amount,
          base_amount: p2.base_amount
        }))
      });
      return payments;
    },
    convert_amount(amount) {
      const baseCurrency = this.price_list_currency || this.pos_profile.currency;
      if (this.selected_currency === baseCurrency) {
        return amount;
      }
      return this.flt(amount * this.exchange_rate, this.currency_precision);
    },
    update_invoice(doc2) {
      var vm2 = this;
      if (isOffline()) {
        vm2.invoice_doc = Object.assign({}, vm2.invoice_doc || {}, doc2);
        return vm2.invoice_doc;
      }
      frappe.call({
        method: doc2.doctype === "Sales Order" && this.pos_profile.posa_create_only_sales_order ? "posawesome.posawesome.api.sales_orders.update_sales_order" : "posawesome.posawesome.api.invoices.update_invoice",
        args: {
          data: doc2
        },
        async: false,
        callback: function(r) {
          if (r.message) {
            vm2.invoice_doc = r.message;
            if (r.message.exchange_rate_date) {
              vm2.exchange_rate_date = r.message.exchange_rate_date;
              const posting_backend = vm2.formatDateForBackend(vm2.posting_date_display);
              if (posting_backend !== vm2.exchange_rate_date) {
                vm2.eventBus.emit("show_message", {
                  title: __(
                    "Exchange rate date " + vm2.exchange_rate_date + " differs from posting date " + posting_backend
                  ),
                  color: "warning"
                });
              }
            }
          }
        }
      });
      return this.invoice_doc;
    },
    update_invoice_from_order(doc2) {
      var vm2 = this;
      if (isOffline()) {
        vm2.invoice_doc = Object.assign({}, vm2.invoice_doc || {}, doc2);
        return vm2.invoice_doc;
      }
      frappe.call({
        method: "posawesome.posawesome.api.invoices.update_invoice_from_order",
        args: {
          data: doc2
        },
        async: false,
        callback: function(r) {
          if (r.message) {
            vm2.invoice_doc = r.message;
            if (r.message.exchange_rate_date) {
              vm2.exchange_rate_date = r.message.exchange_rate_date;
              const posting_backend = vm2.formatDateForBackend(vm2.posting_date_display);
              if (posting_backend !== vm2.exchange_rate_date) {
                vm2.eventBus.emit("show_message", {
                  title: __(
                    "Exchange rate date " + vm2.exchange_rate_date + " differs from posting date " + posting_backend
                  ),
                  color: "warning"
                });
              }
            }
          }
        }
      });
      return this.invoice_doc;
    },
    process_invoice() {
      const doc2 = this.get_invoice_doc();
      try {
        const updated_doc = this.update_invoice(doc2);
        if (updated_doc && updated_doc.posting_date) {
          this.posting_date = this.formatDateForBackend(updated_doc.posting_date);
        }
        return updated_doc;
      } catch (error) {
        console.error("Error in process_invoice:", error);
        this.eventBus.emit("show_message", {
          title: __(error.message || "Error processing invoice"),
          color: "error"
        });
        return false;
      }
    },
    async process_invoice_from_order() {
      const doc2 = await this.get_invoice_from_order_doc();
      var up_invoice;
      if (doc2.name) {
        up_invoice = await this.update_invoice_from_order(doc2);
        return up_invoice;
      } else {
        return this.update_invoice_from_order(doc2);
      }
    },
    async show_payment() {
      try {
        console.log("Starting show_payment process");
        console.log("Invoice state before payment:", {
          invoiceType: this.invoiceType,
          is_return: this.invoice_doc ? this.invoice_doc.is_return : false,
          items_count: this.items.length,
          customer: this.customer
        });
        if (!this.customer) {
          console.log("Customer validation failed");
          this.eventBus.emit("show_message", {
            title: __(`Select a customer`),
            color: "error"
          });
          return;
        }
        if (!this.items.length) {
          console.log("Items validation failed - no items");
          this.eventBus.emit("show_message", {
            title: __(`Select items to sell`),
            color: "error"
          });
          return;
        }
        console.log("Basic validations passed, proceeding to main validation");
        const isValid3 = this.validate();
        console.log("Main validation result:", isValid3);
        if (!isValid3) {
          console.log("Main validation failed");
          return;
        }
        let invoice_doc;
        if (this.invoiceType === "Order" && this.pos_profile.posa_create_only_sales_order && !this.new_delivery_date && !this.invoice_doc.posa_delivery_date) {
          console.log("Building local Sales Order doc for payment");
          invoice_doc = this.get_invoice_doc();
        } else if (this.invoice_doc.doctype == "Sales Order" && !this.pos_profile.posa_create_only_sales_order) {
          console.log("Processing Sales Order payment");
          invoice_doc = await this.process_invoice_from_order();
        } else {
          console.log("Processing regular invoice");
          invoice_doc = this.process_invoice();
        }
        if (!invoice_doc) {
          console.log("Failed to process invoice");
          return;
        }
        invoice_doc.currency = this.selected_currency || this.pos_profile.currency;
        invoice_doc.conversion_rate = this.conversion_rate || 1;
        invoice_doc.plc_conversion_rate = this.exchange_rate || 1;
        if (this.isReturnInvoice || invoice_doc.is_return) {
          console.log("Preparing RETURN invoice for payment with:", {
            is_return: invoice_doc.is_return,
            invoiceType: this.invoiceType,
            return_against: invoice_doc.return_against,
            items: invoice_doc.items.length,
            grand_total: invoice_doc.grand_total
          });
          invoice_doc.is_return = 1;
          if (invoice_doc.grand_total > 0)
            invoice_doc.grand_total = -Math.abs(invoice_doc.grand_total);
          if (invoice_doc.rounded_total > 0)
            invoice_doc.rounded_total = -Math.abs(invoice_doc.rounded_total);
          if (invoice_doc.total > 0)
            invoice_doc.total = -Math.abs(invoice_doc.total);
          if (invoice_doc.base_grand_total > 0)
            invoice_doc.base_grand_total = -Math.abs(invoice_doc.base_grand_total);
          if (invoice_doc.base_rounded_total > 0)
            invoice_doc.base_rounded_total = -Math.abs(invoice_doc.base_rounded_total);
          if (invoice_doc.base_total > 0)
            invoice_doc.base_total = -Math.abs(invoice_doc.base_total);
          if (invoice_doc.items && invoice_doc.items.length) {
            invoice_doc.items.forEach((item) => {
              if (item.qty > 0)
                item.qty = -Math.abs(item.qty);
              if (item.stock_qty > 0)
                item.stock_qty = -Math.abs(item.stock_qty);
              if (item.amount > 0)
                item.amount = -Math.abs(item.amount);
            });
          }
        }
        invoice_doc.payments = this.get_payments();
        console.log("Final payment data:", invoice_doc.payments);
        if ((this.isReturnInvoice || invoice_doc.is_return) && invoice_doc.payments.length) {
          invoice_doc.payments.forEach((payment) => {
            if (payment.amount > 0)
              payment.amount = -Math.abs(payment.amount);
            if (payment.base_amount > 0)
              payment.base_amount = -Math.abs(payment.base_amount);
          });
          console.log("Ensured negative payment amounts for return:", invoice_doc.payments);
        }
        console.log("Showing payment dialog with currency:", invoice_doc.currency);
        this.eventBus.emit("show_payment", "true");
        this.eventBus.emit("send_invoice_doc_payment", invoice_doc);
      } catch (error) {
        console.error("Error in show_payment:", error);
        this.eventBus.emit("show_message", {
          title: __("Error processing payment"),
          color: "error",
          message: error.message
        });
      }
    },
    async validate() {
      console.log("Starting return validation");
      if (this.isReturnInvoice) {
        console.log("Validating return invoice values");
        const positiveItems = this.items.filter((item) => item.qty >= 0 || item.stock_qty >= 0);
        if (positiveItems.length > 0) {
          console.log("Found positive quantities in return items:", positiveItems.map((i) => i.item_code));
          this.eventBus.emit("show_message", {
            title: __(`Return items must have negative quantities`),
            color: "error"
          });
          positiveItems.forEach((item) => {
            item.qty = -Math.abs(item.qty);
            item.stock_qty = -Math.abs(item.stock_qty);
          });
          this.$forceUpdate();
        }
        if (this.subtotal > 0) {
          console.log("Return has positive subtotal:", this.subtotal);
          this.eventBus.emit("show_message", {
            title: __(`Return total must be negative`),
            color: "warning"
          });
        }
      }
      if (this.invoice_doc.is_return && this.invoice_doc.return_against) {
        console.log("Return doc:", this.invoice_doc);
        console.log("Current items:", this.items);
        try {
          const original_items = await new Promise((resolve2, reject) => {
            frappe.call({
              method: "frappe.client.get",
              args: {
                doctype: "Sales Invoice",
                name: this.invoice_doc.return_against
              },
              callback: (r) => {
                if (r.message) {
                  console.log("Original invoice data:", r.message);
                  resolve2(r.message.items || []);
                } else {
                  reject(new Error("Original invoice not found"));
                }
              }
            });
          });
          console.log("Original invoice items:", original_items);
          console.log("Original item codes:", original_items.map((item) => ({
            item_code: item.item_code,
            qty: item.qty,
            rate: item.rate
          })));
          for (const item of this.items) {
            console.log("Validating return item:", {
              item_code: item.item_code,
              rate: item.rate,
              qty: item.qty
            });
            const normalized_return_item_code = item.item_code.trim().toUpperCase();
            const original_item = original_items.find(
              (orig) => orig.item_code.trim().toUpperCase() === normalized_return_item_code
            );
            if (!original_item) {
              console.log("Item not found in original invoice:", {
                return_item_code: normalized_return_item_code,
                original_items: original_items.map((i) => i.item_code.trim().toUpperCase())
              });
              this.eventBus.emit("show_message", {
                title: __(`Item ${item.item_code} not found in original invoice`),
                color: "error"
              });
              return false;
            }
            const rate_diff = Math.abs(original_item.rate - item.rate);
            console.log("Rate comparison:", {
              return_rate: item.rate,
              orig_rate: original_item.rate,
              difference: rate_diff
            });
            if (rate_diff > 0.01) {
              this.eventBus.emit("show_message", {
                title: __(`Rate mismatch for item ${item.item_code}`),
                color: "error"
              });
              return false;
            }
            const return_qty = Math.abs(item.qty);
            const orig_qty = original_item.qty;
            console.log("Quantity comparison:", {
              return_qty,
              orig_qty
            });
            if (return_qty > orig_qty) {
              this.eventBus.emit("show_message", {
                title: __(`Return quantity cannot be greater than original quantity for item ${item.item_code}`),
                color: "error"
              });
              return false;
            }
          }
        } catch (error) {
          console.error("Error in validation:", error);
          this.eventBus.emit("show_message", {
            title: __(`Error validating return: ${error.message}`),
            color: "error"
          });
          return false;
        }
      }
      return true;
    },
    get_draft_invoices() {
      var vm2 = this;
      frappe.call({
        method: "posawesome.posawesome.api.invoices.get_draft_invoices",
        args: {
          pos_opening_shift: this.pos_opening_shift.name
        },
        async: false,
        callback: function(r) {
          if (r.message) {
            vm2.eventBus.emit("open_drafts", r.message);
          }
        }
      });
    },
    get_draft_orders() {
      var vm2 = this;
      frappe.call({
        method: "posawesome.posawesome.api.sales_orders.search_orders",
        args: {
          company: this.pos_profile.company,
          currency: this.pos_profile.currency
        },
        async: false,
        callback: function(r) {
          if (r.message) {
            vm2.eventBus.emit("open_orders", r.message);
          }
        }
      });
    },
    open_returns() {
      this.eventBus.emit("open_returns", this.pos_profile.company);
    },
    close_payments() {
      this.eventBus.emit("show_payment", "false");
    },
    async update_items_details(items) {
      if (!(items == null ? void 0 : items.length))
        return;
      if (!this.pos_profile)
        return;
      try {
        const response = await frappe.call({
          method: "posawesome.posawesome.api.items.get_items_details",
          args: {
            pos_profile: JSON.stringify(this.pos_profile),
            items_data: JSON.stringify(items)
          }
        });
        if (response == null ? void 0 : response.message) {
          items.forEach((item) => {
            const updated_item = response.message.find(
              (element) => element.posa_row_id == item.posa_row_id
            );
            if (updated_item) {
              item.actual_qty = updated_item.actual_qty;
              item.serial_no_data = updated_item.serial_no_data;
              item.batch_no_data = updated_item.batch_no_data;
              item.item_uoms = updated_item.item_uoms;
              item.has_batch_no = updated_item.has_batch_no;
              item.has_serial_no = updated_item.has_serial_no;
            }
          });
        }
      } catch (error) {
        console.error("Error updating items:", error);
        this.eventBus.emit("show_message", {
          title: __("Error updating item details"),
          color: "error"
        });
      }
    },
    update_item_detail(item, force_update = false) {
      if (!item.item_code) {
        return;
      }
      var vm2 = this;
      frappe.call({
        method: "posawesome.posawesome.api.items.get_item_detail",
        args: {
          warehouse: this.pos_profile.warehouse,
          doc: this.get_invoice_doc(),
          price_list: this.selected_price_list || this.pos_profile.selling_price_list,
          item: {
            item_code: item.item_code,
            customer: this.customer,
            doctype: "Sales Invoice",
            name: "New Sales Invoice 1",
            company: this.pos_profile.company,
            conversion_rate: 1,
            currency: this.pos_profile.currency,
            qty: item.qty,
            price_list_rate: item.base_price_list_rate || item.price_list_rate,
            child_docname: "New Sales Invoice Item 1",
            cost_center: this.pos_profile.cost_center,
            pos_profile: this.pos_profile.name,
            uom: item.uom,
            tax_category: "",
            transaction_type: "selling",
            update_stock: this.pos_profile.update_stock,
            price_list: this.get_price_list(),
            has_batch_no: item.has_batch_no,
            serial_no: item.serial_no,
            batch_no: item.batch_no,
            is_stock_item: item.is_stock_item
          }
        },
        callback: function(r) {
          if (r.message) {
            const data = r.message;
            if (data.price_list_currency) {
              vm2.price_list_currency = data.price_list_currency;
            }
            if (!item.original_currency) {
              item.original_currency = data.price_list_currency || vm2.price_list_currency || vm2.selected_currency;
            }
            if (!item.original_rate) {
              item.original_rate = data.price_list_rate;
            }
            if (data.batch_no_data) {
              item.batch_no_data = data.batch_no_data;
            }
            if (item.has_batch_no && vm2.pos_profile.posa_auto_set_batch && !item.batch_no && data.batch_no_data && data.batch_no_data.length > 0) {
              item.batch_no_data = data.batch_no_data;
              vm2.set_batch_qty(item, null, false);
            }
            if (force_update || !item.base_rate) {
              if (data.price_list_rate !== 0 || !item.base_price_list_rate) {
                item.base_price_list_rate = data.price_list_rate;
                if (!item.posa_offer_applied) {
                  item.base_rate = data.price_list_rate;
                }
              }
            }
            if (!item.posa_offer_applied) {
              const companyCurrency = vm2.pos_profile.currency;
              const baseCurrency = companyCurrency;
              if (vm2.selected_currency === vm2.price_list_currency && vm2.selected_currency !== companyCurrency) {
                const conv = vm2.conversion_rate || 1;
                item.price_list_rate = vm2.flt(item.base_price_list_rate / conv, vm2.currency_precision);
                if (!item._manual_rate_set) {
                  item.rate = vm2.flt(item.base_rate / conv, vm2.currency_precision);
                }
              } else if (vm2.selected_currency !== baseCurrency) {
                const exchange_rate = vm2.exchange_rate || 1;
                item.price_list_rate = vm2.flt(item.base_price_list_rate * exchange_rate, vm2.currency_precision);
                item.rate = vm2.flt(item.base_rate * exchange_rate, vm2.currency_precision);
              } else {
                item.price_list_rate = item.base_price_list_rate;
                if (!item._manual_rate_set) {
                  item.rate = item.base_rate;
                }
              }
            } else {
              const companyCurrency = vm2.pos_profile.currency;
              const baseCurrency = companyCurrency;
              if (vm2.selected_currency === vm2.price_list_currency && vm2.selected_currency !== companyCurrency) {
                const conv = vm2.conversion_rate || 1;
                item.price_list_rate = vm2.flt(item.base_price_list_rate / conv, vm2.currency_precision);
              } else if (vm2.selected_currency !== baseCurrency) {
                const exchange_rate = vm2.exchange_rate || 1;
                item.price_list_rate = vm2.flt(item.base_price_list_rate * exchange_rate, vm2.currency_precision);
              } else {
                item.price_list_rate = item.base_price_list_rate;
              }
            }
            if (!item.posa_offer_applied && vm2.pos_profile.posa_apply_customer_discount && vm2.customer_info.posa_discount > 0 && vm2.customer_info.posa_discount <= 100 && item.posa_is_offer == 0 && !item.posa_is_replace) {
              const discount_percent = item.max_discount > 0 ? Math.min(item.max_discount, vm2.customer_info.posa_discount) : vm2.customer_info.posa_discount;
              item.discount_percentage = discount_percent;
              const discount_amount = vm2.flt(item.price_list_rate * discount_percent / 100, vm2.currency_precision);
              item.discount_amount = discount_amount;
              item.base_discount_amount = vm2.flt(item.base_price_list_rate * discount_percent / 100, vm2.currency_precision);
              item.rate = vm2.flt(item.price_list_rate - discount_amount, vm2.currency_precision);
              item.base_rate = vm2.flt(item.base_price_list_rate - item.base_discount_amount, vm2.currency_precision);
            }
            item.last_purchase_rate = data.last_purchase_rate;
            item.projected_qty = data.projected_qty;
            item.reserved_qty = data.reserved_qty;
            item.conversion_factor = data.conversion_factor;
            item.stock_qty = data.stock_qty;
            item.actual_qty = data.actual_qty;
            item.stock_uom = data.stock_uom;
            item.has_serial_no = data.has_serial_no;
            item.has_batch_no = data.has_batch_no;
            item.amount = vm2.flt(item.qty * item.rate, vm2.currency_precision);
            item.base_amount = vm2.flt(item.qty * item.base_rate, vm2.currency_precision);
            console.log(`Updated rates for ${item.item_code} on expand:`, {
              base_rate: item.base_rate,
              rate: item.rate,
              base_price_list_rate: item.base_price_list_rate,
              price_list_rate: item.price_list_rate,
              exchange_rate: vm2.exchange_rate,
              selected_currency: vm2.selected_currency,
              default_currency: vm2.pos_profile.currency
            });
            vm2.$forceUpdate();
          }
        }
      });
    },
    async fetch_customer_details() {
      var vm2 = this;
      if (this.customer) {
        try {
          const r = await frappe.call({
            method: "posawesome.posawesome.api.customers.get_customer_info",
            args: {
              customer: vm2.customer
            }
          });
          const message2 = r.message;
          if (!r.exc) {
            vm2.customer_info = __spreadValues({}, message2);
          }
          if (vm2.pos_profile.posa_force_reload_items && message2.customer_price_list) {
            vm2.selected_price_list = message2.customer_price_list;
            vm2.eventBus.emit("update_customer_price_list", message2.customer_price_list);
            vm2.apply_cached_price_list(message2.customer_price_list);
          }
        } catch (error) {
          console.error("Failed to fetch customer details", error);
        }
      }
    },
    get_price_list() {
      return this.selected_price_list || this.pos_profile.selling_price_list;
    },
    update_price_list() {
      const price_list = this.pos_profile.selling_price_list;
      if (this.selected_price_list !== price_list) {
        this.selected_price_list = price_list;
        this.eventBus.emit("update_customer_price_list", null);
      }
    },
    apply_cached_price_list(price_list) {
      const cached = getCachedPriceListItems(price_list);
      if (!cached) {
        return;
      }
      const map2 = {};
      cached.forEach((ci2) => {
        map2[ci2.item_code] = ci2;
      });
      this.items.forEach((item) => {
        const ci2 = map2[item.item_code];
        if (!ci2)
          return;
        const newRate = ci2.rate || ci2.price_list_rate;
        const priceCurrency = ci2.currency || this.selected_currency;
        if (!item.original_currency) {
          item.original_currency = priceCurrency;
        }
        if (!item.original_rate) {
          item.original_rate = newRate;
        }
        if (priceCurrency === this.selected_currency) {
          const companyCurrency = this.pos_profile.currency;
          if (priceCurrency !== companyCurrency) {
            const conv = this.conversion_rate || 1;
            item.base_price_list_rate = newRate * conv;
            if (!item._manual_rate_set) {
              item.base_rate = newRate * conv;
            }
          } else {
            item.base_price_list_rate = newRate;
            if (!item._manual_rate_set) {
              item.base_rate = newRate;
            }
          }
          item.price_list_rate = newRate;
          if (!item._manual_rate_set) {
            item.rate = newRate;
          }
        } else {
          if (newRate !== 0 || !item.base_price_list_rate) {
            item.base_price_list_rate = newRate;
            if (!item._manual_rate_set) {
              item.base_rate = newRate;
            }
          }
          const baseCurrency = this.pos_profile.currency;
          if (this.selected_currency !== baseCurrency) {
            const conv = this.exchange_rate || 1;
            const convRate = this.flt(newRate * conv, this.currency_precision);
            if (newRate !== 0 || !item.price_list_rate) {
              item.price_list_rate = convRate;
            }
            if (!item._manual_rate_set && (newRate !== 0 || !item.rate)) {
              item.rate = convRate;
            }
          } else {
            if (newRate !== 0 || !item.price_list_rate) {
              item.price_list_rate = newRate;
            }
            if (!item._manual_rate_set && (newRate !== 0 || !item.rate)) {
              item.rate = newRate;
            }
          }
        }
        item.amount = this.flt(item.qty * item.rate, this.currency_precision);
        item.base_amount = this.flt(item.qty * item.base_rate, this.currency_precision);
      });
      this.$forceUpdate();
    },
    update_discount_umount() {
      const value = flt(this.additional_discount_percentage);
      if (value < -100 || value > 100) {
        this.additional_discount_percentage = 0;
        this.additional_discount = 0;
        return;
      }
      if (this.Total && this.Total !== 0) {
        this.additional_discount = this.Total * value / 100;
      } else {
        this.additional_discount = 0;
      }
    },
    calc_prices(item, value, $event) {
      var _a3;
      if (!((_a3 = $event == null ? void 0 : $event.target) == null ? void 0 : _a3.id) || !item)
        return;
      const fieldId = $event.target.id;
      let newValue = flt(value, this.currency_precision);
      try {
        if (fieldId === "rate") {
          item._manual_rate_set = true;
        }
        if (newValue < 0) {
          newValue = 0;
          this.eventBus.emit("show_message", {
            title: __("Negative values not allowed"),
            color: "error"
          });
        }
        const baseCurrency = this.price_list_currency || this.pos_profile.currency;
        const converted_price_list_rate = this.selected_currency !== baseCurrency ? this.flt(item.price_list_rate * this.exchange_rate, this.currency_precision) : item.price_list_rate;
        switch (fieldId) {
          case "rate":
            item.base_rate = this.flt(newValue * this.exchange_rate, this.currency_precision);
            item.rate = newValue;
            item.discount_amount = this.flt(converted_price_list_rate - item.rate, this.currency_precision);
            item.base_discount_amount = this.flt(item.price_list_rate - item.base_rate, this.currency_precision);
            if (converted_price_list_rate) {
              item.discount_percentage = this.flt(item.discount_amount / converted_price_list_rate * 100, this.float_precision);
            }
            break;
          case "discount_amount":
            console.log("[calc_prices] Event Target ID:", fieldId);
            console.log("[calc_prices] RAW value received by function:", value);
            console.log("[calc_prices] Original item.price_list_rate:", item.price_list_rate);
            console.log("[calc_prices] Converted price_list_rate for calc:", converted_price_list_rate);
            console.log("[calc_prices] Input value (newValue before Math.min):", newValue);
            newValue = Math.min(newValue, converted_price_list_rate);
            console.log("[calc_prices] Input value (newValue after Math.min):", newValue);
            item.base_discount_amount = this.flt(newValue * this.exchange_rate, this.currency_precision);
            item.discount_amount = newValue;
            console.log("[calc_prices] Updated item.discount_amount:", item.discount_amount);
            console.log("[calc_prices] Updated item.base_discount_amount:", item.base_discount_amount);
            item.rate = this.flt(converted_price_list_rate - item.discount_amount, this.currency_precision);
            item.base_rate = this.flt(item.price_list_rate - item.base_discount_amount, this.currency_precision);
            console.log("[calc_prices] Calculated item.rate:", item.rate);
            console.log("[calc_prices] Calculated item.base_rate:", item.base_rate);
            if (converted_price_list_rate) {
              item.discount_percentage = this.flt(item.discount_amount / converted_price_list_rate * 100, this.float_precision);
            } else {
              item.discount_percentage = 0;
            }
            console.log("[calc_prices] Calculated item.discount_percentage:", item.discount_percentage);
            break;
          case "discount_percentage":
            newValue = Math.min(newValue, 100);
            item.discount_percentage = this.flt(newValue, this.float_precision);
            item.discount_amount = this.flt(converted_price_list_rate * item.discount_percentage / 100, this.currency_precision);
            item.base_discount_amount = this.flt(item.price_list_rate * item.discount_percentage / 100, this.currency_precision);
            item.rate = this.flt(converted_price_list_rate - item.discount_amount, this.currency_precision);
            item.base_rate = this.flt(item.price_list_rate - item.base_discount_amount, this.currency_precision);
            break;
        }
        if (item.rate < 0) {
          item.rate = 0;
          item.base_rate = 0;
          item.discount_amount = converted_price_list_rate;
          item.base_discount_amount = item.price_list_rate;
          item.discount_percentage = 100;
        }
        this.calc_stock_qty(item, item.qty);
        this.$forceUpdate();
      } catch (error) {
        console.error("Error calculating prices:", error);
        this.eventBus.emit("show_message", {
          title: __("Error calculating prices"),
          color: "error"
        });
      }
    },
    calc_item_price(item) {
      if (item._skip_calc) {
        item._skip_calc = false;
        return;
      }
      const baseCurrency = this.price_list_currency || this.pos_profile.currency;
      if (!item.posa_offer_applied) {
        if (item.price_list_rate) {
          if (!item.base_price_list_rate) {
            item.base_price_list_rate = item.price_list_rate;
            item.base_rate = item.rate;
          }
          if (this.selected_currency !== baseCurrency) {
            item.price_list_rate = this.flt(item.base_price_list_rate * this.exchange_rate, this.currency_precision);
            item.rate = this.flt(item.base_rate * this.exchange_rate, this.currency_precision);
          } else {
            item.price_list_rate = item.base_price_list_rate;
            item.rate = item.base_rate;
          }
        }
      }
      if (item.discount_percentage) {
        const price_list_rate = item.price_list_rate;
        const discount_amount = this.flt(price_list_rate * item.discount_percentage / 100, this.currency_precision);
        item.discount_amount = discount_amount;
        item.rate = this.flt(price_list_rate - discount_amount, this.currency_precision);
        if (this.selected_currency !== baseCurrency) {
          item.base_discount_amount = this.flt(discount_amount / this.exchange_rate, this.currency_precision);
        } else {
          item.base_discount_amount = item.discount_amount;
        }
      }
      item.amount = this.flt(item.qty * item.rate, this.currency_precision);
      if (this.selected_currency !== baseCurrency) {
        item.base_amount = this.flt(item.amount / this.exchange_rate, this.currency_precision);
      } else {
        item.base_amount = item.amount;
      }
      this.$forceUpdate();
    },
    calc_uom(item, value) {
      let new_uom = item.item_uoms.find((element) => element.uom == value);
      const baseCurrency = this.price_list_currency || this.pos_profile.currency;
      if (!new_uom) {
        const cached = getItemUOMs2(item.item_code);
        if (cached.length) {
          item.item_uoms = cached;
          new_uom = cached.find((u) => u.uom == value);
        }
      }
      if (!new_uom && item.stock_uom === value) {
        new_uom = { uom: item.stock_uom, conversion_factor: 1 };
        if (!item.item_uoms)
          item.item_uoms = [];
        item.item_uoms.push(new_uom);
      }
      if (!new_uom) {
        return;
      }
      const old_conversion_factor = item.conversion_factor || 1;
      item.conversion_factor = new_uom.conversion_factor;
      const conversion_ratio = item.conversion_factor / old_conversion_factor;
      if (!item.posa_offer_applied) {
        item.discount_amount = 0;
        item.discount_percentage = 0;
      }
      if (!item.original_base_rate && !item.posa_offer_applied) {
        item.original_base_rate = item.base_rate / old_conversion_factor;
        item.original_base_price_list_rate = item.base_price_list_rate / old_conversion_factor;
      }
      if (item.posa_offer_applied) {
        const offer = this.posOffers && Array.isArray(this.posOffers) ? this.posOffers.find((o) => {
          if (!o || !o.items)
            return false;
          const items = typeof o.items === "string" ? JSON.parse(o.items) : o.items;
          return Array.isArray(items) && items.includes(item.posa_row_id);
        }) : null;
        if (offer && offer.discount_type === "Rate") {
          const converted_rate = flt(offer.rate * item.conversion_factor);
          item.base_rate = converted_rate;
          item.base_price_list_rate = converted_rate;
          if (this.selected_currency !== baseCurrency) {
            item.rate = this.flt(converted_rate * this.exchange_rate, this.currency_precision);
            item.price_list_rate = item.rate;
          } else {
            item.rate = converted_rate;
            item.price_list_rate = converted_rate;
          }
        } else if (offer && offer.discount_type === "Discount Percentage") {
          let updated_base_price;
          if (item.original_base_price_list_rate) {
            updated_base_price = this.flt(item.original_base_price_list_rate * item.conversion_factor, this.currency_precision);
          } else {
            updated_base_price = this.flt(item.base_price_list_rate * conversion_ratio, this.currency_precision);
          }
          item.base_price_list_rate = updated_base_price;
          const base_discount = this.flt(updated_base_price * offer.discount_percentage / 100, this.currency_precision);
          item.base_discount_amount = base_discount;
          item.base_rate = this.flt(updated_base_price - base_discount, this.currency_precision);
          if (this.selected_currency !== baseCurrency) {
            item.price_list_rate = this.flt(updated_base_price * this.exchange_rate, this.currency_precision);
            item.discount_amount = this.flt(base_discount * this.exchange_rate, this.currency_precision);
            item.rate = this.flt(item.base_rate * this.exchange_rate, this.currency_precision);
          } else {
            item.price_list_rate = updated_base_price;
            item.discount_amount = base_discount;
            item.rate = item.base_rate;
          }
        }
      } else {
        if (item.batch_price) {
          item.base_rate = item.batch_price * item.conversion_factor;
          item.base_price_list_rate = item.base_rate;
        } else if (item.original_base_rate) {
          item.base_rate = item.original_base_rate * item.conversion_factor;
          item.base_price_list_rate = item.original_base_price_list_rate * item.conversion_factor;
        }
        if (this.selected_currency !== baseCurrency) {
          item.rate = this.flt(item.base_rate * this.exchange_rate, this.currency_precision);
          item.price_list_rate = this.flt(item.base_price_list_rate * this.exchange_rate, this.currency_precision);
        } else {
          item.rate = item.base_rate;
          item.price_list_rate = item.base_price_list_rate;
        }
      }
      this.calc_stock_qty(item, item.qty);
      this.$forceUpdate();
    },
    calc_stock_qty(item, value) {
      item.stock_qty = item.conversion_factor * value;
    },
    set_serial_no(item) {
      console.log(item);
      if (!item.has_serial_no)
        return;
      item.serial_no = "";
      item.serial_no_selected.forEach((element) => {
        item.serial_no += element + "\n";
      });
      item.serial_no_selected_count = item.serial_no_selected.length;
      if (item.serial_no_selected_count != item.stock_qty) {
        item.qty = item.serial_no_selected_count;
        this.calc_stock_qty(item, item.qty);
        this.$forceUpdate();
      }
    },
    set_batch_qty(item, value, update = true) {
      console.log("Setting batch quantity:", item, value);
      const baseCurrency = this.price_list_currency || this.pos_profile.currency;
      const existing_items = this.items.filter(
        (element) => element.item_code == item.item_code && element.posa_row_id != item.posa_row_id
      );
      const used_batches = {};
      item.batch_no_data.forEach((batch2) => {
        used_batches[batch2.batch_no] = __spreadProps(__spreadValues({}, batch2), {
          used_qty: 0,
          remaining_qty: batch2.batch_qty
        });
        existing_items.forEach((element) => {
          if (element.batch_no && element.batch_no == batch2.batch_no) {
            used_batches[batch2.batch_no].used_qty += element.qty;
            used_batches[batch2.batch_no].remaining_qty -= element.qty;
            used_batches[batch2.batch_no].batch_qty -= element.qty;
          }
        });
      });
      const batch_no_data = Object.values(used_batches).filter((batch2) => batch2.remaining_qty > 0).sort((a, b) => {
        if (a.expiry_date && b.expiry_date) {
          return new Date(a.expiry_date) - new Date(b.expiry_date);
        } else if (a.expiry_date) {
          return -1;
        } else if (b.expiry_date) {
          return 1;
        } else if (a.manufacturing_date && b.manufacturing_date) {
          return new Date(a.manufacturing_date) - new Date(b.manufacturing_date);
        } else if (a.manufacturing_date) {
          return -1;
        } else if (b.manufacturing_date) {
          return 1;
        } else {
          return b.remaining_qty - a.remaining_qty;
        }
      });
      if (batch_no_data.length > 0) {
        let batch_to_use = null;
        if (value) {
          batch_to_use = batch_no_data.find((batch2) => batch2.batch_no == value);
        }
        if (!batch_to_use) {
          batch_to_use = batch_no_data[0];
        }
        item.batch_no = batch_to_use.batch_no;
        item.actual_batch_qty = batch_to_use.batch_qty;
        item.batch_no_expiry_date = batch_to_use.expiry_date;
        if (batch_to_use.batch_price) {
          item.base_batch_price = batch_to_use.batch_price;
          if (this.selected_currency !== baseCurrency) {
            item.batch_price = this.flt(batch_to_use.batch_price * this.exchange_rate, this.currency_precision);
          } else {
            item.batch_price = batch_to_use.batch_price;
          }
          item.base_price_list_rate = item.base_batch_price;
          item.base_rate = item.base_batch_price;
          if (this.selected_currency !== baseCurrency) {
            item.price_list_rate = item.batch_price;
            item.rate = item.batch_price;
          } else {
            item.price_list_rate = item.base_batch_price;
            item.rate = item.base_batch_price;
          }
          item.discount_percentage = 0;
          item.discount_amount = 0;
          item.base_discount_amount = 0;
          item.amount = this.flt(item.qty * item.rate, this.currency_precision);
          item.base_amount = this.flt(item.qty * item.base_rate, this.currency_precision);
          console.log("Updated batch prices:", {
            base_batch_price: item.base_batch_price,
            batch_price: item.batch_price,
            rate: item.rate,
            base_rate: item.base_rate,
            price_list_rate: item.price_list_rate,
            exchange_rate: this.exchange_rate
          });
        } else if (update) {
          item.batch_price = null;
          item.base_batch_price = null;
          this.update_item_detail(item);
        }
      } else {
        item.batch_no = null;
        item.actual_batch_qty = null;
        item.batch_no_expiry_date = null;
        item.batch_price = null;
        item.base_batch_price = null;
      }
      item.batch_no_data = batch_no_data;
      this.$forceUpdate();
    }
  };

  // ../posawesome/posawesome/public/js/offline.js
  var db2 = new import_wrapper_default("posawesome_offline");
  db2.version(1).stores({ keyval: "&key" });
  var persistWorker2 = null;
  if (typeof Worker !== "undefined") {
    try {
      const workerUrl = "/assets/posawesome/js/posapp/workers/itemWorker.js";
      persistWorker2 = new Worker(workerUrl, { type: "classic" });
    } catch (e) {
      console.error("Failed to init persist worker", e);
      persistWorker2 = null;
    }
  }
  var memory2 = {
    offline_invoices: [],
    offline_customers: [],
    offline_payments: [],
    pos_last_sync_totals: { pending: 0, synced: 0, drafted: 0 },
    uom_cache: {},
    offers_cache: [],
    customer_balance_cache: {},
    local_stock_cache: {},
    stock_cache_ready: false,
    items_storage: [],
    customer_storage: [],
    pos_opening_storage: null,
    opening_dialog_storage: null,
    sales_persons_storage: [],
    price_list_cache: {},
    item_details_cache: {},
    manual_offline: false
  };
  var initPromise2 = new Promise((resolve2) => {
    const init = async () => {
      try {
        await db2.open();
        for (const key of Object.keys(memory2)) {
          const stored = await db2.table("keyval").get(key);
          if (stored && stored.value !== void 0) {
            memory2[key] = stored.value;
            continue;
          }
          if (typeof localStorage !== "undefined") {
            const ls = localStorage.getItem(`posa_${key}`);
            if (ls) {
              try {
                memory2[key] = JSON.parse(ls);
                continue;
              } catch (err) {
                console.error("Failed to parse localStorage for", key, err);
              }
            }
          }
        }
      } catch (e) {
        console.error("Failed to initialize offline DB", e);
      } finally {
        resolve2();
      }
    };
    if (typeof requestIdleCallback === "function") {
      requestIdleCallback(init);
    } else {
      setTimeout(init, 0);
    }
  });

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/Invoice.vue?type=script
  var Invoice_default = {
    name: "POSInvoice",
    mixins: [format_default],
    data() {
      return {
        pos_profile: "",
        pos_opening_shift: "",
        stock_settings: "",
        invoice_doc: "",
        return_doc: "",
        customer: "",
        customer_info: "",
        customer_balance: 0,
        discount_amount: 0,
        additional_discount: 0,
        additional_discount_percentage: 0,
        total_tax: 0,
        items: [],
        posOffers: [],
        posa_offers: [],
        posa_coupons: [],
        allItems: [],
        discount_percentage_offer_name: null,
        invoiceTypes: ["Invoice", "Order"],
        invoiceType: "Invoice",
        itemsPerPage: 1e3,
        expanded: [],
        singleExpand: true,
        cancel_dialog: false,
        reference_dialog: false,
        reference_no: "",
        reference_name: "",
        float_precision: 6,
        currency_precision: 6,
        new_line: false,
        delivery_charges: [],
        delivery_charges_rate: 0,
        selected_delivery_charge: "",
        invoice_posting_date: false,
        posting_date: frappe.datetime.nowdate(),
        posting_date_display: "",
        items_headers: [],
        selected_currency: "",
        exchange_rate: 1,
        conversion_rate: 1,
        exchange_rate_date: "",
        company: null,
        available_currencies: [],
        price_lists: [],
        selected_price_list: "",
        price_list_currency: "",
        selected_columns: [],
        temp_selected_columns: [],
        available_columns: [],
        show_column_selector: false
      };
    },
    components: {
      Customer: Customer_default2,
      DeliveryCharges: DeliveryCharges_default2,
      PostingDateRow: PostingDateRow_default2,
      MultiCurrencyRow: MultiCurrencyRow_default2,
      InvoiceSummary: InvoiceSummary_default2,
      CancelSaleDialog: CancelSaleDialog_default2,
      ItemsTable: ItemsTable_default2
    },
    computed: __spreadProps(__spreadValues({}, invoiceComputed_default), {
      isDarkTheme() {
        return this.$theme.current === "dark";
      }
    }),
    methods: __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, invoiceShortcuts_default), itemAddition_default), batchSerial_default), discounts_default), stockUtils_default), invoiceOfferMethods_default), invoiceItemMethods_default), {
      show_payment() {
        if (this.pos_profile.custom_add_reference_details) {
          console.log("Reference details required - showing dialog");
          this.reference_no = "";
          this.reference_name = "";
          this.reference_dialog = true;
          return;
        }
        this.process_payment();
      },
      async process_payment() {
        try {
          let invoice_doc;
          if (this.invoice_doc.doctype == "Sales Order") {
            console.log("Processing Sales Order payment");
            invoice_doc = await this.process_invoice_from_order();
          } else {
            console.log("Processing regular invoice");
            invoice_doc = this.process_invoice();
          }
          if (!invoice_doc) {
            console.log("Failed to process invoice");
            return;
          }
          if (this.reference_no || this.reference_name) {
            invoice_doc.custom_reference_no = this.reference_no;
            invoice_doc.custom_reference_name = this.reference_name;
          }
          invoice_doc.currency = this.selected_currency || this.pos_profile.currency;
          invoice_doc.conversion_rate = this.exchange_rate || 1;
          invoice_doc.total = this.Total;
          invoice_doc.grand_total = this.subtotal;
          invoice_doc.rounded_total = this.roundAmount(this.subtotal);
          invoice_doc.base_total = this.Total * (1 / this.exchange_rate || 1);
          invoice_doc.base_grand_total = this.subtotal * (1 / this.exchange_rate || 1);
          invoice_doc.base_rounded_total = this.roundAmount(invoice_doc.base_grand_total);
          if (this.invoiceType === "Return" || invoice_doc.is_return) {
            console.log("Preparing RETURN invoice for payment with:", {
              is_return: invoice_doc.is_return,
              invoiceType: this.invoiceType,
              return_against: invoice_doc.return_against,
              items: invoice_doc.items.length,
              grand_total: invoice_doc.grand_total
            });
            invoice_doc.is_return = 1;
            if (invoice_doc.grand_total > 0)
              invoice_doc.grand_total = -Math.abs(invoice_doc.grand_total);
            if (invoice_doc.rounded_total > 0)
              invoice_doc.rounded_total = -Math.abs(invoice_doc.rounded_total);
            if (invoice_doc.total > 0)
              invoice_doc.total = -Math.abs(invoice_doc.total);
            if (invoice_doc.base_grand_total > 0)
              invoice_doc.base_grand_total = -Math.abs(invoice_doc.base_grand_total);
            if (invoice_doc.base_rounded_total > 0)
              invoice_doc.base_rounded_total = -Math.abs(invoice_doc.base_rounded_total);
            if (invoice_doc.base_total > 0)
              invoice_doc.base_total = -Math.abs(invoice_doc.base_total);
            if (invoice_doc.items && invoice_doc.items.length) {
              invoice_doc.items.forEach((item) => {
                if (item.qty > 0)
                  item.qty = -Math.abs(item.qty);
                if (item.stock_qty > 0)
                  item.stock_qty = -Math.abs(item.stock_qty);
                if (item.amount > 0)
                  item.amount = -Math.abs(item.amount);
              });
            }
          }
          invoice_doc.payments = this.get_payments();
          console.log("Final payment data:", invoice_doc.payments);
          if ((this.invoiceType === "Return" || invoice_doc.is_return) && invoice_doc.payments.length) {
            invoice_doc.payments.forEach((payment) => {
              if (payment.amount > 0)
                payment.amount = -Math.abs(payment.amount);
              if (payment.base_amount > 0)
                payment.base_amount = -Math.abs(payment.base_amount);
            });
            console.log("Ensured negative payment amounts for return:", invoice_doc.payments);
          }
          console.log("Showing payment dialog with currency:", invoice_doc.currency);
          this.eventBus.emit("show_payment", "true");
          this.eventBus.emit("send_invoice_doc_payment", invoice_doc);
        } catch (error) {
          console.error("Error in process_payment:", error);
          this.eventBus.emit("show_message", {
            title: __("Error processing payment"),
            color: "error",
            message: error.message
          });
        }
      },
      async confirm_reference_and_proceed() {
        try {
          if (this.pos_profile.custom_add_reference_details) {
            if (!this.reference_no || !this.reference_name) {
              this.eventBus.emit("show_message", {
                title: __("Please fill in both reference number and reference name"),
                color: "error"
              });
              return;
            }
          }
          this.reference_dialog = false;
          await this.process_payment();
        } catch (error) {
          console.error("Error in confirm_reference_and_proceed:", error);
          this.eventBus.emit("show_message", {
            title: __("Error processing reference details"),
            color: "error",
            message: error.message
          });
        }
      },
      cancel_reference_dialog() {
        this.reference_dialog = false;
        this.reference_no = "";
        this.reference_name = "";
      },
      initializeItemsHeaders() {
        this.available_columns = [
          { title: __("Name"), align: "start", sortable: true, key: "item_name", required: true },
          { title: __("QTY"), key: "qty", align: "center", required: true },
          { title: __("UOM"), key: "uom", align: "center", required: false },
          { title: __("Rate"), key: "rate", align: "center", required: true },
          { title: __("Discount %"), key: "discount_value", align: "center", required: false },
          { title: __("Discount Amount"), key: "discount_amount", align: "center", required: false },
          { title: __("Amount"), key: "amount", align: "center", required: true },
          { title: __("Offer?"), key: "posa_is_offer", align: "center", required: false }
        ];
        if (!this.selected_columns || this.selected_columns.length === 0) {
          this.selected_columns = this.available_columns.filter((col) => {
            if (col.required)
              return true;
            if (col.key === "discount_value" && this.pos_profile.posa_display_discount_percentage)
              return true;
            if (col.key === "discount_amount" && this.pos_profile.posa_display_discount_amount)
              return true;
            return false;
          }).map((col) => col.key);
        }
        this.updateHeadersFromSelection();
      },
      handleItemDrop(item) {
        console.log("Item dropped:", item);
        this.add_item(item);
        this.eventBus.emit("show_message", {
          title: __(`Item {0} added to invoice`, [item.item_name]),
          color: "success"
        });
      },
      showDropFeedback(isDragging) {
        const itemsTable = this.$el.querySelector(".modern-items-table");
        if (itemsTable) {
          if (isDragging) {
            itemsTable.classList.add("drag-over");
          } else {
            itemsTable.classList.remove("drag-over");
          }
        }
      },
      toggleColumnSelection() {
        this.temp_selected_columns = [...this.selected_columns];
        this.show_column_selector = true;
      },
      cancelColumnSelection() {
        this.show_column_selector = false;
      },
      updateHeadersFromSelection() {
        this.items_headers = this.available_columns.filter(
          (col) => this.selected_columns.includes(col.key) || col.required
        );
      },
      updateSelectedColumns() {
        this.selected_columns = [...this.temp_selected_columns];
        const requiredKeys = this.available_columns.filter((col) => col.required).map((col) => col.key);
        requiredKeys.forEach((key) => {
          if (!this.selected_columns.includes(key)) {
            this.selected_columns.push(key);
          }
        });
        this.updateHeadersFromSelection();
        this.saveColumnPreferences();
        this.show_column_selector = false;
      },
      saveColumnPreferences() {
        try {
          localStorage.setItem("posawesome_selected_columns", JSON.stringify(this.selected_columns));
        } catch (e) {
          console.error("Failed to save column preferences:", e);
        }
      },
      loadColumnPreferences() {
        try {
          const saved2 = localStorage.getItem("posawesome_selected_columns");
          if (saved2) {
            this.selected_columns = JSON.parse(saved2);
          }
        } catch (e) {
          console.error("Failed to load column preferences:", e);
        }
      },
      makeid(length) {
        let result = "";
        const characters = "abcdefghijklmnopqrstuvwxyz0123456789";
        const charactersLength = characters.length;
        for (var i = 0; i < length; i++) {
          result += characters.charAt(
            Math.floor(Math.random() * charactersLength)
          );
        }
        return result;
      },
      print_draft_invoice() {
        if (!this.pos_profile.posa_allow_print_draft_invoices) {
          this.eventBus.emit("show_message", {
            title: __(`You are not allowed to print draft invoices`),
            color: "error"
          });
          return;
        }
        let invoice_name = this.invoice_doc.name;
        frappe.run_serially([
          () => {
            const invoice_doc = this.save_and_clear_invoice();
            invoice_name = invoice_doc.name ? invoice_doc.name : invoice_name;
          },
          () => {
            this.load_print_page(invoice_name);
          }
        ]);
      },
      async set_delivery_charges() {
        var vm2 = this;
        if (!this.pos_profile || !this.customer || !this.pos_profile.posa_use_delivery_charges) {
          this.delivery_charges = [];
          this.delivery_charges_rate = 0;
          this.selected_delivery_charge = "";
          return;
        }
        this.delivery_charges_rate = 0;
        this.selected_delivery_charge = "";
        try {
          const r = await frappe.call({
            method: "posawesome.posawesome.api.offers.get_applicable_delivery_charges",
            args: {
              company: this.pos_profile.company,
              pos_profile: this.pos_profile.name,
              customer: this.customer
            }
          });
          if (r.message && r.message.length) {
            console.log(r.message);
            vm2.delivery_charges = r.message;
          }
        } catch (error) {
          console.error("Failed to fetch delivery charges", error);
        }
      },
      deliveryChargesFilter(itemText, queryText, itemRow) {
        const item = itemRow.raw;
        console.log("dl charges", item);
        const textOne = item.name.toLowerCase();
        const searchText = queryText.toLowerCase();
        return textOne.indexOf(searchText) > -1;
      },
      update_delivery_charges() {
        if (this.selected_delivery_charge) {
          this.delivery_charges_rate = this.selected_delivery_charge.rate;
        } else {
          this.delivery_charges_rate = 0;
        }
      },
      updatePostingDate(date2) {
        if (!date2)
          return;
        this.posting_date = date2;
        this.$forceUpdate();
      },
      setFormatedQty(item, field_name, precision, no_negative, value) {
        let parsedValue = this.setFormatedFloat(item, field_name, precision, no_negative, value);
        if (this.isReturnInvoice && parsedValue > 0) {
          parsedValue = -Math.abs(parsedValue);
          item[field_name] = parsedValue;
        }
        return parsedValue;
      },
      async fetch_available_currencies() {
        try {
          console.log("Fetching available currencies...");
          const r = await frappe.call({
            method: "posawesome.posawesome.api.invoices.get_available_currencies"
          });
          if (r.message) {
            console.log("Received currencies:", r.message);
            const baseCurrency = this.pos_profile.currency;
            this.available_currencies = r.message.map((currency) => {
              return {
                value: currency.name,
                title: currency.name
              };
            });
            this.available_currencies.sort((a, b) => {
              if (a.value === baseCurrency)
                return -1;
              if (b.value === baseCurrency)
                return 1;
              return a.value.localeCompare(b.value);
            });
            if (!this.selected_currency) {
              this.selected_currency = baseCurrency;
            }
            return this.available_currencies;
          }
          return [];
        } catch (error) {
          console.error("Error fetching currencies:", error);
          const defaultCurrency = this.pos_profile.currency;
          this.available_currencies = [{
            value: defaultCurrency,
            title: defaultCurrency
          }];
          this.selected_currency = defaultCurrency;
          return this.available_currencies;
        }
      },
      async fetch_price_lists() {
        if (this.pos_profile.posa_enable_price_list_dropdown) {
          try {
            const r = await frappe.call({
              method: "posawesome.posawesome.api.posapp.get_selling_price_lists"
            });
            if (r && r.message) {
              this.price_lists = r.message.map((pl) => pl.name);
            }
          } catch (error) {
            console.error("Failed fetching price lists", error);
            this.price_lists = [this.pos_profile.selling_price_list];
          }
        } else {
          this.price_lists = [this.pos_profile.selling_price_list];
        }
        if (!this.selected_price_list) {
          this.selected_price_list = this.pos_profile.selling_price_list;
        }
        try {
          const r = await frappe.call({
            method: "posawesome.posawesome.api.invoices.get_price_list_currency",
            args: { price_list: this.selected_price_list }
          });
          if (r && r.message) {
            this.price_list_currency = r.message;
          }
        } catch (error) {
          console.error("Failed fetching price list currency", error);
        }
        return this.price_lists;
      },
      async update_currency(currency) {
        if (!currency)
          return;
        this.selected_currency = currency;
        await this.update_currency_and_rate();
      },
      update_exchange_rate() {
        if (!this.exchange_rate || this.exchange_rate <= 0) {
          this.exchange_rate = 1;
        }
        this.eventBus.emit("update_currency", {
          currency: this.selected_currency || this.pos_profile.currency,
          exchange_rate: this.exchange_rate
        });
        this.update_item_rates();
      },
      update_conversion_rate() {
        if (!this.conversion_rate || this.conversion_rate <= 0) {
          this.conversion_rate = 1;
        }
        this.sync_exchange_rate();
      },
      update_item_rates() {
        console.log("Updating item rates with exchange rate:", this.exchange_rate);
        this.items.forEach((item) => {
          item._skip_calc = true;
          if (!item.base_rate) {
            console.log(`Setting base rates for ${item.item_code} for the first time`);
            const baseCurrency2 = this.price_list_currency || this.pos_profile.currency;
            if (this.selected_currency === baseCurrency2) {
              item.base_rate = item.rate;
              item.base_price_list_rate = item.price_list_rate;
              item.base_discount_amount = item.discount_amount || 0;
            } else {
              item.base_rate = item.rate / this.exchange_rate;
              item.base_price_list_rate = item.price_list_rate / this.exchange_rate;
              item.base_discount_amount = (item.discount_amount || 0) / this.exchange_rate;
            }
          }
          const baseCurrency = this.price_list_currency || this.pos_profile.currency;
          if (this.selected_currency === baseCurrency) {
            console.log(`Restoring rates for ${item.item_code} from base rates`);
            item.price_list_rate = item.base_price_list_rate;
            item.rate = item.base_rate;
            item.discount_amount = item.base_discount_amount;
          } else if (item.original_currency === this.selected_currency) {
            console.log(
              `Using original currency rates for ${item.item_code}`
            );
            item.price_list_rate = item.base_price_list_rate;
            item.rate = item.base_rate;
            item.discount_amount = item.base_discount_amount;
          } else {
            console.log(`Converting rates for ${item.item_code} to ${this.selected_currency}`);
            const converted_price = this.flt(item.base_price_list_rate * this.exchange_rate, this.currency_precision);
            const converted_rate = this.flt(item.base_rate * this.exchange_rate, this.currency_precision);
            const converted_discount = this.flt(item.base_discount_amount * this.exchange_rate, this.currency_precision);
            item.price_list_rate = converted_price < 1e-6 ? 0 : converted_price;
            item.rate = converted_rate < 1e-6 ? 0 : converted_rate;
            item.discount_amount = converted_discount < 1e-6 ? 0 : converted_discount;
          }
          item.amount = this.flt(item.qty * item.rate, this.currency_precision);
          item.base_amount = this.flt(item.qty * item.base_rate, this.currency_precision);
          console.log(`Updated rates for ${item.item_code}:`, {
            price_list_rate: item.price_list_rate,
            base_price_list_rate: item.base_price_list_rate,
            rate: item.rate,
            base_rate: item.base_rate,
            discount: item.discount_amount,
            base_discount: item.base_discount_amount,
            amount: item.amount,
            base_amount: item.base_amount
          });
          this.calc_item_price(item);
        });
        this.$forceUpdate();
      },
      formatCurrency(value, precision = null) {
        const prec = precision != null ? precision : this.currency_precision;
        return this.$options.mixins[0].methods.formatCurrency.call(this, value, prec);
      },
      flt(value, precision = null) {
        if (precision === null) {
          precision = this.float_precision;
        }
        const _value = Number(value);
        if (isNaN(_value)) {
          return 0;
        }
        if (Math.abs(_value) < 1e-6) {
          return _value;
        }
        return Number((_value || 0).toFixed(precision));
      },
      async update_currency_and_rate() {
        if (!this.selected_currency)
          return;
        const companyCurrency = this.company && this.company.default_currency || this.pos_profile.currency;
        const priceListCurrency = this.price_list_currency || companyCurrency;
        try {
          if (this.selected_currency === priceListCurrency) {
            this.exchange_rate = 1;
          } else {
            const r = await frappe.call({
              method: "posawesome.posawesome.api.invoices.fetch_exchange_rate_pair",
              args: {
                from_currency: priceListCurrency,
                to_currency: this.selected_currency
              }
            });
            if (r && r.message) {
              this.exchange_rate = r.message.exchange_rate;
            }
          }
          if (this.selected_currency === companyCurrency) {
            this.conversion_rate = 1;
            this.exchange_rate_date = this.formatDateForBackend(this.posting_date_display);
          } else {
            const r2 = await frappe.call({
              method: "posawesome.posawesome.api.invoices.fetch_exchange_rate_pair",
              args: {
                from_currency: this.selected_currency,
                to_currency: companyCurrency
              }
            });
            if (r2 && r2.message) {
              this.conversion_rate = r2.message.exchange_rate;
              this.exchange_rate_date = r2.message.date;
              const posting_backend = this.formatDateForBackend(this.posting_date_display);
              if (this.exchange_rate_date && posting_backend !== this.exchange_rate_date) {
                this.eventBus.emit("show_message", {
                  title: __(
                    "Exchange rate date " + this.exchange_rate_date + " differs from posting date " + posting_backend
                  ),
                  color: "warning"
                });
              }
            }
          }
        } catch (error) {
          console.error("Error updating currency:", error);
          this.eventBus.emit("show_message", {
            title: "Error updating currency",
            color: "error"
          });
        }
        this.sync_exchange_rate();
        if (this.items.length) {
          const doc2 = this.get_invoice_doc();
          doc2.currency = this.selected_currency;
          doc2.price_list_currency = priceListCurrency || this.pos_profile.currency;
          doc2.conversion_rate = this.conversion_rate;
          doc2.plc_conversion_rate = this.exchange_rate;
          try {
            await this.update_invoice(doc2);
          } catch (error) {
            console.error("Error updating invoice currency:", error);
            this.eventBus.emit("show_message", {
              title: "Error updating currency",
              color: "error"
            });
          }
        }
      },
      async update_exchange_rate_on_server() {
        if (this.conversion_rate) {
          if (!this.items.length) {
            this.sync_exchange_rate();
            return;
          }
          const doc2 = this.get_invoice_doc();
          doc2.conversion_rate = this.conversion_rate;
          doc2.plc_conversion_rate = this.exchange_rate;
          try {
            const resp = await this.update_invoice(doc2);
            if (resp && resp.exchange_rate_date) {
              this.exchange_rate_date = resp.exchange_rate_date;
              const posting_backend = this.formatDateForBackend(this.posting_date_display);
              if (posting_backend !== this.exchange_rate_date) {
                this.eventBus.emit("show_message", {
                  title: __("Exchange rate date " + this.exchange_rate_date + " differs from posting date " + posting_backend),
                  color: "warning"
                });
              }
            }
            this.sync_exchange_rate();
          } catch (error) {
            console.error("Error updating exchange rate:", error);
            this.eventBus.emit("show_message", {
              title: "Error updating exchange rate",
              color: "error"
            });
          }
        }
      },
      sync_exchange_rate() {
        if (!this.exchange_rate || this.exchange_rate <= 0) {
          this.exchange_rate = 1;
        }
        if (!this.conversion_rate || this.conversion_rate <= 0) {
          this.conversion_rate = 1;
        }
        this.eventBus.emit("update_currency", {
          currency: this.selected_currency || this.pos_profile.currency,
          exchange_rate: this.exchange_rate,
          conversion_rate: this.conversion_rate
        });
        this.update_item_rates();
      },
      roundAmount(amount) {
        if (this.pos_profile.disable_rounded_total) {
          return this.flt(amount, this.currency_precision);
        }
        const baseCurrency = this.price_list_currency || this.pos_profile.currency;
        if (this.pos_profile.posa_allow_multi_currency && this.selected_currency !== baseCurrency) {
          return this.flt(amount, 2);
        }
        return Math.round(amount);
      },
      async calc_uom(item, value) {
        const new_uom = item.item_uoms.find((element) => element.uom == value);
        if (!new_uom) {
          return;
        }
        const old_conversion_factor = item.conversion_factor || 1;
        item.conversion_factor = new_uom.conversion_factor;
        if (!item.posa_offer_applied) {
          item.discount_amount = 0;
          item.discount_percentage = 0;
        }
        try {
          const response = await frappe.call({
            method: "posawesome.posawesome.api.invoice.get_item_price_for_uom",
            args: {
              item_code: item.item_code,
              price_list: this.get_price_list(),
              uom: value,
              customer: this.customer,
              company: this.pos_profile.company,
              currency: this.pos_profile.currency,
              conversion_factor: item.conversion_factor
            }
          });
          if (response && response.message && response.message.price_list_rate) {
            const fetched_rate = response.message.price_list_rate;
            item.base_rate = fetched_rate;
            item.base_price_list_rate = fetched_rate;
            if (this.selected_currency !== this.pos_profile.currency) {
              item.rate = this.flt(fetched_rate / this.exchange_rate, this.currency_precision);
              item.price_list_rate = item.rate;
            } else {
              item.rate = fetched_rate;
              item.price_list_rate = fetched_rate;
            }
            console.log(`Found Item Price for ${item.item_code} with UOM ${value}: ${fetched_rate}`);
          } else {
            console.log(`No Item Price found for ${item.item_code} with UOM ${value}, using conversion factor`);
            this.fallbackToConversionFactor(item, old_conversion_factor);
          }
        } catch (error) {
          console.error("Error fetching item price for UOM:", error);
          this.fallbackToConversionFactor(item, old_conversion_factor);
          this.eventBus.emit("show_message", {
            title: __("Could not fetch item price for UOM, using conversion factor"),
            color: "warning"
          });
        }
        this.calc_stock_qty(item, item.qty);
        this.$forceUpdate();
      },
      fallbackToConversionFactor(item, old_conversion_factor) {
        if (!item.original_base_rate && !item.posa_offer_applied) {
          item.original_base_rate = item.base_rate / old_conversion_factor;
          item.original_base_price_list_rate = item.base_price_list_rate / old_conversion_factor;
        }
        if (item.batch_price) {
          item.base_rate = item.batch_price * item.conversion_factor;
          item.base_price_list_rate = item.base_rate;
        } else if (item.original_base_rate) {
          item.base_rate = item.original_base_rate * item.conversion_factor;
          item.base_price_list_rate = item.original_base_price_list_rate * item.conversion_factor;
        }
        if (this.selected_currency !== this.pos_profile.currency) {
          item.rate = this.flt(item.base_rate / this.exchange_rate, this.currency_precision);
          item.price_list_rate = this.flt(item.base_price_list_rate / this.exchange_rate, this.currency_precision);
        } else {
          item.rate = item.base_rate;
          item.price_list_rate = item.base_price_list_rate;
        }
      },
      add_one(item) {
        item.qty++;
        if (item.qty == 0) {
          this.remove_item(item);
        }
        this.calc_stock_qty(item, item.qty);
        this.$forceUpdate();
      },
      subtract_one(item) {
        item.qty--;
        if (item.qty == 0) {
          this.remove_item(item);
        }
        this.calc_stock_qty(item, item.qty);
        this.$forceUpdate();
      },
      handleItemReorder(reorderData) {
        const { fromIndex, toIndex } = reorderData;
        if (fromIndex === toIndex)
          return;
        const newItems = [...this.items];
        const [movedItem] = newItems.splice(fromIndex, 1);
        newItems.splice(toIndex, 0, movedItem);
        this.items = newItems;
        this.eventBus.emit("show_message", {
          title: __("Item order updated"),
          color: "success"
        });
        this.items.forEach((item, index) => {
          item.idx = index + 1;
        });
      }
    }),
    mounted() {
      this.loadColumnPreferences();
      this.eventBus.on("item-drag-start", (item) => {
        this.showDropFeedback(true);
      });
      this.eventBus.on("item-drag-end", () => {
        this.showDropFeedback(false);
      });
      this.eventBus.on("register_pos_profile", (data) => {
        this.pos_profile = data.pos_profile;
        this.company = data.company || null;
        this.customer = data.pos_profile.customer;
        this.pos_opening_shift = data.pos_opening_shift;
        this.stock_settings = data.stock_settings;
        const prec = parseInt(data.pos_profile.posa_decimal_precision);
        if (!isNaN(prec)) {
          this.float_precision = prec;
          this.currency_precision = prec;
        }
        this.invoiceType = this.pos_profile.posa_default_sales_order ? "Order" : "Invoice";
        this.initializeItemsHeaders();
        if (this.pos_profile.posa_allow_multi_currency) {
          this.fetch_available_currencies().then(async () => {
            this.selected_currency = this.pos_profile.currency;
            await this.update_currency_and_rate();
          }).catch((error) => {
            console.error("Error initializing currencies:", error);
            this.eventBus.emit("show_message", {
              title: __("Error loading currencies"),
              color: "error"
            });
          });
        }
        this.fetch_price_lists();
        this.update_price_list();
      });
      this.eventBus.on("add_item", this.add_item);
      this.eventBus.on("update_customer", (customer) => {
        this.customer = customer;
      });
      this.eventBus.on("fetch_customer_details", () => {
        this.fetch_customer_details();
      });
      this.eventBus.on("clear_invoice", () => {
        this.clear_invoice();
      });
      this.eventBus.on("load_invoice", (data) => {
        this.load_invoice(data);
      });
      this.eventBus.on("load_order", (data) => {
        this.new_order(data);
      });
      this.eventBus.on("set_offers", (data) => {
        this.posOffers = data;
      });
      this.eventBus.on("update_invoice_offers", (data) => {
        this.updateInvoiceOffers(data);
      });
      this.eventBus.on("update_invoice_coupons", (data) => {
        this.posa_coupons = data;
        this.handelOffers();
      });
      this.eventBus.on("set_all_items", (data) => {
        this.allItems = data;
        this.items.forEach((item) => {
          this.update_item_detail(item);
        });
      });
      this.eventBus.on("load_return_invoice", (data) => {
        console.log("Invoice component received load_return_invoice event with data:", data);
        this.load_invoice(data.invoice_doc);
        this.invoiceType = "Return";
        this.invoiceTypes = ["Return"];
        this.invoice_doc.is_return = 1;
        if (this.items && this.items.length) {
          this.items.forEach((item) => {
            if (item.qty > 0)
              item.qty = -Math.abs(item.qty);
            if (item.stock_qty > 0)
              item.stock_qty = -Math.abs(item.stock_qty);
          });
        }
        if (data.return_doc) {
          console.log("Return against existing invoice:", data.return_doc.name);
          this.discount_amount = data.return_doc.discount_amount > 0 ? -Math.abs(data.return_doc.discount_amount) : data.return_doc.discount_amount;
          this.additional_discount_percentage = data.return_doc.additional_discount_percentage > 0 ? -Math.abs(data.return_doc.additional_discount_percentage) : data.return_doc.additional_discount_percentage;
          this.return_doc = data.return_doc;
          this.invoice_doc.return_against = data.return_doc.name;
        } else {
          console.log("Return without invoice reference");
          this.discount_amount = 0;
          this.additional_discount_percentage = 0;
        }
        console.log("Invoice state after loading return:", {
          invoiceType: this.invoiceType,
          is_return: this.invoice_doc.is_return,
          items: this.items.length,
          customer: this.customer
        });
      });
      this.eventBus.on("set_new_line", (data) => {
        this.new_line = data;
      });
      if (this.pos_profile.posa_allow_multi_currency) {
        this.fetch_available_currencies();
      }
      this.eventBus.on("reset_posting_date", () => {
        this.posting_date = frappe.datetime.nowdate();
      });
      this.eventBus.on("open_variants_model", this.open_variants_model);
      this.eventBus.on("calc_uom", this.calc_uom);
      this.eventBus.on("item-drag-start", (item) => {
        this.showDropFeedback(true);
      });
      this.eventBus.on("item-drag-end", () => {
        this.showDropFeedback(false);
      });
    },
    beforeUnmount() {
      this.eventBus.off("register_pos_profile");
      this.eventBus.off("add_item");
      this.eventBus.off("update_customer");
      this.eventBus.off("fetch_customer_details");
      this.eventBus.off("clear_invoice");
      this.eventBus.off("reset_posting_date");
    },
    created() {
      document.addEventListener("keydown", this.shortOpenPayment.bind(this));
      document.addEventListener("keydown", this.shortDeleteFirstItem.bind(this));
      document.addEventListener("keydown", this.shortOpenFirstItem.bind(this));
      document.addEventListener("keydown", this.shortSelectDiscount.bind(this));
    },
    unmounted() {
      document.removeEventListener("keydown", this.shortOpenPayment);
      document.removeEventListener("keydown", this.shortDeleteFirstItem);
      document.removeEventListener("keydown", this.shortOpenFirstItem);
      document.removeEventListener("keydown", this.shortSelectDiscount);
    },
    watch: invoiceWatchers_default
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/Invoice.vue?type=template
  var _hoisted_128 = { class: "pa-0" };
  var _hoisted_215 = { class: "dynamic-padding" };
  var _hoisted_313 = { class: "column-selector-container" };
  var _hoisted_410 = { class: "text-caption mt-2" };
  function render20(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_CancelSaleDialog = resolveComponent("CancelSaleDialog");
    const _component_v_icon = resolveComponent("v-icon");
    const _component_v_card_title = resolveComponent("v-card-title");
    const _component_v_text_field = resolveComponent("v-text-field");
    const _component_v_col = resolveComponent("v-col");
    const _component_v_row = resolveComponent("v-row");
    const _component_v_container = resolveComponent("v-container");
    const _component_v_card_text = resolveComponent("v-card-text");
    const _component_v_spacer = resolveComponent("v-spacer");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_card_actions = resolveComponent("v-card-actions");
    const _component_v_card = resolveComponent("v-card");
    const _component_v_dialog = resolveComponent("v-dialog");
    const _component_Customer = resolveComponent("Customer");
    const _component_v_select = resolveComponent("v-select");
    const _component_DeliveryCharges = resolveComponent("DeliveryCharges");
    const _component_PostingDateRow = resolveComponent("PostingDateRow");
    const _component_MultiCurrencyRow = resolveComponent("MultiCurrencyRow");
    const _component_v_divider = resolveComponent("v-divider");
    const _component_v_switch = resolveComponent("v-switch");
    const _component_ItemsTable = resolveComponent("ItemsTable");
    const _component_InvoiceSummary = resolveComponent("InvoiceSummary");
    return openBlock(), createElementBlock(Fragment, null, [
      createCommentVNode(" Main Invoice Wrapper "),
      createBaseVNode("div", _hoisted_128, [
        createCommentVNode(" Cancel Sale Confirmation Dialog "),
        createVNode(_component_CancelSaleDialog, {
          modelValue: $data.cancel_dialog,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.cancel_dialog = $event),
          onConfirm: _ctx.cancel_invoice
        }, null, 8, ["modelValue", "onConfirm"]),
        createCommentVNode(" Reference Details Dialog "),
        createVNode(_component_v_dialog, {
          modelValue: $data.reference_dialog,
          "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $data.reference_dialog = $event),
          "max-width": "500",
          persistent: ""
        }, {
          default: withCtx(() => [
            createVNode(_component_v_card, null, {
              default: withCtx(() => [
                createVNode(_component_v_card_title, { class: "text-h5 bg-primary white--text" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_icon, {
                      left: "",
                      color: "white"
                    }, {
                      default: withCtx(() => [
                        createTextVNode("mdi-file-document-edit")
                      ]),
                      _: 1
                    }),
                    createTextVNode(" " + toDisplayString(_ctx.__("Enter Reference Details")), 1)
                  ]),
                  _: 1
                }),
                createVNode(_component_v_card_text, { class: "pt-6 pb-2" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_container, null, {
                      default: withCtx(() => [
                        createVNode(_component_v_row, null, {
                          default: withCtx(() => [
                            createVNode(_component_v_col, { cols: "12" }, {
                              default: withCtx(() => [
                                createVNode(_component_v_text_field, {
                                  modelValue: $data.reference_no,
                                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.reference_no = $event),
                                  label: _ctx.__("Reference Number"),
                                  variant: "outlined",
                                  density: "compact",
                                  color: "primary",
                                  "prepend-inner-icon": "mdi-numeric",
                                  rules: [(v) => !!v || _ctx.__("Reference Number is required")],
                                  required: "",
                                  "hide-details": "auto",
                                  autocomplete: "off",
                                  class: "mb-3"
                                }, null, 8, ["modelValue", "label", "rules"])
                              ]),
                              _: 1
                            }),
                            createVNode(_component_v_col, { cols: "12" }, {
                              default: withCtx(() => [
                                createVNode(_component_v_text_field, {
                                  modelValue: $data.reference_name,
                                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.reference_name = $event),
                                  label: _ctx.__("Reference Name"),
                                  variant: "outlined",
                                  density: "compact",
                                  color: "primary",
                                  "prepend-inner-icon": "mdi-account",
                                  rules: [(v) => !!v || _ctx.__("Reference Name is required")],
                                  required: "",
                                  "hide-details": "auto",
                                  autocomplete: "off"
                                }, null, 8, ["modelValue", "label", "rules"])
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                createVNode(_component_v_card_actions, { class: "px-6 pb-4" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_spacer),
                    createVNode(_component_v_btn, {
                      color: "grey",
                      variant: "outlined",
                      onClick: $options.cancel_reference_dialog,
                      "prepend-icon": "mdi-close"
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.__("Cancel")), 1)
                      ]),
                      _: 1
                    }, 8, ["onClick"]),
                    createVNode(_component_v_btn, {
                      color: "primary",
                      variant: "elevated",
                      onClick: $options.confirm_reference_and_proceed,
                      "prepend-icon": "mdi-credit-card",
                      disabled: !$data.reference_no || !$data.reference_name,
                      class: "ml-3"
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.__("Proceed to Payment")), 1)
                      ]),
                      _: 1
                    }, 8, ["onClick", "disabled"])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["modelValue"]),
        createCommentVNode(" Main Invoice Card (contains all invoice content) "),
        createVNode(_component_v_card, {
          style: normalizeStyle({ height: "var(--container-height)", maxHeight: "var(--container-height)", backgroundColor: $options.isDarkTheme ? "#121212" : "" }),
          class: normalizeClass(["cards my-0 py-0 mt-3", $options.isDarkTheme ? "" : "bg-grey-lighten-5", { "return-mode": _ctx.isReturnInvoice }])
        }, {
          default: withCtx(() => [
            createCommentVNode(" Dynamic padding wrapper "),
            createBaseVNode("div", _hoisted_215, [
              createCommentVNode(" Top Row: Customer Selection and Invoice Type "),
              createVNode(_component_v_row, {
                align: "center",
                class: "items px-3 py-2"
              }, {
                default: withCtx(() => [
                  createVNode(_component_v_col, {
                    cols: $data.pos_profile.posa_allow_sales_order ? 9 : 12,
                    class: "pb-0 pr-0"
                  }, {
                    default: withCtx(() => [
                      createCommentVNode(" Customer selection component "),
                      createVNode(_component_Customer)
                    ]),
                    _: 1
                  }, 8, ["cols"]),
                  createCommentVNode(" Invoice Type Selection (Only shown if sales orders are allowed) "),
                  $data.pos_profile.posa_allow_sales_order ? (openBlock(), createBlock(_component_v_col, {
                    key: 0,
                    cols: "3",
                    class: "pb-4"
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_v_select, {
                        density: "compact",
                        "hide-details": "",
                        variant: "outlined",
                        color: "primary",
                        "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                        class: "dark-field",
                        items: $data.invoiceTypes,
                        label: _ctx.frappe._("Type"),
                        modelValue: $data.invoiceType,
                        "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $data.invoiceType = $event),
                        disabled: $data.invoiceType == "Return"
                      }, null, 8, ["bg-color", "items", "label", "modelValue", "disabled"])
                    ]),
                    _: 1
                  })) : createCommentVNode("v-if", true)
                ]),
                _: 1
              }),
              createCommentVNode(" Delivery Charges Section (Only if enabled in POS profile) "),
              createVNode(_component_DeliveryCharges, {
                pos_profile: $data.pos_profile,
                delivery_charges: $data.delivery_charges,
                selected_delivery_charge: $data.selected_delivery_charge,
                delivery_charges_rate: $data.delivery_charges_rate,
                deliveryChargesFilter: $options.deliveryChargesFilter,
                formatCurrency: $options.formatCurrency,
                currencySymbol: _ctx.currencySymbol,
                readonly: _ctx.readonly,
                "onUpdate:selected_delivery_charge": _cache[5] || (_cache[5] = (val) => {
                  $data.selected_delivery_charge = val;
                  $options.update_delivery_charges();
                })
              }, null, 8, ["pos_profile", "delivery_charges", "selected_delivery_charge", "delivery_charges_rate", "deliveryChargesFilter", "formatCurrency", "currencySymbol", "readonly"]),
              createCommentVNode(" Posting Date and Customer Balance Section "),
              createVNode(_component_PostingDateRow, {
                pos_profile: $data.pos_profile,
                posting_date_display: $data.posting_date_display,
                customer_balance: $data.customer_balance,
                "price-list": $data.selected_price_list,
                "price-lists": $data.price_lists,
                formatCurrency: $options.formatCurrency,
                "onUpdate:posting_date_display": _cache[6] || (_cache[6] = (val) => {
                  $data.posting_date_display = val;
                }),
                "onUpdate:priceList": _cache[7] || (_cache[7] = (val) => {
                  $data.selected_price_list = val;
                })
              }, null, 8, ["pos_profile", "posting_date_display", "customer_balance", "price-list", "price-lists", "formatCurrency"]),
              createCommentVNode(" Multi-Currency Section (Only if enabled in POS profile) "),
              createVNode(_component_MultiCurrencyRow, {
                pos_profile: $data.pos_profile,
                selected_currency: $data.selected_currency,
                plc_conversion_rate: $data.exchange_rate,
                conversion_rate: $data.conversion_rate,
                available_currencies: $data.available_currencies,
                isNumber: _ctx.isNumber,
                price_list_currency: $data.price_list_currency,
                "onUpdate:selected_currency": _cache[8] || (_cache[8] = (val) => {
                  $data.selected_currency = val;
                  $options.update_currency(val);
                }),
                "onUpdate:plc_conversion_rate": _cache[9] || (_cache[9] = (val) => {
                  $data.exchange_rate = val;
                  $options.update_exchange_rate();
                }),
                "onUpdate:conversion_rate": _cache[10] || (_cache[10] = (val) => {
                  $data.conversion_rate = val;
                  $options.update_conversion_rate();
                })
              }, null, 8, ["pos_profile", "selected_currency", "plc_conversion_rate", "conversion_rate", "available_currencies", "isNumber", "price_list_currency"]),
              createCommentVNode(" Items Table Section (Main items list for invoice) "),
              createCommentVNode(" Add this right before the ItemsTable component "),
              createBaseVNode("div", _hoisted_313, [
                createVNode(_component_v_btn, {
                  density: "compact",
                  variant: "text",
                  color: "primary",
                  "prepend-icon": "mdi-cog-outline",
                  onClick: $options.toggleColumnSelection,
                  class: "column-selector-btn"
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.__("Columns")), 1)
                  ]),
                  _: 1
                }, 8, ["onClick"]),
                createVNode(_component_v_dialog, {
                  modelValue: $data.show_column_selector,
                  "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => $data.show_column_selector = $event),
                  "max-width": "500px"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_v_card, null, {
                      default: withCtx(() => [
                        createVNode(_component_v_card_title, { class: "text-h6 pa-4 d-flex align-center" }, {
                          default: withCtx(() => [
                            createBaseVNode("span", null, toDisplayString(_ctx.__("Select Columns to Display")), 1),
                            createVNode(_component_v_spacer),
                            createVNode(_component_v_btn, {
                              icon: "mdi-close",
                              variant: "text",
                              density: "compact",
                              onClick: _cache[11] || (_cache[11] = ($event) => $data.show_column_selector = false)
                            })
                          ]),
                          _: 1
                        }),
                        createVNode(_component_v_divider),
                        createVNode(_component_v_card_text, { class: "pa-4" }, {
                          default: withCtx(() => [
                            createVNode(_component_v_row, { dense: "" }, {
                              default: withCtx(() => [
                                (openBlock(true), createElementBlock(Fragment, null, renderList($data.available_columns.filter((col) => !col.required), (column) => {
                                  return openBlock(), createBlock(_component_v_col, {
                                    cols: "12",
                                    key: column.key
                                  }, {
                                    default: withCtx(() => [
                                      createVNode(_component_v_switch, {
                                        modelValue: $data.temp_selected_columns,
                                        "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => $data.temp_selected_columns = $event),
                                        label: column.title,
                                        value: column.key,
                                        "hide-details": "",
                                        density: "compact",
                                        color: "primary",
                                        class: "column-switch mb-1",
                                        disabled: column.required
                                      }, null, 8, ["modelValue", "label", "value", "disabled"])
                                    ]),
                                    _: 2
                                  }, 1024);
                                }), 128))
                              ]),
                              _: 1
                            }),
                            createBaseVNode("div", _hoisted_410, toDisplayString(_ctx.__("Required columns cannot be hidden")), 1)
                          ]),
                          _: 1
                        }),
                        createVNode(_component_v_card_actions, { class: "pa-4 pt-0" }, {
                          default: withCtx(() => [
                            createVNode(_component_v_btn, {
                              color: "error",
                              variant: "text",
                              onClick: $options.cancelColumnSelection
                            }, {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString(_ctx.__("Cancel")), 1)
                              ]),
                              _: 1
                            }, 8, ["onClick"]),
                            createVNode(_component_v_spacer),
                            createVNode(_component_v_btn, {
                              color: "primary",
                              variant: "tonal",
                              onClick: $options.updateSelectedColumns
                            }, {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString(_ctx.__("Apply")), 1)
                              ]),
                              _: 1
                            }, 8, ["onClick"])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["modelValue"])
              ]),
              createCommentVNode(" ItemsTable component with reorder event handler "),
              createVNode(_component_ItemsTable, {
                headers: $data.items_headers,
                items: $data.items,
                expanded: $data.expanded,
                itemsPerPage: $data.itemsPerPage,
                itemSearch: _ctx.itemSearch,
                pos_profile: $data.pos_profile,
                invoice_doc: $data.invoice_doc,
                invoiceType: $data.invoiceType,
                displayCurrency: _ctx.displayCurrency,
                formatFloat: _ctx.formatFloat,
                formatCurrency: $options.formatCurrency,
                currencySymbol: _ctx.currencySymbol,
                isNumber: _ctx.isNumber,
                setFormatedQty: $options.setFormatedQty,
                calcStockQty: _ctx.calc_stock_qty,
                setFormatedCurrency: _ctx.setFormatedCurrency,
                calcPrices: _ctx.calc_prices,
                calcUom: $options.calc_uom,
                setSerialNo: _ctx.set_serial_no,
                setBatchQty: _ctx.set_batch_qty,
                validateDueDate: _ctx.validate_due_date,
                removeItem: _ctx.remove_item,
                subtractOne: $options.subtract_one,
                addOne: $options.add_one,
                toggleOffer: _ctx.toggleOffer,
                "onUpdate:expanded": _cache[14] || (_cache[14] = ($event) => $data.expanded = $event),
                onReorderItems: $options.handleItemReorder,
                onAddItemFromDrag: $options.handleItemDrop,
                onShowDropFeedback: $options.showDropFeedback,
                onItemDropped: _cache[15] || (_cache[15] = ($event) => $options.showDropFeedback(false))
              }, null, 8, ["headers", "items", "expanded", "itemsPerPage", "itemSearch", "pos_profile", "invoice_doc", "invoiceType", "displayCurrency", "formatFloat", "formatCurrency", "currencySymbol", "isNumber", "setFormatedQty", "calcStockQty", "setFormatedCurrency", "calcPrices", "calcUom", "setSerialNo", "setBatchQty", "validateDueDate", "removeItem", "subtractOne", "addOne", "toggleOffer", "onReorderItems", "onAddItemFromDrag", "onShowDropFeedback"])
            ])
          ]),
          _: 1
        }, 8, ["style", "class"]),
        createCommentVNode(" Payment Section "),
        createVNode(_component_InvoiceSummary, {
          pos_profile: $data.pos_profile,
          total_qty: _ctx.total_qty,
          additional_discount: $data.additional_discount,
          additional_discount_percentage: $data.additional_discount_percentage,
          total_items_discount_amount: _ctx.total_items_discount_amount,
          subtotal: _ctx.subtotal,
          displayCurrency: _ctx.displayCurrency,
          formatFloat: _ctx.formatFloat,
          formatCurrency: $options.formatCurrency,
          currencySymbol: _ctx.currencySymbol,
          discount_percentage_offer_name: $data.discount_percentage_offer_name,
          isNumber: _ctx.isNumber,
          "onUpdate:additional_discount": _cache[16] || (_cache[16] = (val) => $data.additional_discount = val),
          "onUpdate:additional_discount_percentage": _cache[17] || (_cache[17] = (val) => $data.additional_discount_percentage = val),
          onUpdate_discount_umount: _ctx.update_discount_umount,
          onSaveAndClear: _ctx.save_and_clear_invoice,
          onLoadDrafts: _ctx.get_draft_invoices,
          onSelectOrder: _ctx.get_draft_orders,
          onCancelSale: _cache[18] || (_cache[18] = ($event) => $data.cancel_dialog = true),
          onOpenReturns: _ctx.open_returns,
          onPrintDraft: $options.print_draft_invoice,
          onShowPayment: $options.show_payment
        }, null, 8, ["pos_profile", "total_qty", "additional_discount", "additional_discount_percentage", "total_items_discount_amount", "subtotal", "displayCurrency", "formatFloat", "formatCurrency", "currencySymbol", "discount_percentage_offer_name", "isNumber", "onUpdate_discount_umount", "onSaveAndClear", "onLoadDrafts", "onSelectOrder", "onOpenReturns", "onPrintDraft", "onShowPayment"])
      ])
    ], 2112);
  }

  // ../posawesome/posawesome/public/js/posapp/components/pos/Invoice.vue
  Invoice_default.render = render20;
  Invoice_default.__file = "../posawesome/posawesome/public/js/posapp/components/pos/Invoice.vue";
  Invoice_default.__scopeId = "data-v-698ff108";
  var Invoice_default2 = Invoice_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/OpeningDialog.vue?type=script
  var OpeningDialog_default = {
    mixins: [format_default],
    props: ["dialog"],
    data() {
      return {
        isOpen: this.dialog ? this.dialog : false,
        dialog_data: {},
        is_loading: false,
        companies: [],
        company: "",
        pos_profiles_data: [],
        pos_profiles: [],
        pos_profile: "",
        payments_method_data: [],
        payments_methods: [],
        payments_methods_headers: [
          {
            title: __("Mode of Payment"),
            align: "start",
            sortable: false,
            value: "mode_of_payment"
          },
          {
            title: __("Opening Amount"),
            value: "amount",
            align: "center",
            sortable: false
          }
        ],
        itemsPerPage: 100,
        max25chars: (v) => v.length <= 12 || "Input too long!",
        pagination: {},
        snack: false,
        snackColor: "",
        snackText: ""
      };
    },
    watch: {
      company(val) {
        this.pos_profiles = [];
        this.pos_profiles_data.forEach((element) => {
          if (element.company === val) {
            this.pos_profiles.push(element.name);
          }
          if (this.pos_profiles.length) {
            this.pos_profile = this.pos_profiles[0];
          } else {
            this.pos_profile = "";
          }
        });
      },
      pos_profile(val) {
        this.payments_methods = [];
        this.payments_method_data.forEach((element) => {
          if (element.parent === val) {
            this.payments_methods.push({
              mode_of_payment: element.mode_of_payment,
              amount: 0,
              currency: element.currency
            });
          }
        });
      }
    },
    methods: {
      close_opening_dialog() {
        this.eventBus.emit("close_opening_dialog");
      },
      async get_opening_dialog_data() {
        const vm2 = this;
        await initPromise;
        const cached = getOpeningDialogStorage();
        if (cached) {
          try {
            vm2.companies = cached.companies.map((c) => c.name);
            vm2.pos_profiles_data = cached.pos_profiles_data || [];
            vm2.payments_method_data = cached.payments_method || [];
            vm2.company = vm2.companies[0] || "";
          } catch (e) {
            console.error("Failed to parse opening dialog cache", e);
          }
        }
        frappe.call({
          method: "posawesome.posawesome.api.shifts.get_opening_dialog_data",
          args: {},
          callback: function(r) {
            if (r.message) {
              vm2.companies = r.message.companies.map((element) => element.name);
              vm2.pos_profiles_data = r.message.pos_profiles_data;
              vm2.payments_method_data = r.message.payments_method;
              vm2.company = vm2.companies[0] || "";
              try {
                setOpeningDialogStorage(r.message);
              } catch (e) {
                console.error("Failed to cache opening dialog data", e);
              }
            }
          }
        });
      },
      submit_dialog() {
        if (!this.payments_methods.length || !this.company || !this.pos_profile) {
          return;
        }
        this.is_loading = true;
        const vm2 = this;
        return frappe.call("posawesome.posawesome.api.shifts.create_opening_voucher", {
          pos_profile: this.pos_profile,
          company: this.company,
          balance_details: this.payments_methods
        }).then((r) => {
          if (r.message) {
            vm2.eventBus.emit("register_pos_data", r.message);
            vm2.eventBus.emit("set_company", r.message.company);
            try {
              setOpeningStorage(r.message);
            } catch (e) {
              console.error("Failed to cache opening data", e);
            }
            vm2.close_opening_dialog();
            vm2.is_loading = false;
          }
        });
      },
      go_desk() {
        frappe.set_route("/");
        location.reload();
      }
    },
    mounted() {
      this.get_opening_dialog_data();
    },
    beforeUnmount() {
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/OpeningDialog.vue?type=template
  var _hoisted_129 = { class: "header-content" };
  var _hoisted_216 = { class: "header-icon-wrapper" };
  var _hoisted_314 = { class: "header-text" };
  var _hoisted_411 = { class: "header-title" };
  var _hoisted_59 = { class: "header-subtitle" };
  var _hoisted_69 = { class: "section-header-compact" };
  var _hoisted_78 = { class: "section-title-compact" };
  function render21(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_icon = resolveComponent("v-icon");
    const _component_v_card_title = resolveComponent("v-card-title");
    const _component_v_autocomplete = resolveComponent("v-autocomplete");
    const _component_v_col = resolveComponent("v-col");
    const _component_v_text_field = resolveComponent("v-text-field");
    const _component_v_data_table = resolveComponent("v-data-table");
    const _component_v_row = resolveComponent("v-row");
    const _component_v_container = resolveComponent("v-container");
    const _component_v_card_text = resolveComponent("v-card-text");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_spacer = resolveComponent("v-spacer");
    const _component_v_card_actions = resolveComponent("v-card-actions");
    const _component_v_card = resolveComponent("v-card");
    const _component_v_dialog = resolveComponent("v-dialog");
    return openBlock(), createBlock(_component_v_row, { justify: "center" }, {
      default: withCtx(() => [
        createVNode(_component_v_dialog, {
          modelValue: $data.isOpen,
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.isOpen = $event),
          persistent: "",
          "max-width": "800px",
          "max-height": "90vh"
        }, {
          default: withCtx(() => [
            createVNode(_component_v_card, {
              elevation: "8",
              class: "opening-dialog-card"
            }, {
              default: withCtx(() => [
                createCommentVNode(" Header Section - White Background with Blue Text "),
                createVNode(_component_v_card_title, { class: "opening-dialog-header" }, {
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_129, [
                      createBaseVNode("div", _hoisted_216, [
                        createVNode(_component_v_icon, { class: "header-icon" }, {
                          default: withCtx(() => [
                            createTextVNode("mdi-cash-plus")
                          ]),
                          _: 1
                        })
                      ]),
                      createBaseVNode("div", _hoisted_314, [
                        createBaseVNode("h5", _hoisted_411, toDisplayString(_ctx.__("Create POS Opening Shift")), 1),
                        createBaseVNode("p", _hoisted_59, toDisplayString(_ctx.__("Initialize your shift with opening balances")), 1)
                      ])
                    ])
                  ]),
                  _: 1
                }),
                createCommentVNode(" Content Section - Optimized for minimal scrolling "),
                createVNode(_component_v_card_text, { class: "opening-dialog-content" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_container, { class: "pa-0" }, {
                      default: withCtx(() => [
                        createVNode(_component_v_row, null, {
                          default: withCtx(() => [
                            createCommentVNode(" Company and POS Profile in same row for space efficiency "),
                            createVNode(_component_v_col, {
                              cols: "12",
                              md: "6",
                              class: "form-field"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_v_autocomplete, {
                                  items: $data.companies,
                                  label: _ctx.frappe._("Company"),
                                  modelValue: $data.company,
                                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.company = $event),
                                  required: "",
                                  variant: "outlined",
                                  color: "primary",
                                  density: "compact",
                                  "prepend-inner-icon": "mdi-domain",
                                  class: normalizeClass(["enhanced-field", { "field-focused": $data.company }])
                                }, null, 8, ["items", "label", "modelValue", "class"])
                              ]),
                              _: 1
                            }),
                            createVNode(_component_v_col, {
                              cols: "12",
                              md: "6",
                              class: "form-field"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_v_autocomplete, {
                                  items: $data.pos_profiles,
                                  label: _ctx.frappe._("POS Profile"),
                                  modelValue: $data.pos_profile,
                                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.pos_profile = $event),
                                  required: "",
                                  variant: "outlined",
                                  color: "primary",
                                  density: "compact",
                                  "prepend-inner-icon": "mdi-point-of-sale",
                                  class: normalizeClass(["enhanced-field", { "field-focused": $data.pos_profile }])
                                }, null, 8, ["items", "label", "modelValue", "class"])
                              ]),
                              _: 1
                            }),
                            createCommentVNode(" Payment Methods Section - Compact "),
                            createVNode(_component_v_col, { cols: "12" }, {
                              default: withCtx(() => [
                                createBaseVNode("div", _hoisted_69, [
                                  createBaseVNode("h6", _hoisted_78, [
                                    createVNode(_component_v_icon, { class: "section-icon" }, {
                                      default: withCtx(() => [
                                        createTextVNode("mdi-credit-card-multiple")
                                      ]),
                                      _: 1
                                    }),
                                    createTextVNode(" " + toDisplayString(_ctx.__("Payment Methods")), 1)
                                  ])
                                ]),
                                createVNode(_component_v_data_table, {
                                  headers: $data.payments_methods_headers,
                                  items: $data.payments_methods,
                                  "item-key": "mode_of_payment",
                                  class: "enhanced-table-compact",
                                  "items-per-page": $data.itemsPerPage,
                                  "hide-default-footer": "",
                                  density: "compact",
                                  height: "300px",
                                  "fixed-header": ""
                                }, {
                                  "item.amount": withCtx(({ item }) => [
                                    createVNode(_component_v_text_field, {
                                      modelValue: item.amount,
                                      "onUpdate:modelValue": ($event) => item.amount = $event,
                                      rules: [$data.max25chars],
                                      type: "number",
                                      density: "compact",
                                      variant: "outlined",
                                      color: "primary",
                                      "hide-details": "",
                                      prefix: _ctx.currencySymbol(item.currency),
                                      class: "amount-input"
                                    }, null, 8, ["modelValue", "onUpdate:modelValue", "rules", "prefix"])
                                  ]),
                                  _: 1
                                }, 8, ["headers", "items", "items-per-page"])
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                createCommentVNode(" Actions Section "),
                createVNode(_component_v_card_actions, { class: "dialog-actions-container" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_btn, {
                      theme: "dark",
                      onClick: $options.go_desk,
                      class: "pos-action-btn cancel-action-btn",
                      size: "large",
                      elevation: "2"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_v_icon, { start: "" }, {
                          default: withCtx(() => [
                            createTextVNode("mdi-close-circle-outline")
                          ]),
                          _: 1
                        }),
                        createBaseVNode("span", null, toDisplayString(_ctx.__("Cancel")), 1)
                      ]),
                      _: 1
                    }, 8, ["onClick"]),
                    createVNode(_component_v_spacer),
                    createVNode(_component_v_btn, {
                      theme: "dark",
                      disabled: $data.is_loading,
                      loading: $data.is_loading,
                      onClick: $options.submit_dialog,
                      class: "pos-action-btn submit-action-btn",
                      size: "large",
                      elevation: "2"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_v_icon, { start: "" }, {
                          default: withCtx(() => [
                            createTextVNode("mdi-check-circle-outline")
                          ]),
                          _: 1
                        }),
                        createBaseVNode("span", null, toDisplayString(_ctx.__("Submit")), 1)
                      ]),
                      _: 1
                    }, 8, ["disabled", "loading", "onClick"])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]),
      _: 1
    });
  }

  // ../posawesome/posawesome/public/js/posapp/components/pos/OpeningDialog.vue
  OpeningDialog_default.render = render21;
  OpeningDialog_default.__file = "../posawesome/posawesome/public/js/posapp/components/pos/OpeningDialog.vue";
  OpeningDialog_default.__scopeId = "data-v-6c820fa0";
  var OpeningDialog_default2 = OpeningDialog_default;

  // ../posawesome/posawesome/public/js/offline_print_template.js
  function generateOfflineInvoiceHTML(invoice) {
    if (!invoice)
      return "";
    const itemsRows = (invoice.items || []).map((it2) => {
      const sn2 = it2.serial_no ? `<br><b>SR.No:</b><br>${it2.serial_no.replace(/\n/g, ", ")}` : "";
      return `<tr>
        <td>${it2.item_code}${it2.item_name && it2.item_name !== it2.item_code ? `<br>${it2.item_name}` : ""}${sn2}</td>
        <td style="text-align:right">${it2.qty} ${it2.uom || ""}<br>@ ${it2.rate}</td>
        <td style="text-align:right">${it2.amount}</td>
      </tr>`;
    }).join("");
    const taxesRows = (invoice.taxes || []).map((row) => `<tr>
      <td class="text-right" style="width:70%">${row.description}@${row.rate}%</td>
      <td class="text-right">${row.tax_amount}</td>
    </tr>`).join("");
    const discountRow = invoice.discount_amount ? `<tr>
      <td class="text-right" style="width:75%">Discount</td>
      <td class="text-right">${invoice.discount_amount}</td>
    </tr>` : "";
    const changeRow = invoice.change_amount ? `<tr>
      <td class="text-right" style="width:75%">Change Amount</td>
      <td class="text-right">${invoice.change_amount}</td>
    </tr>` : "";
    const html = `<!DOCTYPE html>
  <html>
  <head>
    <meta charset="utf-8">
    <title>Invoice ${invoice.name || ""}</title>
    <style>
      table, tr, td, div, p { line-height:120%; vertical-align:middle; font-size:10px; }
      .print-format { width:3.5in; padding:0.1in; min-height:7in; }
      .text-right { text-align:right; }
    </style>
  </head>
  <body class="print-format">
    <div style="text-align:center; margin-bottom:0"><h5 style="margin:0; font-size:11px;">${invoice.is_duplicate ? "Duplicate" : "Original"}</h5></div>
    <p style="margin-top:0">
      <b>Invoice Status:</b> ${invoice.status || ""}<br>
      <b>Receipt No:</b> ${invoice.name || ""}<br>
      <b>Customer:</b> ${invoice.customer_name || invoice.customer || ""}<br>
      <b>Mobile:</b> ${invoice.contact_mobile || ""}<br>
      <b>Date:</b> ${invoice.posting_date || ""}
      <b>Time:</b> ${invoice.posting_time || ""}<br>
    </p>
    <p style="margin-top:3px;"><b>Additional Note:</b> <strong>${invoice.posa_notes || ""}</strong></p>
    <table cellpadding="0" cellspacing="0" style="width:100%">
      <thead>
        <tr><th width="50%"><b>Item</b></th><th width="25%" class="text-right"><b>Qty</b></th><th width="25%" class="text-right"><b>Amount</b></th></tr>
      </thead>
      <tbody>${itemsRows}</tbody>
    </table>
    <table cellpadding="0" cellspacing="0" style="width:100%">
      <tbody>
        <tr><td class="text-right" style="width:70%"><b>Total</b></td><td class="text-right">${invoice.total}</td></tr>
        ${taxesRows}
        ${discountRow}
        <tr><td class="text-right" style="width:70%"><b>Grand Total</b></td><td class="text-right">${invoice.grand_total}</td></tr>
        <tr><td class="text-right" style="width:75%"><b>Paid Amount</b></td><td class="text-right">${invoice.paid_amount}</td></tr>
        ${changeRow}
      </tbody>
    </table>
    <p class="text-center" style="margin-top:3px;">Thank you, please visit again.</p>
  </body>
  </html>`;
    return html;
  }

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/Payments.vue?type=script
  var Payments_default = {
    mixins: [format_default],
    data() {
      return {
        loading: false,
        pos_profile: "",
        pos_settings: "",
        invoice_doc: "",
        invoiceType: "Invoice",
        is_return: false,
        loyalty_amount: 0,
        redeemed_customer_credit: 0,
        credit_change: 0,
        paid_change: 0,
        is_credit_sale: false,
        is_write_off_change: false,
        is_cashback: true,
        is_credit_return: false,
        redeem_customer_credit: false,
        customer_credit_dict: [],
        paid_change_rules: [],
        phone_dialog: false,
        custom_days_dialog: false,
        custom_days_value: null,
        new_delivery_date: null,
        new_po_date: null,
        new_credit_due_date: null,
        credit_due_days: null,
        credit_due_presets: [7, 14, 30],
        customer_info: "",
        mpesa_modes: [],
        sales_persons: [],
        sales_person: "",
        addresses: [],
        is_user_editing_paid_change: false
      };
    },
    computed: {
      currencySymbol() {
        return (currency) => {
          return get_currency_symbol(currency || this.invoice_doc.currency);
        };
      },
      displayCurrency() {
        return this.invoice_doc ? this.invoice_doc.currency : "";
      },
      total_payments() {
        let total = 0;
        if (this.invoice_doc && this.invoice_doc.payments) {
          this.invoice_doc.payments.forEach((payment) => {
            total += parseFloat(payment.amount) || 0;
          });
        }
        if (this.loyalty_amount) {
          if (this.invoice_doc.currency !== this.pos_profile.currency) {
            total += this.flt(this.loyalty_amount / (this.invoice_doc.conversion_rate || 1), this.currency_precision);
          } else {
            total += parseFloat(this.loyalty_amount) || 0;
          }
        }
        if (this.redeemed_customer_credit) {
          if (this.invoice_doc.currency !== this.pos_profile.currency) {
            total += this.flt(this.redeemed_customer_credit / (this.invoice_doc.conversion_rate || 1), this.currency_precision);
          } else {
            total += parseFloat(this.redeemed_customer_credit) || 0;
          }
        }
        return this.flt(total, this.currency_precision);
      },
      diff_payment() {
        if (!this.invoice_doc)
          return 0;
        let invoice_total;
        if (this.pos_profile.posa_allow_multi_currency && this.invoice_doc.currency !== this.pos_profile.currency) {
          invoice_total = this.flt(this.invoice_doc.grand_total, this.currency_precision);
        } else {
          invoice_total = this.flt(this.invoice_doc.rounded_total || this.invoice_doc.grand_total, this.currency_precision);
        }
        let diff = this.flt(invoice_total - this.total_payments, this.currency_precision);
        if (this.invoice_doc.is_return) {
          return diff >= 0 ? diff : 0;
        }
        return diff >= 0 ? diff : 0;
      },
      credit_change() {
        let invoice_total;
        if (this.pos_profile.posa_allow_multi_currency && this.invoice_doc.currency !== this.pos_profile.currency) {
          invoice_total = this.flt(this.invoice_doc.grand_total, this.currency_precision);
        } else {
          invoice_total = this.flt(this.invoice_doc.rounded_total || this.invoice_doc.grand_total, this.currency_precision);
        }
        let change = this.flt(this.total_payments - invoice_total, this.currency_precision);
        return change > 0 ? change : 0;
      },
      diff_label() {
        return this.diff_payment > 0 ? `To Be Paid (${this.displayCurrency})` : `Change (${this.displayCurrency})`;
      },
      total_payments_display() {
        return this.formatCurrency(this.total_payments, this.displayCurrency);
      },
      diff_payment_display() {
        return this.formatCurrency(this.diff_payment, this.displayCurrency);
      },
      available_points_amount() {
        let amount = 0;
        if (this.customer_info.loyalty_points) {
          amount = this.customer_info.loyalty_points * this.customer_info.conversion_factor;
          if (this.invoice_doc.currency !== this.pos_profile.currency) {
            amount = this.flt(amount / (this.invoice_doc.conversion_rate || 1), this.currency_precision);
          }
        }
        return amount;
      },
      available_customer_credit() {
        return this.customer_credit_dict.reduce((total, row) => total + this.flt(row.total_credit), 0);
      },
      vaildatPayment() {
        if (this.pos_profile.posa_allow_sales_order) {
          if (this.invoiceType === "Order" && !this.invoice_doc.posa_delivery_date) {
            return true;
          }
        }
        return false;
      },
      request_payment_field() {
        var _a3, _b;
        return ((_b = (_a3 = this.pos_settings) == null ? void 0 : _a3.invoice_fields) == null ? void 0 : _b.some(
          (el) => el.fieldtype === "Button" && el.fieldname === "request_for_payment"
        )) || false;
      },
      isDarkTheme() {
        return this.$theme.current === "dark";
      }
    },
    watch: {
      diff_payment(newVal) {
        if (!this.is_user_editing_paid_change) {
          this.paid_change = -newVal;
        }
      },
      paid_change(newVal) {
        const changeLimit = -this.diff_payment;
        if (newVal > changeLimit) {
          this.paid_change = changeLimit;
          this.credit_change = 0;
          this.paid_change_rules = ["Paid change can not be greater than total change!"];
        } else {
          this.paid_change_rules = [];
          this.credit_change = this.flt(newVal - changeLimit, this.currency_precision);
        }
      },
      loyalty_amount(value) {
        if (value > this.available_points_amount) {
          this.invoice_doc.loyalty_amount = 0;
          this.invoice_doc.redeem_loyalty_points = 0;
          this.invoice_doc.loyalty_points = 0;
          this.loyalty_amount = 0;
          this.eventBus.emit("show_message", {
            title: `Loyalty Amount can not be more than ${this.available_points_amount}`,
            color: "error"
          });
        } else {
          this.invoice_doc.loyalty_amount = this.flt(this.loyalty_amount);
          this.invoice_doc.redeem_loyalty_points = 1;
          this.invoice_doc.loyalty_points = this.flt(this.loyalty_amount) / this.customer_info.conversion_factor;
        }
      },
      redeemed_customer_credit(newVal) {
        if (newVal > this.available_customer_credit) {
          this.redeemed_customer_credit = this.available_customer_credit;
          this.eventBus.emit("show_message", {
            title: `You can redeem customer credit up to ${this.available_customer_credit}`,
            color: "error"
          });
        }
      },
      sales_person(newVal) {
        if (newVal) {
          this.invoice_doc.sales_team = [
            {
              sales_person: newVal,
              allocated_percentage: 100
            }
          ];
          console.log("Updated sales_team with sales_person:", newVal);
        } else {
          this.invoice_doc.sales_team = [];
          console.log("Cleared sales_team");
        }
      },
      is_credit_sale(newVal) {
        if (newVal) {
          this.invoice_doc.payments.forEach((payment) => {
            if (payment.mode_of_payment.toLowerCase() === "cash") {
              payment.amount = 0;
            }
          });
        } else {
          this.invoice_doc.payments.forEach((payment) => {
            if (payment.mode_of_payment.toLowerCase() === "cash") {
              payment.amount = this.invoice_doc.rounded_total || this.invoice_doc.grand_total;
            }
          });
        }
      },
      is_credit_return(newVal) {
        if (newVal) {
          this.is_cashback = false;
          this.invoice_doc.payments.forEach((payment) => {
            payment.amount = 0;
            if (payment.base_amount !== void 0) {
              payment.base_amount = 0;
            }
          });
        } else {
          this.is_cashback = true;
          this.ensureReturnPaymentsAreNegative();
        }
      }
    },
    methods: {
      back_to_invoice() {
        this.eventBus.emit("show_payment", "false");
        this.eventBus.emit("set_customer_readonly", false);
      },
      reset_cash_payments() {
        this.invoice_doc.payments.forEach((payment) => {
          if (payment.mode_of_payment.toLowerCase() === "cash") {
            payment.amount = 0;
          }
        });
      },
      ensureReturnPaymentsAreNegative() {
        if (!this.invoice_doc || !this.invoice_doc.is_return || !this.is_cashback) {
          return;
        }
        let hasPaymentSet = false;
        this.invoice_doc.payments.forEach((payment) => {
          if (Math.abs(payment.amount) > 0) {
            hasPaymentSet = true;
          }
        });
        if (!hasPaymentSet) {
          const default_payment = this.invoice_doc.payments.find((payment) => payment.default === 1);
          if (default_payment) {
            const amount = this.invoice_doc.rounded_total || this.invoice_doc.grand_total;
            default_payment.amount = -Math.abs(amount);
            if (default_payment.base_amount !== void 0) {
              default_payment.base_amount = -Math.abs(amount);
            }
          }
        }
        this.invoice_doc.payments.forEach((payment) => {
          if (payment.amount > 0) {
            payment.amount = -Math.abs(payment.amount);
          }
          if (payment.base_amount !== void 0 && payment.base_amount > 0) {
            payment.base_amount = -Math.abs(payment.base_amount);
          }
        });
      },
      submit(event2, payment_received = false, print = false) {
        if (this.invoice_doc.is_return) {
          this.ensureReturnPaymentsAreNegative();
        }
        if (!this.is_credit_sale && !this.invoice_doc.is_return && this.total_payments <= 0 && (this.invoice_doc.rounded_total || this.invoice_doc.grand_total) > 0) {
          this.eventBus.emit("show_message", {
            title: `Please enter payment amount`,
            color: "error"
          });
          frappe.utils.play_sound("error");
          return;
        }
        if (!this.is_credit_sale && !this.invoice_doc.is_return) {
          let has_cash_payment = false;
          let cash_amount = 0;
          this.invoice_doc.payments.forEach((payment) => {
            if (payment.mode_of_payment.toLowerCase().includes("cash")) {
              has_cash_payment = true;
              cash_amount = this.flt(payment.amount);
            }
          });
          if (has_cash_payment && cash_amount > 0) {
            if (!this.pos_profile.posa_allow_partial_payment && cash_amount < (this.invoice_doc.rounded_total || this.invoice_doc.grand_total) && (this.invoice_doc.rounded_total || this.invoice_doc.grand_total) > 0) {
              this.eventBus.emit("show_message", {
                title: `Cash payment cannot be less than invoice total when partial payment is not allowed`,
                color: "error"
              });
              frappe.utils.play_sound("error");
              return;
            }
          }
        }
        if (!this.is_credit_sale && !this.pos_profile.posa_allow_partial_payment && this.total_payments < (this.invoice_doc.rounded_total || this.invoice_doc.grand_total) && (this.invoice_doc.rounded_total || this.invoice_doc.grand_total) > 0) {
          this.eventBus.emit("show_message", {
            title: `The amount paid is not complete`,
            color: "error"
          });
          frappe.utils.play_sound("error");
          return;
        }
        let phone_payment_is_valid = true;
        if (!payment_received) {
          this.invoice_doc.payments.forEach((payment) => {
            if (payment.type === "Phone" && ![0, "0", "", null, void 0].includes(payment.amount)) {
              phone_payment_is_valid = false;
            }
          });
          if (!phone_payment_is_valid) {
            this.eventBus.emit("show_message", {
              title: __("Please request phone payment or use another payment method"),
              color: "error"
            });
            frappe.utils.play_sound("error");
            return;
          }
        }
        if (this.paid_change > -this.diff_payment) {
          this.eventBus.emit("show_message", {
            title: `Paid change cannot be greater than total change!`,
            color: "error"
          });
          frappe.utils.play_sound("error");
          return;
        }
        let total_change = this.flt(this.flt(this.paid_change) + this.flt(-this.credit_change));
        if (this.is_cashback && total_change !== -this.diff_payment) {
          this.eventBus.emit("show_message", {
            title: `Error in change calculations!`,
            color: "error"
          });
          frappe.utils.play_sound("error");
          return;
        }
        let credit_calc_check = this.customer_credit_dict.filter((row) => {
          return this.flt(row.credit_to_redeem) > this.flt(row.total_credit);
        });
        if (credit_calc_check.length > 0) {
          this.eventBus.emit("show_message", {
            title: `Redeemed credit cannot be greater than its total.`,
            color: "error"
          });
          frappe.utils.play_sound("error");
          return;
        }
        if (!this.invoice_doc.is_return && this.redeemed_customer_credit > (this.invoice_doc.rounded_total || this.invoice_doc.grand_total)) {
          this.eventBus.emit("show_message", {
            title: `Cannot redeem customer credit more than invoice total`,
            color: "error"
          });
          frappe.utils.play_sound("error");
          return;
        }
        this.loading = true;
        this.submit_invoice(print);
      },
      submit_invoice(print) {
        if (this.invoice_doc.is_return) {
          this.ensureReturnPaymentsAreNegative();
        }
        let totalPayedAmount = 0;
        this.invoice_doc.payments.forEach((payment) => {
          payment.amount = this.flt(payment.amount);
          totalPayedAmount += payment.amount;
        });
        if (this.invoice_doc.is_return && totalPayedAmount === 0) {
          this.invoice_doc.is_pos = 0;
        }
        if (this.customer_credit_dict.length) {
          this.customer_credit_dict.forEach((row) => {
            row.credit_to_redeem = this.flt(row.credit_to_redeem);
          });
        }
        let data = {
          total_change: !this.invoice_doc.is_return ? -this.diff_payment : 0,
          paid_change: !this.invoice_doc.is_return ? this.paid_change : 0,
          credit_change: -this.credit_change,
          redeemed_customer_credit: this.redeemed_customer_credit,
          customer_credit_dict: this.customer_credit_dict,
          is_cashback: this.is_cashback
        };
        const vm2 = this;
        if (isOffline()) {
          try {
            saveOfflineInvoice({ data, invoice: this.invoice_doc });
            this.eventBus.emit("pending_invoices_changed", getPendingOfflineInvoiceCount());
            vm2.eventBus.emit("show_message", { title: __("Invoice saved offline"), color: "warning" });
            if (print) {
              this.print_offline_invoice(this.invoice_doc);
            }
            vm2.eventBus.emit("clear_invoice");
            vm2.eventBus.emit("reset_posting_date");
            vm2.back_to_invoice();
            vm2.loading = false;
            return;
          } catch (error) {
            vm2.eventBus.emit("show_message", {
              title: __("Cannot Save Offline Invoice: ") + (error.message || __("Unknown error")),
              color: "error"
            });
            vm2.loading = false;
            return;
          }
        }
        frappe.call({
          method: this.invoiceType === "Order" && this.pos_profile.posa_create_only_sales_order ? "posawesome.posawesome.api.sales_orders.submit_sales_order" : "posawesome.posawesome.api.invoices.submit_invoice",
          args: {
            data,
            invoice: this.invoice_doc,
            order: this.invoice_doc
          },
          callback: function(r) {
            if (r.exc) {
              console.error("Error submitting invoice:", r.exc);
              let errorMsg = r.exc.toString();
              if (errorMsg.includes("Amount must be negative")) {
                vm2.eventBus.emit("show_message", {
                  title: __("Fixing payment amounts for return invoice..."),
                  color: "warning"
                });
                vm2.invoice_doc.payments.forEach((payment) => {
                  if (payment.amount > 0) {
                    payment.amount = -Math.abs(payment.amount);
                  }
                  if (payment.base_amount > 0) {
                    payment.base_amount = -Math.abs(payment.base_amount);
                  }
                });
                console.log("Retrying submission with fixed payment amounts");
                setTimeout(() => {
                  vm2.submit_invoice(print);
                }, 500);
              } else {
                vm2.eventBus.emit("show_message", {
                  title: __("Error submitting invoice: ") + errorMsg,
                  color: "error"
                });
              }
              vm2.loading = false;
              return;
            }
            if (!r.message) {
              vm2.eventBus.emit("show_message", {
                title: __("Error submitting invoice: No response from server"),
                color: "error"
              });
              vm2.loading = false;
              return;
            }
            if (print) {
              vm2.load_print_page();
            }
            vm2.customer_credit_dict = [];
            vm2.redeem_customer_credit = false;
            vm2.is_cashback = true;
            vm2.is_credit_return = false;
            vm2.sales_person = "";
            vm2.eventBus.emit("set_last_invoice", vm2.invoice_doc.name);
            vm2.eventBus.emit("show_message", {
              title: vm2.invoiceType === "Order" && vm2.pos_profile.posa_create_only_sales_order ? __("Sales Order {0} is Submitted", [r.message.name]) : __("Invoice {0} is Submitted", [r.message.name]),
              color: "success"
            });
            frappe.utils.play_sound("submit");
            updateLocalStock(vm2.invoice_doc.items || []);
            vm2.addresses = [];
            vm2.eventBus.emit("clear_invoice");
            vm2.eventBus.emit("reset_posting_date");
            vm2.back_to_invoice();
            vm2.loading = false;
          }
        });
      },
      set_full_amount(idx) {
        var _a3, _b;
        const isReturn = this.invoice_doc.is_return || this.invoiceType === "Return";
        let totalAmount = this.invoice_doc.rounded_total || this.invoice_doc.grand_total;
        console.log("Setting full amount for payment method idx:", idx);
        console.log("Current payments:", JSON.stringify(this.invoice_doc.payments));
        this.invoice_doc.payments.forEach((payment) => {
          payment.amount = 0;
          if (payment.base_amount !== void 0) {
            payment.base_amount = 0;
          }
        });
        const clickedButton = (_b = (_a3 = event == null ? void 0 : event.target) == null ? void 0 : _a3.textContent) == null ? void 0 : _b.trim();
        console.log("Clicked button text:", clickedButton);
        const clickedPayment = this.invoice_doc.payments.find(
          (payment) => payment.mode_of_payment === clickedButton
        );
        if (clickedPayment) {
          console.log("Found clicked payment:", clickedPayment.mode_of_payment);
          let amount = isReturn ? -Math.abs(totalAmount) : totalAmount;
          clickedPayment.amount = amount;
          if (clickedPayment.base_amount !== void 0) {
            clickedPayment.base_amount = isReturn ? -Math.abs(amount) : amount;
          }
          console.log("Set amount for payment:", clickedPayment.mode_of_payment, "amount:", amount);
        } else {
          console.log("No payment found for button text:", clickedButton);
        }
        this.$forceUpdate();
      },
      set_rest_amount(idx) {
        const isReturn = this.invoice_doc.is_return || this.invoiceType === "Return";
        this.invoice_doc.payments.forEach((payment) => {
          if (payment.idx === idx && payment.amount === 0 && this.diff_payment > 0) {
            let amount = this.diff_payment;
            if (isReturn) {
              amount = -Math.abs(amount);
            }
            payment.amount = amount;
            if (payment.base_amount !== void 0) {
              payment.base_amount = isReturn ? -Math.abs(amount) : amount;
            }
          }
        });
      },
      clear_all_amounts() {
        this.invoice_doc.payments.forEach((payment) => {
          payment.amount = 0;
        });
      },
      load_print_page() {
        const print_format = this.pos_profile.print_format_for_online || this.pos_profile.print_format;
        const letter_head = this.pos_profile.letter_head || 0;
        const url = frappe.urllib.get_base_url() + "/printview?doctype=Sales%20Invoice&name=" + this.invoice_doc.name + "&trigger_print=1&format=" + print_format + "&no_letterhead=" + letter_head;
        if (this.pos_profile.posa_silent_print) {
          silentPrint(url);
        } else {
          const printWindow = window.open(url, "Print");
          printWindow.addEventListener(
            "load",
            function() {
              printWindow.print();
            },
            { once: true }
          );
        }
      },
      print_offline_invoice(invoice) {
        if (!invoice)
          return;
        const html = generateOfflineInvoiceHTML(invoice);
        const win = window.open("", "_blank");
        win.document.write(html);
        win.document.close();
        win.focus();
        win.print();
      },
      validate_due_date() {
        const today = frappe.datetime.now_date();
        const new_date = Date.parse(this.invoice_doc.due_date);
        const parse_today = Date.parse(today);
        if (new_date < parse_today) {
          this.invoice_doc.due_date = today;
        }
      },
      shortPay(e) {
        if (e.key.toLowerCase() === "x" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          e.stopPropagation();
          if (this.invoice_doc && this.invoice_doc.payments) {
            this.submit_invoice();
          }
        }
      },
      get_available_credit(use_credit) {
        this.clear_all_amounts();
        if (use_credit) {
          frappe.call("posawesome.posawesome.api.payments.get_available_credit", {
            customer: this.invoice_doc.customer,
            company: this.pos_profile.company
          }).then((r) => {
            const data = r.message;
            if (data.length) {
              const amount = this.invoice_doc.rounded_total || this.invoice_doc.grand_total;
              let remainAmount = amount;
              data.forEach((row) => {
                if (remainAmount > 0) {
                  if (remainAmount >= row.total_credit) {
                    row.credit_to_redeem = row.total_credit;
                    remainAmount -= row.total_credit;
                  } else {
                    row.credit_to_redeem = remainAmount;
                    remainAmount = 0;
                  }
                } else {
                  row.credit_to_redeem = 0;
                }
              });
              this.customer_credit_dict = data;
            } else {
              this.customer_credit_dict = [];
            }
          });
        } else {
          this.customer_credit_dict = [];
        }
      },
      get_addresses() {
        const vm2 = this;
        if (!vm2.invoice_doc || !vm2.invoice_doc.customer) {
          vm2.addresses = [];
          return;
        }
        frappe.call({
          method: "posawesome.posawesome.api.customers.get_customer_addresses",
          args: { customer: vm2.invoice_doc.customer },
          async: true,
          callback: function(r) {
            if (!r.exc) {
              vm2.addresses = r.message;
            } else {
              vm2.addresses = [];
            }
          }
        });
      },
      addressFilter(item, queryText, itemText) {
        const searchText = queryText.toLowerCase();
        return item.address_title && item.address_title.toLowerCase().includes(searchText) || item.address_line1 && item.address_line1.toLowerCase().includes(searchText) || item.address_line2 && item.address_line2.toLowerCase().includes(searchText) || item.city && item.city.toLowerCase().includes(searchText) || item.name && item.name.toLowerCase().includes(searchText);
      },
      new_address() {
        if (!this.invoice_doc || !this.invoice_doc.customer) {
          this.eventBus.emit("show_message", {
            title: __("Please select a customer first"),
            color: "error"
          });
          return;
        }
        this.eventBus.emit("open_new_address", this.invoice_doc.customer);
      },
      get_sales_person_names() {
        const vm2 = this;
        if (vm2.pos_profile.posa_local_storage && getSalesPersonsStorage().length) {
          try {
            vm2.sales_persons = getSalesPersonsStorage();
          } catch (e) {
          }
        }
        frappe.call({
          method: "posawesome.posawesome.api.utilities.get_sales_person_names",
          callback: function(r) {
            if (r.message && r.message.length > 0) {
              vm2.sales_persons = r.message.map((sp) => ({
                value: sp.name,
                title: sp.sales_person_name,
                sales_person_name: sp.sales_person_name,
                name: sp.name
              }));
              if (vm2.pos_profile.posa_local_storage) {
                setSalesPersonsStorage(vm2.sales_persons);
              }
            } else {
              vm2.sales_persons = [];
            }
          }
        });
      },
      request_payment(payment) {
        this.phone_dialog = false;
        const vm2 = this;
        if (!this.invoice_doc.contact_mobile) {
          this.eventBus.emit("show_message", {
            title: __("Please set the customer's mobile number"),
            color: "error"
          });
          this.eventBus.emit("open_edit_customer");
          this.back_to_invoice();
          return;
        }
        this.eventBus.emit("freeze", { title: __("Waiting for payment...") });
        this.invoice_doc.payments.forEach((payment2) => {
          payment2.amount = this.flt(payment2.amount);
        });
        let formData = __spreadValues({}, this.invoice_doc);
        formData["total_change"] = !this.invoice_doc.is_return ? -this.diff_payment : 0;
        formData["paid_change"] = !this.invoice_doc.is_return ? this.paid_change : 0;
        formData["credit_change"] = -this.credit_change;
        formData["redeemed_customer_credit"] = this.redeemed_customer_credit;
        formData["customer_credit_dict"] = this.customer_credit_dict;
        formData["is_cashback"] = this.is_cashback;
        frappe.call({
          method: "posawesome.posawesome.api.invoices.update_invoice",
          args: { data: formData },
          async: false,
          callback: function(r) {
            if (r.message) {
              vm2.invoice_doc = r.message;
            }
          }
        }).then(() => {
          frappe.call({
            method: "posawesome.posawesome.api.payments.create_payment_request",
            args: { doc: vm2.invoice_doc }
          }).fail(() => {
            vm2.eventBus.emit("unfreeze");
            vm2.eventBus.emit("show_message", {
              title: __("Payment request failed"),
              color: "error"
            });
          }).then(({ message: message2 }) => {
            const payment_request_name = message2.name;
            setTimeout(() => {
              frappe.db.get_value("Payment Request", payment_request_name, ["status", "grand_total"]).then(({ message: message3 }) => {
                if (message3.status !== "Paid") {
                  vm2.eventBus.emit("unfreeze");
                  vm2.eventBus.emit("show_message", {
                    title: __("Payment Request took too long to respond. Please try requesting for payment again"),
                    color: "error"
                  });
                } else {
                  vm2.eventBus.emit("unfreeze");
                  vm2.eventBus.emit("show_message", {
                    title: __("Payment of {0} received successfully.", [
                      vm2.formatCurrency(message3.grand_total, vm2.invoice_doc.currency, 0)
                    ]),
                    color: "success"
                  });
                  frappe.db.get_doc("Sales Invoice", vm2.invoice_doc.name).then((doc2) => {
                    vm2.invoice_doc = doc2;
                    vm2.submit(null, true);
                  });
                }
              });
            }, 3e4);
          });
        });
      },
      get_mpesa_modes() {
        const vm2 = this;
        frappe.call({
          method: "posawesome.posawesome.api.m_pesa.get_mpesa_mode_of_payment",
          args: { company: vm2.pos_profile.company },
          async: true,
          callback: function(r) {
            if (!r.exc) {
              vm2.mpesa_modes = r.message;
            } else {
              vm2.mpesa_modes = [];
            }
          }
        });
      },
      is_mpesa_c2b_payment(payment) {
        if (this.mpesa_modes.includes(payment.mode_of_payment) && payment.type === "Bank") {
          payment.amount = 0;
          return true;
        } else {
          return false;
        }
      },
      mpesa_c2b_dialog(payment) {
        const data = {
          company: this.pos_profile.company,
          mode_of_payment: payment.mode_of_payment,
          customer: this.invoice_doc.customer
        };
        this.eventBus.emit("open_mpesa_payments", data);
      },
      set_mpesa_payment(payment) {
        this.pos_profile.use_customer_credit = true;
        this.redeem_customer_credit = true;
        const invoiceAmount = this.invoice_doc.rounded_total || this.invoice_doc.grand_total;
        let amount = payment.unallocated_amount > invoiceAmount ? invoiceAmount : payment.unallocated_amount;
        amount = amount > 0 ? amount : 0;
        const advance = {
          type: "Advance",
          credit_origin: payment.name,
          total_credit: this.flt(payment.unallocated_amount),
          credit_to_redeem: this.flt(amount)
        };
        this.clear_all_amounts();
        this.customer_credit_dict.push(advance);
      },
      update_delivery_date() {
        this.invoice_doc.posa_delivery_date = this.formatDate(this.new_delivery_date);
        if (this.invoice_doc.customer && (!this.addresses || this.addresses.length === 0)) {
          this.get_addresses();
        }
      },
      update_po_date() {
        this.invoice_doc.po_date = this.formatDate(this.new_po_date);
      },
      update_credit_due_date() {
        this.invoice_doc.due_date = this.formatDate(this.new_credit_due_date);
      },
      applyDuePreset(days) {
        if (days === null || days === "" || isNaN(days)) {
          return;
        }
        const d = new Date();
        d.setDate(d.getDate() + parseInt(days, 10));
        this.new_credit_due_date = this.formatDateDisplay(d);
        this.credit_due_days = parseInt(days, 10);
        this.update_credit_due_date();
      },
      applyCustomDays() {
        this.applyDuePreset(this.custom_days_value);
        this.custom_days_dialog = false;
      },
      formatDate(date2) {
        if (!date2)
          return null;
        if (typeof date2 === "string") {
          if (/^\d{4}-\d{2}-\d{2}$/.test(date2)) {
            return date2;
          }
          if (/^\d{1,2}-\d{1,2}-\d{4}$/.test(date2)) {
            const [d2, m, y] = date2.split("-");
            return `${y}-${m.padStart(2, "0")}-${d2.padStart(2, "0")}`;
          }
        }
        const d = new Date(date2);
        if (!isNaN(d.getTime())) {
          const year = d.getFullYear();
          const month = `0${d.getMonth() + 1}`.slice(-2);
          const day = `0${d.getDate()}`.slice(-2);
          return `${year}-${month}-${day}`;
        }
        return date2;
      },
      formatDateDisplay(date2) {
        if (!date2)
          return "";
        if (typeof date2 === "string" && /^\d{4}-\d{2}-\d{2}$/.test(date2)) {
          const [y, m, d2] = date2.split("-");
          return `${d2}-${m}-${y}`;
        }
        const d = new Date(date2);
        if (!isNaN(d.getTime())) {
          const year = d.getFullYear();
          const month = `0${d.getMonth() + 1}`.slice(-2);
          const day = `0${d.getDate()}`.slice(-2);
          return `${day}-${month}-${year}`;
        }
        return date2;
      },
      showPaidAmount() {
        this.eventBus.emit("show_message", {
          title: `Total Paid Amount: ${this.formatCurrency(this.total_payments)}`,
          color: "info"
        });
      },
      showDiffPayment() {
        if (!this.invoice_doc)
          return;
        this.eventBus.emit("show_message", {
          title: `To Be Paid: ${this.formatCurrency(this.diff_payment)}`,
          color: "info"
        });
      },
      showPaidChange() {
        this.eventBus.emit("show_message", {
          title: `Paid Change: ${this.formatCurrency(this.paid_change)}`,
          color: "info"
        });
      },
      showCreditChange(value) {
        if (value > 0) {
          this.credit_change = value;
          this.paid_change = -this.diff_payment;
        } else {
          this.credit_change = 0;
        }
      },
      formatCurrency(value) {
        return this.$options.mixins[0].methods.formatCurrency.call(this, value, this.currency_precision);
      },
      get_change_amount() {
        return Math.max(0, this.total_payments - this.invoice_doc.grand_total);
      },
      async syncPendingInvoices() {
        const pending = getPendingOfflineInvoiceCount();
        if (pending) {
          this.eventBus.emit("show_message", {
            title: `${pending} invoice${pending > 1 ? "s" : ""} pending for sync`,
            color: "warning"
          });
          this.eventBus.emit("pending_invoices_changed", pending);
        }
        if (isOffline()) {
          return;
        }
        const result = await syncOfflineInvoices();
        if (result && (result.synced || result.drafted)) {
          if (result.synced) {
            this.eventBus.emit("show_message", {
              title: `${result.synced} offline invoice${result.synced > 1 ? "s" : ""} synced`,
              color: "success"
            });
          }
          if (result.drafted) {
            this.eventBus.emit("show_message", {
              title: `${result.drafted} offline invoice${result.drafted > 1 ? "s" : ""} saved as draft`,
              color: "warning"
            });
          }
        }
        this.eventBus.emit("pending_invoices_changed", getPendingOfflineInvoiceCount());
      }
    },
    created() {
      document.addEventListener("keydown", this.shortPay.bind(this));
      this.syncPendingInvoices();
      this.eventBus.on("network-online", this.syncPendingInvoices);
      this.eventBus.on("server-online", this.syncPendingInvoices);
    },
    mounted() {
      this.$nextTick(() => {
        this.eventBus.on("send_invoice_doc_payment", (invoice_doc) => {
          this.invoice_doc = invoice_doc;
          const default_payment = this.invoice_doc.payments.find(
            (payment) => payment.default === 1
          );
          this.is_credit_sale = false;
          this.is_write_off_change = false;
          if (invoice_doc.is_return) {
            this.is_return = true;
            this.is_credit_return = false;
            invoice_doc.payments.forEach((payment) => {
              payment.amount = 0;
              payment.base_amount = 0;
            });
            if (default_payment) {
              const amount = invoice_doc.rounded_total || invoice_doc.grand_total;
              default_payment.amount = -Math.abs(amount);
              if (default_payment.base_amount !== void 0) {
                default_payment.base_amount = -Math.abs(amount);
              }
            }
          } else if (default_payment) {
            default_payment.amount = this.flt(
              invoice_doc.rounded_total || invoice_doc.grand_total,
              this.currency_precision
            );
            this.is_credit_return = false;
          }
          this.loyalty_amount = 0;
          this.redeemed_customer_credit = 0;
          if (invoice_doc.customer) {
            this.get_addresses();
          }
          this.get_sales_person_names();
        });
        this.eventBus.on("register_pos_profile", (data) => {
          this.pos_profile = data.pos_profile;
          this.get_mpesa_modes();
        });
        this.eventBus.on("add_the_new_address", (data) => {
          this.addresses.push(data);
          this.$forceUpdate();
        });
        this.eventBus.on("update_invoice_type", (data) => {
          this.invoiceType = data;
          if (this.invoice_doc && data !== "Order") {
            this.invoice_doc.posa_delivery_date = null;
            this.invoice_doc.posa_notes = null;
            this.invoice_doc.shipping_address_name = null;
          } else if (this.invoice_doc && data === "Order") {
            this.new_delivery_date = this.formatDateDisplay(frappe.datetime.now_date());
            this.update_delivery_date();
          }
          if (this.invoice_doc && data === "Return") {
            this.invoice_doc.is_return = 1;
            this.ensureReturnPaymentsAreNegative();
            this.is_credit_return = false;
          }
        });
        this.eventBus.on("update_customer", (customer) => {
          if (this.customer !== customer) {
            this.customer_credit_dict = [];
            this.redeem_customer_credit = false;
            this.is_cashback = true;
            this.is_credit_return = false;
          }
        });
        this.eventBus.on("set_pos_settings", (data) => {
          this.pos_settings = data;
        });
        this.eventBus.on("set_customer_info_to_edit", (data) => {
          this.customer_info = data;
        });
        this.eventBus.on("set_mpesa_payment", (data) => {
          this.set_mpesa_payment(data);
        });
        this.eventBus.on("clear_invoice", () => {
          this.invoice_doc = "";
          this.is_return = false;
          this.is_credit_return = false;
        });
      });
    },
    beforeUnmount() {
      this.eventBus.off("send_invoice_doc_payment");
      this.eventBus.off("register_pos_profile");
      this.eventBus.off("add_the_new_address");
      this.eventBus.off("update_invoice_type");
      this.eventBus.off("update_customer");
      this.eventBus.off("set_pos_settings");
      this.eventBus.off("set_customer_info_to_edit");
      this.eventBus.off("set_mpesa_payment");
      this.eventBus.off("clear_invoice");
      this.eventBus.off("network-online", this.syncPendingInvoices);
      this.eventBus.off("server-online", this.syncPendingInvoices);
    },
    unmounted() {
      document.removeEventListener("keydown", this.shortPay);
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/Payments.vue?type=template
  var _hoisted_130 = { class: "pa-0" };
  var _hoisted_217 = {
    class: "overflow-y-auto px-2 pt-2",
    style: { "max-height": "67vh" }
  };
  var _hoisted_315 = { key: 1 };
  var _hoisted_412 = ["innerHTML"];
  var _hoisted_510 = ["innerHTML"];
  var _hoisted_610 = ["innerHTML"];
  var _hoisted_79 = ["innerHTML"];
  var _hoisted_87 = ["innerHTML"];
  var _hoisted_97 = ["innerHTML"];
  var _hoisted_106 = ["innerHTML"];
  var _hoisted_1111 = ["innerHTML"];
  var _hoisted_1210 = { key: 4 };
  var _hoisted_137 = { class: "mt-1" };
  var _hoisted_145 = { key: 5 };
  var _hoisted_155 = { class: "pa-2 py-3" };
  var _hoisted_165 = {
    key: 0,
    class: "mt-1 mb-1 text-subtitle-2"
  };
  var _hoisted_175 = {
    key: 1,
    class: "mt-1 mb-1 text-subtitle-2 text-red"
  };
  var _hoisted_185 = { class: "text-h5 text-primary" };
  function render22(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_progress_linear = resolveComponent("v-progress-linear");
    const _component_v_text_field = resolveComponent("v-text-field");
    const _component_v_col = resolveComponent("v-col");
    const _component_v_row = resolveComponent("v-row");
    const _component_v_divider = resolveComponent("v-divider");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_VueDatePicker = resolveComponent("VueDatePicker");
    const _component_v_list_item_title = resolveComponent("v-list-item-title");
    const _component_v_list_item_subtitle = resolveComponent("v-list-item-subtitle");
    const _component_v_list_item_content = resolveComponent("v-list-item-content");
    const _component_v_list_item = resolveComponent("v-list-item");
    const _component_v_autocomplete = resolveComponent("v-autocomplete");
    const _component_v_textarea = resolveComponent("v-textarea");
    const _component_v_switch = resolveComponent("v-switch");
    const _component_v_chip = resolveComponent("v-chip");
    const _component_v_select = resolveComponent("v-select");
    const _component_v_card = resolveComponent("v-card");
    const _component_v_card_title = resolveComponent("v-card-title");
    const _component_v_container = resolveComponent("v-container");
    const _component_v_card_text = resolveComponent("v-card-text");
    const _component_v_spacer = resolveComponent("v-spacer");
    const _component_v_card_actions = resolveComponent("v-card-actions");
    const _component_v_dialog = resolveComponent("v-dialog");
    return openBlock(), createElementBlock("div", _hoisted_130, [
      createVNode(_component_v_card, {
        class: normalizeClass(["selection mx-auto pa-1 my-0 py-0 mt-3", $options.isDarkTheme ? "" : "bg-grey-lighten-5"]),
        style: normalizeStyle([$options.isDarkTheme ? "background-color:#1E1E1E" : "", { "max-height": "68vh", "height": "68vh" }])
      }, {
        default: withCtx(() => [
          createVNode(_component_v_progress_linear, {
            active: $data.loading,
            indeterminate: $data.loading,
            absolute: "",
            location: "top",
            color: "info"
          }, null, 8, ["active", "indeterminate"]),
          createBaseVNode("div", _hoisted_217, [
            createCommentVNode(" Payment Summary (Paid, To Be Paid, Change) "),
            $data.invoice_doc ? (openBlock(), createBlock(_component_v_row, {
              key: 0,
              class: "px-1 py-0",
              dense: ""
            }, {
              default: withCtx(() => [
                createVNode(_component_v_col, { cols: "7" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_text_field, {
                      variant: "outlined",
                      color: "primary",
                      label: _ctx.frappe._("Paid Amount"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "hide-details": "",
                      modelValue: $options.total_payments_display,
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $options.total_payments_display = $event),
                      readonly: "",
                      prefix: $options.currencySymbol($data.invoice_doc.currency),
                      density: "compact",
                      onClick: $options.showPaidAmount
                    }, null, 8, ["label", "bg-color", "modelValue", "prefix", "onClick"])
                  ]),
                  _: 1
                }),
                createVNode(_component_v_col, { cols: "5" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_text_field, {
                      variant: "outlined",
                      color: "primary",
                      label: "To Be Paid",
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "hide-details": "",
                      modelValue: $options.diff_payment_display,
                      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $options.diff_payment_display = $event),
                      prefix: $options.currencySymbol($data.invoice_doc.currency),
                      density: "compact",
                      onFocus: $options.showDiffPayment,
                      "persistent-placeholder": ""
                    }, null, 8, ["bg-color", "modelValue", "prefix", "onFocus"])
                  ]),
                  _: 1
                }),
                createCommentVNode(" Paid Change (if applicable) "),
                $options.credit_change > 0 && !$data.invoice_doc.is_return ? (openBlock(), createBlock(_component_v_col, {
                  key: 0,
                  cols: "7"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_v_text_field, {
                      variant: "outlined",
                      color: "primary",
                      label: _ctx.frappe._("Paid Change"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "model-value": $options.formatCurrency($data.paid_change),
                      prefix: $options.currencySymbol($data.invoice_doc.currency),
                      rules: $data.paid_change_rules,
                      density: "compact",
                      readonly: "",
                      type: "text",
                      onClick: $options.showPaidChange
                    }, null, 8, ["label", "bg-color", "model-value", "prefix", "rules", "onClick"])
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true),
                createCommentVNode(" Credit Change (if applicable) "),
                $options.credit_change > 0 && !$data.invoice_doc.is_return ? (openBlock(), createBlock(_component_v_col, {
                  key: 1,
                  cols: "5"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_v_text_field, {
                      variant: "outlined",
                      color: "primary",
                      label: _ctx.frappe._("Credit Change"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "model-value": $options.formatCurrency($options.credit_change),
                      prefix: $options.currencySymbol($data.invoice_doc.currency),
                      density: "compact",
                      type: "text",
                      onChange: _cache[2] || (_cache[2] = ($event) => {
                        _ctx.setFormatedCurrency(this, "credit_change", null, false, $event);
                        _ctx.updateCreditChange(this.credit_change);
                      })
                    }, null, 8, ["label", "bg-color", "model-value", "prefix"])
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true)
              ]),
              _: 1
            })) : createCommentVNode("v-if", true),
            createVNode(_component_v_divider),
            createCommentVNode(" Payment Inputs (All Payment Methods) "),
            $data.is_cashback ? (openBlock(), createElementBlock("div", _hoisted_315, [
              (openBlock(true), createElementBlock(Fragment, null, renderList($data.invoice_doc.payments, (payment, index) => {
                return openBlock(), createBlock(_component_v_row, {
                  class: "payments px-1 py-0",
                  key: payment.name
                }, {
                  default: withCtx(() => [
                    !$options.is_mpesa_c2b_payment(payment) ? (openBlock(), createBlock(_component_v_col, {
                      key: 0,
                      cols: "6"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_v_text_field, {
                          density: "compact",
                          variant: "outlined",
                          color: "primary",
                          label: _ctx.frappe._(payment.mode_of_payment),
                          "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                          class: "dark-field",
                          "hide-details": "",
                          "model-value": $options.formatCurrency(payment.amount),
                          onChange: ($event) => _ctx.setFormatedCurrency(payment, "amount", null, false, $event),
                          rules: [
                            _ctx.isNumber,
                            (v) => !payment.mode_of_payment.toLowerCase().includes("cash") || this.is_credit_sale || v >= (this.invoice_doc.rounded_total || this.invoice_doc.grand_total) || "Cash payment cannot be less than invoice total when credit sale is off"
                          ],
                          prefix: $options.currencySymbol($data.invoice_doc.currency),
                          onFocus: ($event) => $options.set_rest_amount(payment.idx),
                          readonly: $data.invoice_doc.is_return
                        }, null, 8, ["label", "bg-color", "model-value", "onChange", "rules", "prefix", "onFocus", "readonly"])
                      ]),
                      _: 2
                    }, 1024)) : createCommentVNode("v-if", true),
                    !$options.is_mpesa_c2b_payment(payment) ? (openBlock(), createBlock(_component_v_col, {
                      key: 1,
                      cols: "6"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_v_btn, {
                          block: "",
                          color: "primary",
                          theme: "dark",
                          onClick: ($event) => $options.set_full_amount(payment.idx)
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(payment.mode_of_payment), 1)
                          ]),
                          _: 2
                        }, 1032, ["onClick"])
                      ]),
                      _: 2
                    }, 1024)) : createCommentVNode("v-if", true),
                    createCommentVNode(" M-Pesa Payment Button (if payment is M-Pesa) "),
                    $options.is_mpesa_c2b_payment(payment) ? (openBlock(), createBlock(_component_v_col, {
                      key: 2,
                      cols: "12",
                      class: "pl-3"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_v_btn, {
                          block: "",
                          color: "success",
                          theme: "dark",
                          onClick: ($event) => $options.mpesa_c2b_dialog(payment)
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(_ctx.__("Get Payments")) + " " + toDisplayString(payment.mode_of_payment), 1)
                          ]),
                          _: 2
                        }, 1032, ["onClick"])
                      ]),
                      _: 2
                    }, 1024)) : createCommentVNode("v-if", true),
                    createCommentVNode(" Request Payment for Phone Type "),
                    payment.type === "Phone" && payment.amount > 0 && $options.request_payment_field ? (openBlock(), createBlock(_component_v_col, {
                      key: 3,
                      cols: "3",
                      class: "pl-1"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_v_btn, {
                          block: "",
                          color: "success",
                          theme: "dark",
                          disabled: payment.amount === 0,
                          onClick: ($event) => $options.request_payment(payment)
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(_ctx.__("Request")), 1)
                          ]),
                          _: 2
                        }, 1032, ["disabled", "onClick"])
                      ]),
                      _: 2
                    }, 1024)) : createCommentVNode("v-if", true)
                  ]),
                  _: 2
                }, 1024);
              }), 128))
            ])) : createCommentVNode("v-if", true),
            createCommentVNode(" Loyalty Points Redemption "),
            $data.invoice_doc && $options.available_points_amount > 0 && !$data.invoice_doc.is_return ? (openBlock(), createBlock(_component_v_row, {
              key: 2,
              class: "payments px-1 py-0"
            }, {
              default: withCtx(() => [
                createVNode(_component_v_col, { cols: "7" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      variant: "outlined",
                      color: "primary",
                      label: _ctx.frappe._("Redeem Loyalty Points"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "hide-details": "",
                      "model-value": $options.formatCurrency($data.loyalty_amount),
                      type: "text",
                      onChange: _cache[3] || (_cache[3] = ($event) => _ctx.setFormatedCurrency(this, "loyalty_amount", null, false, $event)),
                      prefix: $options.currencySymbol($data.invoice_doc.currency)
                    }, null, 8, ["label", "bg-color", "model-value", "prefix"])
                  ]),
                  _: 1
                }),
                createVNode(_component_v_col, { cols: "5" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      variant: "outlined",
                      color: "primary",
                      label: _ctx.frappe._("You can redeem up to"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "hide-details": "",
                      value: _ctx.formatFloat($options.available_points_amount),
                      prefix: $options.currencySymbol($data.invoice_doc.currency),
                      readonly: ""
                    }, null, 8, ["label", "bg-color", "value", "prefix"])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })) : createCommentVNode("v-if", true),
            createCommentVNode(" Customer Credit Redemption "),
            $data.invoice_doc && $options.available_customer_credit > 0 && !$data.invoice_doc.is_return && $data.redeem_customer_credit ? (openBlock(), createBlock(_component_v_row, {
              key: 3,
              class: "payments px-1 py-0"
            }, {
              default: withCtx(() => [
                createVNode(_component_v_col, { cols: "7" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      variant: "outlined",
                      color: "primary",
                      label: _ctx.frappe._("Redeemed Customer Credit"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "hide-details": "",
                      "model-value": $options.formatCurrency($data.redeemed_customer_credit),
                      type: "text",
                      onChange: _cache[4] || (_cache[4] = ($event) => _ctx.setFormatedCurrency(this, "redeemed_customer_credit", null, false, $event)),
                      prefix: $options.currencySymbol($data.invoice_doc.currency),
                      readonly: ""
                    }, null, 8, ["label", "bg-color", "model-value", "prefix"])
                  ]),
                  _: 1
                }),
                createVNode(_component_v_col, { cols: "5" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      variant: "outlined",
                      color: "primary",
                      label: _ctx.frappe._("You can redeem credit up to"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "hide-details": "",
                      value: $options.formatCurrency($options.available_customer_credit),
                      prefix: $options.currencySymbol($data.invoice_doc.currency),
                      readonly: ""
                    }, null, 8, ["label", "bg-color", "value", "prefix"])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })) : createCommentVNode("v-if", true),
            createVNode(_component_v_divider),
            createCommentVNode(" Invoice Totals (Net, Tax, Total, Discount, Grand, Rounded) "),
            createVNode(_component_v_row, { class: "px-1 py-0" }, {
              default: withCtx(() => [
                createVNode(_component_v_col, { cols: "6" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      variant: "outlined",
                      color: "primary",
                      label: _ctx.frappe._("Net Total"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      value: $options.formatCurrency($data.invoice_doc.net_total, $options.displayCurrency),
                      readonly: "",
                      prefix: $options.currencySymbol(),
                      "persistent-placeholder": ""
                    }, null, 8, ["label", "bg-color", "value", "prefix"])
                  ]),
                  _: 1
                }),
                createVNode(_component_v_col, { cols: "6" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      variant: "outlined",
                      color: "primary",
                      label: _ctx.frappe._("Tax and Charges"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "hide-details": "",
                      value: $options.formatCurrency($data.invoice_doc.total_taxes_and_charges, $options.displayCurrency),
                      readonly: "",
                      prefix: $options.currencySymbol(),
                      "persistent-placeholder": ""
                    }, null, 8, ["label", "bg-color", "value", "prefix"])
                  ]),
                  _: 1
                }),
                createVNode(_component_v_col, { cols: "6" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      variant: "outlined",
                      color: "primary",
                      label: _ctx.frappe._("Total Amount"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "hide-details": "",
                      value: $options.formatCurrency($data.invoice_doc.total, $options.displayCurrency),
                      readonly: "",
                      prefix: $options.currencySymbol(),
                      "persistent-placeholder": ""
                    }, null, 8, ["label", "bg-color", "value", "prefix"])
                  ]),
                  _: 1
                }),
                createVNode(_component_v_col, { cols: "6" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      variant: "outlined",
                      color: "primary",
                      label: $options.diff_label,
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "hide-details": "",
                      value: $options.formatCurrency($options.diff_payment, $options.displayCurrency),
                      readonly: "",
                      prefix: $options.currencySymbol(),
                      "persistent-placeholder": ""
                    }, null, 8, ["label", "bg-color", "value", "prefix"])
                  ]),
                  _: 1
                }),
                createVNode(_component_v_col, { cols: "6" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      variant: "outlined",
                      color: "primary",
                      label: _ctx.frappe._("Discount Amount"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "hide-details": "",
                      value: $options.formatCurrency($data.invoice_doc.discount_amount),
                      readonly: "",
                      prefix: $options.currencySymbol($data.invoice_doc.currency),
                      "persistent-placeholder": ""
                    }, null, 8, ["label", "bg-color", "value", "prefix"])
                  ]),
                  _: 1
                }),
                createVNode(_component_v_col, { cols: "6" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      variant: "outlined",
                      color: "primary",
                      label: _ctx.frappe._("Grand Total"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "hide-details": "",
                      value: $options.formatCurrency($data.invoice_doc.grand_total),
                      readonly: "",
                      prefix: $options.currencySymbol($data.invoice_doc.currency),
                      "persistent-placeholder": ""
                    }, null, 8, ["label", "bg-color", "value", "prefix"])
                  ]),
                  _: 1
                }),
                $data.invoice_doc.rounded_total ? (openBlock(), createBlock(_component_v_col, {
                  key: 0,
                  cols: "6"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_v_text_field, {
                      density: "compact",
                      variant: "outlined",
                      color: "primary",
                      label: _ctx.frappe._("Rounded Total"),
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "hide-details": "",
                      value: $options.formatCurrency($data.invoice_doc.rounded_total),
                      readonly: "",
                      prefix: $options.currencySymbol($data.invoice_doc.currency),
                      "persistent-placeholder": ""
                    }, null, 8, ["label", "bg-color", "value", "prefix"])
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true),
                createCommentVNode(" Delivery Date and Address (if applicable) "),
                $data.pos_profile.posa_allow_sales_order && $data.invoiceType === "Order" ? (openBlock(), createBlock(_component_v_col, {
                  key: 1,
                  cols: "6"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_VueDatePicker, {
                      modelValue: $data.new_delivery_date,
                      "onUpdate:modelValue": [
                        _cache[5] || (_cache[5] = ($event) => $data.new_delivery_date = $event),
                        _cache[6] || (_cache[6] = ($event) => $options.update_delivery_date())
                      ],
                      "model-type": "format",
                      format: "dd-MM-yyyy",
                      "min-date": new Date(),
                      "auto-apply": "",
                      dark: $options.isDarkTheme
                    }, null, 8, ["modelValue", "min-date", "dark"])
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true),
                createCommentVNode(" Shipping Address Selection (if delivery date is set) "),
                $data.invoice_doc.posa_delivery_date ? (openBlock(), createBlock(_component_v_col, {
                  key: 2,
                  cols: "12"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_v_autocomplete, {
                      density: "compact",
                      clearable: "",
                      "auto-select-first": "",
                      variant: "outlined",
                      color: "primary",
                      label: _ctx.frappe._("Address"),
                      modelValue: $data.invoice_doc.shipping_address_name,
                      "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => $data.invoice_doc.shipping_address_name = $event),
                      items: $data.addresses,
                      "item-title": "address_title",
                      "item-value": "name",
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "no-data-text": "Address not found",
                      "hide-details": "",
                      customFilter: $options.addressFilter,
                      "append-icon": "mdi-plus",
                      "onClick:append": $options.new_address
                    }, {
                      item: withCtx(({ item }) => [
                        createVNode(_component_v_list_item, null, {
                          default: withCtx(() => [
                            createVNode(_component_v_list_item_content, null, {
                              default: withCtx(() => [
                                createVNode(_component_v_list_item_title, { class: "text-primary text-subtitle-1" }, {
                                  default: withCtx(() => [
                                    createBaseVNode("div", {
                                      innerHTML: item.address_title
                                    }, null, 8, _hoisted_412)
                                  ]),
                                  _: 2
                                }, 1024),
                                createVNode(_component_v_list_item_subtitle, null, {
                                  default: withCtx(() => [
                                    createBaseVNode("div", {
                                      innerHTML: item.address_line1
                                    }, null, 8, _hoisted_510)
                                  ]),
                                  _: 2
                                }, 1024),
                                item.address_line2 ? (openBlock(), createBlock(_component_v_list_item_subtitle, { key: 0 }, {
                                  default: withCtx(() => [
                                    createBaseVNode("div", {
                                      innerHTML: item.address_line2
                                    }, null, 8, _hoisted_610)
                                  ]),
                                  _: 2
                                }, 1024)) : createCommentVNode("v-if", true),
                                item.city ? (openBlock(), createBlock(_component_v_list_item_subtitle, { key: 1 }, {
                                  default: withCtx(() => [
                                    createBaseVNode("div", {
                                      innerHTML: item.city
                                    }, null, 8, _hoisted_79)
                                  ]),
                                  _: 2
                                }, 1024)) : createCommentVNode("v-if", true),
                                item.state ? (openBlock(), createBlock(_component_v_list_item_subtitle, { key: 2 }, {
                                  default: withCtx(() => [
                                    createBaseVNode("div", {
                                      innerHTML: item.state
                                    }, null, 8, _hoisted_87)
                                  ]),
                                  _: 2
                                }, 1024)) : createCommentVNode("v-if", true),
                                item.country ? (openBlock(), createBlock(_component_v_list_item_subtitle, { key: 3 }, {
                                  default: withCtx(() => [
                                    createBaseVNode("div", {
                                      innerHTML: item.country
                                    }, null, 8, _hoisted_97)
                                  ]),
                                  _: 2
                                }, 1024)) : createCommentVNode("v-if", true),
                                item.mobile_no ? (openBlock(), createBlock(_component_v_list_item_subtitle, { key: 4 }, {
                                  default: withCtx(() => [
                                    createBaseVNode("div", {
                                      innerHTML: item.mobile_no
                                    }, null, 8, _hoisted_106)
                                  ]),
                                  _: 2
                                }, 1024)) : createCommentVNode("v-if", true),
                                item.address_type ? (openBlock(), createBlock(_component_v_list_item_subtitle, { key: 5 }, {
                                  default: withCtx(() => [
                                    createBaseVNode("div", {
                                      innerHTML: item.address_type
                                    }, null, 8, _hoisted_1111)
                                  ]),
                                  _: 2
                                }, 1024)) : createCommentVNode("v-if", true)
                              ]),
                              _: 2
                            }, 1024)
                          ]),
                          _: 2
                        }, 1024)
                      ]),
                      _: 1
                    }, 8, ["label", "modelValue", "items", "bg-color", "customFilter", "onClick:append"])
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true),
                createCommentVNode(" Additional Notes (if enabled in POS profile) "),
                $data.pos_profile.posa_display_additional_notes ? (openBlock(), createBlock(_component_v_col, {
                  key: 3,
                  cols: "12"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_v_textarea, {
                      class: "pa-0 dark-field",
                      variant: "outlined",
                      density: "compact",
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      clearable: "",
                      color: "primary",
                      "auto-grow": "",
                      rows: "2",
                      label: _ctx.frappe._("Additional Notes"),
                      modelValue: $data.invoice_doc.posa_notes,
                      "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => $data.invoice_doc.posa_notes = $event)
                    }, null, 8, ["bg-color", "label", "modelValue"])
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true)
              ]),
              _: 1
            }),
            createCommentVNode(" Customer Purchase Order (if enabled in POS profile) "),
            $data.pos_profile.posa_allow_customer_purchase_order ? (openBlock(), createElementBlock("div", _hoisted_1210, [
              createVNode(_component_v_divider),
              createVNode(_component_v_row, {
                class: "px-1 py-0",
                justify: "center",
                align: "start"
              }, {
                default: withCtx(() => [
                  createVNode(_component_v_col, { cols: "6" }, {
                    default: withCtx(() => [
                      createVNode(_component_v_text_field, {
                        modelValue: $data.invoice_doc.po_no,
                        "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => $data.invoice_doc.po_no = $event),
                        label: _ctx.frappe._("Purchase Order"),
                        variant: "outlined",
                        density: "compact",
                        "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                        class: "dark-field",
                        clearable: "",
                        color: "primary",
                        "hide-details": ""
                      }, null, 8, ["modelValue", "label", "bg-color"])
                    ]),
                    _: 1
                  }),
                  createVNode(_component_v_col, { cols: "6" }, {
                    default: withCtx(() => [
                      createVNode(_component_VueDatePicker, {
                        modelValue: $data.new_po_date,
                        "onUpdate:modelValue": [
                          _cache[10] || (_cache[10] = ($event) => $data.new_po_date = $event),
                          _cache[11] || (_cache[11] = ($event) => $options.update_po_date())
                        ],
                        "model-type": "format",
                        format: "dd-MM-yyyy",
                        "min-date": new Date(),
                        "auto-apply": "",
                        dark: $options.isDarkTheme
                      }, null, 8, ["modelValue", "min-date", "dark"]),
                      createVNode(_component_v_text_field, {
                        modelValue: $data.invoice_doc.po_date,
                        "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => $data.invoice_doc.po_date = $event),
                        label: _ctx.frappe._("Purchase Order Date"),
                        readonly: "",
                        variant: "outlined",
                        density: "compact",
                        "hide-details": "",
                        color: "primary"
                      }, null, 8, ["modelValue", "label"])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ])) : createCommentVNode("v-if", true),
            createVNode(_component_v_divider),
            createCommentVNode(" Switches for Write Off and Credit Sale "),
            createVNode(_component_v_row, {
              class: "px-1 py-0",
              align: "start",
              "no-gutters": ""
            }, {
              default: withCtx(() => [
                $data.pos_profile.posa_allow_write_off_change && $options.credit_change > 0 && !$data.invoice_doc.is_return ? (openBlock(), createBlock(_component_v_col, {
                  key: 0,
                  cols: "6"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_v_switch, {
                      modelValue: $data.is_write_off_change,
                      "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => $data.is_write_off_change = $event),
                      flat: "",
                      label: _ctx.frappe._("Write Off Difference Amount"),
                      class: "my-0 py-0"
                    }, null, 8, ["modelValue", "label"])
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true),
                $data.pos_profile.posa_allow_credit_sale && !$data.invoice_doc.is_return ? (openBlock(), createBlock(_component_v_col, {
                  key: 1,
                  cols: "6"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_v_switch, {
                      modelValue: $data.is_credit_sale,
                      "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => $data.is_credit_sale = $event),
                      label: _ctx.frappe._("Credit Sale?")
                    }, null, 8, ["modelValue", "label"])
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true),
                $data.invoice_doc.is_return && $data.pos_profile.use_cashback ? (openBlock(), createBlock(_component_v_col, {
                  key: 2,
                  cols: "6"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_v_switch, {
                      modelValue: $data.is_cashback,
                      "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => $data.is_cashback = $event),
                      flat: "",
                      label: _ctx.frappe._("Cashback?"),
                      class: "my-0 py-0"
                    }, null, 8, ["modelValue", "label"])
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true),
                $data.invoice_doc.is_return ? (openBlock(), createBlock(_component_v_col, {
                  key: 3,
                  cols: "6"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_v_switch, {
                      modelValue: $data.is_credit_return,
                      "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => $data.is_credit_return = $event),
                      flat: "",
                      label: _ctx.frappe._("Credit Return?"),
                      class: "my-0 py-0"
                    }, null, 8, ["modelValue", "label"])
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true),
                $data.is_credit_sale ? (openBlock(), createBlock(_component_v_col, {
                  key: 4,
                  cols: "6"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_VueDatePicker, {
                      modelValue: $data.new_credit_due_date,
                      "onUpdate:modelValue": [
                        _cache[17] || (_cache[17] = ($event) => $data.new_credit_due_date = $event),
                        _cache[18] || (_cache[18] = ($event) => $options.update_credit_due_date())
                      ],
                      "model-type": "format",
                      format: "dd-MM-yyyy",
                      "min-date": new Date(),
                      "auto-apply": "",
                      dark: $options.isDarkTheme
                    }, null, 8, ["modelValue", "min-date", "dark"]),
                    createVNode(_component_v_text_field, {
                      class: "mt-2",
                      density: "compact",
                      variant: "outlined",
                      type: "number",
                      min: "0",
                      max: "365",
                      modelValue: $data.credit_due_days,
                      "onUpdate:modelValue": _cache[19] || (_cache[19] = ($event) => $data.credit_due_days = $event),
                      modelModifiers: { number: true },
                      label: _ctx.frappe._("Days until due"),
                      "hide-details": "",
                      onChange: _cache[20] || (_cache[20] = ($event) => $options.applyDuePreset($data.credit_due_days))
                    }, null, 8, ["modelValue", "label"]),
                    createBaseVNode("div", _hoisted_137, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList($data.credit_due_presets, (d) => {
                        return openBlock(), createBlock(_component_v_chip, {
                          key: d,
                          size: "small",
                          class: "ma-1",
                          variant: "outlined",
                          color: "primary",
                          onClick: ($event) => $options.applyDuePreset(d)
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(d) + " " + toDisplayString(_ctx.frappe._("days")), 1)
                          ]),
                          _: 2
                        }, 1032, ["onClick"]);
                      }), 128))
                    ])
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true),
                !$data.invoice_doc.is_return && $data.pos_profile.use_customer_credit ? (openBlock(), createBlock(_component_v_col, {
                  key: 5,
                  cols: "6"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_v_switch, {
                      modelValue: $data.redeem_customer_credit,
                      "onUpdate:modelValue": _cache[21] || (_cache[21] = ($event) => $data.redeem_customer_credit = $event),
                      flat: "",
                      label: _ctx.frappe._("Use Customer Credit"),
                      class: "my-0 py-0",
                      onChange: _cache[22] || (_cache[22] = ($event) => $options.get_available_credit($data.redeem_customer_credit))
                    }, null, 8, ["modelValue", "label"])
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true)
              ]),
              _: 1
            }),
            createCommentVNode(" Customer Credit Details "),
            $data.invoice_doc && $options.available_customer_credit > 0 && !$data.invoice_doc.is_return && $data.redeem_customer_credit ? (openBlock(), createElementBlock("div", _hoisted_145, [
              (openBlock(true), createElementBlock(Fragment, null, renderList($data.customer_credit_dict, (row, idx) => {
                return openBlock(), createBlock(_component_v_row, { key: idx }, {
                  default: withCtx(() => [
                    createVNode(_component_v_col, { cols: "4" }, {
                      default: withCtx(() => [
                        createBaseVNode("div", _hoisted_155, toDisplayString(row.credit_origin), 1)
                      ]),
                      _: 2
                    }, 1024),
                    createVNode(_component_v_col, { cols: "4" }, {
                      default: withCtx(() => [
                        createVNode(_component_v_text_field, {
                          density: "compact",
                          variant: "outlined",
                          color: "primary",
                          label: _ctx.frappe._("Available Credit"),
                          "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                          class: "dark-field",
                          "hide-details": "",
                          value: $options.formatCurrency(row.total_credit),
                          readonly: "",
                          prefix: $options.currencySymbol($data.invoice_doc.currency)
                        }, null, 8, ["label", "bg-color", "value", "prefix"])
                      ]),
                      _: 2
                    }, 1024),
                    createVNode(_component_v_col, { cols: "4" }, {
                      default: withCtx(() => [
                        createVNode(_component_v_text_field, {
                          density: "compact",
                          variant: "outlined",
                          color: "primary",
                          label: _ctx.frappe._("Redeem Credit"),
                          "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                          class: "dark-field",
                          "hide-details": "",
                          type: "text",
                          "model-value": $options.formatCurrency(row.credit_to_redeem),
                          onChange: ($event) => _ctx.setFormatedCurrency(row, "credit_to_redeem", null, false, $event),
                          prefix: $options.currencySymbol($data.invoice_doc.currency)
                        }, null, 8, ["label", "bg-color", "model-value", "onChange", "prefix"])
                      ]),
                      _: 2
                    }, 1024)
                  ]),
                  _: 2
                }, 1024);
              }), 128))
            ])) : createCommentVNode("v-if", true),
            createVNode(_component_v_divider),
            createCommentVNode(" Sales Person Selection "),
            createVNode(_component_v_row, {
              class: "pb-0 mb-2",
              align: "start"
            }, {
              default: withCtx(() => [
                createVNode(_component_v_col, { cols: "12" }, {
                  default: withCtx(() => [
                    $data.sales_persons && $data.sales_persons.length > 0 ? (openBlock(), createElementBlock("p", _hoisted_165, toDisplayString($data.sales_persons.length) + " sales persons found", 1)) : (openBlock(), createElementBlock("p", _hoisted_175, "No sales persons found")),
                    createVNode(_component_v_select, {
                      density: "compact",
                      clearable: "",
                      variant: "outlined",
                      color: "primary",
                      label: _ctx.frappe._("Sales Person"),
                      modelValue: $data.sales_person,
                      "onUpdate:modelValue": _cache[23] || (_cache[23] = ($event) => $data.sales_person = $event),
                      items: $data.sales_persons,
                      "item-title": "title",
                      "item-value": "value",
                      "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                      class: "dark-field",
                      "no-data-text": _ctx.__("Sales Person not found"),
                      "hide-details": "",
                      disabled: _ctx.readonly
                    }, null, 8, ["label", "modelValue", "items", "bg-color", "no-data-text", "disabled"])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ])
        ]),
        _: 1
      }, 8, ["class", "style"]),
      createCommentVNode(" Action Buttons "),
      createVNode(_component_v_card, {
        flat: "",
        class: "cards mb-0 mt-3 py-0"
      }, {
        default: withCtx(() => [
          createVNode(_component_v_row, {
            align: "start",
            "no-gutters": ""
          }, {
            default: withCtx(() => [
              createVNode(_component_v_col, { cols: "6" }, {
                default: withCtx(() => [
                  createVNode(_component_v_btn, {
                    block: "",
                    size: "large",
                    color: "primary",
                    theme: "dark",
                    onClick: $options.submit,
                    loading: $data.loading,
                    disabled: $data.loading || $options.vaildatPayment
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.__("Submit")), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick", "loading", "disabled"])
                ]),
                _: 1
              }),
              createVNode(_component_v_col, {
                cols: "6",
                class: "pl-1"
              }, {
                default: withCtx(() => [
                  createVNode(_component_v_btn, {
                    block: "",
                    size: "large",
                    color: "success",
                    theme: "dark",
                    onClick: _cache[24] || (_cache[24] = ($event) => $options.submit(void 0, false, true)),
                    loading: $data.loading,
                    disabled: $data.loading || $options.vaildatPayment
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.__("Submit & Print")), 1)
                    ]),
                    _: 1
                  }, 8, ["loading", "disabled"])
                ]),
                _: 1
              }),
              createVNode(_component_v_col, { cols: "12" }, {
                default: withCtx(() => [
                  createVNode(_component_v_btn, {
                    block: "",
                    class: "mt-2 pa-1",
                    size: "large",
                    color: "error",
                    theme: "dark",
                    onClick: $options.back_to_invoice
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.__("Cancel Payment")), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick"])
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      }),
      createCommentVNode(" Custom Days Dialog "),
      createVNode(_component_v_dialog, {
        modelValue: $data.custom_days_dialog,
        "onUpdate:modelValue": _cache[27] || (_cache[27] = ($event) => $data.custom_days_dialog = $event),
        "max-width": "300px"
      }, {
        default: withCtx(() => [
          createVNode(_component_v_card, null, {
            default: withCtx(() => [
              createVNode(_component_v_card_title, { class: "text-h6" }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(_ctx.__("Custom Due Days")), 1)
                ]),
                _: 1
              }),
              createVNode(_component_v_card_text, { class: "pa-0" }, {
                default: withCtx(() => [
                  createVNode(_component_v_container, null, {
                    default: withCtx(() => [
                      createVNode(_component_v_text_field, {
                        density: "compact",
                        variant: "outlined",
                        type: "number",
                        min: "0",
                        max: "365",
                        modelValue: $data.custom_days_value,
                        "onUpdate:modelValue": _cache[25] || (_cache[25] = ($event) => $data.custom_days_value = $event),
                        modelModifiers: { number: true },
                        label: _ctx.frappe._("Days"),
                        "hide-details": ""
                      }, null, 8, ["modelValue", "label"])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              createVNode(_component_v_card_actions, null, {
                default: withCtx(() => [
                  createVNode(_component_v_spacer),
                  createVNode(_component_v_btn, {
                    color: "error",
                    theme: "dark",
                    onClick: _cache[26] || (_cache[26] = ($event) => $data.custom_days_dialog = false)
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.__("Close")), 1)
                    ]),
                    _: 1
                  }),
                  createVNode(_component_v_btn, {
                    color: "primary",
                    theme: "dark",
                    onClick: $options.applyCustomDays
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.__("Apply")), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick"])
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["modelValue"]),
      createCommentVNode(" Phone Payment Dialog "),
      createVNode(_component_v_dialog, {
        modelValue: $data.phone_dialog,
        "onUpdate:modelValue": _cache[30] || (_cache[30] = ($event) => $data.phone_dialog = $event),
        "max-width": "400px"
      }, {
        default: withCtx(() => [
          createVNode(_component_v_card, null, {
            default: withCtx(() => [
              createVNode(_component_v_card_title, null, {
                default: withCtx(() => [
                  createBaseVNode("span", _hoisted_185, toDisplayString(_ctx.__("Confirm Mobile Number")), 1)
                ]),
                _: 1
              }),
              createVNode(_component_v_card_text, { class: "pa-0" }, {
                default: withCtx(() => [
                  createVNode(_component_v_container, null, {
                    default: withCtx(() => [
                      createVNode(_component_v_text_field, {
                        density: "compact",
                        variant: "outlined",
                        color: "primary",
                        label: _ctx.frappe._("Mobile Number"),
                        "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                        class: "dark-field",
                        "hide-details": "",
                        modelValue: $data.invoice_doc.contact_mobile,
                        "onUpdate:modelValue": _cache[28] || (_cache[28] = ($event) => $data.invoice_doc.contact_mobile = $event),
                        type: "number"
                      }, null, 8, ["label", "bg-color", "modelValue"])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              createVNode(_component_v_card_actions, null, {
                default: withCtx(() => [
                  createVNode(_component_v_spacer),
                  createVNode(_component_v_btn, {
                    color: "error",
                    theme: "dark",
                    onClick: _cache[29] || (_cache[29] = ($event) => $data.phone_dialog = false)
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.__("Close")), 1)
                    ]),
                    _: 1
                  }),
                  createVNode(_component_v_btn, {
                    color: "primary",
                    theme: "dark",
                    onClick: $options.request_payment
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.__("Request")), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick"])
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["modelValue"])
    ]);
  }

  // ../posawesome/posawesome/public/js/posapp/components/pos/Payments.vue
  Payments_default.render = render22;
  Payments_default.__file = "../posawesome/posawesome/public/js/posapp/components/pos/Payments.vue";
  Payments_default.__scopeId = "data-v-4f3b00ab";
  var Payments_default2 = Payments_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/PosOffers.vue?type=script
  var PosOffers_default = {
    mixins: [format_default],
    data: () => ({
      loading: false,
      pos_profile: "",
      pos_offers: [],
      allItems: [],
      discount_percentage_offer_name: null,
      itemsPerPage: 1e3,
      expanded: [],
      singleExpand: true,
      items_headers: [
        { title: __("Name"), value: "name", align: "start" },
        { title: __("Apply On"), value: "apply_on", align: "start" },
        { title: __("Offer"), value: "offer", align: "start" },
        { title: __("Applied"), value: "offer_applied", align: "start" }
      ]
    }),
    computed: {
      offersCount() {
        return this.pos_offers.length;
      },
      appliedOffersCount() {
        return this.pos_offers.filter((el) => !!el.offer_applied).length;
      },
      isDarkTheme() {
        var _a3;
        return ((_a3 = this.$theme) == null ? void 0 : _a3.current) === "dark";
      }
    },
    methods: {
      back_to_invoice() {
        this.eventBus.emit("show_offers", "false");
      },
      forceUpdateItem() {
        let list_offers = [];
        list_offers = [...this.pos_offers];
        this.pos_offers = list_offers;
      },
      makeid(length) {
        let result = "";
        const characters = "abcdefghijklmnopqrstuvwxyz0123456789";
        const charactersLength = characters.length;
        for (var i = 0; i < length; i++) {
          result += characters.charAt(
            Math.floor(Math.random() * charactersLength)
          );
        }
        return result;
      },
      updatePosOffers(offers) {
        const toRemove = [];
        this.pos_offers.forEach((pos_offer) => {
          const offer = offers.find((offer2) => offer2.name === pos_offer.name);
          if (!offer) {
            toRemove.push(pos_offer.row_id);
          }
        });
        this.removeOffers(toRemove);
        offers.forEach((offer) => {
          const pos_offer = this.pos_offers.find(
            (pos_offer2) => offer.name === pos_offer2.name
          );
          if (pos_offer) {
            pos_offer.items = offer.items;
            if (pos_offer.offer === "Grand Total" && !this.discount_percentage_offer_name) {
              pos_offer.offer_applied = !!pos_offer.auto;
            }
            if (offer.apply_on == "Item Group" && offer.apply_type == "Item Group" && offer.replace_cheapest_item) {
              pos_offer.give_item = offer.give_item;
              pos_offer.apply_item_code = offer.apply_item_code;
            }
          } else {
            const newOffer = __spreadValues({}, offer);
            if (!offer.row_id) {
              newOffer.row_id = this.makeid(20);
            }
            if (offer.apply_type == "Item Code") {
              newOffer.give_item = offer.apply_item_code || "Nothing";
            }
            if (offer.offer_applied) {
              newOffer.offer_applied == !!offer.offer_applied;
            } else {
              if (offer.apply_type == "Item Group" && offer.offer == "Give Product" && !offer.replace_cheapest_item && !offer.replace_item) {
                newOffer.offer_applied = false;
              } else if (offer.offer === "Grand Total" && this.discount_percentage_offer_name) {
                newOffer.offer_applied = false;
              } else {
                newOffer.offer_applied = !!offer.auto;
              }
            }
            if (newOffer.offer == "Give Product" && !newOffer.give_item) {
              newOffer.give_item = this.get_give_items(newOffer)[0].item_code;
            }
            this.pos_offers.push(newOffer);
            this.eventBus.emit("show_message", {
              title: __("New Offer Available"),
              color: "warning"
            });
          }
        });
      },
      removeOffers(offers_id_list) {
        this.pos_offers = this.pos_offers.filter(
          (offer) => !offers_id_list.includes(offer.row_id)
        );
      },
      handelOffers() {
        const applyedOffers = this.pos_offers.filter(
          (offer) => offer.offer_applied
        );
        this.eventBus.emit("update_invoice_offers", applyedOffers);
      },
      handleNewLine(str) {
        if (str) {
          return str.replace(/(?:\r\n|\r|\n)/g, "<br />");
        } else {
          return "";
        }
      },
      get_give_items(offer) {
        if (offer.apply_type == "Item Code") {
          return [offer.apply_item_code];
        } else if (offer.apply_type == "Item Group") {
          const items = this.allItems;
          let filterd_items = [];
          const filterd_items_1 = items.filter(
            (item) => item.item_group == offer.apply_item_group
          );
          if (offer.less_then > 0) {
            filterd_items = filterd_items_1.filter(
              (item) => item.rate < offer.less_then
            );
          } else {
            filterd_items = filterd_items_1;
          }
          return filterd_items;
        } else {
          return [];
        }
      },
      updateCounters() {
        this.eventBus.emit("update_offers_counters", {
          offersCount: this.offersCount,
          appliedOffersCount: this.appliedOffersCount
        });
      },
      updatePosCoupuns() {
        const applyedOffers = this.pos_offers.filter(
          (offer) => offer.offer_applied && offer.coupon_based
        );
        this.eventBus.emit("update_pos_coupons", applyedOffers);
      }
    },
    watch: {
      pos_offers: {
        deep: true,
        handler(pos_offers) {
          this.handelOffers();
          this.updateCounters();
          this.updatePosCoupuns();
        }
      }
    },
    created: function() {
      this.$nextTick(function() {
        this.eventBus.on("register_pos_profile", (data) => {
          this.pos_profile = data.pos_profile;
        });
      });
      this.eventBus.on("update_customer", (customer) => {
        if (this.customer != customer) {
          this.offers = [];
        }
      });
      this.eventBus.on("update_pos_offers", (data) => {
        this.updatePosOffers(data);
      });
      this.eventBus.on("update_discount_percentage_offer_name", (data) => {
        this.discount_percentage_offer_name = data.value;
      });
      this.eventBus.on("set_all_items", (data) => {
        this.allItems = data;
      });
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/PosOffers.vue?type=template
  var _hoisted_131 = { class: "text-h6 text-primary" };
  var _hoisted_218 = ["colspan"];
  var _hoisted_316 = ["innerHTML"];
  function render23(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_card_title = resolveComponent("v-card-title");
    const _component_v_checkbox_btn = resolveComponent("v-checkbox-btn");
    const _component_v_col = resolveComponent("v-col");
    const _component_v_autocomplete = resolveComponent("v-autocomplete");
    const _component_v_row = resolveComponent("v-row");
    const _component_v_data_table = resolveComponent("v-data-table");
    const _component_v_card = resolveComponent("v-card");
    const _component_v_btn = resolveComponent("v-btn");
    return openBlock(), createElementBlock("div", null, [
      createVNode(_component_v_card, {
        class: normalizeClass(["selection mx-auto mt-3", $options.isDarkTheme ? "" : "bg-grey-lighten-5"]),
        style: normalizeStyle([$options.isDarkTheme ? "background-color:#1E1E1E" : "", { "max-height": "80vh", "height": "80vh" }])
      }, {
        default: withCtx(() => [
          createVNode(_component_v_card_title, null, {
            default: withCtx(() => [
              createBaseVNode("span", _hoisted_131, toDisplayString(_ctx.__("Offers")), 1)
            ]),
            _: 1
          }),
          createBaseVNode("div", {
            class: "my-0 py-0 overflow-y-auto",
            style: { "max-height": "75vh" },
            onMouseover: _cache[1] || (_cache[1] = ($event) => _ctx.style = "cursor: pointer")
          }, [
            createVNode(_component_v_data_table, {
              headers: _ctx.items_headers,
              items: _ctx.pos_offers,
              "single-expand": _ctx.singleExpand,
              expanded: _ctx.expanded,
              "onUpdate:expanded": _cache[0] || (_cache[0] = ($event) => _ctx.expanded = $event),
              "show-expand": "",
              "item-key": "row_id",
              class: "elevation-1",
              "items-per-page": _ctx.itemsPerPage,
              "hide-default-footer": ""
            }, {
              "item.offer_applied": withCtx(({ item }) => [
                createVNode(_component_v_checkbox_btn, {
                  onClick: ($event) => _ctx.toggleOfferApplied(item),
                  modelValue: item.offer_applied,
                  "onUpdate:modelValue": ($event) => item.offer_applied = $event,
                  disabled: item.offer == "Give Product" && !item.give_item && (!_ctx.offer.replace_cheapest_item || !_ctx.offer.replace_item) || item.offer == "Grand Total" && _ctx.discount_percentage_offer_name && _ctx.discount_percentage_offer_name != item.name
                }, null, 8, ["onClick", "modelValue", "onUpdate:modelValue", "disabled"])
              ]),
              "expanded-item": withCtx(({ headers, item }) => [
                createBaseVNode("td", {
                  colspan: headers.length
                }, [
                  createVNode(_component_v_row, { class: "mt-2" }, {
                    default: withCtx(() => [
                      item.description ? (openBlock(), createBlock(_component_v_col, { key: 0 }, {
                        default: withCtx(() => [
                          createBaseVNode("div", {
                            class: "text-primary",
                            innerHTML: $options.handleNewLine(item.description)
                          }, null, 8, _hoisted_316)
                        ]),
                        _: 2
                      }, 1024)) : createCommentVNode("v-if", true),
                      item.offer == "Give Product" ? (openBlock(), createBlock(_component_v_col, { key: 1 }, {
                        default: withCtx(() => [
                          createVNode(_component_v_autocomplete, {
                            modelValue: item.give_item,
                            "onUpdate:modelValue": ($event) => item.give_item = $event,
                            items: $options.get_give_items(item),
                            "item-title": "item_code",
                            variant: "outlined",
                            density: "compact",
                            color: "primary",
                            label: _ctx.frappe._("Give Item"),
                            disabled: item.apply_type != "Item Group" || item.replace_item || item.replace_cheapest_item
                          }, null, 8, ["modelValue", "onUpdate:modelValue", "items", "label", "disabled"])
                        ]),
                        _: 2
                      }, 1024)) : createCommentVNode("v-if", true)
                    ]),
                    _: 2
                  }, 1024)
                ], 8, _hoisted_218)
              ]),
              _: 1
            }, 8, ["headers", "items", "single-expand", "expanded", "items-per-page"])
          ], 32)
        ]),
        _: 1
      }, 8, ["class", "style"]),
      createVNode(_component_v_card, {
        flat: "",
        style: { "max-height": "11vh", "height": "11vh" },
        class: "cards mb-0 mt-3 py-0"
      }, {
        default: withCtx(() => [
          createVNode(_component_v_row, {
            align: "start",
            "no-gutters": ""
          }, {
            default: withCtx(() => [
              createVNode(_component_v_col, { cols: "12" }, {
                default: withCtx(() => [
                  createVNode(_component_v_btn, {
                    block: "",
                    class: "pa-1",
                    size: "large",
                    color: "warning",
                    theme: "dark",
                    onClick: $options.back_to_invoice
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.__("Back")), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick"])
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      })
    ]);
  }

  // ../posawesome/posawesome/public/js/posapp/components/pos/PosOffers.vue
  PosOffers_default.render = render23;
  PosOffers_default.__file = "../posawesome/posawesome/public/js/posapp/components/pos/PosOffers.vue";
  var PosOffers_default2 = PosOffers_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/PosCoupons.vue?type=script
  var PosCoupons_default = {
    data: () => ({
      loading: false,
      pos_profile: "",
      customer: "",
      posa_coupons: [],
      new_coupon: null,
      itemsPerPage: 1e3,
      singleExpand: true,
      items_headers: [
        { title: __("Coupon"), value: "coupon_code", align: "start" },
        { title: __("Type"), value: "type", align: "start" },
        { title: __("Offer"), value: "pos_offer", align: "start" },
        { title: __("Applied"), value: "applied", align: "start" }
      ]
    }),
    computed: {
      couponsCount() {
        return this.posa_coupons.length;
      },
      appliedCouponsCount() {
        return this.posa_coupons.filter((el) => !!el.applied).length;
      },
      isDarkTheme() {
        var _a3;
        return ((_a3 = this.$theme) == null ? void 0 : _a3.current) === "dark";
      }
    },
    methods: {
      back_to_invoice() {
        this.eventBus.emit("show_coupons", "false");
      },
      add_coupon(new_coupon) {
        if (!this.customer || !new_coupon) {
          this.eventBus.emit("show_message", {
            title: __("Select a customer to use coupon"),
            color: "error"
          });
          return;
        }
        ;
        const exist = this.posa_coupons.find(
          (el) => el.coupon_code == new_coupon
        );
        if (exist) {
          this.eventBus.emit("show_message", {
            title: __("This coupon already used !"),
            color: "error"
          });
          return;
        }
        const vm2 = this;
        frappe.call({
          method: "posawesome.posawesome.api.offers.get_pos_coupon",
          args: {
            coupon: new_coupon,
            customer: vm2.customer,
            company: vm2.pos_profile.company
          },
          callback: function(r) {
            if (r.message) {
              const res = r.message;
              if (res.msg != "Apply" || !res.coupon) {
                vm2.eventBus.emit("show_message", {
                  text: res.msg,
                  color: "error"
                });
              } else {
                vm2.new_coupon = null;
                const coupon = res.coupon;
                vm2.posa_coupons.push({
                  coupon: coupon.name,
                  coupon_code: coupon.coupon_code,
                  type: coupon.coupon_type,
                  applied: 0,
                  pos_offer: coupon.pos_offer,
                  customer: coupon.customer || vm2.customer
                });
              }
            }
          }
        });
      },
      setActiveGiftCoupons() {
        if (!this.customer)
          return;
        const vm2 = this;
        frappe.call({
          method: "posawesome.posawesome.api.offers.get_active_gift_coupons",
          args: {
            customer: vm2.customer,
            company: vm2.pos_profile.company
          },
          callback: function(r) {
            if (r.message) {
              const coupons = r.message;
              coupons.forEach((coupon_code) => {
                vm2.add_coupon(coupon_code);
              });
            }
          }
        });
      },
      updatePosCoupons(offers) {
        this.posa_coupons.forEach((coupon) => {
          const offer = offers.find(
            (el) => el.offer_applied && el.coupon == coupon.coupon
          );
          if (offer) {
            coupon.applied = 1;
          } else {
            coupon.applied = 0;
          }
        });
      },
      removeCoupon(reomove_list) {
        this.posa_coupons = this.posa_coupons.filter(
          (coupon) => !reomove_list.includes(coupon.coupon)
        );
      },
      updateInvoice() {
        this.eventBus.emit("update_invoice_coupons", this.posa_coupons);
      },
      updateCounters() {
        this.eventBus.emit("update_coupons_counters", {
          couponsCount: this.couponsCount,
          appliedCouponsCount: this.appliedCouponsCount
        });
      }
    },
    watch: {
      posa_coupons: {
        deep: true,
        handler() {
          this.updateInvoice();
          this.updateCounters();
        }
      }
    },
    created: function() {
      this.$nextTick(function() {
        this.eventBus.on("register_pos_profile", (data) => {
          this.pos_profile = data.pos_profile;
        });
      });
      this.eventBus.on("update_customer", (customer) => {
        if (this.customer != customer) {
          const to_remove = [];
          this.posa_coupons.forEach((el) => {
            if (el.type == "Promotional") {
              el.customer = customer;
            } else {
              to_remove.push(el.coupon);
            }
          });
          this.customer = customer;
          if (to_remove.length) {
            this.removeCoupon(to_remove);
          }
        }
        this.setActiveGiftCoupons();
      });
      this.eventBus.on("update_pos_coupons", (data) => {
        this.updatePosCoupons(data);
      });
      this.eventBus.on("set_pos_coupons", (data) => {
        this.posa_coupons = data;
      });
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/PosCoupons.vue?type=template
  var _hoisted_138 = { class: "text-h6 text-primary" };
  function render24(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_card_title = resolveComponent("v-card-title");
    const _component_v_text_field = resolveComponent("v-text-field");
    const _component_v_col = resolveComponent("v-col");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_row = resolveComponent("v-row");
    const _component_v_checkbox_btn = resolveComponent("v-checkbox-btn");
    const _component_v_data_table = resolveComponent("v-data-table");
    const _component_v_card = resolveComponent("v-card");
    return openBlock(), createElementBlock("div", null, [
      createVNode(_component_v_card, {
        class: normalizeClass(["selection mx-auto mt-3", $options.isDarkTheme ? "" : "bg-grey-lighten-5"]),
        style: normalizeStyle([$options.isDarkTheme ? "background-color:#1E1E1E" : "", { "max-height": "80vh", "height": "80vh" }])
      }, {
        default: withCtx(() => [
          createVNode(_component_v_card_title, null, {
            default: withCtx(() => [
              createBaseVNode("span", _hoisted_138, toDisplayString(_ctx.__("Coupons")), 1)
            ]),
            _: 1
          }),
          createCommentVNode(" Input and Button Row - Same Level "),
          createVNode(_component_v_row, {
            class: "px-4 pb-2",
            "no-gutters": ""
          }, {
            default: withCtx(() => [
              createVNode(_component_v_col, {
                cols: "8",
                class: "pr-2"
              }, {
                default: withCtx(() => [
                  createVNode(_component_v_text_field, {
                    density: "compact",
                    variant: "outlined",
                    color: "primary",
                    label: _ctx.frappe._("Coupon"),
                    "bg-color": "white",
                    "hide-details": "",
                    modelValue: _ctx.new_coupon,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.new_coupon = $event),
                    class: "coupon-input",
                    onKeydown: _cache[1] || (_cache[1] = withKeys(($event) => $options.add_coupon(_ctx.new_coupon), ["enter"]))
                  }, null, 8, ["label", "modelValue"])
                ]),
                _: 1
              }),
              createVNode(_component_v_col, { cols: "4" }, {
                default: withCtx(() => [
                  createVNode(_component_v_btn, {
                    class: "add-coupon-btn",
                    color: "success",
                    theme: "dark",
                    block: "",
                    onClick: _cache[2] || (_cache[2] = ($event) => $options.add_coupon(_ctx.new_coupon))
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.__("add")), 1)
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          createBaseVNode("div", {
            class: "my-0 py-0 overflow-y-auto",
            style: { "max-height": "75vh" },
            onMouseover: _cache[4] || (_cache[4] = ($event) => _ctx.style = "cursor: pointer")
          }, [
            createVNode(_component_v_data_table, {
              headers: _ctx.items_headers,
              items: _ctx.posa_coupons,
              "single-expand": _ctx.singleExpand,
              expanded: _ctx.expanded,
              "onUpdate:expanded": _cache[3] || (_cache[3] = ($event) => _ctx.expanded = $event),
              "item-key": "coupon",
              class: "elevation-1",
              "items-per-page": _ctx.itemsPerPage,
              "hide-default-footer": ""
            }, {
              "item.applied": withCtx(({ item }) => [
                createVNode(_component_v_checkbox_btn, {
                  modelValue: item.applied,
                  "onUpdate:modelValue": ($event) => item.applied = $event,
                  disabled: ""
                }, null, 8, ["modelValue", "onUpdate:modelValue"])
              ]),
              _: 1
            }, 8, ["headers", "items", "single-expand", "expanded", "items-per-page"])
          ], 32)
        ]),
        _: 1
      }, 8, ["class", "style"]),
      createVNode(_component_v_card, {
        flat: "",
        style: { "max-height": "11vh", "height": "11vh" },
        class: "cards mb-0 mt-3 py-0"
      }, {
        default: withCtx(() => [
          createVNode(_component_v_row, {
            align: "start",
            "no-gutters": ""
          }, {
            default: withCtx(() => [
              createVNode(_component_v_col, { cols: "12" }, {
                default: withCtx(() => [
                  createVNode(_component_v_btn, {
                    block: "",
                    class: "pa-1",
                    size: "large",
                    color: "warning",
                    theme: "dark",
                    onClick: $options.back_to_invoice
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.__("Back")), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick"])
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      })
    ]);
  }

  // ../posawesome/posawesome/public/js/posapp/components/pos/PosCoupons.vue
  PosCoupons_default.render = render24;
  PosCoupons_default.__file = "../posawesome/posawesome/public/js/posapp/components/pos/PosCoupons.vue";
  PosCoupons_default.__scopeId = "data-v-04579dff";
  var PosCoupons_default2 = PosCoupons_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/Drafts.vue?type=script
  var Drafts_default = {
    mixins: [format_default],
    data: () => ({
      draftsDialog: false,
      singleSelect: true,
      selected: [],
      dialog_data: {},
      headers: [
        {
          title: __("Customer"),
          value: "customer_name",
          align: "start",
          sortable: true
        },
        {
          title: __("Date"),
          align: "start",
          sortable: true,
          value: "posting_date"
        },
        {
          title: __("Time"),
          align: "start",
          sortable: true,
          value: "posting_time"
        },
        {
          title: __("Invoice"),
          value: "name",
          align: "start",
          sortable: true
        },
        {
          title: __("Amount"),
          value: "grand_total",
          align: "end",
          sortable: false
        }
      ]
    }),
    watch: {},
    methods: {
      close_dialog() {
        this.draftsDialog = false;
      },
      submit_dialog() {
        if (this.selected.length > 0) {
          this.eventBus.emit("load_invoice", this.selected[0]);
          this.draftsDialog = false;
        } else {
          this.eventBus.emit("show_message", {
            title: `Select an invoice to load`,
            color: "error"
          });
        }
      }
    },
    created: function() {
      this.eventBus.on("open_drafts", (data) => {
        this.draftsDialog = true;
        this.dialog_data = data;
      });
    },
    beforeUnmount() {
      this.eventBus.off("open_drafts");
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/Drafts.vue?type=template
  var _hoisted_139 = { class: "text-h5 text-primary" };
  var _hoisted_219 = { class: "text-primary" };
  function render25(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_card_title = resolveComponent("v-card-title");
    const _component_v_card_subtitle = resolveComponent("v-card-subtitle");
    const _component_v_data_table = resolveComponent("v-data-table");
    const _component_v_col = resolveComponent("v-col");
    const _component_v_row = resolveComponent("v-row");
    const _component_v_container = resolveComponent("v-container");
    const _component_v_card_text = resolveComponent("v-card-text");
    const _component_v_spacer = resolveComponent("v-spacer");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_card_actions = resolveComponent("v-card-actions");
    const _component_v_card = resolveComponent("v-card");
    const _component_v_dialog = resolveComponent("v-dialog");
    return openBlock(), createBlock(_component_v_row, { justify: "center" }, {
      default: withCtx(() => [
        createVNode(_component_v_dialog, {
          modelValue: _ctx.draftsDialog,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.draftsDialog = $event),
          "max-width": "900px"
        }, {
          default: withCtx(() => [
            createCommentVNode(' <template v-slot:activator="{ on, attrs }">\n        <v-btn color="primary" theme="dark" v-bind="attrs" v-on="on">Open Dialog</v-btn>\n      </template>'),
            createVNode(_component_v_card, {
              variant: "flat",
              color: "white"
            }, {
              default: withCtx(() => [
                createVNode(_component_v_card_title, null, {
                  default: withCtx(() => [
                    createBaseVNode("span", _hoisted_139, toDisplayString(_ctx.__("Load Sales Invoice")), 1)
                  ]),
                  _: 1
                }),
                createVNode(_component_v_card_subtitle, null, {
                  default: withCtx(() => [
                    createBaseVNode("span", _hoisted_219, toDisplayString(_ctx.__("Load previously saved invoices")), 1)
                  ]),
                  _: 1
                }),
                createVNode(_component_v_card_text, { class: "pa-0" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_container, null, {
                      default: withCtx(() => [
                        createVNode(_component_v_row, { "no-gutters": "" }, {
                          default: withCtx(() => [
                            createVNode(_component_v_col, {
                              cols: "12",
                              class: "pa-1"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_v_data_table, {
                                  headers: _ctx.headers,
                                  items: _ctx.dialog_data,
                                  "item-value": "name",
                                  class: "elevation-1",
                                  "show-select": "",
                                  modelValue: _ctx.selected,
                                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.selected = $event),
                                  "select-strategy": "single",
                                  "return-object": ""
                                }, {
                                  "item.posting_time": withCtx(({ item }) => [
                                    createTextVNode(toDisplayString(item.posting_time.split(".")[0]), 1)
                                  ]),
                                  "item.grand_total": withCtx(({ item }) => [
                                    createTextVNode(toDisplayString(_ctx.currencySymbol(item.currency)) + " " + toDisplayString(_ctx.formatCurrency(item.grand_total)), 1)
                                  ]),
                                  _: 1
                                }, 8, ["headers", "items", "modelValue"])
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                createVNode(_component_v_card_actions, null, {
                  default: withCtx(() => [
                    createVNode(_component_v_spacer),
                    createVNode(_component_v_btn, {
                      color: "error",
                      theme: "dark",
                      onClick: $options.close_dialog
                    }, {
                      default: withCtx(() => [
                        createTextVNode("Close")
                      ]),
                      _: 1
                    }, 8, ["onClick"]),
                    createVNode(_component_v_btn, {
                      color: "success",
                      theme: "dark",
                      onClick: $options.submit_dialog
                    }, {
                      default: withCtx(() => [
                        createTextVNode("Load Sale")
                      ]),
                      _: 1
                    }, 8, ["onClick"])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]),
      _: 1
    });
  }

  // ../posawesome/posawesome/public/js/posapp/components/pos/Drafts.vue
  Drafts_default.render = render25;
  Drafts_default.__file = "../posawesome/posawesome/public/js/posapp/components/pos/Drafts.vue";
  var Drafts_default2 = Drafts_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/SalesOrders.vue?type=script
  var SalesOrders_default = {
    mixins: [format_default],
    data: () => ({
      draftsDialog: false,
      singleSelect: true,
      pos_profile: {},
      selected: [],
      dialog_data: {},
      order_name: "",
      headers: [
        {
          title: __("Customer"),
          key: "customer_name",
          align: "start",
          sortable: true
        },
        {
          title: __("Date"),
          align: "start",
          sortable: true,
          key: "transaction_date"
        },
        {
          title: __("Order"),
          key: "name",
          align: "start",
          sortable: true
        },
        {
          title: __("Amount"),
          key: "grand_total",
          align: "end",
          sortable: false
        }
      ]
    }),
    watch: {},
    methods: {
      close_dialog() {
        this.draftsDialog = false;
      },
      clearSelected() {
        this.selected = [];
      },
      search_orders() {
        frappe.call({
          method: "posawesome.posawesome.api.sales_orders.search_orders",
          args: {
            order_name: vm.order_name,
            company: this.pos_profile.company,
            currency: this.pos_profile.currency
          },
          async: false,
          callback: function(r) {
            if (r.message) {
              vm.dialog_data = r.message;
            }
          }
        });
      },
      async submit_dialog() {
        if (this.selected.length > 0) {
          var invoice_doc_for_load = {};
          await frappe.call({
            method: "posawesome.posawesome.api.invoices.create_sales_invoice_from_order",
            args: {
              sales_order: this.selected[0].name
            },
            callback: function(r) {
              if (r.message) {
                invoice_doc_for_load = r.message;
              }
            }
          });
          if (invoice_doc_for_load.items) {
            const selectedItems = this.selected[0].items;
            const loadedItems = invoice_doc_for_load.items;
            const loadedItemsMap = {};
            loadedItems.forEach((item) => {
              loadedItemsMap[item.item_code] = item;
            });
            for (let i = 0; i < selectedItems.length; i++) {
              const selectedItem = selectedItems[i];
              const loadedItem = loadedItemsMap[selectedItem.item_code];
              if (loadedItem) {
                selectedItem.qty = loadedItem.qty;
                selectedItem.amount = loadedItem.amount;
                selectedItem.uom = loadedItem.uom;
                selectedItem.rate = loadedItem.rate;
              } else {
                selectedItems.splice(i, 1);
                i--;
              }
            }
          }
          this.eventBus.emit("load_order", this.selected[0]);
          this.draftsDialog = false;
          frappe.call({
            method: "posawesome.posawesome.api.invoices.delete_sales_invoice",
            args: {
              sales_invoice: invoice_doc_for_load.name
            },
            callback: function(r) {
              if (r.message) {
              }
            }
          });
        }
      }
    },
    created: function() {
      this.eventBus.on("open_orders", (data) => {
        this.clearSelected();
        this.draftsDialog = true;
        this.dialog_data = data;
        this.order_name = "";
      });
    },
    mounted() {
      this.eventBus.on("register_pos_profile", (data) => {
        this.pos_profile = data.pos_profile;
      });
    },
    beforeUnmount() {
      this.eventBus.off("open_orders");
      this.eventBus.off("register_pos_profile");
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/SalesOrders.vue?type=template
  var _hoisted_140 = { class: "text-h5 text-primary" };
  function render26(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_card_title = resolveComponent("v-card-title");
    const _component_v_text_field = resolveComponent("v-text-field");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_row = resolveComponent("v-row");
    const _component_v_data_table = resolveComponent("v-data-table");
    const _component_v_col = resolveComponent("v-col");
    const _component_v_container = resolveComponent("v-container");
    const _component_v_card_text = resolveComponent("v-card-text");
    const _component_v_spacer = resolveComponent("v-spacer");
    const _component_v_card_actions = resolveComponent("v-card-actions");
    const _component_v_card = resolveComponent("v-card");
    const _component_v_dialog = resolveComponent("v-dialog");
    return openBlock(), createBlock(_component_v_row, { justify: "center" }, {
      default: withCtx(() => [
        createVNode(_component_v_dialog, {
          modelValue: _ctx.draftsDialog,
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.draftsDialog = $event),
          "max-width": "900px"
        }, {
          default: withCtx(() => [
            createCommentVNode(' <template v-slot:activator="{ on, attrs }">\n              <v-btn color="primary" theme="dark" v-bind="attrs" v-on="on">Open Dialog</v-btn>\n            </template>'),
            createVNode(_component_v_card, null, {
              default: withCtx(() => [
                createVNode(_component_v_card_title, null, {
                  default: withCtx(() => [
                    createBaseVNode("span", _hoisted_140, toDisplayString(_ctx.__("Select Sales Orders")), 1)
                  ]),
                  _: 1
                }),
                createVNode(_component_v_card_text, { class: "pa-0" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_container, null, {
                      default: withCtx(() => [
                        createVNode(_component_v_row, { class: "mb-4" }, {
                          default: withCtx(() => [
                            createVNode(_component_v_text_field, {
                              color: "primary",
                              label: _ctx.frappe._("Order ID"),
                              "bg-color": "white",
                              "hide-details": "",
                              modelValue: _ctx.order_name,
                              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.order_name = $event),
                              density: "compact",
                              clearable: "",
                              class: "mx-4"
                            }, null, 8, ["label", "modelValue"]),
                            createVNode(_component_v_btn, {
                              variant: "text",
                              class: "ml-2",
                              color: "primary",
                              theme: "dark",
                              onClick: $options.search_orders
                            }, {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString(_ctx.__("Search")), 1)
                              ]),
                              _: 1
                            }, 8, ["onClick"])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_v_row, { "no-gutters": "" }, {
                          default: withCtx(() => [
                            createVNode(_component_v_col, {
                              cols: "12",
                              class: "pa-1"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_v_data_table, {
                                  headers: _ctx.headers,
                                  items: _ctx.dialog_data,
                                  "item-key": "name",
                                  class: "elevation-1",
                                  "show-select": "",
                                  modelValue: _ctx.selected,
                                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.selected = $event),
                                  "return-object": "",
                                  "select-strategy": "single"
                                }, {
                                  "item.grand_total": withCtx(({ item }) => [
                                    createTextVNode(toDisplayString(_ctx.currencySymbol(item.currency)) + " " + toDisplayString(_ctx.formatCurrency(item.grand_total)), 1)
                                  ]),
                                  _: 1
                                }, 8, ["headers", "items", "modelValue"])
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                createVNode(_component_v_card_actions, null, {
                  default: withCtx(() => [
                    createVNode(_component_v_spacer),
                    createVNode(_component_v_btn, {
                      color: "error",
                      theme: "dark",
                      onClick: $options.close_dialog
                    }, {
                      default: withCtx(() => [
                        createTextVNode("Close")
                      ]),
                      _: 1
                    }, 8, ["onClick"]),
                    _ctx.selected.length ? (openBlock(), createBlock(_component_v_btn, {
                      key: 0,
                      color: "success",
                      theme: "dark",
                      onClick: $options.submit_dialog
                    }, {
                      default: withCtx(() => [
                        createTextVNode("Select")
                      ]),
                      _: 1
                    }, 8, ["onClick"])) : createCommentVNode("v-if", true)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]),
      _: 1
    });
  }

  // ../posawesome/posawesome/public/js/posapp/components/pos/SalesOrders.vue
  SalesOrders_default.render = render26;
  SalesOrders_default.__file = "../posawesome/posawesome/public/js/posapp/components/pos/SalesOrders.vue";
  var SalesOrders_default2 = SalesOrders_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/ClosingDialog.vue?type=script
  var ClosingDialog_default = {
    mixins: [format_default],
    data: () => ({
      closingDialog: false,
      itemsPerPage: 20,
      dialog_data: {},
      pos_profile: "",
      headers: [
        {
          title: __("Mode of Payment"),
          value: "mode_of_payment",
          align: "start",
          sortable: true
        },
        {
          title: __("Opening Amount"),
          align: "end",
          sortable: true,
          value: "opening_amount"
        },
        {
          title: __("Closing Amount"),
          value: "closing_amount",
          align: "end",
          sortable: true
        }
      ],
      max25chars: (v) => v.length <= 20 || "Input too long!",
      pagination: {}
    }),
    watch: {},
    methods: {
      close_dialog() {
        this.closingDialog = false;
      },
      submit_dialog() {
        this.eventBus.emit("submit_closing_pos", this.dialog_data);
        this.closingDialog = false;
      }
    },
    created: function() {
      this.eventBus.on("open_ClosingDialog", (data) => {
        this.closingDialog = true;
        this.dialog_data = data;
      });
      this.eventBus.on("register_pos_profile", (data) => {
        this.pos_profile = data.pos_profile;
        if (!this.pos_profile.hide_expected_amount) {
          this.headers.push({
            title: __("Expected Amount"),
            value: "expected_amount",
            align: "end",
            sortable: false
          });
          this.headers.push({
            title: __("Difference"),
            value: "difference",
            align: "end",
            sortable: false
          });
        }
      });
    },
    beforeUnmount() {
      this.eventBus.off("open_ClosingDialog");
      this.eventBus.off("register_pos_profile");
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/ClosingDialog.vue?type=template
  var _hoisted_141 = { class: "header-content" };
  var _hoisted_220 = { class: "header-icon-wrapper" };
  var _hoisted_317 = { class: "header-text" };
  var _hoisted_413 = { class: "header-title" };
  var _hoisted_511 = { class: "header-subtitle" };
  var _hoisted_611 = { class: "table-header mb-4" };
  var _hoisted_710 = { class: "text-h6 text-grey-darken-2 mb-1" };
  var _hoisted_88 = { class: "text-body-2 text-grey" };
  function render27(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_icon = resolveComponent("v-icon");
    const _component_v_card_title = resolveComponent("v-card-title");
    const _component_v_divider = resolveComponent("v-divider");
    const _component_v_text_field = resolveComponent("v-text-field");
    const _component_v_data_table = resolveComponent("v-data-table");
    const _component_v_col = resolveComponent("v-col");
    const _component_v_row = resolveComponent("v-row");
    const _component_v_container = resolveComponent("v-container");
    const _component_v_card_text = resolveComponent("v-card-text");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_spacer = resolveComponent("v-spacer");
    const _component_v_card_actions = resolveComponent("v-card-actions");
    const _component_v_card = resolveComponent("v-card");
    const _component_v_dialog = resolveComponent("v-dialog");
    return openBlock(), createBlock(_component_v_row, { justify: "center" }, {
      default: withCtx(() => [
        createVNode(_component_v_dialog, {
          modelValue: _ctx.closingDialog,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.closingDialog = $event),
          "max-width": "900px",
          persistent: ""
        }, {
          default: withCtx(() => [
            createVNode(_component_v_card, {
              elevation: "8",
              class: "closing-dialog-card"
            }, {
              default: withCtx(() => [
                createCommentVNode(" Enhanced White Header "),
                createVNode(_component_v_card_title, { class: "closing-header pa-6" }, {
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_141, [
                      createBaseVNode("div", _hoisted_220, [
                        createVNode(_component_v_icon, {
                          class: "header-icon",
                          size: "40"
                        }, {
                          default: withCtx(() => [
                            createTextVNode("mdi-store-clock-outline")
                          ]),
                          _: 1
                        })
                      ]),
                      createBaseVNode("div", _hoisted_317, [
                        createBaseVNode("h3", _hoisted_413, toDisplayString(_ctx.__("Closing POS Shift")), 1),
                        createBaseVNode("p", _hoisted_511, toDisplayString(_ctx.__("Reconcile payment methods and close shift")), 1)
                      ])
                    ])
                  ]),
                  _: 1
                }),
                createVNode(_component_v_divider, { class: "header-divider" }),
                createVNode(_component_v_card_text, { class: "pa-0 white-background" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_container, { class: "pa-6" }, {
                      default: withCtx(() => [
                        createVNode(_component_v_row, null, {
                          default: withCtx(() => [
                            createVNode(_component_v_col, {
                              cols: "12",
                              class: "pa-1"
                            }, {
                              default: withCtx(() => [
                                createBaseVNode("div", _hoisted_611, [
                                  createBaseVNode("h4", _hoisted_710, toDisplayString(_ctx.__("Payment Reconciliation")), 1),
                                  createBaseVNode("p", _hoisted_88, toDisplayString(_ctx.__("Verify closing amounts for each payment method")), 1)
                                ]),
                                createVNode(_component_v_data_table, {
                                  headers: _ctx.headers,
                                  items: _ctx.dialog_data.payment_reconciliation,
                                  "item-key": "mode_of_payment",
                                  class: "elevation-0 rounded-lg white-table",
                                  "items-per-page": _ctx.itemsPerPage,
                                  "hide-default-footer": "",
                                  density: "compact"
                                }, {
                                  "item.closing_amount": withCtx((props) => [
                                    createVNode(_component_v_text_field, {
                                      modelValue: props.item.closing_amount,
                                      "onUpdate:modelValue": ($event) => props.item.closing_amount = $event,
                                      rules: [_ctx.max25chars],
                                      label: _ctx.frappe._("Edit"),
                                      "single-line": "",
                                      counter: "",
                                      type: "number",
                                      density: "compact",
                                      variant: "outlined",
                                      color: "primary",
                                      "bg-color": "white",
                                      "hide-details": "",
                                      prefix: _ctx.currencySymbol(_ctx.pos_profile.currency)
                                    }, null, 8, ["modelValue", "onUpdate:modelValue", "rules", "label", "prefix"])
                                  ]),
                                  "item.difference": withCtx(({ item }) => [
                                    createTextVNode(toDisplayString(_ctx.currencySymbol(_ctx.pos_profile.currency)) + " " + toDisplayString(item.difference = _ctx.formatCurrency(
                                      item.expected_amount - item.closing_amount
                                    )), 1)
                                  ]),
                                  "item.opening_amount": withCtx(({ item }) => [
                                    createTextVNode(toDisplayString(_ctx.currencySymbol(_ctx.pos_profile.currency)) + " " + toDisplayString(_ctx.formatCurrency(item.opening_amount)), 1)
                                  ]),
                                  "item.expected_amount": withCtx(({ item }) => [
                                    createTextVNode(toDisplayString(_ctx.currencySymbol(_ctx.pos_profile.currency)) + " " + toDisplayString(_ctx.formatCurrency(item.expected_amount)), 1)
                                  ]),
                                  _: 1
                                }, 8, ["headers", "items", "items-per-page"])
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                createVNode(_component_v_divider),
                createVNode(_component_v_card_actions, { class: "dialog-actions-container" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_btn, {
                      theme: "dark",
                      onClick: $options.submit_dialog,
                      class: "pos-action-btn submit-action-btn",
                      size: "large",
                      elevation: "2"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_v_icon, { start: "" }, {
                          default: withCtx(() => [
                            createTextVNode("mdi-check-circle-outline")
                          ]),
                          _: 1
                        }),
                        createBaseVNode("span", null, toDisplayString(_ctx.__("Submit")), 1)
                      ]),
                      _: 1
                    }, 8, ["onClick"]),
                    createVNode(_component_v_spacer),
                    createVNode(_component_v_btn, {
                      theme: "dark",
                      onClick: $options.close_dialog,
                      class: "pos-action-btn cancel-action-btn",
                      size: "large",
                      elevation: "2"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_v_icon, { start: "" }, {
                          default: withCtx(() => [
                            createTextVNode("mdi-close-circle-outline")
                          ]),
                          _: 1
                        }),
                        createBaseVNode("span", null, toDisplayString(_ctx.__("Close")), 1)
                      ]),
                      _: 1
                    }, 8, ["onClick"])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]),
      _: 1
    });
  }

  // ../posawesome/posawesome/public/js/posapp/components/pos/ClosingDialog.vue
  ClosingDialog_default.render = render27;
  ClosingDialog_default.__file = "../posawesome/posawesome/public/js/posapp/components/pos/ClosingDialog.vue";
  ClosingDialog_default.__scopeId = "data-v-a28dc816";
  var ClosingDialog_default2 = ClosingDialog_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/NewAddress.vue?type=script
  var NewAddress_default = {
    data: () => ({
      addressDialog: false,
      address: {},
      customer: ""
    }),
    computed: {
      isDarkTheme() {
        return this.$theme.current === "dark";
      }
    },
    methods: {
      close_dialog() {
        this.addressDialog = false;
      },
      submit_dialog() {
        var vm2 = this;
        this.address.customer = this.customer;
        this.address.doctype = "Customer";
        frappe.call({
          method: "posawesome.posawesome.api.customers.make_address",
          args: {
            args: this.address
          },
          callback: (r) => {
            if (!r.exc) {
              vm2.eventBus.emit("add_the_new_address", r.message);
              vm2.eventBus.emit("show_message", {
                text: "Customer Address created successfully.",
                color: "success"
              });
              vm2.addressDialog = false;
              vm2.customer = "";
              vm2.address = {};
            }
          }
        });
      }
    },
    created: function() {
      this.eventBus.on("open_new_address", (data) => {
        this.addressDialog = true;
        this.customer = data;
      });
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/NewAddress.vue?type=template
  var _hoisted_146 = { class: "text-h5 text-primary" };
  function render28(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_card_title = resolveComponent("v-card-title");
    const _component_v_text_field = resolveComponent("v-text-field");
    const _component_v_col = resolveComponent("v-col");
    const _component_v_row = resolveComponent("v-row");
    const _component_v_container = resolveComponent("v-container");
    const _component_v_card_text = resolveComponent("v-card-text");
    const _component_v_spacer = resolveComponent("v-spacer");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_card_actions = resolveComponent("v-card-actions");
    const _component_v_card = resolveComponent("v-card");
    const _component_v_dialog = resolveComponent("v-dialog");
    return openBlock(), createBlock(_component_v_row, { justify: "center" }, {
      default: withCtx(() => [
        createVNode(_component_v_dialog, {
          modelValue: _ctx.addressDialog,
          "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => _ctx.addressDialog = $event),
          "max-width": "600px"
        }, {
          default: withCtx(() => [
            createVNode(_component_v_card, null, {
              default: withCtx(() => [
                createVNode(_component_v_card_title, null, {
                  default: withCtx(() => [
                    createBaseVNode("span", _hoisted_146, toDisplayString(_ctx.__("Add New Address")), 1)
                  ]),
                  _: 1
                }),
                createVNode(_component_v_card_text, { class: "pa-0" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_container, null, {
                      default: withCtx(() => [
                        createVNode(_component_v_row, null, {
                          default: withCtx(() => [
                            createVNode(_component_v_col, { cols: "12" }, {
                              default: withCtx(() => [
                                createVNode(_component_v_text_field, {
                                  density: "compact",
                                  color: "primary",
                                  label: _ctx.frappe._("Address Name"),
                                  "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                                  class: "dark-field",
                                  "hide-details": "",
                                  modelValue: _ctx.address.name,
                                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.address.name = $event)
                                }, null, 8, ["label", "bg-color", "modelValue"])
                              ]),
                              _: 1
                            }),
                            createVNode(_component_v_col, { cols: "12" }, {
                              default: withCtx(() => [
                                createVNode(_component_v_text_field, {
                                  density: "compact",
                                  color: "primary",
                                  label: _ctx.frappe._("Address Line 1"),
                                  "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                                  class: "dark-field",
                                  "hide-details": "",
                                  modelValue: _ctx.address.address_line1,
                                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.address.address_line1 = $event)
                                }, null, 8, ["label", "bg-color", "modelValue"])
                              ]),
                              _: 1
                            }),
                            createVNode(_component_v_col, { cols: "12" }, {
                              default: withCtx(() => [
                                createVNode(_component_v_text_field, {
                                  density: "compact",
                                  color: "primary",
                                  label: _ctx.frappe._("Address Line 2"),
                                  "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                                  class: "dark-field",
                                  "hide-details": "",
                                  modelValue: _ctx.address.address_line2,
                                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.address.address_line2 = $event)
                                }, null, 8, ["label", "bg-color", "modelValue"])
                              ]),
                              _: 1
                            }),
                            createVNode(_component_v_col, { cols: "6" }, {
                              default: withCtx(() => [
                                createVNode(_component_v_text_field, {
                                  label: "City",
                                  density: "compact",
                                  color: "primary",
                                  "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                                  class: "dark-field",
                                  "hide-details": "",
                                  modelValue: _ctx.address.city,
                                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.address.city = $event)
                                }, null, 8, ["bg-color", "modelValue"])
                              ]),
                              _: 1
                            }),
                            createVNode(_component_v_col, { cols: "6" }, {
                              default: withCtx(() => [
                                createVNode(_component_v_text_field, {
                                  label: "State",
                                  density: "compact",
                                  "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                                  class: "dark-field",
                                  "hide-details": "",
                                  modelValue: _ctx.address.state,
                                  "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.address.state = $event)
                                }, null, 8, ["bg-color", "modelValue"])
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                createVNode(_component_v_card_actions, null, {
                  default: withCtx(() => [
                    createVNode(_component_v_spacer),
                    createVNode(_component_v_btn, {
                      color: "error",
                      theme: "dark",
                      onClick: $options.close_dialog
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.__("Close")), 1)
                      ]),
                      _: 1
                    }, 8, ["onClick"]),
                    createVNode(_component_v_btn, {
                      color: "success",
                      theme: "dark",
                      onClick: $options.submit_dialog
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.__("Submit")), 1)
                      ]),
                      _: 1
                    }, 8, ["onClick"])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]),
      _: 1
    });
  }

  // ../posawesome/posawesome/public/js/posapp/components/pos/NewAddress.vue
  NewAddress_default.render = render28;
  NewAddress_default.__file = "../posawesome/posawesome/public/js/posapp/components/pos/NewAddress.vue";
  NewAddress_default.__scopeId = "data-v-96aa8cfb";
  var NewAddress_default2 = NewAddress_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/Variants.vue?type=script
  var Variants_default = {
    data: () => ({
      varaintsDialog: false,
      parentItem: null,
      items: null,
      filters: {},
      filterdItems: []
    }),
    computed: {
      variantsItems() {
        if (!this.parentItem) {
          return [];
        } else {
          return this.items.filter(
            (item) => item.variant_of == this.parentItem.item_code
          );
        }
      }
    },
    methods: {
      close_dialog() {
        this.varaintsDialog = false;
      },
      formatCurrency(value) {
        return this.$options.mixins[0].methods.formatCurrency.call(this, value, 2);
      },
      updateFiltredItems() {
        this.$nextTick(function() {
          const values = [];
          Object.entries(this.filters).forEach(([key, value]) => {
            if (value) {
              values.push(value);
            }
          });
          if (!values.length) {
            this.filterdItems = this.variantsItems;
          } else {
            const itemsList = [];
            this.filterdItems = [];
            this.variantsItems.forEach((item) => {
              let apply2 = true;
              item.item_attributes.forEach((attr) => {
                if (this.filters[attr.attribute] && this.filters[attr.attribute] != attr.attribute_value) {
                  apply2 = false;
                }
              });
              if (apply2 && !itemsList.includes(item.item_code)) {
                this.filterdItems.push(item);
                itemsList.push(item.item_code);
              }
            });
          }
        });
      },
      add_item(item) {
        this.eventBus.emit("add_item", item);
        this.close_dialog();
      }
    },
    created: function() {
      this.eventBus.on("open_variants_model", (item, items) => {
        this.varaintsDialog = true;
        this.parentItem = item || null;
        this.items = items;
        this.filters = {};
        this.$nextTick(function() {
          this.filterdItems = this.variantsItems;
        });
      });
    },
    beforeUnmount() {
      this.eventBus.off("open_variants_model");
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/Variants.vue?type=template
  var _hoisted_147 = /* @__PURE__ */ createBaseVNode("span", { class: "text-h5 text-primary" }, "Select Item", -1);
  var _hoisted_221 = { class: "text-caption text-primary accent-3" };
  function render29(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_spacer = resolveComponent("v-spacer");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_card_title = resolveComponent("v-card-title");
    const _component_v_chip = resolveComponent("v-chip");
    const _component_v_chip_group = resolveComponent("v-chip-group");
    const _component_v_divider = resolveComponent("v-divider");
    const _component_v_card_text = resolveComponent("v-card-text");
    const _component_v_img = resolveComponent("v-img");
    const _component_v_card = resolveComponent("v-card");
    const _component_v_col = resolveComponent("v-col");
    const _component_v_row = resolveComponent("v-row");
    const _component_v_container = resolveComponent("v-container");
    const _component_v_dialog = resolveComponent("v-dialog");
    return openBlock(), createBlock(_component_v_row, { justify: "center" }, {
      default: withCtx(() => [
        createVNode(_component_v_dialog, {
          modelValue: _ctx.varaintsDialog,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.varaintsDialog = $event),
          "max-width": "600px"
        }, {
          default: withCtx(() => [
            createVNode(_component_v_card, { "min-height": "500px" }, {
              default: withCtx(() => [
                createVNode(_component_v_card_title, null, {
                  default: withCtx(() => [
                    _hoisted_147,
                    createVNode(_component_v_spacer),
                    createVNode(_component_v_btn, {
                      color: "error",
                      theme: "dark",
                      onClick: $options.close_dialog
                    }, {
                      default: withCtx(() => [
                        createTextVNode("Close")
                      ]),
                      _: 1
                    }, 8, ["onClick"])
                  ]),
                  _: 1
                }),
                createVNode(_component_v_card_text, { class: "pa-0" }, {
                  default: withCtx(() => [
                    _ctx.parentItem ? (openBlock(), createBlock(_component_v_container, { key: 0 }, {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.parentItem.attributes, (attr) => {
                          return openBlock(), createElementBlock("div", {
                            key: attr.attribute
                          }, [
                            createVNode(_component_v_chip_group, {
                              modelValue: _ctx.filters[attr.attribute],
                              "onUpdate:modelValue": ($event) => _ctx.filters[attr.attribute] = $event,
                              "selected-class": "green--text text--accent-4",
                              column: ""
                            }, {
                              default: withCtx(() => [
                                (openBlock(true), createElementBlock(Fragment, null, renderList(attr.values, (value) => {
                                  return openBlock(), createBlock(_component_v_chip, {
                                    key: value.abbr,
                                    value: value.attribute_value,
                                    variant: "outlined",
                                    label: "",
                                    onClick: $options.updateFiltredItems
                                  }, {
                                    default: withCtx(() => [
                                      createTextVNode(toDisplayString(value.attribute_value), 1)
                                    ]),
                                    _: 2
                                  }, 1032, ["value", "onClick"]);
                                }), 128))
                              ]),
                              _: 2
                            }, 1032, ["modelValue", "onUpdate:modelValue"]),
                            createVNode(_component_v_divider, { class: "p-0 m-0" })
                          ]);
                        }), 128)),
                        createBaseVNode("div", null, [
                          createVNode(_component_v_row, {
                            density: "default",
                            class: "overflow-y-auto",
                            style: { "max-height": "500px" }
                          }, {
                            default: withCtx(() => [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filterdItems, (item, idx) => {
                                return openBlock(), createBlock(_component_v_col, {
                                  key: idx,
                                  xl: "2",
                                  lg: "3",
                                  md: "4",
                                  sm: "4",
                                  cols: "6",
                                  "min-height": "50"
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_v_card, {
                                      hover: "hover",
                                      onClick: ($event) => $options.add_item(item)
                                    }, {
                                      default: withCtx(() => [
                                        createVNode(_component_v_img, {
                                          src: item.image || "/assets/posawesome/js/posapp/components/pos/placeholder-image.png",
                                          class: "text-white align-end",
                                          gradient: "to bottom, rgba(0,0,0,.2), rgba(0,0,0,.7)",
                                          height: "100px"
                                        }, {
                                          default: withCtx(() => [
                                            createVNode(_component_v_card_text, {
                                              textContent: toDisplayString(item.item_name),
                                              class: "text-subtitle-2 px-1 pb-2"
                                            }, null, 8, ["textContent"])
                                          ]),
                                          _: 2
                                        }, 1032, ["src"]),
                                        createVNode(_component_v_card_text, { class: "text--primary pa-1" }, {
                                          default: withCtx(() => [
                                            createBaseVNode("div", _hoisted_221, toDisplayString(item.rate || 0) + " " + toDisplayString(item.currency || ""), 1)
                                          ]),
                                          _: 2
                                        }, 1024)
                                      ]),
                                      _: 2
                                    }, 1032, ["onClick"])
                                  ]),
                                  _: 2
                                }, 1024);
                              }), 128))
                            ]),
                            _: 1
                          })
                        ])
                      ]),
                      _: 1
                    })) : createCommentVNode("v-if", true)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]),
      _: 1
    });
  }

  // ../posawesome/posawesome/public/js/posapp/components/pos/Variants.vue
  Variants_default.render = render29;
  Variants_default.__file = "../posawesome/posawesome/public/js/posapp/components/pos/Variants.vue";
  var Variants_default2 = Variants_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/Returns.vue?type=script
  var Returns_default = {
    mixins: [format_default],
    data: () => ({
      invoicesDialog: false,
      singleSelect: true,
      selected: [],
      dialog_data: [],
      company: "",
      invoice_name: "",
      customer_name: "",
      customer_id: "",
      mobile_no: "",
      tax_id: "",
      from_date: null,
      to_date: null,
      from_date_formatted: null,
      to_date_formatted: null,
      min_amount: "",
      max_amount: "",
      pos_profile: "",
      page: 1,
      has_more_invoices: false,
      loading_more: false,
      searched_once: false,
      current_search_params: null,
      headers: [
        {
          title: __("Customer"),
          value: "customer",
          align: "start",
          sortable: true
        },
        {
          title: __("Date"),
          align: "start",
          sortable: true,
          value: "posting_date"
        },
        {
          title: __("Invoice"),
          value: "name",
          align: "start",
          sortable: true
        },
        {
          title: __("Amount"),
          value: "grand_total",
          align: "end",
          sortable: false
        }
      ]
    }),
    computed: {
      isDarkTheme() {
        var _a3;
        return ((_a3 = this.$theme) == null ? void 0 : _a3.current) === "dark";
      }
    },
    watch: {
      from_date() {
        this.formatFromDate();
      },
      to_date() {
        this.formatToDate();
      }
    },
    methods: {
      formatDateDisplay(dateStr) {
        if (!dateStr)
          return "";
        try {
          const parts = dateStr.split("-");
          if (parts.length === 3) {
            return `${parts[2]}-${parts[1]}-${parts[0]}`;
          }
        } catch (error) {
          console.error("Error formatting date:", error);
        }
        return dateStr;
      },
      formatFromDate() {
        if (this.from_date) {
          try {
            let dateString = "";
            if (typeof this.from_date === "object" && this.from_date instanceof Date) {
              const day = String(this.from_date.getDate()).padStart(2, "0");
              const month = String(this.from_date.getMonth() + 1).padStart(2, "0");
              const year = this.from_date.getFullYear();
              dateString = `${day}-${month}-${year}`;
            } else if (typeof this.from_date === "string" && this.from_date.includes("-")) {
              const parts = this.from_date.split("-");
              if (parts.length === 3) {
                dateString = `${parts[2]}-${parts[1]}-${parts[0]}`;
              } else {
                dateString = this.from_date;
              }
            } else {
              dateString = String(this.from_date);
            }
            this.from_date_formatted = dateString;
          } catch (error) {
            console.error("Error formatting from_date:", error);
            this.from_date_formatted = String(this.from_date);
          }
        } else {
          this.from_date_formatted = null;
        }
      },
      formatToDate() {
        if (this.to_date) {
          try {
            let dateString = "";
            if (typeof this.to_date === "object" && this.to_date instanceof Date) {
              const day = String(this.to_date.getDate()).padStart(2, "0");
              const month = String(this.to_date.getMonth() + 1).padStart(2, "0");
              const year = this.to_date.getFullYear();
              dateString = `${day}-${month}-${year}`;
            } else if (typeof this.to_date === "string" && this.to_date.includes("-")) {
              const parts = this.to_date.split("-");
              if (parts.length === 3) {
                dateString = `${parts[2]}-${parts[1]}-${parts[0]}`;
              } else {
                dateString = this.to_date;
              }
            } else {
              dateString = String(this.to_date);
            }
            this.to_date_formatted = dateString;
          } catch (error) {
            console.error("Error formatting to_date:", error);
            this.to_date_formatted = String(this.to_date);
          }
        } else {
          this.to_date_formatted = null;
        }
      },
      clearFromDate() {
        this.from_date = null;
        this.from_date_formatted = null;
      },
      clearToDate() {
        this.to_date = null;
        this.to_date_formatted = null;
      },
      close_dialog() {
        this.invoicesDialog = false;
      },
      clear_search() {
        this.invoice_name = "";
        this.customer_name = "";
        this.customer_id = "";
        this.mobile_no = "";
        this.tax_id = "";
        this.from_date = null;
        this.to_date = null;
        this.from_date_formatted = null;
        this.to_date_formatted = null;
        this.min_amount = "";
        this.max_amount = "";
        this.dialog_data = [];
        this.page = 1;
        this.has_more_invoices = false;
        this.searched_once = false;
      },
      search_invoices_by_enter(e) {
        if (e.keyCode === 13) {
          this.search_invoices();
        }
      },
      search_invoices() {
        this.page = 1;
        this.dialog_data = [];
        this.perform_search();
      },
      perform_search() {
        const vm2 = this;
        vm2.loading_more = true;
        let formattedFromDate = null;
        let formattedToDate = null;
        if (vm2.from_date) {
          if (typeof vm2.from_date === "object" && vm2.from_date instanceof Date) {
            formattedFromDate = [
              vm2.from_date.getFullYear(),
              String(vm2.from_date.getMonth() + 1).padStart(2, "0"),
              String(vm2.from_date.getDate()).padStart(2, "0")
            ].join("-");
          } else if (typeof vm2.from_date === "string") {
            if (vm2.from_date.includes("/")) {
              const parts = vm2.from_date.split("/");
              if (parts.length === 3) {
                formattedFromDate = `${parts[2]}-${parts[1]}-${parts[0]}`;
              }
            } else if (vm2.from_date.includes("-")) {
              const parts = vm2.from_date.split("-");
              if (parts.length === 3) {
                if (parts[0].length === 4) {
                  formattedFromDate = vm2.from_date;
                } else {
                  formattedFromDate = `${parts[2]}-${parts[1]}-${parts[0]}`;
                }
              }
            } else {
              formattedFromDate = null;
            }
          }
        }
        if (vm2.to_date) {
          if (typeof vm2.to_date === "object" && vm2.to_date instanceof Date) {
            formattedToDate = [
              vm2.to_date.getFullYear(),
              String(vm2.to_date.getMonth() + 1).padStart(2, "0"),
              String(vm2.to_date.getDate()).padStart(2, "0")
            ].join("-");
          } else if (typeof vm2.to_date === "string") {
            if (vm2.to_date.includes("/")) {
              const parts = vm2.to_date.split("/");
              if (parts.length === 3) {
                formattedToDate = `${parts[2]}-${parts[1]}-${parts[0]}`;
              }
            } else if (vm2.to_date.includes("-")) {
              const parts = vm2.to_date.split("-");
              if (parts.length === 3) {
                if (parts[0].length === 4) {
                  formattedToDate = vm2.to_date;
                } else {
                  formattedToDate = `${parts[2]}-${parts[1]}-${parts[0]}`;
                }
              }
            } else {
              formattedToDate = null;
            }
          }
        }
        let minAmount = vm2.min_amount ? parseFloat(vm2.min_amount) : null;
        let maxAmount = vm2.max_amount ? parseFloat(vm2.max_amount) : null;
        this.current_search_params = {
          invoice_name: vm2.invoice_name,
          customer_name: vm2.customer_name,
          customer_id: vm2.customer_id,
          mobile_no: vm2.mobile_no,
          tax_id: vm2.tax_id,
          from_date: formattedFromDate,
          to_date: formattedToDate,
          min_amount: minAmount,
          max_amount: maxAmount,
          company: vm2.company,
          page: vm2.page
        };
        frappe.call({
          method: "posawesome.posawesome.api.invoices.search_invoices_for_return",
          args: this.current_search_params,
          callback: function(r) {
            vm2.loading_more = false;
            vm2.searched_once = true;
            if (r.message) {
              if (vm2.page === 1) {
                vm2.dialog_data = r.message.invoices;
              } else {
                vm2.dialog_data = [...vm2.dialog_data, ...r.message.invoices];
              }
              vm2.has_more_invoices = r.message.has_more;
            } else {
              vm2.dialog_data = [];
              vm2.has_more_invoices = false;
              vm2.eventBus.emit("show_message", {
                title: __("No invoices found"),
                color: "warning"
              });
            }
          },
          error: function(err) {
            vm2.loading_more = false;
            console.error("Error searching invoices:", err);
            vm2.eventBus.emit("show_message", {
              title: __("Error searching invoices"),
              color: "error"
            });
          }
        });
      },
      load_more_invoices() {
        this.page += 1;
        this.perform_search();
      },
      return_without_invoice() {
        console.log("Starting return without invoice flow");
        const invoice_doc = {};
        invoice_doc.items = [];
        invoice_doc.is_return = 1;
        const data = { invoice_doc };
        console.log("Emitting load_return_invoice event with data:", data);
        this.eventBus.emit("load_return_invoice", data);
        this.invoicesDialog = false;
      },
      submit_dialog() {
        if (this.selected.length > 0) {
          console.log("Starting return with invoice flow");
          const return_doc = this.selected[0];
          const invoice_doc = {};
          const items = [];
          console.log("Original return doc:", return_doc);
          return_doc.items.forEach((item) => {
            const new_item = __spreadValues({}, item);
            new_item.sales_invoice_item = item.name;
            delete new_item.name;
            new_item.qty = item.qty > 0 ? item.qty * -1 : item.qty;
            new_item.stock_qty = item.stock_qty > 0 ? item.stock_qty * -1 : item.stock_qty;
            new_item.amount = item.amount > 0 ? item.amount * -1 : item.amount;
            items.push(new_item);
          });
          invoice_doc.items = items;
          invoice_doc.is_return = 1;
          invoice_doc.return_against = return_doc.name;
          invoice_doc.customer = return_doc.customer;
          if (return_doc.grand_total > 0) {
            invoice_doc.grand_total = return_doc.grand_total * -1;
          } else {
            invoice_doc.grand_total = return_doc.grand_total;
          }
          invoice_doc.update_stock = 1;
          invoice_doc.pos_profile = this.pos_profile.name;
          invoice_doc.company = this.company;
          const data = { invoice_doc, return_doc };
          console.log("Emitting load_return_invoice event with data:", data);
          this.eventBus.emit("load_return_invoice", data);
          this.invoicesDialog = false;
        }
      }
    },
    created: function() {
      this.eventBus.on("open_returns", (data) => {
        this.invoicesDialog = true;
        this.company = data;
        this.invoice_name = "";
        this.customer_name = "";
        this.customer_id = "";
        this.mobile_no = "";
        this.tax_id = "";
        this.from_date = null;
        this.to_date = null;
        this.from_date_formatted = null;
        this.to_date_formatted = null;
        this.min_amount = "";
        this.max_amount = "";
        this.dialog_data = [];
        this.selected = [];
        this.page = 1;
        this.has_more_invoices = false;
        this.searched_once = false;
      });
      this.eventBus.on("register_pos_profile", (data) => {
        this.pos_profile = data.pos_profile;
      });
    },
    beforeUnmount() {
      this.eventBus.off("open_returns");
      this.eventBus.off("register_pos_profile");
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/Returns.vue?type=template
  var _hoisted_148 = { class: "text-h5 text-primary" };
  var _hoisted_223 = {
    key: 0,
    class: "text-center mt-3"
  };
  function render30(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_card_title = resolveComponent("v-card-title");
    const _component_v_alert = resolveComponent("v-alert");
    const _component_v_col = resolveComponent("v-col");
    const _component_v_row = resolveComponent("v-row");
    const _component_v_text_field = resolveComponent("v-text-field");
    const _component_VueDatePicker = resolveComponent("VueDatePicker");
    const _component_v_divider = resolveComponent("v-divider");
    const _component_v_spacer = resolveComponent("v-spacer");
    const _component_v_icon = resolveComponent("v-icon");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_data_table = resolveComponent("v-data-table");
    const _component_v_container = resolveComponent("v-container");
    const _component_v_card_actions = resolveComponent("v-card-actions");
    const _component_v_card = resolveComponent("v-card");
    const _component_v_dialog = resolveComponent("v-dialog");
    return openBlock(), createBlock(_component_v_row, { justify: "center" }, {
      default: withCtx(() => [
        createVNode(_component_v_dialog, {
          modelValue: _ctx.invoicesDialog,
          "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => _ctx.invoicesDialog = $event),
          "max-width": "800px",
          "min-width": "800px"
        }, {
          default: withCtx(() => [
            createVNode(_component_v_card, null, {
              default: withCtx(() => [
                createVNode(_component_v_card_title, null, {
                  default: withCtx(() => [
                    createBaseVNode("span", _hoisted_148, toDisplayString(_ctx.__("Select Return Invoice")), 1)
                  ]),
                  _: 1
                }),
                createVNode(_component_v_container, null, {
                  default: withCtx(() => [
                    createCommentVNode(" Invoice ID and Date Range search "),
                    createVNode(_component_v_row, { class: "mb-2" }, {
                      default: withCtx(() => [
                        createVNode(_component_v_col, { cols: "12" }, {
                          default: withCtx(() => [
                            !_ctx.from_date && !_ctx.to_date ? (openBlock(), createBlock(_component_v_alert, {
                              key: 0,
                              dense: "",
                              type: "info",
                              text: "",
                              outlined: ""
                            }, {
                              default: withCtx(() => [
                                createBaseVNode("small", null, toDisplayString(_ctx.__("Use date range to search for older invoices")), 1)
                              ]),
                              _: 1
                            })) : createCommentVNode("v-if", true)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    createVNode(_component_v_row, { class: "mb-3" }, {
                      default: withCtx(() => [
                        createVNode(_component_v_col, {
                          cols: "12",
                          sm: "6"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_text_field, {
                              color: "primary",
                              label: _ctx.frappe._("Invoice ID"),
                              "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                              class: "dark-field",
                              "hide-details": "",
                              modelValue: _ctx.invoice_name,
                              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.invoice_name = $event),
                              density: "compact",
                              clearable: ""
                            }, null, 8, ["label", "bg-color", "modelValue"])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_v_col, {
                          cols: "12",
                          sm: "3"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_VueDatePicker, {
                              modelValue: _ctx.from_date,
                              "onUpdate:modelValue": [
                                _cache[1] || (_cache[1] = ($event) => _ctx.from_date = $event),
                                _cache[2] || (_cache[2] = ($event) => $options.formatFromDate())
                              ],
                              "model-type": "format",
                              format: "dd-MM-yyyy",
                              "enable-time-picker": false,
                              "auto-apply": "",
                              dark: $options.isDarkTheme
                            }, null, 8, ["modelValue", "dark"])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_v_col, {
                          cols: "12",
                          sm: "3"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_VueDatePicker, {
                              modelValue: _ctx.to_date,
                              "onUpdate:modelValue": [
                                _cache[3] || (_cache[3] = ($event) => _ctx.to_date = $event),
                                _cache[4] || (_cache[4] = ($event) => $options.formatToDate())
                              ],
                              "model-type": "format",
                              format: "dd-MM-yyyy",
                              "enable-time-picker": false,
                              "auto-apply": "",
                              dark: $options.isDarkTheme
                            }, null, 8, ["modelValue", "dark"])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    createCommentVNode(" Customer search fields "),
                    createVNode(_component_v_row, { class: "mb-2" }, {
                      default: withCtx(() => [
                        createVNode(_component_v_col, {
                          cols: "12",
                          sm: "6"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_text_field, {
                              color: "primary",
                              label: _ctx.frappe._("Customer Name"),
                              "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                              class: "dark-field",
                              "hide-details": "",
                              modelValue: _ctx.customer_name,
                              "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => _ctx.customer_name = $event),
                              density: "compact",
                              clearable: ""
                            }, null, 8, ["label", "bg-color", "modelValue"])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_v_col, {
                          cols: "12",
                          sm: "6"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_text_field, {
                              color: "primary",
                              label: _ctx.frappe._("Customer ID"),
                              "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                              class: "dark-field",
                              "hide-details": "",
                              modelValue: _ctx.customer_id,
                              "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => _ctx.customer_id = $event),
                              density: "compact",
                              clearable: ""
                            }, null, 8, ["label", "bg-color", "modelValue"])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    createVNode(_component_v_row, { class: "mb-3" }, {
                      default: withCtx(() => [
                        createVNode(_component_v_col, {
                          cols: "12",
                          sm: "6"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_text_field, {
                              color: "primary",
                              label: _ctx.frappe._("Mobile Number"),
                              "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                              class: "dark-field",
                              "hide-details": "",
                              modelValue: _ctx.mobile_no,
                              "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => _ctx.mobile_no = $event),
                              density: "compact",
                              clearable: ""
                            }, null, 8, ["label", "bg-color", "modelValue"])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_v_col, {
                          cols: "12",
                          sm: "6"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_text_field, {
                              color: "primary",
                              label: _ctx.frappe._("Tax ID"),
                              "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                              class: "dark-field",
                              "hide-details": "",
                              modelValue: _ctx.tax_id,
                              "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => _ctx.tax_id = $event),
                              density: "compact",
                              clearable: ""
                            }, null, 8, ["label", "bg-color", "modelValue"])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    createCommentVNode(" Amount Filter "),
                    createVNode(_component_v_row, { class: "mb-3" }, {
                      default: withCtx(() => [
                        createVNode(_component_v_col, {
                          cols: "12",
                          sm: "6"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_text_field, {
                              color: "primary",
                              label: _ctx.frappe._("Minimum Amount"),
                              "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                              class: "dark-field",
                              "hide-details": "",
                              modelValue: _ctx.min_amount,
                              "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => _ctx.min_amount = $event),
                              density: "compact",
                              clearable: "",
                              type: "number",
                              min: "0",
                              placeholder: "0"
                            }, null, 8, ["label", "bg-color", "modelValue"])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_v_col, {
                          cols: "12",
                          sm: "6"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_text_field, {
                              color: "primary",
                              label: _ctx.frappe._("Maximum Amount"),
                              "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                              class: "dark-field",
                              "hide-details": "",
                              modelValue: _ctx.max_amount,
                              "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => _ctx.max_amount = $event),
                              density: "compact",
                              clearable: "",
                              type: "number",
                              min: "0",
                              placeholder: "No limit"
                            }, null, 8, ["label", "bg-color", "modelValue"])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    createVNode(_component_v_row, null, {
                      default: withCtx(() => [
                        createVNode(_component_v_col, {
                          cols: "12",
                          class: "pt-0 pb-0"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_divider)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    createCommentVNode(" Action buttons "),
                    createVNode(_component_v_row, { class: "mt-2 mb-2" }, {
                      default: withCtx(() => [
                        createVNode(_component_v_spacer),
                        createVNode(_component_v_btn, {
                          variant: "text",
                          class: "ml-2",
                          color: "primary",
                          theme: "dark",
                          onClick: $options.search_invoices
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_icon, { left: "" }, {
                              default: withCtx(() => [
                                createTextVNode("mdi-magnify")
                              ]),
                              _: 1
                            }),
                            createTextVNode(" " + toDisplayString(_ctx.__("Search")), 1)
                          ]),
                          _: 1
                        }, 8, ["onClick"]),
                        createVNode(_component_v_btn, {
                          variant: "text",
                          class: "ml-2",
                          color: "warning",
                          theme: "dark",
                          onClick: $options.clear_search
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_icon, { left: "" }, {
                              default: withCtx(() => [
                                createTextVNode("mdi-refresh")
                              ]),
                              _: 1
                            }),
                            createTextVNode(" " + toDisplayString(_ctx.__("Clear")), 1)
                          ]),
                          _: 1
                        }, 8, ["onClick"]),
                        _ctx.pos_profile.posa_allow_return_without_invoice == 1 ? (openBlock(), createBlock(_component_v_btn, {
                          key: 0,
                          variant: "text",
                          class: "ml-2",
                          color: "secondary",
                          theme: "dark",
                          onClick: $options.return_without_invoice
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(_ctx.__("Return without Invoice")), 1)
                          ]),
                          _: 1
                        }, 8, ["onClick"])) : createCommentVNode("v-if", true)
                      ]),
                      _: 1
                    }),
                    createCommentVNode(" Results "),
                    createVNode(_component_v_row, null, {
                      default: withCtx(() => [
                        _ctx.dialog_data && _ctx.dialog_data.length > 0 ? (openBlock(), createBlock(_component_v_col, {
                          key: 0,
                          cols: "12",
                          class: "pa-0 mt-1"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_data_table, {
                              headers: _ctx.headers,
                              items: _ctx.dialog_data,
                              "item-key": "name",
                              class: "elevation-1",
                              "show-select": "",
                              modelValue: _ctx.selected,
                              "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => _ctx.selected = $event),
                              "select-strategy": "single",
                              "return-object": "",
                              "footer-props": {
                                "items-per-page-options": [10, 25, 50, 100],
                                "items-per-page-text": "Invoices per page"
                              },
                              "items-per-page": 25
                            }, {
                              "item.posting_date": withCtx(({ item }) => [
                                createTextVNode(toDisplayString($options.formatDateDisplay(item.posting_date)), 1)
                              ]),
                              "item.grand_total": withCtx(({ item }) => [
                                createTextVNode(toDisplayString(_ctx.currencySymbol(item.currency)) + " " + toDisplayString(_ctx.formatCurrency(item.grand_total)), 1)
                              ]),
                              _: 1
                            }, 8, ["headers", "items", "modelValue"]),
                            createCommentVNode(" Load More button at the bottom of results "),
                            _ctx.has_more_invoices ? (openBlock(), createElementBlock("div", _hoisted_223, [
                              createVNode(_component_v_btn, {
                                color: "primary",
                                text: "",
                                outlined: "",
                                loading: _ctx.loading_more,
                                onClick: $options.load_more_invoices
                              }, {
                                default: withCtx(() => [
                                  createTextVNode(toDisplayString(_ctx.__("Load More Invoices")), 1)
                                ]),
                                _: 1
                              }, 8, ["loading", "onClick"])
                            ])) : createCommentVNode("v-if", true)
                          ]),
                          _: 1
                        })) : _ctx.searched_once && (!_ctx.dialog_data || _ctx.dialog_data.length === 0) ? (openBlock(), createBlock(_component_v_col, {
                          key: 1,
                          cols: "12",
                          class: "text-center"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_alert, {
                              type: "warning",
                              text: ""
                            }, {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString(_ctx.__("No invoices found. Try different search criteria.")), 1)
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })) : createCommentVNode("v-if", true)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                createVNode(_component_v_card_actions, { class: "mt-1" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_spacer),
                    createVNode(_component_v_btn, {
                      color: "error mx-2",
                      theme: "dark",
                      onClick: $options.close_dialog
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.__("Close")), 1)
                      ]),
                      _: 1
                    }, 8, ["onClick"]),
                    _ctx.selected.length ? (openBlock(), createBlock(_component_v_btn, {
                      key: 0,
                      color: "success",
                      theme: "dark",
                      onClick: $options.submit_dialog
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.__("Select")), 1)
                      ]),
                      _: 1
                    }, 8, ["onClick"])) : createCommentVNode("v-if", true)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]),
      _: 1
    });
  }

  // ../posawesome/posawesome/public/js/posapp/components/pos/Returns.vue
  Returns_default.render = render30;
  Returns_default.__file = "../posawesome/posawesome/public/js/posapp/components/pos/Returns.vue";
  var Returns_default2 = Returns_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/Mpesa-Payments.vue?type=script
  var Mpesa_Payments_default = {
    data: () => ({
      dialog: false,
      singleSelect: true,
      selected: [],
      dialog_data: "",
      company: "",
      customer: "",
      mode_of_payment: "",
      full_name: "",
      mobile_no: "",
      headers: [
        {
          title: __("Full Name"),
          value: "full_name",
          align: "start",
          sortable: true
        },
        {
          title: __("Mobile No"),
          value: "mobile_no",
          align: "start",
          sortable: true
        },
        {
          title: __("Amount"),
          value: "amount",
          align: "start",
          sortable: true
        },
        {
          title: __("Date"),
          align: "start",
          sortable: true,
          value: "posting_date"
        }
      ]
    }),
    watch: {},
    methods: {
      close_dialog() {
        this.dialog = false;
      },
      search_by_enter(e) {
        if (e.keyCode === 13) {
          this.search();
        }
      },
      search() {
        const vm2 = this;
        frappe.call({
          method: "posawesome.posawesome.api.m_pesa.get_mpesa_draft_payments",
          args: {
            company: this.company,
            mode_of_payment: this.mode_of_payment,
            mobile_no: this.mobile_no,
            full_name: this.full_name
          },
          async: false,
          callback: function(r) {
            if (!r.exc) {
              vm2.dialog_data = r.message;
            }
          }
        });
      },
      submit_dialog() {
        var vm2 = this;
        if (this.selected.length > 0) {
          const selected_payment = this.selected[0].name;
          frappe.call({
            method: "posawesome.posawesome.api.m_pesa.submit_mpesa_payment",
            args: {
              mpesa_payment: selected_payment,
              customer: this.customer
            },
            async: false,
            callback: function(r) {
              if (!r.exc) {
                vm2.eventBus.emit("set_mpesa_payment", r.message);
                vm2.dialog = false;
              }
            }
          });
        }
      },
      formatCurrency(value) {
        return this.$options.mixins[0].methods.formatCurrency.call(this, value, 2);
      }
    },
    created: function() {
      this.eventBus.on("open_mpesa_payments", (data) => {
        this.dialog = true;
        this.full_name = "";
        this.mobile_no = "";
        this.company = data.company;
        this.customer = data.customer;
        this.mode_of_payment = data.mode_of_payment;
        this.dialog_data = "";
        this.selected = [];
      });
    },
    beforeUnmount() {
      this.eventBus.off("open_mpesa_payments");
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/Mpesa-Payments.vue?type=template
  var _hoisted_149 = { class: "text-h5 text-primary" };
  function render31(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_card_title = resolveComponent("v-card-title");
    const _component_v_text_field = resolveComponent("v-text-field");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_row = resolveComponent("v-row");
    const _component_v_data_table = resolveComponent("v-data-table");
    const _component_v_col = resolveComponent("v-col");
    const _component_v_container = resolveComponent("v-container");
    const _component_v_spacer = resolveComponent("v-spacer");
    const _component_v_card_actions = resolveComponent("v-card-actions");
    const _component_v_card = resolveComponent("v-card");
    const _component_v_dialog = resolveComponent("v-dialog");
    return openBlock(), createBlock(_component_v_row, { justify: "center" }, {
      default: withCtx(() => [
        createVNode(_component_v_dialog, {
          modelValue: _ctx.dialog,
          "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.dialog = $event),
          "max-width": "800px",
          "min-width": "800px"
        }, {
          default: withCtx(() => [
            createVNode(_component_v_card, null, {
              default: withCtx(() => [
                createVNode(_component_v_card_title, null, {
                  default: withCtx(() => [
                    createBaseVNode("span", _hoisted_149, toDisplayString(_ctx.__("Select Payment")), 1)
                  ]),
                  _: 1
                }),
                createVNode(_component_v_container, null, {
                  default: withCtx(() => [
                    createVNode(_component_v_row, { class: "mb-4" }, {
                      default: withCtx(() => [
                        createVNode(_component_v_text_field, {
                          color: "primary",
                          label: _ctx.frappe._("Full Name"),
                          "bg-color": "white",
                          "hide-details": "",
                          modelValue: _ctx.full_name,
                          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.full_name = $event),
                          density: "compact",
                          clearable: "",
                          class: "mx-4"
                        }, null, 8, ["label", "modelValue"]),
                        createVNode(_component_v_text_field, {
                          color: "primary",
                          label: _ctx.frappe._("Mobile No"),
                          "bg-color": "white",
                          "hide-details": "",
                          modelValue: _ctx.mobile_no,
                          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.mobile_no = $event),
                          density: "compact",
                          clearable: "",
                          class: "mx-4"
                        }, null, 8, ["label", "modelValue"]),
                        createVNode(_component_v_btn, {
                          variant: "text",
                          class: "ml-2",
                          color: "primary",
                          theme: "dark",
                          onClick: $options.search
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(_ctx.__("Search")), 1)
                          ]),
                          _: 1
                        }, 8, ["onClick"])
                      ]),
                      _: 1
                    }),
                    createVNode(_component_v_row, null, {
                      default: withCtx(() => [
                        _ctx.dialog_data ? (openBlock(), createBlock(_component_v_col, {
                          key: 0,
                          cols: "12",
                          class: "pa-1"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_data_table, {
                              headers: _ctx.headers,
                              items: _ctx.dialog_data,
                              "item-key": "name",
                              class: "elevation-1",
                              "show-select": "",
                              modelValue: _ctx.selected,
                              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.selected = $event),
                              "return-object": "",
                              "select-strategy": "single"
                            }, {
                              "item.amount": withCtx(({ item }) => [
                                createTextVNode(toDisplayString($options.formatCurrency(item.amount)), 1)
                              ]),
                              "item.posting_date": withCtx(({ item }) => [
                                createTextVNode(toDisplayString(item.posting_date.slice(0, 16)), 1)
                              ]),
                              _: 1
                            }, 8, ["headers", "items", "modelValue"])
                          ]),
                          _: 1
                        })) : createCommentVNode("v-if", true)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                createVNode(_component_v_card_actions, { class: "mt-4" }, {
                  default: withCtx(() => [
                    createVNode(_component_v_spacer),
                    createVNode(_component_v_btn, {
                      color: "error mx-2",
                      theme: "dark",
                      onClick: $options.close_dialog
                    }, {
                      default: withCtx(() => [
                        createTextVNode("Close")
                      ]),
                      _: 1
                    }, 8, ["onClick"]),
                    _ctx.selected.length ? (openBlock(), createBlock(_component_v_btn, {
                      key: 0,
                      color: "success",
                      theme: "dark",
                      onClick: $options.submit_dialog
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.__("Submit")), 1)
                      ]),
                      _: 1
                    }, 8, ["onClick"])) : createCommentVNode("v-if", true)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]),
      _: 1
    });
  }

  // ../posawesome/posawesome/public/js/posapp/components/pos/Mpesa-Payments.vue
  Mpesa_Payments_default.render = render31;
  Mpesa_Payments_default.__file = "../posawesome/posawesome/public/js/posapp/components/pos/Mpesa-Payments.vue";
  var Mpesa_Payments_default2 = Mpesa_Payments_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/Pos.vue?type=script
  var Pos_default = {
    mixins: [responsiveMixin],
    data: function() {
      return {
        dialog: false,
        pos_profile: "",
        pos_opening_shift: "",
        payment: false,
        offers: false,
        coupons: false
      };
    },
    components: {
      ItemsSelector: ItemsSelector_default2,
      Invoice: Invoice_default2,
      OpeningDialog: OpeningDialog_default2,
      Payments: Payments_default2,
      Drafts: Drafts_default2,
      ClosingDialog: ClosingDialog_default2,
      Returns: Returns_default2,
      PosOffers: PosOffers_default2,
      PosCoupons: PosCoupons_default2,
      NewAddress: NewAddress_default2,
      Variants: Variants_default2,
      MpesaPayments: Mpesa_Payments_default2,
      SalesOrders: SalesOrders_default2
    },
    methods: {
      async check_opening_entry() {
        await initPromise;
        return frappe.call("posawesome.posawesome.api.shifts.check_opening_shift", {
          user: frappe.session.user
        }).then((r) => {
          if (r.message) {
            this.pos_profile = r.message.pos_profile;
            this.pos_opening_shift = r.message.pos_opening_shift;
            this.get_offers(this.pos_profile.name);
            this.eventBus.emit("register_pos_profile", r.message);
            this.eventBus.emit("set_company", r.message.company);
            try {
              frappe.realtime.emit("pos_profile_registered");
            } catch (e) {
              console.warn("Realtime emit failed", e);
            }
            console.info("LoadPosProfile");
            try {
              setOpeningStorage(r.message);
            } catch (e) {
              console.error("Failed to cache opening data", e);
            }
          } else {
            const data = getOpeningStorage();
            if (data) {
              this.pos_profile = data.pos_profile;
              this.pos_opening_shift = data.pos_opening_shift;
              this.get_offers(this.pos_profile.name);
              this.eventBus.emit("register_pos_profile", data);
              this.eventBus.emit("set_company", data.company);
              try {
                frappe.realtime.emit("pos_profile_registered");
              } catch (e) {
                console.warn("Realtime emit failed", e);
              }
              console.info("LoadPosProfile (cached)");
              return;
            }
            this.create_opening_voucher();
          }
        }).catch(() => {
          const data = getOpeningStorage();
          if (data) {
            this.pos_profile = data.pos_profile;
            this.pos_opening_shift = data.pos_opening_shift;
            this.get_offers(this.pos_profile.name);
            this.eventBus.emit("register_pos_profile", data);
            this.eventBus.emit("set_company", data.company);
            try {
              frappe.realtime.emit("pos_profile_registered");
            } catch (e) {
              console.warn("Realtime emit failed", e);
            }
            console.info("LoadPosProfile (cached)");
            return;
          }
          this.create_opening_voucher();
        });
      },
      create_opening_voucher() {
        this.dialog = true;
      },
      get_closing_data() {
        return frappe.call(
          "posawesome.posawesome.doctype.pos_closing_shift.pos_closing_shift.make_closing_shift_from_opening",
          {
            opening_shift: this.pos_opening_shift
          }
        ).then((r) => {
          if (r.message) {
            this.eventBus.emit("open_ClosingDialog", r.message);
          } else {
          }
        });
      },
      submit_closing_pos(data) {
        frappe.call(
          "posawesome.posawesome.doctype.pos_closing_shift.pos_closing_shift.submit_closing_shift",
          {
            closing_shift: data
          }
        ).then((r) => {
          if (r.message) {
            this.pos_opening_shift = null;
            this.pos_profile = null;
            clearOpeningStorage();
            this.eventBus.emit("show_message", {
              title: `POS Shift Closed`,
              color: "success"
            });
            this.check_opening_entry();
          } else {
            console.log(r);
          }
        });
      },
      get_offers(pos_profile) {
        if (this.pos_profile && this.pos_profile.posa_local_storage) {
          const cached = getCachedOffers();
          if (cached.length) {
            this.eventBus.emit("set_offers", cached);
          }
        }
        return frappe.call("posawesome.posawesome.api.offers.get_offers", {
          profile: pos_profile
        }).then((r) => {
          if (r.message) {
            console.info("LoadOffers");
            saveOffers(r.message);
            this.eventBus.emit("set_offers", r.message);
          }
        }).catch((err) => {
          console.error("Failed to fetch offers:", err);
          const cached = getCachedOffers();
          if (cached.length) {
            this.eventBus.emit("set_offers", cached);
          }
        });
      },
      get_pos_setting() {
        frappe.db.get_doc("POS Settings", void 0).then((doc2) => {
          this.eventBus.emit("set_pos_settings", doc2);
        });
      }
    },
    mounted: function() {
      this.$nextTick(function() {
        this.check_opening_entry();
        this.get_pos_setting();
        this.eventBus.on("close_opening_dialog", () => {
          this.dialog = false;
        });
        this.eventBus.on("register_pos_data", (data) => {
          this.pos_profile = data.pos_profile;
          this.get_offers(this.pos_profile.name);
          this.pos_opening_shift = data.pos_opening_shift;
          this.eventBus.emit("register_pos_profile", data);
          console.info("LoadPosProfile");
        });
        this.eventBus.on("show_payment", (data) => {
          this.payment = true ? data === "true" : false;
          this.offers = false ? data === "true" : false;
          this.coupons = false ? data === "true" : false;
        });
        this.eventBus.on("show_offers", (data) => {
          this.offers = true ? data === "true" : false;
          this.payment = false ? data === "true" : false;
          this.coupons = false ? data === "true" : false;
        });
        this.eventBus.on("show_coupons", (data) => {
          this.coupons = true ? data === "true" : false;
          this.offers = false ? data === "true" : false;
          this.payment = false ? data === "true" : false;
        });
        this.eventBus.on("open_closing_dialog", () => {
          this.get_closing_data();
        });
        this.eventBus.on("submit_closing_pos", (data) => {
          this.submit_closing_pos(data);
        });
      });
    },
    beforeUnmount() {
      this.eventBus.off("close_opening_dialog");
      this.eventBus.off("register_pos_data");
      this.eventBus.off("LoadPosProfile");
      this.eventBus.off("show_offers");
      this.eventBus.off("show_coupons");
      this.eventBus.off("open_closing_dialog");
      this.eventBus.off("submit_closing_pos");
    },
    created() {
      clearExpiredCustomerBalances();
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/pos/Pos.vue?type=template
  function render32(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ClosingDialog = resolveComponent("ClosingDialog");
    const _component_Drafts = resolveComponent("Drafts");
    const _component_SalesOrders = resolveComponent("SalesOrders");
    const _component_Returns = resolveComponent("Returns");
    const _component_NewAddress = resolveComponent("NewAddress");
    const _component_MpesaPayments = resolveComponent("MpesaPayments");
    const _component_Variants = resolveComponent("Variants");
    const _component_OpeningDialog = resolveComponent("OpeningDialog");
    const _component_ItemsSelector = resolveComponent("ItemsSelector");
    const _component_v_col = resolveComponent("v-col");
    const _component_PosOffers = resolveComponent("PosOffers");
    const _component_PosCoupons = resolveComponent("PosCoupons");
    const _component_Payments = resolveComponent("Payments");
    const _component_Invoice = resolveComponent("Invoice");
    const _component_v_row = resolveComponent("v-row");
    return openBlock(), createElementBlock("div", {
      class: "pos-main-container dynamic-container",
      style: normalizeStyle(_ctx.responsiveStyles)
    }, [
      createVNode(_component_ClosingDialog),
      createVNode(_component_Drafts),
      createVNode(_component_SalesOrders),
      createVNode(_component_Returns),
      createVNode(_component_NewAddress),
      createVNode(_component_MpesaPayments),
      createVNode(_component_Variants),
      _ctx.dialog ? (openBlock(), createBlock(_component_OpeningDialog, {
        key: 0,
        dialog: _ctx.dialog
      }, null, 8, ["dialog"])) : createCommentVNode("v-if", true),
      withDirectives(createVNode(_component_v_row, {
        dense: "",
        class: "ma-0 dynamic-main-row"
      }, {
        default: withCtx(() => [
          withDirectives(createVNode(_component_v_col, {
            xl: "5",
            lg: "5",
            md: "5",
            sm: "5",
            cols: "12",
            class: "pos dynamic-col"
          }, {
            default: withCtx(() => [
              createVNode(_component_ItemsSelector)
            ]),
            _: 1
          }, 512), [
            [vShow, !_ctx.payment && !_ctx.offers && !_ctx.coupons]
          ]),
          withDirectives(createVNode(_component_v_col, {
            xl: "5",
            lg: "5",
            md: "5",
            sm: "5",
            cols: "12",
            class: "pos dynamic-col"
          }, {
            default: withCtx(() => [
              createVNode(_component_PosOffers)
            ]),
            _: 1
          }, 512), [
            [vShow, _ctx.offers]
          ]),
          withDirectives(createVNode(_component_v_col, {
            xl: "5",
            lg: "5",
            md: "5",
            sm: "5",
            cols: "12",
            class: "pos dynamic-col"
          }, {
            default: withCtx(() => [
              createVNode(_component_PosCoupons)
            ]),
            _: 1
          }, 512), [
            [vShow, _ctx.coupons]
          ]),
          withDirectives(createVNode(_component_v_col, {
            xl: "5",
            lg: "5",
            md: "5",
            sm: "5",
            cols: "12",
            class: "pos dynamic-col"
          }, {
            default: withCtx(() => [
              createVNode(_component_Payments)
            ]),
            _: 1
          }, 512), [
            [vShow, _ctx.payment]
          ]),
          createVNode(_component_v_col, {
            xl: "7",
            lg: "7",
            md: "7",
            sm: "7",
            cols: "12",
            class: "pos dynamic-col"
          }, {
            default: withCtx(() => [
              createVNode(_component_Invoice)
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 512), [
        [vShow, !_ctx.dialog]
      ])
    ], 4);
  }

  // ../posawesome/posawesome/public/js/posapp/components/pos/Pos.vue
  Pos_default.render = render32;
  Pos_default.__file = "../posawesome/posawesome/public/js/posapp/components/pos/Pos.vue";
  Pos_default.__scopeId = "data-v-d5091f4d";
  var Pos_default2 = Pos_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/payments/Pay.vue?type=script
  var Pay_default = {
    mixins: [format_default],
    data: function() {
      return {
        dialog: false,
        pos_profile: "",
        pos_opening_shift: "",
        customer_name: "",
        customer_info: "",
        company: "",
        singleSelect: true,
        invoices_loading: false,
        unallocated_payments_loading: false,
        mpesa_payments_loading: false,
        payment_methods: [],
        outstanding_invoices: [],
        unallocated_payments: [],
        mpesa_payments: [],
        selected_invoices: [],
        selected_payments: [],
        selected_mpesa_payments: [],
        pos_profiles_list: [],
        pos_profile_search: "",
        payment_methods_list: [],
        mpesa_searchname: "",
        mpesa_search_mobile: "",
        invoices_headers: [
          {
            title: "",
            align: "start",
            sortable: false,
            key: "actions",
            width: "50px"
          },
          {
            title: __("Invoice"),
            align: "start",
            sortable: true,
            key: "voucher_no"
          },
          {
            title: __("Customer"),
            align: "start",
            sortable: true,
            key: "customer_name"
          },
          {
            title: __("Date"),
            align: "start",
            sortable: true,
            key: "posting_date"
          },
          {
            title: __("Due Date"),
            align: "start",
            sortable: true,
            key: "due_date"
          },
          {
            title: __("Total"),
            align: "end",
            sortable: true,
            key: "invoice_amount"
          },
          {
            title: __("Outstanding"),
            align: "end",
            sortable: true,
            key: "outstanding_amount"
          }
        ],
        unallocated_payments_headers: [
          {
            title: "",
            align: "center",
            sortable: false,
            key: "select",
            width: "50px"
          },
          {
            title: __("Payment ID"),
            align: "start",
            sortable: true,
            key: "name"
          },
          {
            title: __("Customer"),
            align: "start",
            sortable: true,
            key: "customer_name"
          },
          {
            title: __("Date"),
            align: "start",
            sortable: true,
            key: "posting_date"
          },
          {
            title: __("Mode"),
            align: "start",
            sortable: true,
            key: "mode_of_payment"
          },
          {
            title: __("Paid"),
            align: "end",
            sortable: true,
            key: "paid_amount"
          },
          {
            title: __("Unallocated"),
            align: "end",
            sortable: true,
            key: "unallocated_amount"
          }
        ],
        mpesa_payment_headers: [
          {
            title: __("Payment ID"),
            align: "start",
            sortable: true,
            key: "transid"
          },
          {
            title: __("Full Name"),
            align: "start",
            sortable: true,
            key: "full_name"
          },
          {
            title: __("Nobile Number"),
            align: "start",
            sortable: true,
            key: "mobile_no"
          },
          {
            title: __("Date"),
            align: "start",
            sortable: true,
            key: "posting_date"
          },
          {
            title: __("Amount"),
            align: "end",
            sortable: true,
            key: "amount"
          }
        ],
        isSubmitting: false
      };
    },
    components: {
      Customer: Customer_default2,
      UpdateCustomer: UpdateCustomer_default2
    },
    methods: {
      async check_opening_entry() {
        var vm2 = this;
        await initPromise;
        return frappe.call("posawesome.posawesome.api.shifts.check_opening_shift", {
          user: frappe.session.user
        }).then((r) => {
          if (r.message) {
            this.pos_profile = r.message.pos_profile;
            this.pos_opening_shift = r.message.pos_opening_shift;
            this.company = r.message.company.name;
            vm2.eventBus.emit("payments_register_pos_profile", r.message);
            vm2.eventBus.emit("set_company", r.message.company);
            this.set_payment_methods();
            try {
              setOpeningStorage(r.message);
            } catch (e) {
              console.error("Failed to cache opening data", e);
            }
            this.pos_profile_search = "";
            this.pos_profiles_list = [];
            if (r.message.pos_profile && r.message.pos_profile.name) {
              this.pos_profiles_list.push(r.message.pos_profile.name);
            }
            this.payment_methods_list = [];
            this.pos_profile.payments.forEach((element) => {
              this.payment_methods_list.push(element.mode_of_payment);
            });
            this.get_available_pos_profiles();
            this.get_outstanding_invoices();
            this.get_draft_mpesa_payments_register();
          } else {
            const data = getOpeningStorage();
            if (data) {
              this.pos_profile = data.pos_profile;
              this.pos_opening_shift = data.pos_opening_shift;
              this.company = data.company.name;
              vm2.eventBus.emit("payments_register_pos_profile", data);
              vm2.eventBus.emit("set_company", data.company);
              this.set_payment_methods();
              this.payment_methods_list = [];
              this.pos_profile.payments.forEach((element) => {
                this.payment_methods_list.push(element.mode_of_payment);
              });
              this.get_available_pos_profiles();
              this.get_outstanding_invoices();
              this.get_draft_mpesa_payments_register();
              return;
            }
            this.create_opening_voucher();
          }
        }).catch(() => {
          const data = getOpeningStorage();
          if (data) {
            this.pos_profile = data.pos_profile;
            this.pos_opening_shift = data.pos_opening_shift;
            this.company = data.company.name;
            vm2.eventBus.emit("payments_register_pos_profile", data);
            vm2.eventBus.emit("set_company", data.company);
            this.set_payment_methods();
            this.payment_methods_list = [];
            this.pos_profile.payments.forEach((element) => {
              this.payment_methods_list.push(element.mode_of_payment);
            });
            this.get_available_pos_profiles();
            this.get_outstanding_invoices();
            this.get_draft_mpesa_payments_register();
            return;
          }
          this.create_opening_voucher();
        });
      },
      get_available_pos_profiles() {
        if (!this.pos_profile.posa_allow_mpesa_reconcile_payments)
          return;
        return frappe.call(
          "posawesome.posawesome.api.payment_entry.get_available_pos_profiles",
          {
            company: this.company,
            currency: this.pos_profile.currency
          }
        ).then((r) => {
          if (r.message) {
            this.pos_profiles_list = r.message;
          }
        });
      },
      create_opening_voucher() {
        this.dialog = true;
      },
      async fetch_customer_details() {
        var vm2 = this;
        if (!this.customer_name)
          return;
        if (isOffline()) {
          try {
            const r = await frappe.call({
              method: "posawesome.posawesome.api.customers.get_customer_info",
              args: {
                customer: vm2.customer_name
              }
            });
            const message2 = r.message;
            if (!r.exc) {
              vm2.customer_info = __spreadValues({}, message2);
              vm2.set_mpesa_search_params();
              vm2.eventBus.emit("set_customer_info_to_edit", vm2.customer_info);
            }
          } catch (error) {
            console.error("Failed to fetch cached customer", error);
          }
          return;
        }
        try {
          const r = await frappe.call({
            method: "posawesome.posawesome.api.posapp.get_customer_info",
            args: {
              customer: vm2.customer_name
            }
          });
          const message2 = r.message;
          if (!r.exc) {
            vm2.customer_info = __spreadValues({}, message2);
            vm2.set_mpesa_search_params();
            vm2.eventBus.emit("set_customer_info_to_edit", vm2.customer_info);
          }
        } catch (error) {
          console.error("Failed to fetch customer details", error);
        }
      },
      onInvoiceSelected(event2) {
        if (event2 && event2.item && event2.item.customer) {
          this.eventBus.emit("set_customer", event2.item.customer);
          this.$nextTick(() => {
            this.$forceUpdate();
          });
        }
      },
      get_outstanding_invoices() {
        this.invoices_loading = true;
        this.selected_invoices = [];
        if (isOffline()) {
          this.outstanding_invoices = [];
          this.invoices_loading = false;
          return;
        }
        return frappe.call(
          "posawesome.posawesome.api.payment_entry.get_outstanding_invoices",
          {
            customer: this.customer_name,
            company: this.company,
            currency: this.pos_profile.currency,
            pos_profile: this.pos_profile_search || null
          }
        ).then((r) => {
          if (r.message) {
            this.outstanding_invoices = r.message;
            this.invoices_loading = false;
            this.$nextTick(() => {
              this.$forceUpdate();
            });
          }
        });
      },
      get_unallocated_payments() {
        if (!this.pos_profile.posa_allow_reconcile_payments)
          return;
        this.unallocated_payments_loading = true;
        if (!this.customer_name) {
          this.unallocated_payments = [];
          this.unallocated_payments_loading = false;
          return;
        }
        if (isOffline()) {
          this.unallocated_payments = [];
          this.unallocated_payments_loading = false;
          return;
        }
        return frappe.call(
          "posawesome.posawesome.api.payment_entry.get_unallocated_payments",
          {
            customer: this.customer_name,
            company: this.company,
            currency: this.pos_profile.currency
          }
        ).then((r) => {
          if (r.message) {
            this.unallocated_payments = r.message;
            this.unallocated_payments_loading = false;
          }
        });
      },
      set_mpesa_search_params() {
        if (!this.pos_profile.posa_allow_mpesa_reconcile_payments)
          return;
        if (!this.customer_name)
          return;
        this.mpesa_search_name = this.customer_info.customer_name.split(" ")[0];
        if (this.customer_info.mobile_no) {
          this.mpesa_search_mobile = this.customer_info.mobile_no.substring(0, 4) + " ***** " + this.customer_info.mobile_no.substring(9);
        }
      },
      get_draft_mpesa_payments_register() {
        if (!this.pos_profile.posa_allow_mpesa_reconcile_payments)
          return;
        const vm2 = this;
        this.mpesa_payments_loading = true;
        if (isOffline()) {
          this.mpesa_payments = [];
          this.mpesa_payments_loading = false;
          return;
        }
        return frappe.call("posawesome.posawesome.api.m_pesa.get_mpesa_draft_payments", {
          company: vm2.company,
          mode_of_payment: null,
          full_name: vm2.mpesa_search_name || null,
          mobile_no: vm2.mpesa_search_mobile || null,
          payment_methods_list: vm2.payment_methods_list
        }).then((r) => {
          if (r.message) {
            vm2.mpesa_payments = r.message;
          } else {
            vm2.mpesa_payments = [];
          }
          vm2.mpesa_payments_loading = false;
        });
      },
      set_payment_methods() {
        if (!this.pos_profile.posa_allow_make_new_payments)
          return;
        this.payment_methods = [];
        this.pos_profile.payments.forEach((method) => {
          this.payment_methods.push({
            mode_of_payment: method.mode_of_payment,
            amount: 0,
            row_id: method.name
          });
        });
      },
      clear_all(with_customer_info = true) {
        this.customer_name = "";
        if (with_customer_info) {
          this.customer_info = "";
        }
        this.mpesa_search_mobile = "";
        this.mpesa_search_name = "";
        this.mpesa_payments = [];
        this.selected_mpesa_payments = [];
        this.outstanding_invoices = [];
        this.unallocated_payments = [];
        this.selected_invoices = [];
        this.selected_payments = [];
        this.selected_mpesa_payments = [];
        this.set_payment_methods();
      },
      submit() {
        if (this.isSubmitting)
          return;
        this.isSubmitting = true;
        const customer = this.customer_name;
        const vm2 = this;
        if (!customer) {
          this.isSubmitting = false;
          frappe.throw(__("Please select a customer"));
          return;
        }
        if (this.selected_invoices.length == 0) {
          this.isSubmitting = false;
          frappe.throw(__("Please select an invoice"));
          return;
        }
        let total_payments = this.total_selected_payments + this.total_selected_mpesa_payments + this.total_payment_methods;
        if (total_payments <= 0) {
          this.isSubmitting = false;
          frappe.throw(__("Please make a payment or select an payment"));
          return;
        }
        this.payment_methods.forEach((payment) => {
          payment.amount = flt(payment.amount);
        });
        const payload = {};
        payload.customer = customer;
        payload.company = this.company;
        payload.currency = this.pos_profile.currency;
        payload.pos_opening_shift_name = this.pos_opening_shift.name;
        payload.pos_profile_name = this.pos_profile.name;
        payload.pos_profile = this.pos_profile;
        payload.payment_methods = this.payment_methods;
        payload.selected_invoices = this.selected_invoices;
        payload.selected_payments = this.selected_payments;
        payload.total_selected_invoices = flt(this.total_selected_invoices);
        payload.selected_mpesa_payments = this.selected_mpesa_payments;
        payload.total_selected_payments = flt(this.total_selected_payments);
        payload.total_payment_methods = flt(this.total_payment_methods);
        payload.total_selected_mpesa_payments = flt(
          this.total_selected_mpesa_payments
        );
        if (isOffline()) {
          try {
            saveOfflinePayment({ args: { payload } });
            vm2.eventBus.emit("show_message", { title: __("Payment saved offline"), color: "warning" });
            vm2.clear_all(false);
            vm2.customer_name = customer;
            vm2.get_outstanding_invoices();
            vm2.get_unallocated_payments();
            vm2.set_mpesa_search_params();
            vm2.get_draft_mpesa_payments_register();
          } catch (error) {
            frappe.msgprint(__("Cannot Save Offline Payment: ") + (error.message || __("Unknown error")));
          }
          vm2.isSubmitting = false;
          return;
        }
        frappe.call({
          method: "posawesome.posawesome.api.payment_entry.process_pos_payment",
          args: { payload },
          freeze: true,
          freeze_message: __("Processing Payment"),
          callback: function(r) {
            vm2.isSubmitting = false;
            if (r.message) {
              frappe.utils.play_sound("submit");
              vm2.clear_all(false);
              vm2.customer_name = customer;
              vm2.get_outstanding_invoices();
              vm2.get_unallocated_payments();
              vm2.set_mpesa_search_params();
              vm2.get_draft_mpesa_payments_register();
            }
          },
          error: function() {
            vm2.isSubmitting = false;
          }
        });
      },
      submit_and_print() {
        if (this.isSubmitting)
          return;
        this.isSubmitting = true;
        const customer = this.customer_name;
        const vm2 = this;
        if (!customer) {
          this.isSubmitting = false;
          frappe.throw(__("Please select a customer"));
          return;
        }
        if (this.selected_invoices.length == 0) {
          this.isSubmitting = false;
          frappe.throw(__("Please select an invoice"));
          return;
        }
        let total_payments = this.total_selected_payments + this.total_selected_mpesa_payments + this.total_payment_methods;
        if (total_payments <= 0) {
          this.isSubmitting = false;
          frappe.throw(__("Please make a payment or select an payment"));
          return;
        }
        this.payment_methods.forEach((payment) => {
          payment.amount = flt(payment.amount);
        });
        const payload = {};
        payload.customer = customer;
        payload.company = this.company;
        payload.currency = this.pos_profile.currency;
        payload.pos_opening_shift_name = this.pos_opening_shift.name;
        payload.pos_profile_name = this.pos_profile.name;
        payload.pos_profile = this.pos_profile;
        payload.payment_methods = this.payment_methods;
        payload.selected_invoices = this.selected_invoices;
        payload.selected_payments = this.selected_payments;
        payload.total_selected_invoices = flt(this.total_selected_invoices);
        payload.selected_mpesa_payments = this.selected_mpesa_payments;
        payload.total_selected_payments = flt(this.total_selected_payments);
        payload.total_payment_methods = flt(this.total_payment_methods);
        payload.total_selected_mpesa_payments = flt(
          this.total_selected_mpesa_payments
        );
        if (isOffline()) {
          try {
            saveOfflinePayment({ args: { payload } });
            vm2.eventBus.emit("show_message", { title: __("Payment saved offline"), color: "warning" });
            vm2.clear_all(false);
            vm2.customer_name = customer;
            vm2.get_outstanding_invoices();
            vm2.get_unallocated_payments();
            vm2.set_mpesa_search_params();
            vm2.get_draft_mpesa_payments_register();
          } catch (error) {
            frappe.msgprint(__("Cannot Save Offline Payment: ") + (error.message || __("Unknown error")));
          }
          vm2.isSubmitting = false;
          return;
        }
        frappe.call({
          method: "posawesome.posawesome.api.payment_entry.process_pos_payment",
          args: { payload },
          freeze: true,
          freeze_message: __("Processing Payment"),
          callback: function(r) {
            vm2.isSubmitting = false;
            if (r.message) {
              console.log("Server response:", JSON.stringify(r.message));
              frappe.utils.play_sound("submit");
              const payment_name = r.message.new_payments_entry && r.message.new_payments_entry.length > 0 ? r.message.new_payments_entry[0].name : null;
              if (payment_name) {
                console.log("Opening print view with payment name:", payment_name);
                vm2.load_print_page(payment_name);
              } else {
                console.log("No payment_name found in response");
                frappe.msgprint(__("Payment submitted but print function could not be executed. Payment name not found."));
              }
              vm2.clear_all(false);
              vm2.customer_name = customer;
              vm2.get_outstanding_invoices();
              vm2.get_unallocated_payments();
              vm2.set_mpesa_search_params();
              vm2.get_draft_mpesa_payments_register();
            }
          },
          error: function() {
            vm2.isSubmitting = false;
          }
        });
      },
      selectSingleInvoice(item) {
        console.log("Row clicked:", item);
        if (item) {
          this.toggleInvoiceSelection(item);
        }
      },
      isInvoiceSelected(item) {
        return this.selected_invoices.some((i) => i.voucher_no === item.voucher_no);
      },
      toggleInvoiceSelection(item) {
        if (this.isInvoiceSelected(item)) {
          this.selected_invoices = this.selected_invoices.filter((i) => i.voucher_no !== item.voucher_no);
        } else {
          this.selected_invoices.push(item);
          if (item.customer && !this.customer_name) {
            this.eventBus.emit("set_customer", item.customer);
          }
        }
        this.$nextTick(() => {
          console.log("Selected invoices:", this.selected_invoices);
          console.log("Total selected amount:", this.total_selected_invoices);
          this.$forceUpdate();
        });
      },
      isSelected(item) {
        return this.isInvoiceSelected(item) ? "selected-row bg-primary bg-lighten-4" : "";
      },
      load_print_page(payment_name) {
        var _a3;
        if (!payment_name) {
          frappe.msgprint(__("Payment name not found. Cannot open print view."));
          return;
        }
        const url = frappe.urllib.get_base_url() + "/printview?doctype=Payment%20Entry&name=" + payment_name + "&trigger_print=1";
        console.log("Opening printing URL:", url);
        if ((_a3 = this.pos_profile) == null ? void 0 : _a3.posa_silent_print) {
          silentPrint(url);
        } else {
          window.open(url, "_blank");
        }
      },
      async syncPendingPayments() {
        const pending = getPendingOfflinePaymentCount();
        if (pending) {
          this.eventBus.emit("show_message", {
            title: `${pending} payment${pending > 1 ? "s" : ""} pending for sync`,
            color: "warning"
          });
        }
        if (isOffline()) {
          return;
        }
        const result = await syncOfflinePayments();
        if (result && result.synced) {
          this.eventBus.emit("show_message", {
            title: `${result.synced} offline payment${result.synced > 1 ? "s" : ""} synced`,
            color: "success"
          });
        }
      }
    },
    computed: {
      total_outstanding_amount() {
        if (!this.outstanding_invoices || !this.outstanding_invoices.length)
          return 0;
        return this.outstanding_invoices.reduce(
          (acc, cur) => acc + flt((cur == null ? void 0 : cur.outstanding_amount) || 0),
          0
        );
      },
      total_unallocated_amount() {
        if (!this.unallocated_payments || !this.unallocated_payments.length)
          return 0;
        return this.unallocated_payments.reduce(
          (acc, cur) => acc + flt((cur == null ? void 0 : cur.unallocated_amount) || 0),
          0
        );
      },
      total_selected_invoices() {
        if (!this.selected_invoices || !this.selected_invoices.length) {
          console.log("No selected invoices");
          return 0;
        }
        const total = this.selected_invoices.reduce(
          (acc, cur) => acc + flt((cur == null ? void 0 : cur.outstanding_amount) || 0),
          0
        );
        console.log("Calculated total selected invoices:", total, "from", this.selected_invoices);
        return total;
      },
      total_selected_payments() {
        if (!this.selected_payments || !this.selected_payments.length)
          return 0;
        return this.selected_payments.reduce(
          (acc, cur) => acc + flt((cur == null ? void 0 : cur.unallocated_amount) || 0),
          0
        );
      },
      total_selected_mpesa_payments() {
        if (!this.selected_mpesa_payments || !this.selected_mpesa_payments.length)
          return 0;
        return this.selected_mpesa_payments.reduce(
          (acc, cur) => acc + flt((cur == null ? void 0 : cur.amount) || 0),
          0
        );
      },
      total_payment_methods() {
        if (!this.payment_methods || !this.payment_methods.length)
          return 0;
        const total = this.payment_methods.reduce(
          (acc, cur) => {
            const amount = parseFloat((cur == null ? void 0 : cur.amount) || 0);
            return acc + (isNaN(amount) ? 0 : amount);
          },
          0
        );
        console.log("Payment methods total:", total, "from", this.payment_methods);
        return total;
      },
      total_of_diff() {
        const invoiceTotal = this.total_selected_invoices || 0;
        const paymentTotal = (this.total_selected_payments || 0) + (this.total_selected_mpesa_payments || 0) + (this.total_payment_methods || 0);
        console.log("Difference calculation:", {
          invoiceTotal,
          paymentTotal,
          selectedPayments: this.total_selected_payments,
          mpesaPayments: this.total_selected_mpesa_payments,
          methodPayments: this.total_payment_methods
        });
        return flt(invoiceTotal - paymentTotal);
      },
      isDarkTheme() {
        return this.$theme.current === "dark";
      }
    },
    created() {
      this.syncPendingPayments();
      this.eventBus.on("network-online", this.syncPendingPayments);
      this.eventBus.on("server-online", this.syncPendingPayments);
    },
    mounted: function() {
      this.$nextTick(function() {
        this.check_opening_entry();
        this.eventBus.on("update_customer", (customer_name) => {
          this.clear_all(true);
          this.customer_name = customer_name;
          this.fetch_customer_details();
          this.get_outstanding_invoices();
          this.get_unallocated_payments();
          this.get_draft_mpesa_payments_register();
        });
        this.eventBus.on("fetch_customer_details", () => {
          this.fetch_customer_details();
        });
      });
    },
    beforeUnmount() {
      this.eventBus.off("update_customer");
      this.eventBus.off("fetch_customer_details");
      this.eventBus.off("network-online", this.syncPendingPayments);
      this.eventBus.off("server-online", this.syncPendingPayments);
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/components/payments/Pay.vue?type=template
  var _hoisted_150 = { fluid: "" };
  var _hoisted_224 = {
    key: 0,
    class: "text-primary"
  };
  var _hoisted_318 = {
    key: 0,
    class: "golden--text text-end"
  };
  var _hoisted_414 = { class: "text-primary" };
  var _hoisted_512 = { key: 0 };
  var _hoisted_612 = {
    key: 0,
    class: "text-primary"
  };
  var _hoisted_711 = {
    key: 0,
    class: "golden--text text-end"
  };
  var _hoisted_89 = { class: "text-primary" };
  var _hoisted_98 = { key: 1 };
  var _hoisted_107 = { class: "golden--text text-end" };
  var _hoisted_1112 = { class: "text-primary" };
  var _hoisted_1211 = /* @__PURE__ */ createBaseVNode("h4", { class: "text-primary" }, "Totals", -1);
  var _hoisted_1310 = {
    key: 0,
    class: "text-primary"
  };
  var _hoisted_1410 = { key: 3 };
  var _hoisted_156 = /* @__PURE__ */ createBaseVNode("h4", { class: "text-primary" }, "Make New Payment", -1);
  var _hoisted_166 = { class: "mt-1" };
  var _hoisted_176 = { class: "d-flex align-center" };
  var _hoisted_186 = { class: "mr-1 text-primary" };
  var _hoisted_195 = { class: "text-primary mt-1" };
  var _hoisted_204 = {
    class: "pb-6 pr-6",
    style: { "position": "absolute", "bottom": "0", "width": "100%" }
  };
  function render33(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Customer = resolveComponent("Customer");
    const _component_v_divider = resolveComponent("v-divider");
    const _component_v_col = resolveComponent("v-col");
    const _component_v_row = resolveComponent("v-row");
    const _component_v_select = resolveComponent("v-select");
    const _component_v_btn = resolveComponent("v-btn");
    const _component_v_checkbox = resolveComponent("v-checkbox");
    const _component_v_data_table = resolveComponent("v-data-table");
    const _component_v_text_field = resolveComponent("v-text-field");
    const _component_v_card = resolveComponent("v-card");
    return openBlock(), createElementBlock("div", _hoisted_150, [
      withDirectives(createVNode(_component_v_row, null, {
        default: withCtx(() => [
          createVNode(_component_v_col, {
            md: "8",
            cols: "12",
            class: "pb-2 pr-0"
          }, {
            default: withCtx(() => [
              createVNode(_component_v_card, {
                class: normalizeClass(["main mx-auto mt-3 p-3 pb-16 overflow-y-auto", $options.isDarkTheme ? "" : "bg-grey-lighten-5"]),
                style: normalizeStyle([$options.isDarkTheme ? "background-color:#1E1E1E" : "", { "max-height": "94vh", "height": "94vh" }])
              }, {
                default: withCtx(() => [
                  createVNode(_component_Customer),
                  createVNode(_component_v_divider),
                  createBaseVNode("div", null, [
                    createVNode(_component_v_row, null, {
                      default: withCtx(() => [
                        createVNode(_component_v_col, {
                          md: "7",
                          cols: "12"
                        }, {
                          default: withCtx(() => [
                            createBaseVNode("p", null, [
                              createBaseVNode("strong", null, toDisplayString(_ctx.__("Invoices")), 1),
                              $options.total_outstanding_amount ? (openBlock(), createElementBlock("span", _hoisted_224, toDisplayString(_ctx.__("- Total Outstanding")) + " : " + toDisplayString(_ctx.currencySymbol(_ctx.pos_profile.currency)) + " " + toDisplayString(_ctx.formatCurrency($options.total_outstanding_amount)), 1)) : createCommentVNode("v-if", true)
                            ])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_v_col, {
                          md: "5",
                          cols: "12"
                        }, {
                          default: withCtx(() => [
                            $options.total_selected_invoices ? (openBlock(), createElementBlock("p", _hoisted_318, [
                              createBaseVNode("span", null, toDisplayString(_ctx.__("Total Selected :")), 1),
                              createBaseVNode("span", null, toDisplayString(_ctx.currencySymbol(_ctx.pos_profile.currency)) + " " + toDisplayString(_ctx.formatCurrency($options.total_selected_invoices)), 1),
                              createBaseVNode("small", null, "(" + toDisplayString(_ctx.selected_invoices.length) + " invoice(s))", 1)
                            ])) : createCommentVNode("v-if", true)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    createVNode(_component_v_row, {
                      align: "center",
                      "no-gutters": "",
                      class: "mb-1"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_v_col, {
                          md: "4",
                          cols: "12"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_select, {
                              density: "compact",
                              variant: "outlined",
                              "hide-details": "",
                              clearable: "",
                              "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                              modelValue: _ctx.pos_profile_search,
                              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.pos_profile_search = $event),
                              items: _ctx.pos_profiles_list,
                              "item-value": "name",
                              label: "Select POS Profile"
                            }, null, 8, ["bg-color", "modelValue", "items"])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_v_col),
                        createVNode(_component_v_col, {
                          md: "3",
                          cols: "12"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_btn, {
                              block: "",
                              color: "warning",
                              theme: "dark",
                              onClick: $options.get_outstanding_invoices
                            }, {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString(_ctx.__("Search")), 1)
                              ]),
                              _: 1
                            }, 8, ["onClick"])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_v_col, {
                          md: "3",
                          cols: "12"
                        }, {
                          default: withCtx(() => [
                            _ctx.selected_invoices.length ? (openBlock(), createBlock(_component_v_btn, {
                              key: 0,
                              block: "",
                              color: "error",
                              theme: "dark",
                              onClick: _cache[1] || (_cache[1] = ($event) => {
                                _ctx.selected_invoices = [];
                                _ctx.$forceUpdate();
                              })
                            }, {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString(_ctx.__("Clear")), 1)
                              ]),
                              _: 1
                            })) : createCommentVNode("v-if", true)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    createVNode(_component_v_data_table, {
                      headers: _ctx.invoices_headers,
                      items: _ctx.outstanding_invoices,
                      "item-key": "voucher_no",
                      class: "elevation-1 mt-0",
                      loading: _ctx.invoices_loading,
                      "onClick:row": $options.selectSingleInvoice,
                      "item-class": $options.isSelected
                    }, {
                      "item.actions": withCtx(({ item }) => [
                        createVNode(_component_v_checkbox, {
                          "model-value": $options.isInvoiceSelected(item),
                          color: "primary",
                          onClick: withModifiers(($event) => $options.toggleInvoiceSelection(item), ["stop"])
                        }, null, 8, ["model-value", "onClick"])
                      ]),
                      "item.invoice_amount": withCtx(({ item }) => [
                        createTextVNode(toDisplayString(_ctx.currencySymbol(item.currency)) + " " + toDisplayString(_ctx.formatCurrency(item.invoice_amount)), 1)
                      ]),
                      "item.outstanding_amount": withCtx(({ item }) => [
                        createBaseVNode("span", _hoisted_414, toDisplayString(_ctx.currencySymbol((item == null ? void 0 : item.currency) || _ctx.pos_profile.currency)) + " " + toDisplayString(_ctx.formatCurrency((item == null ? void 0 : item.outstanding_amount) || 0)), 1)
                      ]),
                      _: 1
                    }, 8, ["headers", "items", "loading", "onClick:row", "item-class"]),
                    createVNode(_component_v_divider)
                  ]),
                  _ctx.pos_profile.posa_allow_reconcile_payments && _ctx.unallocated_payments.length ? (openBlock(), createElementBlock("div", _hoisted_512, [
                    createVNode(_component_v_row, null, {
                      default: withCtx(() => [
                        createVNode(_component_v_col, {
                          md: "7",
                          cols: "12"
                        }, {
                          default: withCtx(() => [
                            createBaseVNode("p", null, [
                              createBaseVNode("strong", null, toDisplayString(_ctx.__("Payments")), 1),
                              $options.total_unallocated_amount ? (openBlock(), createElementBlock("span", _hoisted_612, toDisplayString(_ctx.__("- Total Unallocated")) + " : " + toDisplayString(_ctx.currencySymbol(_ctx.pos_profile.currency)) + " " + toDisplayString(_ctx.formatCurrency($options.total_unallocated_amount)), 1)) : createCommentVNode("v-if", true)
                            ])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_v_col, {
                          md: "5",
                          cols: "12"
                        }, {
                          default: withCtx(() => [
                            $options.total_selected_payments ? (openBlock(), createElementBlock("p", _hoisted_711, [
                              createBaseVNode("span", null, toDisplayString(_ctx.__("Total Selected :")), 1),
                              createBaseVNode("span", null, toDisplayString(_ctx.currencySymbol(_ctx.pos_profile.currency)) + " " + toDisplayString(_ctx.formatCurrency($options.total_selected_payments)), 1)
                            ])) : createCommentVNode("v-if", true)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    createVNode(_component_v_data_table, {
                      headers: _ctx.unallocated_payments_headers,
                      items: _ctx.unallocated_payments,
                      "item-key": "name",
                      class: "elevation-1 mt-0",
                      loading: _ctx.unallocated_payments_loading
                    }, {
                      "item.select": withCtx(({ item }) => [
                        createVNode(_component_v_checkbox, {
                          modelValue: _ctx.selected_payments,
                          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.selected_payments = $event),
                          value: item,
                          color: "primary",
                          "hide-details": "",
                          onClick: _cache[3] || (_cache[3] = withModifiers(() => {
                          }, ["stop"]))
                        }, null, 8, ["modelValue", "value"])
                      ]),
                      "item.paid_amount": withCtx(({ item }) => [
                        createTextVNode(toDisplayString(_ctx.currencySymbol(item.currency)) + " " + toDisplayString(_ctx.formatCurrency(item.paid_amount)), 1)
                      ]),
                      "item.unallocated_amount": withCtx(({ item }) => [
                        createBaseVNode("span", _hoisted_89, toDisplayString(_ctx.currencySymbol(item.currency)) + " " + toDisplayString(_ctx.formatCurrency(item.unallocated_amount)), 1)
                      ]),
                      _: 1
                    }, 8, ["headers", "items", "loading"]),
                    createVNode(_component_v_divider)
                  ])) : createCommentVNode("v-if", true),
                  _ctx.pos_profile.posa_allow_mpesa_reconcile_payments ? (openBlock(), createElementBlock("div", _hoisted_98, [
                    createVNode(_component_v_row, null, {
                      default: withCtx(() => [
                        createVNode(_component_v_col, {
                          md: "8",
                          cols: "12"
                        }, {
                          default: withCtx(() => [
                            createBaseVNode("p", null, [
                              createBaseVNode("span", null, [
                                createBaseVNode("strong", null, toDisplayString(_ctx.__("Search Mpesa Payments")), 1)
                              ])
                            ])
                          ]),
                          _: 1
                        }),
                        $options.total_selected_mpesa_payments ? (openBlock(), createBlock(_component_v_col, {
                          key: 0,
                          md: "4",
                          cols: "12"
                        }, {
                          default: withCtx(() => [
                            createBaseVNode("p", _hoisted_107, [
                              createBaseVNode("span", null, toDisplayString(_ctx.__("Total Selected :")), 1),
                              createBaseVNode("span", null, toDisplayString(_ctx.currencySymbol(_ctx.pos_profile.currency)) + " " + toDisplayString(_ctx.formatCurrency($options.total_selected_mpesa_payments)), 1)
                            ])
                          ]),
                          _: 1
                        })) : createCommentVNode("v-if", true)
                      ]),
                      _: 1
                    }),
                    createVNode(_component_v_row, {
                      align: "center",
                      "no-gutters": "",
                      class: "mb-1"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_v_col, {
                          md: "4",
                          cols: "12",
                          class: "mr-1"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_text_field, {
                              density: "compact",
                              variant: "outlined",
                              color: "primary",
                              label: _ctx.frappe._("Search by Name"),
                              "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                              "hide-details": "",
                              modelValue: _ctx.mpesa_search_name,
                              "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.mpesa_search_name = $event),
                              clearable: ""
                            }, null, 8, ["label", "bg-color", "modelValue"])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_v_col, {
                          md: "4",
                          cols: "12",
                          class: "mr-1"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_text_field, {
                              density: "compact",
                              variant: "outlined",
                              color: "primary",
                              label: _ctx.frappe._("Search by Mobile"),
                              "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                              "hide-details": "",
                              modelValue: _ctx.mpesa_search_mobile,
                              "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => _ctx.mpesa_search_mobile = $event),
                              clearable: ""
                            }, null, 8, ["label", "bg-color", "modelValue"])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_v_col),
                        createVNode(_component_v_col, {
                          md: "3",
                          cols: "12"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_btn, {
                              block: "",
                              color: "warning",
                              theme: "dark",
                              onClick: $options.get_draft_mpesa_payments_register
                            }, {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString(_ctx.__("Search")), 1)
                              ]),
                              _: 1
                            }, 8, ["onClick"])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    createVNode(_component_v_data_table, {
                      headers: _ctx.mpesa_payment_headers,
                      items: _ctx.mpesa_payments,
                      "item-key": "name",
                      class: "elevation-1 mt-0",
                      "single-select": _ctx.singleSelect,
                      "show-select": "",
                      modelValue: _ctx.selected_mpesa_payments,
                      "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => _ctx.selected_mpesa_payments = $event),
                      loading: _ctx.mpesa_payments_loading,
                      "checkbox-color": "primary"
                    }, {
                      "item.amount": withCtx(({ item }) => [
                        createBaseVNode("span", _hoisted_1112, toDisplayString(_ctx.currencySymbol(item.currency)) + " " + toDisplayString(_ctx.formatCurrency(item.amount)), 1)
                      ]),
                      _: 1
                    }, 8, ["headers", "items", "single-select", "modelValue", "loading"])
                  ])) : createCommentVNode("v-if", true)
                ]),
                _: 1
              }, 8, ["class", "style"])
            ]),
            _: 1
          }),
          createVNode(_component_v_col, {
            md: "4",
            cols: "12",
            class: "pb-3"
          }, {
            default: withCtx(() => [
              createVNode(_component_v_card, {
                class: normalizeClass(["invoices mx-auto mt-3 p-3", $options.isDarkTheme ? "" : "bg-grey-lighten-5"]),
                style: normalizeStyle([$options.isDarkTheme ? "background-color:#1E1E1E" : "", { "max-height": "94vh", "height": "94vh" }])
              }, {
                default: withCtx(() => [
                  createBaseVNode("strong", null, [
                    _hoisted_1211,
                    createVNode(_component_v_row, null, {
                      default: withCtx(() => [
                        createVNode(_component_v_col, {
                          md: "7",
                          class: "mt-1"
                        }, {
                          default: withCtx(() => [
                            createBaseVNode("span", null, toDisplayString(_ctx.__("Total Invoices:")), 1)
                          ]),
                          _: 1
                        }),
                        createVNode(_component_v_col, { md: "5" }, {
                          default: withCtx(() => [
                            createVNode(_component_v_text_field, {
                              class: "p-0 m-0 dark-field",
                              density: "compact",
                              color: "primary",
                              "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                              "hide-details": "",
                              "model-value": _ctx.formatCurrency($options.total_selected_invoices),
                              readonly: "",
                              flat: "",
                              prefix: _ctx.currencySymbol(_ctx.pos_profile.currency)
                            }, null, 8, ["bg-color", "model-value", "prefix"]),
                            _ctx.selected_invoices.length ? (openBlock(), createElementBlock("small", _hoisted_1310, toDisplayString(_ctx.selected_invoices.length) + " invoice(s) selected", 1)) : createCommentVNode("v-if", true)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    $options.total_selected_payments ? (openBlock(), createBlock(_component_v_row, { key: 0 }, {
                      default: withCtx(() => [
                        createVNode(_component_v_col, {
                          md: "7",
                          class: "mt-1"
                        }, {
                          default: withCtx(() => [
                            createBaseVNode("span", null, toDisplayString(_ctx.__("Total Payments:")), 1)
                          ]),
                          _: 1
                        }),
                        createVNode(_component_v_col, { md: "5" }, {
                          default: withCtx(() => [
                            createVNode(_component_v_text_field, {
                              class: "p-0 m-0 dark-field",
                              density: "compact",
                              color: "primary",
                              "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                              "hide-details": "",
                              "model-value": _ctx.formatCurrency($options.total_selected_payments),
                              readonly: "",
                              flat: "",
                              prefix: _ctx.currencySymbol(_ctx.pos_profile.currency)
                            }, null, 8, ["bg-color", "model-value", "prefix"])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })) : createCommentVNode("v-if", true),
                    $options.total_selected_mpesa_payments ? (openBlock(), createBlock(_component_v_row, { key: 1 }, {
                      default: withCtx(() => [
                        createVNode(_component_v_col, {
                          md: "7",
                          class: "mt-1"
                        }, {
                          default: withCtx(() => [
                            createBaseVNode("span", null, toDisplayString(_ctx.__("Total Mpesa:")), 1)
                          ]),
                          _: 1
                        }),
                        createVNode(_component_v_col, { md: "5" }, {
                          default: withCtx(() => [
                            createVNode(_component_v_text_field, {
                              class: "p-0 m-0 dark-field",
                              density: "compact",
                              color: "primary",
                              "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                              "hide-details": "",
                              "model-value": _ctx.formatCurrency($options.total_selected_mpesa_payments),
                              readonly: "",
                              flat: "",
                              prefix: _ctx.currencySymbol(_ctx.pos_profile.currency)
                            }, null, 8, ["bg-color", "model-value", "prefix"])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })) : createCommentVNode("v-if", true),
                    _ctx.payment_methods.length ? (openBlock(), createBlock(_component_v_divider, { key: 2 })) : createCommentVNode("v-if", true),
                    _ctx.pos_profile.posa_allow_make_new_payments ? (openBlock(), createElementBlock("div", _hoisted_1410, [
                      _hoisted_156,
                      _ctx.payment_methods.length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.payment_methods, (method) => {
                        return openBlock(), createBlock(_component_v_row, {
                          key: method.row_id
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_col, { md: "7" }, {
                              default: withCtx(() => [
                                createBaseVNode("span", _hoisted_166, toDisplayString(_ctx.__(method.mode_of_payment)) + ":", 1)
                              ]),
                              _: 2
                            }, 1024),
                            createVNode(_component_v_col, { md: "5" }, {
                              default: withCtx(() => [
                                createBaseVNode("div", _hoisted_176, [
                                  createBaseVNode("div", _hoisted_186, toDisplayString(_ctx.currencySymbol(_ctx.pos_profile.currency)), 1),
                                  createVNode(_component_v_text_field, {
                                    class: "p-0 m-0 dark-field",
                                    density: "compact",
                                    color: "primary",
                                    "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                                    "hide-details": "",
                                    modelValue: method.amount,
                                    "onUpdate:modelValue": ($event) => method.amount = $event,
                                    type: "number",
                                    flat: "",
                                    onInput: _cache[7] || (_cache[7] = ($event) => _ctx.$forceUpdate())
                                  }, null, 8, ["bg-color", "modelValue", "onUpdate:modelValue"])
                                ])
                              ]),
                              _: 2
                            }, 1024)
                          ]),
                          _: 2
                        }, 1024);
                      }), 128)) : createCommentVNode("v-if", true)
                    ])) : createCommentVNode("v-if", true),
                    createVNode(_component_v_divider),
                    createVNode(_component_v_row, null, {
                      default: withCtx(() => [
                        createVNode(_component_v_col, { md: "7" }, {
                          default: withCtx(() => [
                            createBaseVNode("h4", _hoisted_195, toDisplayString(_ctx.__("Difference:")), 1)
                          ]),
                          _: 1
                        }),
                        createVNode(_component_v_col, { md: "5" }, {
                          default: withCtx(() => [
                            createVNode(_component_v_text_field, {
                              class: "p-0 m-0 dark-field",
                              density: "compact",
                              color: "primary",
                              "bg-color": $options.isDarkTheme ? "#1E1E1E" : "white",
                              "hide-details": "",
                              "model-value": _ctx.formatCurrency($options.total_of_diff),
                              readonly: "",
                              flat: "",
                              prefix: _ctx.currencySymbol(_ctx.pos_profile.currency)
                            }, null, 8, ["bg-color", "model-value", "prefix"])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  createBaseVNode("div", _hoisted_204, [
                    createVNode(_component_v_row, null, {
                      default: withCtx(() => [
                        createVNode(_component_v_col, {
                          cols: "6",
                          class: "pr-1"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_btn, {
                              block: "",
                              size: "large",
                              color: "primary",
                              theme: "dark",
                              onClick: $options.submit,
                              disabled: _ctx.vaildatPayment || _ctx.isSubmitting,
                              loading: _ctx.isSubmitting
                            }, {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString(_ctx.__("Submit")), 1)
                              ]),
                              _: 1
                            }, 8, ["onClick", "disabled", "loading"])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_v_col, {
                          cols: "6",
                          class: "pl-1"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_v_btn, {
                              block: "",
                              size: "large",
                              color: "success",
                              theme: "dark",
                              onClick: _cache[8] || (_cache[8] = ($event) => $options.submit_and_print()),
                              disabled: _ctx.vaildatPayment || _ctx.isSubmitting,
                              loading: _ctx.isSubmitting
                            }, {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString(_ctx.__("Submit & Print")), 1)
                              ]),
                              _: 1
                            }, 8, ["disabled", "loading"])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ])
                ]),
                _: 1
              }, 8, ["class", "style"])
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 512), [
        [vShow, !_ctx.dialog]
      ])
    ]);
  }

  // ../posawesome/posawesome/public/js/posapp/components/payments/Pay.vue
  Pay_default.render = render33;
  Pay_default.__file = "../posawesome/posawesome/public/js/posapp/components/payments/Pay.vue";
  var Pay_default2 = Pay_default;

  // sfc-script:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/Home.vue?type=script
  var Home_default = {
    data: function() {
      return {
        page: "POS",
        posProfile: {},
        pendingInvoices: 0,
        lastInvoiceId: "",
        networkOnline: navigator.onLine || false,
        serverOnline: false,
        serverConnecting: false,
        isIpHost: false,
        syncTotals: { pending: 0, synced: 0, drafted: 0 },
        manualOffline: false,
        cacheUsage: 0,
        cacheUsageLoading: false,
        cacheUsageDetails: { total: 0, indexedDB: 0, localStorage: 0 }
      };
    },
    computed: {
      isDark() {
        var _a3;
        return ((_a3 = this.$theme) == null ? void 0 : _a3.current) === "dark";
      }
    },
    components: {
      Navbar: Navbar_default2,
      POS: Pos_default2,
      Payments: Pay_default2
    },
    mounted() {
      this.remove_frappe_nav();
      this.initializeData();
      this.setupNetworkListeners();
      this.setupEventListeners();
      this.handleRefreshCacheUsage();
    },
    methods: {
      setPage(page) {
        this.page = page;
      },
      initializeData() {
        const openingData = getOpeningStorage();
        if (openingData && openingData.pos_profile) {
          this.posProfile = openingData.pos_profile;
        }
        this.isIpHost = /^\d+\.\d+\.\d+\.\d+/.test(window.location.hostname);
      },
      setupNetworkListeners() {
        window.addEventListener("online", () => {
          this.networkOnline = true;
          console.log("Network: Online");
          this.checkNetworkConnectivity();
        });
        window.addEventListener("offline", () => {
          this.networkOnline = false;
          this.serverOnline = false;
          console.log("Network: Offline");
          this.$forceUpdate();
        });
        this.networkOnline = navigator.onLine;
        this.checkNetworkConnectivity();
        setInterval(() => {
          if (navigator.onLine) {
            this.checkNetworkConnectivity();
          }
        }, 15e3);
      },
      async checkNetworkConnectivity() {
        try {
          let isConnected = false;
          try {
            const response = await fetch("/app", {
              method: "HEAD",
              cache: "no-cache",
              signal: AbortSignal.timeout(5e3)
            });
            if (response.status < 500) {
              isConnected = true;
            }
          } catch (error) {
            console.log("Desk endpoint check failed:", error.message);
          }
          if (!isConnected) {
            try {
              const response = await fetch("/assets/frappe/images/frappe-logo.svg", {
                method: "HEAD",
                cache: "no-cache",
                signal: AbortSignal.timeout(3e3)
              });
              if (response.status < 500) {
                isConnected = true;
              }
            } catch (error) {
              console.log("Static asset check failed:", error.message);
            }
          }
          if (!isConnected) {
            try {
              const response = await fetch(window.location.origin, {
                method: "HEAD",
                cache: "no-cache",
                signal: AbortSignal.timeout(3e3)
              });
              if (response.status < 500) {
                isConnected = true;
              }
            } catch (error) {
              console.log("Origin check failed:", error.message);
            }
          }
          if (isConnected) {
            this.networkOnline = true;
            this.serverOnline = true;
            this.serverConnecting = false;
            console.log("Network: Connected");
          } else {
            this.networkOnline = navigator.onLine;
            this.serverOnline = false;
            this.serverConnecting = false;
            console.log("Network: Disconnected");
          }
          this.$forceUpdate();
        } catch (error) {
          console.warn("Network connectivity check failed:", error);
          this.networkOnline = navigator.onLine;
          this.serverOnline = false;
          this.serverConnecting = false;
          this.$forceUpdate();
        }
      },
      detectHostType(hostname) {
        const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
        const ipv6Regex = /^(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$|^::1$|^::/;
        const localhostVariants = ["localhost", "127.0.0.1", "::1", "0.0.0.0"];
        return ipv4Regex.test(hostname) || ipv6Regex.test(hostname) || localhostVariants.includes(hostname.toLowerCase());
      },
      async performConnectivityChecks(hostname, protocol, port) {
        const checks = [];
        checks.push(this.checkFrappePing());
        checks.push(this.checkCurrentOrigin(protocol, hostname, port));
        if (!this.isIpHost) {
          checks.push(this.checkExternalConnectivity());
        }
        if (frappe.realtime && frappe.realtime.socket) {
          checks.push(this.checkWebSocketConnectivity());
        }
        try {
          const results = await Promise.allSettled(checks);
          return results.some((result) => result.status === "fulfilled" && result.value === true);
        } catch (error) {
          console.warn("All connectivity checks failed:", error);
          return false;
        }
      },
      async checkFrappePing() {
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 5e3);
          const response = await fetch("/api/method/ping", {
            method: "HEAD",
            cache: "no-cache",
            signal: controller.signal,
            headers: {
              "Cache-Control": "no-cache, no-store, must-revalidate",
              "Pragma": "no-cache",
              "Expires": "0"
            }
          });
          clearTimeout(timeoutId);
          return response.ok;
        } catch (error) {
          if (error.name !== "AbortError") {
            console.warn("Frappe ping check failed:", error);
          }
          return false;
        }
      },
      async checkCurrentOrigin(protocol, hostname, port) {
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 5e3);
          const baseUrl = `${protocol}//${hostname}${port ? ":" + port : ""}`;
          const response = await fetch(`${baseUrl}/api/method/frappe.auth.get_logged_user`, {
            method: "HEAD",
            cache: "no-cache",
            signal: controller.signal,
            headers: {
              "Cache-Control": "no-cache, no-store, must-revalidate"
            }
          });
          clearTimeout(timeoutId);
          return response.status < 500;
        } catch (error) {
          if (error.name !== "AbortError") {
            console.warn("Current origin check failed:", error);
          }
          return false;
        }
      },
      async checkExternalConnectivity() {
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 3e3);
          const response = await fetch("https://httpbin.org/status/200", {
            method: "HEAD",
            mode: "no-cors",
            cache: "no-cache",
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          return true;
        } catch (error) {
          if (error.name !== "AbortError") {
            console.warn("External connectivity check failed:", error);
          }
          return false;
        }
      },
      async checkWebSocketConnectivity() {
        try {
          if (frappe.realtime && frappe.realtime.socket) {
            const socketState = frappe.realtime.socket.readyState;
            return socketState === 1;
          }
          return false;
        } catch (error) {
          console.warn("WebSocket connectivity check failed:", error);
          return false;
        }
      },
      setupEventListeners() {
        if (this.eventBus) {
          this.eventBus.on("register_pos_profile", (data) => {
            this.posProfile = data.pos_profile || {};
          });
        }
        if (frappe.realtime) {
          frappe.realtime.on("connect", () => {
            this.serverOnline = true;
            this.serverConnecting = false;
            console.log("Server: Connected via WebSocket");
            this.$forceUpdate();
          });
          frappe.realtime.on("disconnect", () => {
            this.serverOnline = false;
            this.serverConnecting = false;
            console.log("Server: Disconnected from WebSocket");
            setTimeout(() => this.checkNetworkConnectivity(), 1e3);
          });
          frappe.realtime.on("connecting", () => {
            this.serverConnecting = true;
            console.log("Server: Connecting to WebSocket...");
            this.$forceUpdate();
          });
          frappe.realtime.on("reconnect", () => {
            console.log("Server: Reconnected to WebSocket");
            this.checkNetworkConnectivity();
          });
        }
        document.addEventListener("visibilitychange", () => {
          if (!document.hidden && navigator.onLine) {
            this.checkNetworkConnectivity();
          }
        });
      },
      handleNavClick() {
      },
      handleCloseShift() {
        this.eventBus.emit("close_shift");
      },
      handlePrintLastInvoice() {
        this.eventBus.emit("print_last_invoice");
      },
      handleSyncInvoices() {
        this.eventBus.emit("sync_invoices");
      },
      handleToggleOffline() {
        this.manualOffline = !this.manualOffline;
      },
      handleToggleTheme() {
        this.$theme.toggle();
      },
      handleLogout() {
        window.location.href = "/app";
      },
      handleRefreshCacheUsage() {
        this.cacheUsageLoading = true;
        getCacheUsageEstimate().then((usage) => {
          this.cacheUsage = usage.percentage || 0;
          this.cacheUsageDetails = {
            total: usage.total || 0,
            indexedDB: usage.indexedDB || 0,
            localStorage: usage.localStorage || 0
          };
        }).catch((e) => {
          console.error("Failed to refresh cache usage", e);
        }).finally(() => {
          this.cacheUsageLoading = false;
        });
      },
      handleUpdateAfterDelete() {
      },
      remove_frappe_nav() {
        this.$nextTick(function() {
          $(".page-head").remove();
          $(".navbar.navbar-default.navbar-fixed-top").remove();
        });
      }
    },
    created: function() {
      setTimeout(() => {
        this.remove_frappe_nav();
      }, 1e3);
    }
  };

  // sfc-template:/Users/ashkarm/frappe-bench/apps/posawesome/posawesome/public/js/posapp/Home.vue?type=template
  var _hoisted_151 = { class: "page-content" };
  function render34(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Navbar = resolveComponent("Navbar");
    const _component_v_main = resolveComponent("v-main");
    const _component_v_app = resolveComponent("v-app");
    return openBlock(), createBlock(_component_v_app, { class: "container1" }, {
      default: withCtx(() => [
        createVNode(_component_v_main, { class: "main-content" }, {
          default: withCtx(() => [
            createVNode(_component_Navbar, {
              "pos-profile": _ctx.posProfile,
              "pending-invoices": _ctx.pendingInvoices,
              "last-invoice-id": _ctx.lastInvoiceId,
              "network-online": _ctx.networkOnline,
              "server-online": _ctx.serverOnline,
              "server-connecting": _ctx.serverConnecting,
              "is-ip-host": _ctx.isIpHost,
              "sync-totals": _ctx.syncTotals,
              "manual-offline": _ctx.manualOffline,
              "is-dark": $options.isDark,
              "cache-usage": _ctx.cacheUsage,
              "cache-usage-loading": _ctx.cacheUsageLoading,
              "cache-usage-details": _ctx.cacheUsageDetails,
              onChangePage: _cache[0] || (_cache[0] = ($event) => $options.setPage($event)),
              onNavClick: $options.handleNavClick,
              onCloseShift: $options.handleCloseShift,
              onPrintLastInvoice: $options.handlePrintLastInvoice,
              onSyncInvoices: $options.handleSyncInvoices,
              onToggleOffline: $options.handleToggleOffline,
              onToggleTheme: $options.handleToggleTheme,
              onLogout: $options.handleLogout,
              onRefreshCacheUsage: $options.handleRefreshCacheUsage,
              onUpdateAfterDelete: $options.handleUpdateAfterDelete
            }, null, 8, ["pos-profile", "pending-invoices", "last-invoice-id", "network-online", "server-online", "server-connecting", "is-ip-host", "sync-totals", "manual-offline", "is-dark", "cache-usage", "cache-usage-loading", "cache-usage-details", "onNavClick", "onCloseShift", "onPrintLastInvoice", "onSyncInvoices", "onToggleOffline", "onToggleTheme", "onLogout", "onRefreshCacheUsage", "onUpdateAfterDelete"]),
            createBaseVNode("div", _hoisted_151, [
              (openBlock(), createBlock(resolveDynamicComponent(_ctx.page), { class: "mx-4 md-4" }))
            ])
          ]),
          _: 1
        })
      ]),
      _: 1
    });
  }

  // ../posawesome/posawesome/public/js/posapp/Home.vue
  Home_default.render = render34;
  Home_default.__file = "../posawesome/posawesome/public/js/posapp/Home.vue";
  Home_default.__scopeId = "data-v-528f966a";
  var Home_default2 = Home_default;

  // ../posawesome/posawesome/public/js/posapp/posapp.js
  frappe.provide("frappe.PosApp");
  frappe.PosApp.posapp = class {
    constructor({ parent }) {
      this.$parent = $(document);
      this.page = parent.page;
      this.make_body();
    }
    make_body() {
      this.$el = this.$parent.find(".main-section");
      const vuetify = createVuetify({
        components: components_exports,
        directives: directives_exports,
        locale: {
          rtl: frappe.utils.is_rtl()
        },
        theme: {
          defaultTheme: "light",
          themes: {
            light: {
              colors: {
                background: "#FFFFFF",
                primary: "#0097A7",
                secondary: "#00BCD4",
                accent: "#9575CD",
                success: "#66BB6A",
                info: "#2196F3",
                warning: "#FF9800",
                error: "#E86674",
                orange: "#E65100",
                golden: "#A68C59",
                badge: "#F5528C",
                customPrimary: "#085294"
              }
            },
            dark: {
              dark: true,
              colors: {
                background: "#121212",
                surface: "#1E1E1E",
                primary: "#BB86FC",
                primaryVariant: "#985EFF",
                secondary: "#03DAC6",
                accent: "#9575CD",
                success: "#66BB6A",
                info: "#2196F3",
                warning: "#FF9800",
                error: "#CF6679",
                orange: "#FF6F00",
                golden: "#A68C59",
                badge: "#F5528C",
                customPrimary: "#4FC3F7",
                onBackground: "#FFFFFF",
                onSurface: "#FFFFFF",
                divider: "#373737"
              }
            }
          }
        }
      });
      const app = createApp(Home_default2);
      app.component("VueDatePicker", Qn);
      app.use(bus_default);
      app.use(vuetify);
      app.use(theme_default, { vuetify });
      app.mount(this.$el[0]);
      if (!document.querySelector('link[rel="manifest"]')) {
        const link = document.createElement("link");
        link.rel = "manifest";
        link.href = "/manifest.json";
        document.head.appendChild(link);
      }
      if ("serviceWorker" in navigator && window.location.protocol === "https:" || window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
        navigator.serviceWorker.register("/sw.js").catch((err) => console.error("SW registration failed", err));
      }
    }
    setup_header() {
    }
  };
})();
/*! #__NO_SIDE_EFFECTS__ */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.
Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.
THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
/**
* @vue/reactivity v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/**
* @vue/runtime-core v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/**
* @vue/runtime-dom v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/**
* @vue/shared v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/**
* vue v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
//# sourceMappingURL=posawesome.bundle.NPJ6XWGO.js.map
